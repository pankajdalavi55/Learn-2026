# 4.9 Anagrams & Palindromes

## Table of Contents
1. [Anagrams](#anagrams)
2. [Palindromes](#palindromes)
3. [Combined Patterns](#combined-patterns)
4. [Interview Questions & Answers](#interview-questions--answers)
5. [Practice Problems](#practice-problems)

---

## Anagrams

### What is an Anagram?

**Definition**: Two strings are anagrams if they contain the same characters with the same frequencies.

```
"listen" and "silent" → Anagrams ✓
"triangle" and "integral" → Anagrams ✓
"hello" and "world" → NOT anagrams ✗
```

### Core Techniques

#### 1. Sorting Approach

**Idea**: Sort both strings, compare if equal

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    
    char[] sArr = s.toCharArray();
    char[] tArr = t.toCharArray();
    
    Arrays.sort(sArr);
    Arrays.sort(tArr);
    
    return Arrays.equals(sArr, tArr);
}
```

**Time**: O(n log n), **Space**: O(1) if sorting in-place

#### 2. Frequency Array (Best for Lowercase)

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    
    int[] count = new int[26];
    
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    
    for (int c : count) {
        if (c != 0) return false;
    }
    
    return true;
}
```

**Time**: O(n), **Space**: O(26) = O(1)

#### 3. HashMap (For Unicode/Mixed Case)

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    
    Map<Character, Integer> count = new HashMap<>();
    
    for (char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }
    
    for (char c : t.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) - 1);
        if (count.get(c) < 0) return false;
    }
    
    return true;
}
```

**Time**: O(n), **Space**: O(k) where k = unique characters

### Pattern 1: Group Anagrams (LeetCode 49)

**Problem**: Group strings that are anagrams of each other.

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    
    for (String s : strs) {
        // Create canonical key by sorting
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }
    
    return new ArrayList<>(map.values());
}

// Example:
// Input: ["eat","tea","tan","ate","nat","bat"]
// Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**Alternative**: Use frequency count as key

```java
public List<List<String>> groupAnagramsOptimized(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    
    for (String s : strs) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        // Create key from frequency: "1a2b0c..."
        StringBuilder key = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            if (count[i] > 0) {
                key.append((char)('a' + i)).append(count[i]);
            }
        }
        
        map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);
    }
    
    return new ArrayList<>(map.values());
}
```

**Time**: O(n × k) where n = number of strings, k = max string length

### Pattern 2: Find All Anagrams in String (LeetCode 438)

**Problem**: Find all start indices of anagrams of pattern in string.

```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    
    if (s.length() < p.length()) return result;
    
    int[] pCount = new int[26];
    int[] sCount = new int[26];
    
    // Count pattern characters
    for (char c : p.toCharArray()) {
        pCount[c - 'a']++;
    }
    
    // Sliding window
    for (int i = 0; i < s.length(); i++) {
        sCount[s.charAt(i) - 'a']++;
        
        // Remove character outside window
        if (i >= p.length()) {
            sCount[s.charAt(i - p.length()) - 'a']--;
        }
        
        // Check if window is anagram
        if (Arrays.equals(pCount, sCount)) {
            result.add(i - p.length() + 1);
        }
    }
    
    return result;
}

// Example:
// s = "cbaebabacd", p = "abc"
// Output: [0, 6] (cba at 0, bac at 6)
```

**Optimization**: Use match counter instead of comparing arrays

```java
public List<Integer> findAnagramsOptimized(String s, String p) {
    List<Integer> result = new ArrayList<>();
    if (s.length() < p.length()) return result;
    
    int[] count = new int[26];
    int matches = 0;
    
    // Initialize
    for (char c : p.toCharArray()) {
        count[c - 'a']++;
    }
    
    // Process first window
    for (int i = 0; i < p.length(); i++) {
        int idx = s.charAt(i) - 'a';
        count[idx]--;
        if (count[idx] == 0) matches++;
        else if (count[idx] == -1) matches--;
    }
    
    if (matches == 26) result.add(0);
    
    // Slide window
    for (int i = p.length(); i < s.length(); i++) {
        // Add new character
        int addIdx = s.charAt(i) - 'a';
        count[addIdx]--;
        if (count[addIdx] == 0) matches++;
        else if (count[addIdx] == -1) matches--;
        
        // Remove old character
        int removeIdx = s.charAt(i - p.length()) - 'a';
        count[removeIdx]++;
        if (count[removeIdx] == 0) matches++;
        else if (count[removeIdx] == 1) matches--;
        
        if (matches == 26) {
            result.add(i - p.length() + 1);
        }
    }
    
    return result;
}
```

**Time**: O(n), **Space**: O(1)

### Pattern 3: Minimum Window with All Characters

**Problem**: Find minimum window in s containing all characters of t.

```java
public String minWindow(String s, String t) {
    if (s.length() < t.length()) return "";
    
    Map<Character, Integer> tCount = new HashMap<>();
    for (char c : t.toCharArray()) {
        tCount.put(c, tCount.getOrDefault(c, 0) + 1);
    }
    
    int required = tCount.size();
    int formed = 0;
    
    Map<Character, Integer> windowCounts = new HashMap<>();
    
    int left = 0, right = 0;
    int minLen = Integer.MAX_VALUE;
    int minLeft = 0;
    
    while (right < s.length()) {
        // Expand window
        char c = s.charAt(right);
        windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);
        
        if (tCount.containsKey(c) && 
            windowCounts.get(c).intValue() == tCount.get(c).intValue()) {
            formed++;
        }
        
        // Contract window
        while (left <= right && formed == required) {
            // Update result
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minLeft = left;
            }
            
            char leftChar = s.charAt(left);
            windowCounts.put(leftChar, windowCounts.get(leftChar) - 1);
            
            if (tCount.containsKey(leftChar) && 
                windowCounts.get(leftChar) < tCount.get(leftChar)) {
                formed--;
            }
            
            left++;
        }
        
        right++;
    }
    
    return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);
}

// Example:
// s = "ADOBECODEBANC", t = "ABC"
// Output: "BANC"
```

**Time**: O(|S| + |T|), **Space**: O(|S| + |T|)

---

## Palindromes

### What is a Palindrome?

**Definition**: A string that reads the same forward and backward.

```
"racecar" → Palindrome ✓
"madam" → Palindrome ✓
"hello" → NOT palindrome ✗
```

### Core Techniques

#### 1. Two Pointers

```java
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    
    return true;
}
```

**Time**: O(n), **Space**: O(1)

#### 2. Reverse and Compare

```java
public boolean isPalindrome(String s) {
    String reversed = new StringBuilder(s).reverse().toString();
    return s.equals(reversed);
}
```

**Time**: O(n), **Space**: O(n)

#### 3. Valid Palindrome (Alphanumeric Only)

```java
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        // Skip non-alphanumeric characters
        while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
            left++;
        }
        while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
            right--;
        }
        
        if (Character.toLowerCase(s.charAt(left)) != 
            Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        
        left++;
        right--;
    }
    
    return true;
}

// Example:
// "A man, a plan, a canal: Panama" → true
// "race a car" → false
```

**Time**: O(n), **Space**: O(1)

### Pattern 1: Longest Palindromic Substring (LeetCode 5)

**Approach 1: Expand Around Center**

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) return "";
    
    int start = 0, end = 0;
    
    for (int i = 0; i < s.length(); i++) {
        // Odd length palindrome (center at i)
        int len1 = expandAroundCenter(s, i, i);
        // Even length palindrome (center between i and i+1)
        int len2 = expandAroundCenter(s, i, i + 1);
        
        int len = Math.max(len1, len2);
        
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    return right - left - 1;
}

// Example:
// "babad" → "bab" or "aba"
// "cbbd" → "bb"
```

**Time**: O(n²), **Space**: O(1)

**Approach 2: Dynamic Programming**

```java
public String longestPalindromeDP(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    
    int start = 0, maxLen = 1;
    
    // All single characters are palindromes
    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }
    
    // Check for length 2
    for (int i = 0; i < n - 1; i++) {
        if (s.charAt(i) == s.charAt(i + 1)) {
            dp[i][i + 1] = true;
            start = i;
            maxLen = 2;
        }
    }
    
    // Check for lengths 3 to n
    for (int len = 3; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            
            if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                dp[i][j] = true;
                start = i;
                maxLen = len;
            }
        }
    }
    
    return s.substring(start, start + maxLen);
}
```

**Time**: O(n²), **Space**: O(n²)

### Pattern 2: Palindrome Partitioning (LeetCode 131)

**Problem**: Partition string so every substring is a palindrome.

```java
public List<List<String>> partition(String s) {
    List<List<String>> result = new ArrayList<>();
    backtrack(s, 0, new ArrayList<>(), result);
    return result;
}

private void backtrack(String s, int start, List<String> current, List<List<String>> result) {
    if (start == s.length()) {
        result.add(new ArrayList<>(current));
        return;
    }
    
    for (int end = start; end < s.length(); end++) {
        if (isPalindrome(s, start, end)) {
            current.add(s.substring(start, end + 1));
            backtrack(s, end + 1, current, result);
            current.remove(current.size() - 1);
        }
    }
}

private boolean isPalindrome(String s, int left, int right) {
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) {
            return false;
        }
    }
    return true;
}

// Example:
// "aab" → [["a","a","b"], ["aa","b"]]
```

**Optimization**: Precompute palindromes using DP

```java
public List<List<String>> partitionOptimized(String s) {
    int n = s.length();
    boolean[][] isPalin = new boolean[n][n];
    
    // Precompute palindromes
    for (int i = 0; i < n; i++) {
        isPalin[i][i] = true;
    }
    
    for (int i = 0; i < n - 1; i++) {
        isPalin[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));
    }
    
    for (int len = 3; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            isPalin[i][j] = (s.charAt(i) == s.charAt(j)) && isPalin[i + 1][j - 1];
        }
    }
    
    List<List<String>> result = new ArrayList<>();
    backtrackWithDP(s, 0, new ArrayList<>(), result, isPalin);
    return result;
}

private void backtrackWithDP(String s, int start, List<String> current, 
                             List<List<String>> result, boolean[][] isPalin) {
    if (start == s.length()) {
        result.add(new ArrayList<>(current));
        return;
    }
    
    for (int end = start; end < s.length(); end++) {
        if (isPalin[start][end]) {
            current.add(s.substring(start, end + 1));
            backtrackWithDP(s, end + 1, current, result, isPalin);
            current.remove(current.size() - 1);
        }
    }
}
```

**Time**: O(n × 2^n), **Space**: O(n²)

### Pattern 3: Shortest Palindrome (LeetCode 214)

**Problem**: Find shortest palindrome by adding characters to front.

```java
public String shortestPalindrome(String s) {
    if (s == null || s.length() <= 1) return s;
    
    // Find longest palindrome starting from index 0
    int end = s.length() - 1;
    
    for (int i = s.length() - 1; i >= 0; i--) {
        if (isPalindrome(s, 0, i)) {
            end = i;
            break;
        }
    }
    
    // Add reverse of suffix to front
    String suffix = s.substring(end + 1);
    String prefix = new StringBuilder(suffix).reverse().toString();
    
    return prefix + s;
}

private boolean isPalindrome(String s, int left, int right) {
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) return false;
    }
    return true;
}

// Example:
// "aacecaaa" → "aaacecaaa"
// "abcd" → "dcbabcd"
```

**Optimized**: Using KMP

```java
public String shortestPalindromeKMP(String s) {
    String rev = new StringBuilder(s).reverse().toString();
    String combined = s + "#" + rev;
    
    int[] lps = computeLPS(combined);
    int palindromeLen = lps[combined.length() - 1];
    
    String suffix = s.substring(palindromeLen);
    return new StringBuilder(suffix).reverse().toString() + s;
}

private int[] computeLPS(String s) {
    int[] lps = new int[s.length()];
    int len = 0, i = 1;
    
    while (i < s.length()) {
        if (s.charAt(i) == s.charAt(len)) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    
    return lps;
}
```

**Time**: O(n), **Space**: O(n)

---

## Combined Patterns

### Pattern 1: Palindrome Permutation

**Problem**: Check if string can be rearranged to form a palindrome.

```java
public boolean canPermutePalindrome(String s) {
    Map<Character, Integer> count = new HashMap<>();
    
    for (char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }
    
    int oddCount = 0;
    for (int freq : count.values()) {
        if (freq % 2 == 1) {
            oddCount++;
        }
    }
    
    // At most one character can have odd frequency
    return oddCount <= 1;
}

// Example:
// "code" → false (all chars have odd freq)
// "aab" → true (can form "aba")
// "carerac" → true (can form "racecar")
```

**Time**: O(n), **Space**: O(k) where k = unique characters

### Pattern 2: Longest Palindrome from Characters (LeetCode 409)

**Problem**: Find length of longest palindrome that can be built.

```java
public int longestPalindrome(String s) {
    Map<Character, Integer> count = new HashMap<>();
    
    for (char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }
    
    int length = 0;
    boolean hasOdd = false;
    
    for (int freq : count.values()) {
        length += freq / 2 * 2; // Add pairs
        if (freq % 2 == 1) {
            hasOdd = true;
        }
    }
    
    return hasOdd ? length + 1 : length;
}

// Example:
// "abccccdd" → 7 (can build "dccaccd")
```

**Time**: O(n), **Space**: O(k)

### Pattern 3: Palindromic Anagrams

**Problem**: Find all palindromic permutations of a string.

```java
public List<String> generatePalindromes(String s) {
    List<String> result = new ArrayList<>();
    
    Map<Character, Integer> count = new HashMap<>();
    for (char c : s.toCharArray()) {
        count.put(c, count.getOrDefault(c, 0) + 1);
    }
    
    // Check if palindrome is possible
    char oddChar = 0;
    int oddCount = 0;
    
    for (Map.Entry<Character, Integer> entry : count.entrySet()) {
        if (entry.getValue() % 2 == 1) {
            oddCount++;
            oddChar = entry.getKey();
        }
    }
    
    if (oddCount > 1) return result; // Impossible
    
    // Build half of palindrome
    StringBuilder half = new StringBuilder();
    for (Map.Entry<Character, Integer> entry : count.entrySet()) {
        char c = entry.getKey();
        int freq = entry.getValue() / 2;
        for (int i = 0; i < freq; i++) {
            half.append(c);
        }
    }
    
    // Generate permutations of half
    permute(half.toString().toCharArray(), 0, result, oddChar);
    
    return result;
}

private void permute(char[] chars, int start, List<String> result, char oddChar) {
    if (start == chars.length) {
        String half = new String(chars);
        String palindrome = half + (oddChar == 0 ? "" : oddChar) + 
                           new StringBuilder(half).reverse().toString();
        result.add(palindrome);
        return;
    }
    
    Set<Character> used = new HashSet<>();
    for (int i = start; i < chars.length; i++) {
        if (used.contains(chars[i])) continue;
        
        used.add(chars[i]);
        swap(chars, start, i);
        permute(chars, start + 1, result, oddChar);
        swap(chars, start, i);
    }
}

private void swap(char[] chars, int i, int j) {
    char temp = chars[i];
    chars[i] = chars[j];
    chars[j] = temp;
}

// Example:
// "aabb" → ["abba", "baab"]
// "abc" → [] (impossible)
```

---

## Interview Questions & Answers

### Q1: What's the difference between anagram and palindrome?

**A**: 
- **Anagram**: Same characters, possibly different order ("listen" ↔ "silent")
- **Palindrome**: Reads same forward and backward ("racecar")

A palindrome can be an anagram of itself ("noon" is anagram of "noon"), but most anagrams are not palindromes.

### Q2: Best approach to check if two strings are anagrams?

**A**: Depends on constraints:

**Lowercase English letters**: Use frequency array O(n) time, O(1) space
```java
int[] count = new int[26];
```

**Unicode/Mixed case**: Use HashMap O(n) time, O(k) space
```java
Map<Character, Integer> count = new HashMap<>();
```

**Space-constrained**: Sort both O(n log n) time, O(1) space
```java
Arrays.sort(s.toCharArray());
```

### Q3: How to find if string can form a palindrome?

**A**: Count character frequencies - at most ONE character can have odd frequency.

```java
// "aab" → true (can form "aba")
// "abc" → false (all have odd freq)

int oddCount = 0;
for (int freq : charFrequency.values()) {
    if (freq % 2 == 1) oddCount++;
}
return oddCount <= 1;
```

### Q4: Expand around center vs DP for longest palindromic substring?

**A**: 

**Expand Around Center**:
- Time: O(n²), Space: O(1)
- Easier to implement
- Better space complexity
- **Recommended for interviews**

**Dynamic Programming**:
- Time: O(n²), Space: O(n²)
- Can reuse results for multiple queries
- Better if need all palindromic substrings

### Q5: How to optimize palindrome checking?

**A**: 

**Single check**: Two pointers O(n)

**Multiple checks**: Precompute DP table
```java
boolean[][] isPalin = new boolean[n][n];
// O(n²) preprocessing, O(1) per query
```

**Very long strings**: Use hashing (Rabin-Karp)
```java
// Hash forward and backward, compare
long hashForward = computeHash(s);
long hashBackward = computeHashReverse(s);
return hashForward == hashBackward; // O(n), but needs verification
```

### Q6: Common mistakes with anagrams?

**A**: 

1. **Forgetting length check**
```java
// WRONG
if (sorted(s1).equals(sorted(s2))) return true;

// RIGHT
if (s1.length() != s2.length()) return false;
```

2. **Case sensitivity**
```java
// If case-insensitive needed:
s1 = s1.toLowerCase();
```

3. **Counting wrong**
```java
// WRONG (doesn't detect extra chars)
for (char c : s1) count[c - 'a']++;
for (char c : s2) count[c - 'a']++;

// RIGHT
for (char c : s1) count[c - 'a']++;
for (char c : s2) count[c - 'a']--;
```

### Q7: How to find all anagram indices efficiently?

**A**: Sliding window with frequency matching

```java
// Instead of comparing arrays each time
if (Arrays.equals(pCount, sCount)) // O(26) each iteration

// Use match counter
int matches = 0; // Count of chars with correct frequency
// Update matches as window slides: O(1) per iteration
```

### Q8: Palindrome with one deletion allowed?

**A**: Check both possibilities when mismatch found

```java
public boolean validPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            // Try deleting left OR right
            return isPalindrome(s, left + 1, right) || 
                   isPalindrome(s, left, right - 1);
        }
        left++;
        right--;
    }
    
    return true;
}
```

**Time**: O(n)

### Q9: Shortest way to make string palindrome?

**A**: Three approaches:

1. **Add to front** (LeetCode 214): Find longest palindrome from start
2. **Add to end**: Find longest palindrome from end
3. **Add to middle**: Find longest palindromic subsequence, add missing chars

Minimum additions = n - length(longest palindromic subsequence)

### Q10: Group anagrams efficiently for large datasets?

**A**: 

**Option 1**: Sort as key O(n × k log k)
```java
String key = sortedString(s);
map.put(key, list);
```

**Option 2**: Frequency as key O(n × k)
```java
String key = frequencyString(s); // "a2b1c3"
map.put(key, list);
```

**Option 3**: Prime multiplication (risky - overflow)
```java
long key = primeProduct(s); // 'a'→2, 'b'→3, 'c'→5
// Can overflow for long strings
```

**Recommended**: Option 2 for best performance

---

## Practice Problems

### Problem 1: Valid Anagram (LeetCode 242)

```java
public class ValidAnagram {
    
    // Solution 1: Sorting
    public boolean isAnagram1(String s, String t) {
        if (s.length() != t.length()) return false;
        
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        Arrays.sort(sArr);
        Arrays.sort(tArr);
        
        return Arrays.equals(sArr, tArr);
    }
    
    // Solution 2: Frequency array (Best)
    public boolean isAnagram2(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] count = new int[26];
        
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    // Solution 3: HashMap
    public boolean isAnagram3(String s, String t) {
        if (s.length() != t.length()) return false;
        
        Map<Character, Integer> count = new HashMap<>();
        
        for (char c : s.toCharArray()) {
            count.put(c, count.getOrDefault(c, 0) + 1);
        }
        
        for (char c : t.toCharArray()) {
            if (!count.containsKey(c)) return false;
            count.put(c, count.get(c) - 1);
            if (count.get(c) < 0) return false;
        }
        
        return true;
    }
}
```

### Problem 2: Valid Palindrome II (LeetCode 680)

```java
public class ValidPalindromeII {
    
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                // Try skipping left or right
                return isPalindrome(s, left + 1, right) || 
                       isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        ValidPalindromeII vp = new ValidPalindromeII();
        
        System.out.println(vp.validPalindrome("aba")); // true
        System.out.println(vp.validPalindrome("abca")); // true (remove 'c')
        System.out.println(vp.validPalindrome("abc")); // false
    }
}
```

### Problem 3: Palindromic Substrings (LeetCode 647)

```java
public class PalindromicSubstrings {
    
    // Solution 1: Expand around center
    public int countSubstrings(String s) {
        int count = 0;
        
        for (int i = 0; i < s.length(); i++) {
            // Odd length
            count += expandAroundCenter(s, i, i);
            // Even length
            count += expandAroundCenter(s, i, i + 1);
        }
        
        return count;
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        int count = 0;
        
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            count++;
            left--;
            right++;
        }
        
        return count;
    }
    
    // Solution 2: Dynamic Programming
    public int countSubstringsDP(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int count = 0;
        
        // Single characters
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
            count++;
        }
        
        // Length 2
        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                count++;
            }
        }
        
        // Length 3+
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    count++;
                }
            }
        }
        
        return count;
    }
    
    // Test
    public static void main(String[] args) {
        PalindromicSubstrings ps = new PalindromicSubstrings();
        
        System.out.println(ps.countSubstrings("abc")); // 3 (a, b, c)
        System.out.println(ps.countSubstrings("aaa")); // 6 (a, a, a, aa, aa, aaa)
    }
}
```

### Problem 4: Group Anagrams (LeetCode 49)

```java
public class GroupAnagrams {
    
    // Solution 1: Sorted string as key
    public List<List<String>> groupAnagrams1(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strs) {
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
        }
        
        return new ArrayList<>(map.values());
    }
    
    // Solution 2: Frequency count as key (faster)
    public List<List<String>> groupAnagrams2(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strs) {
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (count[i] > 0) {
                    key.append((char)('a' + i));
                    key.append(count[i]);
                }
            }
            
            map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);
        }
        
        return new ArrayList<>(map.values());
    }
    
    // Test
    public static void main(String[] args) {
        GroupAnagrams ga = new GroupAnagrams();
        
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        System.out.println(ga.groupAnagrams2(strs));
        // Output: [["bat"], ["nat","tan"], ["ate","eat","tea"]]
    }
}
```

### Problem 5: Longest Palindromic Substring (LeetCode 5)

```java
public class LongestPalindromicSubstring {
    
    // Solution: Expand around center (recommended)
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        
        int start = 0, end = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);     // Odd
            int len2 = expandAroundCenter(s, i, i + 1); // Even
            int len = Math.max(len1, len2);
            
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.substring(start, end + 1);
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
    // Test
    public static void main(String[] args) {
        LongestPalindromicSubstring lps = new LongestPalindromicSubstring();
        
        System.out.println(lps.longestPalindrome("babad")); // "bab" or "aba"
        System.out.println(lps.longestPalindrome("cbbd"));  // "bb"
    }
}
```

---

## Summary

### Anagrams - Key Points
✅ Use frequency count for O(n) verification  
✅ Sort as key for grouping: O(k log k)  
✅ Sliding window for finding anagram indices  
✅ At most one odd frequency → can form palindrome  

### Palindromes - Key Points
✅ Two pointers for O(1) space verification  
✅ Expand around center for finding longest: O(n²) time, O(1) space  
✅ DP for precomputing all palindromes: O(n²) time and space  
✅ At most one deletion → try both possibilities  

### Decision Tree

```
Check anagram?
├─ Lowercase only → int[26] frequency array
├─ Unicode → HashMap
└─ Limited space → Sort both strings

Find palindrome?
├─ Check if string is palindrome → Two pointers
├─ Find longest palindromic substring → Expand around center
├─ Count palindromic substrings → Expand around center
├─ Partition into palindromes → Backtracking + DP
└─ Make palindrome with min additions → KMP or greedy
```

### Common Patterns

| Problem Type | Approach | Complexity |
|--------------|----------|------------|
| **Verify anagram** | Frequency count | O(n), O(1) |
| **Group anagrams** | HashMap with sorted/freq key | O(n×k log k) |
| **Find anagram indices** | Sliding window | O(n) |
| **Check palindrome** | Two pointers | O(n), O(1) |
| **Longest palindrome** | Expand around center | O(n²), O(1) |
| **Count palindromes** | Expand around center | O(n²), O(1) |
| **Partition palindromes** | Backtrack + DP | O(n×2^n) |

---

**Related Topics**: String Hashing (4.4), KMP Algorithm (4.5), Rabin-Karp (4.6-4.8)
