# String Manipulation - Complete Guide

## Why String Manipulation?

**Most tested skill in coding interviews!**

- **35% of LeetCode problems** involve string manipulation
- **Top companies:** Google, Facebook, Amazon love these questions
- **Foundation for:** Pattern matching, text processing, parsing
- **Real-world:** Data validation, formatting, text analysis

**Master manipulation = Interview success!**

---

## Table of Contents

1. [Anagram Problems](#anagrams)
2. [Palindrome Problems](#palindromes)
3. [Subsequence and Substring](#subsequence)
4. [String Compression](#compression)
5. [String Permutations](#permutations)
6. [String Encoding/Decoding](#encoding)
7. [Advanced Manipulation Patterns](#advanced)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="anagrams"></a>
## 1. Anagram Problems

### What is an Anagram?

**Anagram:** Two strings with same characters, different order.

Examples:
- "listen" ↔ "silent"
- "evil" ↔ "vile"
- "astronomer" ↔ "moon starer"

---

### Pattern 1.1: Valid Anagram

```java
public class ValidAnagram {
    
    // Method 1: Sorting
    public static boolean isAnagram1(String s, String t) {
        if (s.length() != t.length()) return false;
        
        char[] sArr = s.toCharArray();
        char[] tArr = t.toCharArray();
        
        Arrays.sort(sArr);
        Arrays.sort(tArr);
        
        return Arrays.equals(sArr, tArr);
    }
    
    // Method 2: Frequency Array (Best for lowercase letters)
    public static boolean isAnagram2(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] count = new int[26];
        
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    // Method 3: HashMap (For Unicode/mixed case)
    public static boolean isAnagram3(String s, String t) {
        if (s.length() != t.length()) return false;
        
        Map<Character, Integer> map = new HashMap<>();
        
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        for (char c : t.toCharArray()) {
            if (!map.containsKey(c)) return false;
            map.put(c, map.get(c) - 1);
            if (map.get(c) < 0) return false;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isAnagram1("anagram", "nagaram"));  // true
        System.out.println(isAnagram2("rat", "car"));  // false
        System.out.println(isAnagram3("listen", "silent"));  // true
    }
}
```

**Time Complexity:**
- Method 1: O(n log n) - sorting
- Method 2: O(n) - array ⭐ Best
- Method 3: O(n) - HashMap

**Space Complexity:**
- Method 1: O(1) - in-place sort
- Method 2: O(1) - fixed array
- Method 3: O(n) - HashMap

---

### Pattern 1.2: Group Anagrams

**Problem:** Group strings that are anagrams.

```java
public class GroupAnagrams {
    
    public static List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String str : strs) {
            // Create frequency key
            int[] count = new int[26];
            for (char c : str.toCharArray()) {
                count[c - 'a']++;
            }
            
            // Convert to string key
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (count[i] > 0) {
                    key.append((char) ('a' + i));
                    key.append(count[i]);
                }
            }
            
            String keyStr = key.toString();
            map.putIfAbsent(keyStr, new ArrayList<>());
            map.get(keyStr).add(str);
        }
        
        return new ArrayList<>(map.values());
    }
    
    // Alternative: Sort as key
    public static List<List<String>> groupAnagrams2(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String str : strs) {
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            
            map.putIfAbsent(key, new ArrayList<>());
            map.get(key).add(str);
        }
        
        return new ArrayList<>(map.values());
    }
    
    public static void main(String[] args) {
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        System.out.println(groupAnagrams(strs));
        // [["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
    }
}
```

**Time:** O(n × k) where n = number of strings, k = max length  
**Space:** O(n × k)

---

### Pattern 1.3: Find All Anagrams in String

**Problem:** Find all anagram substrings.

```java
public class FindAnagrams {
    
    public static List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;
        
        int[] pCount = new int[26];
        int[] sCount = new int[26];
        
        // Count p
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        for (int i = 0; i < s.length(); i++) {
            // Add current character
            sCount[s.charAt(i) - 'a']++;
            
            // Remove character that's sliding out
            if (i >= p.length()) {
                sCount[s.charAt(i - p.length()) - 'a']--;
            }
            
            // Compare arrays
            if (i >= p.length() - 1 && Arrays.equals(pCount, sCount)) {
                result.add(i - p.length() + 1);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(findAnagrams("cbaebabacd", "abc"));  // [0, 6]
        System.out.println(findAnagrams("abab", "ab"));  // [0, 1, 2]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="palindromes"></a>
## 2. Palindrome Problems

### Pattern 2.1: Valid Palindrome (Basic)

```java
public class ValidPalindrome {
    
    // Simple palindrome check
    public static boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // Alphanumeric only, case-insensitive
    public static boolean isPalindromeAlphanumeric(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isPalindrome("racecar"));  // true
        System.out.println(isPalindromeAlphanumeric("A man, a plan, a canal: Panama"));  // true
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 2.2: Valid Palindrome II (Delete One Character)

**Problem:** Can string become palindrome by deleting at most one character?

```java
public class ValidPalindromeII {
    
    public static boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                // Try deleting left or right
                return isPalindrome(s, left + 1, right) || 
                       isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    private static boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(validPalindrome("aba"));  // true
        System.out.println(validPalindrome("abca"));  // true (delete 'c')
        System.out.println(validPalindrome("abc"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 2.3: Longest Palindromic Substring

```java
public class LongestPalindrome {
    
    // Expand around center
    public static String longestPalindrome(String s) {
        if (s == null || s.length() < 2) return s;
        
        int start = 0, maxLen = 0;
        
        for (int i = 0; i < s.length(); i++) {
            // Odd length palindromes (center = single char)
            int len1 = expandAroundCenter(s, i, i);
            // Even length palindromes (center = between two chars)
            int len2 = expandAroundCenter(s, i, i + 1);
            
            int len = Math.max(len1, len2);
            
            if (len > maxLen) {
                maxLen = len;
                start = i - (len - 1) / 2;
            }
        }
        
        return s.substring(start, start + maxLen);
    }
    
    private static int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && 
               s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
    public static void main(String[] args) {
        System.out.println(longestPalindrome("babad"));  // "bab" or "aba"
        System.out.println(longestPalindrome("cbbd"));  // "bb"
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### Pattern 2.4: Palindrome Partitioning

**Problem:** Partition string so every substring is palindrome.

```java
public class PalindromePartition {
    
    public static List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        backtrack(s, 0, new ArrayList<>(), result);
        return result;
    }
    
    private static void backtrack(String s, int start, 
                                   List<String> path, 
                                   List<List<String>> result) {
        if (start == s.length()) {
            result.add(new ArrayList<>(path));
            return;
        }
        
        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) {
                path.add(s.substring(start, end + 1));
                backtrack(s, end + 1, path, result);
                path.remove(path.size() - 1);
            }
        }
    }
    
    private static boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) return false;
            left++;
            right--;
        }
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(partition("aab"));
        // [["a", "a", "b"], ["aa", "b"]]
    }
}
```

**Time:** O(n × 2^n), **Space:** O(n)

---

<a name="subsequence"></a>
## 3. Subsequence and Substring

### Understanding the Difference

**Substring:** Contiguous characters  
- "abc" from "abcde" ✅
- "acd" from "abcde" ❌ (not contiguous)

**Subsequence:** Maintains order, not necessarily contiguous  
- "ace" from "abcde" ✅
- "aec" from "abcde" ❌ (wrong order)

---

### Pattern 3.1: Is Subsequence

```java
public class IsSubsequence {
    
    // Two pointers
    public static boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        
        return i == s.length();
    }
    
    public static void main(String[] args) {
        System.out.println(isSubsequence("abc", "ahbgdc"));  // true
        System.out.println(isSubsequence("axc", "ahbgdc"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3.2: Longest Common Subsequence

```java
public class LongestCommonSubsequence {
    
    public static int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    public static void main(String[] args) {
        System.out.println(longestCommonSubsequence("abcde", "ace"));  // 3
        System.out.println(longestCommonSubsequence("abc", "abc"));  // 3
        System.out.println(longestCommonSubsequence("abc", "def"));  // 0
    }
}
```

**Time:** O(m × n), **Space:** O(m × n)

---

### Pattern 3.3: Longest Repeating Character Replacement

**Problem:** Longest substring with same letter after k replacements.

```java
public class CharacterReplacement {
    
    public static int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int maxCount = 0;
        int maxLength = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            count[s.charAt(right) - 'A']++;
            maxCount = Math.max(maxCount, count[s.charAt(right) - 'A']);
            
            // If window size - most frequent > k, shrink window
            while (right - left + 1 - maxCount > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }
            
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(characterReplacement("ABAB", 2));  // 4
        System.out.println(characterReplacement("AABABBA", 1));  // 4
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="compression"></a>
## 4. String Compression

### Pattern 4.1: Basic String Compression

```java
public class StringCompression {
    
    public static String compress(String s) {
        StringBuilder compressed = new StringBuilder();
        int count = 1;
        
        for (int i = 1; i <= s.length(); i++) {
            if (i == s.length() || s.charAt(i) != s.charAt(i - 1)) {
                compressed.append(s.charAt(i - 1));
                if (count > 1) {
                    compressed.append(count);
                }
                count = 1;
            } else {
                count++;
            }
        }
        
        String result = compressed.toString();
        return result.length() < s.length() ? result : s;
    }
    
    public static void main(String[] args) {
        System.out.println(compress("aabcccccaaa"));  // "a2bc5a3"
        System.out.println(compress("abcd"));  // "abcd" (no compression)
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Pattern 4.2: Compress String (In-Place)

**Problem:** Compress array of characters in-place.

```java
public class CompressInPlace {
    
    public static int compress(char[] chars) {
        int write = 0, anchor = 0;
        
        for (int read = 0; read < chars.length; read++) {
            if (read + 1 == chars.length || chars[read] != chars[read + 1]) {
                chars[write++] = chars[anchor];
                
                int count = read - anchor + 1;
                if (count > 1) {
                    for (char c : String.valueOf(count).toCharArray()) {
                        chars[write++] = c;
                    }
                }
                
                anchor = read + 1;
            }
        }
        
        return write;
    }
    
    public static void main(String[] args) {
        char[] chars1 = {'a','a','b','b','c','c','c'};
        int len1 = compress(chars1);
        System.out.println(new String(chars1, 0, len1));  // "a2b2c3"
        
        char[] chars2 = {'a'};
        int len2 = compress(chars2);
        System.out.println(new String(chars2, 0, len2));  // "a"
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 4.3: Decode String

**Problem:** Decode "3[a]2[bc]" → "aaabcbc"

```java
public class DecodeString {
    
    public static String decodeString(String s) {
        Stack<Integer> countStack = new Stack<>();
        Stack<StringBuilder> stringStack = new Stack<>();
        StringBuilder current = new StringBuilder();
        int num = 0;
        
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            } else if (c == '[') {
                countStack.push(num);
                stringStack.push(current);
                current = new StringBuilder();
                num = 0;
            } else if (c == ']') {
                int count = countStack.pop();
                StringBuilder temp = current;
                current = stringStack.pop();
                
                for (int i = 0; i < count; i++) {
                    current.append(temp);
                }
            } else {
                current.append(c);
            }
        }
        
        return current.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(decodeString("3[a]2[bc]"));  // "aaabcbc"
        System.out.println(decodeString("3[a2[c]]"));  // "accaccacc"
        System.out.println(decodeString("2[abc]3[cd]ef"));  // "abcabccdcdcdef"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

<a name="permutations"></a>
## 5. String Permutations

### Pattern 5.1: Check Permutation in String

**Problem:** Check if s1's permutation is substring of s2.

```java
public class PermutationInString {
    
    public static boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        
        int[] s1Count = new int[26];
        int[] s2Count = new int[26];
        
        for (int i = 0; i < s1.length(); i++) {
            s1Count[s1.charAt(i) - 'a']++;
            s2Count[s2.charAt(i) - 'a']++;
        }
        
        if (Arrays.equals(s1Count, s2Count)) return true;
        
        for (int i = s1.length(); i < s2.length(); i++) {
            s2Count[s2.charAt(i) - 'a']++;
            s2Count[s2.charAt(i - s1.length()) - 'a']--;
            
            if (Arrays.equals(s1Count, s2Count)) return true;
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        System.out.println(checkInclusion("ab", "eidbaooo"));  // true
        System.out.println(checkInclusion("ab", "eidboaoo"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 5.2: All Permutations of String

```java
public class StringPermutations {
    
    public static List<String> permute(String s) {
        List<String> result = new ArrayList<>();
        backtrack(s.toCharArray(), 0, result);
        return result;
    }
    
    private static void backtrack(char[] chars, int start, List<String> result) {
        if (start == chars.length) {
            result.add(new String(chars));
            return;
        }
        
        Set<Character> used = new HashSet<>();
        for (int i = start; i < chars.length; i++) {
            if (used.contains(chars[i])) continue;
            used.add(chars[i]);
            
            swap(chars, start, i);
            backtrack(chars, start + 1, result);
            swap(chars, start, i);  // backtrack
        }
    }
    
    private static void swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }
    
    public static void main(String[] args) {
        System.out.println(permute("abc"));
        // [abc, acb, bac, bca, cab, cba]
        
        System.out.println(permute("aab"));
        // [aab, aba, baa]
    }
}
```

**Time:** O(n!), **Space:** O(n)

---

<a name="encoding"></a>
## 6. String Encoding/Decoding

### Pattern 6.1: Encode and Decode Strings

**Problem:** Design encode/decode for list of strings.

```java
public class Codec {
    
    // Encode: length + delimiter + string
    public String encode(List<String> strs) {
        StringBuilder sb = new StringBuilder();
        for (String str : strs) {
            sb.append(str.length()).append('#').append(str);
        }
        return sb.toString();
    }
    
    // Decode: read length, then string
    public List<String> decode(String s) {
        List<String> result = new ArrayList<>();
        int i = 0;
        
        while (i < s.length()) {
            int delimiterIndex = s.indexOf('#', i);
            int length = Integer.parseInt(s.substring(i, delimiterIndex));
            
            int start = delimiterIndex + 1;
            result.add(s.substring(start, start + length));
            
            i = start + length;
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        Codec codec = new Codec();
        List<String> strs = Arrays.asList("Hello", "World", "");
        
        String encoded = codec.encode(strs);
        System.out.println("Encoded: " + encoded);  // "5#Hello5#World0#"
        
        List<String> decoded = codec.decode(encoded);
        System.out.println("Decoded: " + decoded);  // [Hello, World, ""]
    }
}
```

**Why this works:** Handles strings with special characters, empty strings, etc.

**Time:** O(n), **Space:** O(n)

---

### Pattern 6.2: Run-Length Encoding

```java
public class RunLengthEncoding {
    
    public static String encode(String s) {
        if (s.isEmpty()) return "";
        
        StringBuilder encoded = new StringBuilder();
        int count = 1;
        
        for (int i = 1; i <= s.length(); i++) {
            if (i == s.length() || s.charAt(i) != s.charAt(i - 1)) {
                encoded.append(s.charAt(i - 1)).append(count);
                count = 1;
            } else {
                count++;
            }
        }
        
        return encoded.toString();
    }
    
    public static String decode(String s) {
        StringBuilder decoded = new StringBuilder();
        
        for (int i = 0; i < s.length(); i += 2) {
            char c = s.charAt(i);
            int count = s.charAt(i + 1) - '0';
            
            for (int j = 0; j < count; j++) {
                decoded.append(c);
            }
        }
        
        return decoded.toString();
    }
    
    public static void main(String[] args) {
        String original = "aaabbbcc";
        String encoded = encode(original);
        System.out.println("Encoded: " + encoded);  // "a3b3c2"
        
        String decoded = decode(encoded);
        System.out.println("Decoded: " + decoded);  // "aaabbbcc"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

<a name="advanced"></a>
## 7. Advanced Manipulation Patterns

### Pattern 7.1: Minimum Window Substring

**Problem:** Smallest substring of s containing all chars of t.

```java
public class MinimumWindowSubstring {
    
    public static String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        
        Map<Character, Integer> target = new HashMap<>();
        for (char c : t.toCharArray()) {
            target.put(c, target.getOrDefault(c, 0) + 1);
        }
        
        int required = target.size();
        int formed = 0;
        
        Map<Character, Integer> window = new HashMap<>();
        int left = 0, right = 0;
        
        int[] result = {-1, 0, 0};  // length, left, right
        
        while (right < s.length()) {
            char c = s.charAt(right);
            window.put(c, window.getOrDefault(c, 0) + 1);
            
            if (target.containsKey(c) && 
                window.get(c).intValue() == target.get(c).intValue()) {
                formed++;
            }
            
            while (left <= right && formed == required) {
                c = s.charAt(left);
                
                if (result[0] == -1 || right - left + 1 < result[0]) {
                    result[0] = right - left + 1;
                    result[1] = left;
                    result[2] = right;
                }
                
                window.put(c, window.get(c) - 1);
                if (target.containsKey(c) && 
                    window.get(c).intValue() < target.get(c).intValue()) {
                    formed--;
                }
                
                left++;
            }
            
            right++;
        }
        
        return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);
    }
    
    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC"));  // "BANC"
        System.out.println(minWindow("a", "a"));  // "a"
    }
}
```

**Time:** O(|S| + |T|), **Space:** O(|S| + |T|)

---

### Pattern 7.2: Longest Substring Without Repeating Characters

```java
public class LongestSubstringNonRepeating {
    
    public static int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            
            if (map.containsKey(c)) {
                left = Math.max(left, map.get(c) + 1);
            }
            
            map.put(c, right);
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
    
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb"));  // 3 ("abc")
        System.out.println(lengthOfLongestSubstring("bbbbb"));  // 1 ("b")
        System.out.println(lengthOfLongestSubstring("pwwkew"));  // 3 ("wke")
    }
}
```

**Time:** O(n), **Space:** O(min(n, m)) where m = charset size

---

### Pattern 7.3: Word Break

**Problem:** Check if string can be segmented into dictionary words.

```java
public class WordBreak {
    
    public static boolean wordBreak(String s, List<String> wordDict) {
        Set<String> dict = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && dict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[s.length()];
    }
    
    public static void main(String[] args) {
        List<String> dict = Arrays.asList("leet", "code");
        System.out.println(wordBreak("leetcode", dict));  // true
        
        List<String> dict2 = Arrays.asList("apple", "pen");
        System.out.println(wordBreak("applepenapple", dict2));  // true
        
        List<String> dict3 = Arrays.asList("cats", "dog", "sand", "and", "cat");
        System.out.println(wordBreak("catsandog", dict3));  // false
    }
}
```

**Time:** O(n² × k) where k = avg word length, **Space:** O(n)

---

### Pattern 7.4: Multiply Strings

**Problem:** Multiply two number strings (no BigInteger).

```java
public class MultiplyStrings {
    
    public static String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";
        
        int m = num1.length(), n = num2.length();
        int[] result = new int[m + n];
        
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                int p1 = i + j, p2 = i + j + 1;
                
                int sum = mul + result[p2];
                result[p2] = sum % 10;
                result[p1] += sum / 10;
            }
        }
        
        StringBuilder sb = new StringBuilder();
        for (int num : result) {
            if (!(sb.length() == 0 && num == 0)) {
                sb.append(num);
            }
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(multiply("123", "456"));  // "56088"
        System.out.println(multiply("2", "3"));  // "6"
    }
}
```

**Time:** O(m × n), **Space:** O(m + n)

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the difference between substring and subsequence?

**Answer:**
- **Substring:** Contiguous characters ("bc" in "abcd")
- **Subsequence:** Maintains order, not contiguous ("bd" in "abcd")

---

### Q2: How to check if two strings are anagrams efficiently?

**Answer:**
```java
// Best: Frequency array O(n) time, O(1) space
int[] count = new int[26];
for (char c : s.toCharArray()) count[c - 'a']++;
for (char c : t.toCharArray()) count[c - 'a']--;
// Check if all zeros
```

---

### Q3: Best way to reverse words in a string?

**Answer:**
```java
String[] words = s.trim().split("\\s+");
// Reverse array
String.join(" ", reversed);
```

---

### Q4: How to find all palindrome substrings?

**Answer:** Expand around center for each position (odd and even length).  
**Time:** O(n²)

---

### Q5: What's the sliding window pattern for strings?

**Answer:** Maintain window with two pointers, track frequency map.
- Expand right to add characters
- Shrink left when condition violated
- Update result when valid window found

---

### Q6: How to detect if string is rotation of another?

**Answer:** Check if s2 is substring of s1 + s1.
```java
(s1 + s1).contains(s2)
```

---

### Q7: Best approach for permutation in string?

**Answer:** Sliding window with frequency matching.  
**Time:** O(n), **Space:** O(1)

---

### Q8: How to encode/decode strings with special characters?

**Answer:** Use length prefix: "5#Hello3#abc"
- Avoids issues with delimiters in content
- Handles empty strings

---

### Q9: Difference between compareTo() and equals()?

**Answer:**
- **equals():** Returns boolean (true/false)
- **compareTo():** Returns int (< 0, 0, > 0) for ordering

---

### Q10: How to find longest palindrome efficiently?

**Answer:** Expand around center O(n²) is standard.  
Manacher's algorithm achieves O(n) but complex.

---

### Q11: What's the two-pointer technique for palindromes?

**Answer:** Start from ends, move inward:
```java
int left = 0, right = s.length() - 1;
while (left < right) {
    if (s.charAt(left) != s.charAt(right)) return false;
    left++; right--;
}
```

---

### Q12: How to handle Unicode in string problems?

**Answer:**
- Use HashMap instead of fixed array
- Be aware of multi-byte characters
- Use codePoints() for proper iteration

---

### Q13: What's the time complexity of String.contains()?

**Answer:** O(n × m) where n = string length, m = pattern length.  
Uses naive string matching (not KMP).

---

### Q14: Best way to remove duplicates from string?

**Answer:**
```java
Set<Character> seen = new HashSet<>();
StringBuilder sb = new StringBuilder();
for (char c : s.toCharArray()) {
    if (seen.add(c)) sb.append(c);
}
```

---

### Q15: How to count character frequency efficiently?

**Answer:**
```java
// For lowercase: int[26]
// For all chars: HashMap<Character, Integer>
map.put(c, map.getOrDefault(c, 0) + 1);
```

---

### Q16: What's the difference between indexOf() and lastIndexOf()?

**Answer:**
- **indexOf():** First occurrence from left
- **lastIndexOf():** First occurrence from right

---

### Q17: How to check if string has balanced parentheses?

**Answer:** Use stack, push '(' and pop on ')'.
```java
Stack<Character> stack = new Stack<>();
// Return stack.isEmpty() at end
```

---

### Q18: Best approach for string compression?

**Answer:** Single pass with counter:
```java
StringBuilder sb = new StringBuilder();
int count = 1;
// Append char + count when character changes
```

---

### Q19: How to handle case-insensitive comparisons?

**Answer:**
```java
// Method 1: Convert
s1.toLowerCase().equals(s2.toLowerCase())

// Method 2: Compare each char
Character.toLowerCase(c1) == Character.toLowerCase(c2)
```

---

### Q20: What's the space complexity of recursion for string problems?

**Answer:** O(n) for call stack where n = recursion depth.  
For string permutations: O(n!) total solutions.

---

<a name="practice-problems"></a>
## 9. Practice Problems

### Problem 1: Reverse Vowels of String

```java
public class ReverseVowels {
    public static String reverseVowels(String s) {
        char[] chars = s.toCharArray();
        Set<Character> vowels = new HashSet<>(
            Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        );
        
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            while (left < right && !vowels.contains(chars[left])) {
                left++;
            }
            while (left < right && !vowels.contains(chars[right])) {
                right--;
            }
            
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
        
        return new String(chars);
    }
    
    public static void main(String[] args) {
        System.out.println(reverseVowels("hello"));  // "holle"
        System.out.println(reverseVowels("leetcode"));  // "leotcede"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 2: Longest Palindromic Subsequence

```java
public class LongestPalindromicSubsequence {
    public static int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        
        // Base case: single character
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        
        // Build table
        for (int len = 2; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[0][n - 1];
    }
    
    public static void main(String[] args) {
        System.out.println(longestPalindromeSubseq("bbbab"));  // 4 ("bbbb")
        System.out.println(longestPalindromeSubseq("cbbd"));  // 2 ("bb")
    }
}
```

**Time:** O(n²), **Space:** O(n²)

---

### Problem 3: Reorganize String

**Problem:** Rearrange so no two adjacent chars are same.

```java
public class ReorganizeString {
    public static String reorganizeString(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        for (char c : s.toCharArray()) {
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }
        
        PriorityQueue<Character> maxHeap = new PriorityQueue<>(
            (a, b) -> freq.get(b) - freq.get(a)
        );
        maxHeap.addAll(freq.keySet());
        
        StringBuilder result = new StringBuilder();
        
        while (maxHeap.size() > 1) {
            char first = maxHeap.poll();
            char second = maxHeap.poll();
            
            result.append(first);
            result.append(second);
            
            freq.put(first, freq.get(first) - 1);
            freq.put(second, freq.get(second) - 1);
            
            if (freq.get(first) > 0) maxHeap.offer(first);
            if (freq.get(second) > 0) maxHeap.offer(second);
        }
        
        if (!maxHeap.isEmpty()) {
            char last = maxHeap.poll();
            if (freq.get(last) > 1) return "";
            result.append(last);
        }
        
        return result.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(reorganizeString("aab"));  // "aba"
        System.out.println(reorganizeString("aaab"));  // "" (impossible)
    }
}
```

**Time:** O(n log k) where k = unique chars, **Space:** O(k)

---

### Problem 4: Zigzag Conversion

```java
public class ZigzagConversion {
    public static String convert(String s, int numRows) {
        if (numRows == 1) return s;
        
        List<StringBuilder> rows = new ArrayList<>();
        for (int i = 0; i < Math.min(numRows, s.length()); i++) {
            rows.add(new StringBuilder());
        }
        
        int curRow = 0;
        boolean goingDown = false;
        
        for (char c : s.toCharArray()) {
            rows.get(curRow).append(c);
            
            if (curRow == 0 || curRow == numRows - 1) {
                goingDown = !goingDown;
            }
            
            curRow += goingDown ? 1 : -1;
        }
        
        StringBuilder result = new StringBuilder();
        for (StringBuilder row : rows) {
            result.append(row);
        }
        
        return result.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(convert("PAYPALISHIRING", 3));
        // "PAHNAPLSIIGYIR"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 5: Longest Word in Dictionary

```java
public class LongestWord {
    public static String longestWord(String[] words) {
        Set<String> built = new HashSet<>();
        Arrays.sort(words);
        
        String result = "";
        
        for (String word : words) {
            if (word.length() == 1 || built.contains(word.substring(0, word.length() - 1))) {
                built.add(word);
                
                if (word.length() > result.length()) {
                    result = word;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String[] words = {"w", "wo", "wor", "worl", "world"};
        System.out.println(longestWord(words));  // "world"
    }
}
```

**Time:** O(n log n + n × k), **Space:** O(n × k)

---

### Problem 6: Remove K Digits

```java
public class RemoveKDigits {
    public static String removeKdigits(String num, int k) {
        Stack<Character> stack = new Stack<>();
        
        for (char digit : num.toCharArray()) {
            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {
                stack.pop();
                k--;
            }
            stack.push(digit);
        }
        
        // Remove remaining k digits from end
        while (k > 0) {
            stack.pop();
            k--;
        }
        
        // Build result
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        sb.reverse();
        
        // Remove leading zeros
        while (sb.length() > 0 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }
        
        return sb.length() == 0 ? "0" : sb.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(removeKdigits("1432219", 3));  // "1219"
        System.out.println(removeKdigits("10200", 1));  // "200"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

## Summary Cheat Sheet

### Common Patterns

| Pattern | Technique | Time |
|---------|-----------|------|
| **Anagram** | Frequency map/array | O(n) |
| **Palindrome** | Two pointers | O(n) |
| **Subsequence** | Two pointers | O(n) |
| **Substring** | Sliding window | O(n) |
| **Permutation** | Backtracking | O(n!) |
| **Compression** | Counter + StringBuilder | O(n) |

---

### Decision Tree

```
String Problem
│
├─ Same chars different order? → Anagram (frequency map)
├─ Reads same forward/backward? → Palindrome (two pointers)
├─ Order matters, gaps OK? → Subsequence (two pointers)
├─ Contiguous sequence? → Substring (sliding window)
├─ All arrangements? → Permutation (backtracking)
└─ Encode/compress? → Run-length encoding
```

---

### Space Optimization Tricks

1. **Array vs HashMap**
   - Lowercase only: `int[26]` (O(1) space)
   - All chars: `HashMap` (O(k) space)

2. **In-place modification**
   - Convert to char array
   - Two pointers for swapping

3. **StringBuilder for building**
   - Avoid string concatenation in loops

---

## Key Takeaways

✅ **Anagrams:** Frequency counting (array or map)  
✅ **Palindromes:** Two pointers from ends  
✅ **Sliding window:** For substring problems  
✅ **Two pointers:** For subsequence problems  
✅ **Backtracking:** For permutations/combinations  
✅ **Stack:** For nested structures (parentheses, decode)  
✅ **StringBuilder:** For string building  
✅ **HashMap:** For frequency tracking  
✅ **35% of interviews** test string manipulation!  
✅ **Practice patterns** - recognize quickly in interviews!  

---

[← Back: String Basics](./4.1-String-Basics.md) | [Next: Pattern Matching →](./4.3-Pattern-Matching.md)
