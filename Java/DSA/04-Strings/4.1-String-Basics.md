# String Basics - Complete Guide

## Why String Basics?

**Strings are the #1 interview topic!**

- **40% of coding interviews** involve string manipulation
- **Essential for:** Text processing, parsing, validation
- **Foundation for:** Pattern matching, regex, string algorithms
- **Real-world use:** User input, file I/O, API responses

**Master strings = Ace most interviews!**

---

## Table of Contents

1. [What are Strings in Java?](#what-are-strings)
2. [String vs StringBuilder vs StringBuffer](#string-comparison)
3. [String Creation and Internment](#creation)
4. [Essential String Methods](#methods)
5. [Character Operations](#characters)
6. [String Manipulation Patterns](#patterns)
7. [Common Pitfalls](#pitfalls)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="what-are-strings"></a>
## 1. What are Strings in Java?

### String Fundamentals

**Key Properties:**
- **Immutable** - Once created, cannot be changed
- **Sequence of characters** - Internally backed by char array
- **Reference type** - Not primitive
- **Thread-safe** - Because immutable

```java
public class StringBasics {
    public static void main(String[] args) {
        // String is immutable
        String str = "Hello";
        str.concat(" World");  // Creates new string, doesn't modify str
        System.out.println(str);  // Still "Hello"
        
        // Need to reassign
        str = str.concat(" World");
        System.out.println(str);  // "Hello World"
        
        // Internal representation
        String s = "ABC";
        // Internally: char[] {'A', 'B', 'C'}
    }
}
```

---

### Why Strings are Immutable?

**Benefits:**
1. **Security** - String parameters can't be modified
2. **Thread-safety** - Multiple threads can share strings safely
3. **String pool** - Memory optimization through interning
4. **Hashcode caching** - Computed once, reused

```java
public class ImmutabilityDemo {
    public static void main(String[] args) {
        String s1 = "Java";
        String s2 = s1;
        
        s1 = s1 + " 17";  // Creates NEW string
        
        System.out.println(s1);  // "Java 17"
        System.out.println(s2);  // "Java" (unchanged!)
    }
}
```

---

<a name="creation"></a>
## 2. String Creation and Internment

### String Pool (String Constant Pool)

**Located in:** Heap (since Java 7)  
**Purpose:** Reuse string literals for memory efficiency

```java
public class StringPool {
    public static void main(String[] args) {
        // Method 1: String literal (goes to pool)
        String s1 = "Hello";
        String s2 = "Hello";
        
        System.out.println(s1 == s2);  // true (same reference!)
        
        // Method 2: new keyword (creates new object)
        String s3 = new String("Hello");
        String s4 = new String("Hello");
        
        System.out.println(s3 == s4);  // false (different objects)
        System.out.println(s1 == s3);  // false
        
        // Content comparison
        System.out.println(s1.equals(s3));  // true (same content)
    }
}
```

**Visualization:**
```
String Pool:          Heap Memory:
┌─────────┐          ┌─────────┐
│ "Hello" │ ← s1, s2 │ "Hello" │ ← s3
└─────────┘          └─────────┘
                     ┌─────────┐
                     │ "Hello" │ ← s4
                     └─────────┘
```

---

### intern() Method

```java
public class InternExample {
    public static void main(String[] args) {
        String s1 = new String("Hello");
        String s2 = "Hello";
        
        System.out.println(s1 == s2);  // false
        
        // Move to pool
        String s3 = s1.intern();
        
        System.out.println(s3 == s2);  // true (now same reference!)
    }
}
```

---

### Different Ways to Create Strings

```java
public class StringCreation {
    public static void main(String[] args) {
        // 1. String literal
        String s1 = "Hello";
        
        // 2. Using new keyword
        String s2 = new String("Hello");
        
        // 3. From char array
        char[] chars = {'H', 'e', 'l', 'l', 'o'};
        String s3 = new String(chars);
        
        // 4. From byte array
        byte[] bytes = {72, 101, 108, 108, 111};
        String s4 = new String(bytes);
        
        // 5. Using StringBuilder
        StringBuilder sb = new StringBuilder("Hello");
        String s5 = sb.toString();
        
        // 6. Using String.valueOf()
        String s6 = String.valueOf(123);  // "123"
        String s7 = String.valueOf(true);  // "true"
        String s8 = String.valueOf(chars);  // "Hello"
        
        System.out.println(s1 + " " + s2 + " " + s3 + " " + s4 + " " + s5);
    }
}
```

---

<a name="string-comparison"></a>
## 3. String vs StringBuilder vs StringBuffer

### Comparison Table

| Feature | String | StringBuilder | StringBuffer |
|---------|--------|--------------|--------------|
| **Mutability** | Immutable | Mutable | Mutable |
| **Thread-safe** | Yes | No | Yes (synchronized) |
| **Performance** | Slow for concat | Fast | Slower than StringBuilder |
| **Memory** | Creates new objects | Modifies same object | Modifies same object |
| **When to use** | Few modifications | Single thread, many mods | Multi-threaded |

---

### String Concatenation Performance

```java
public class ConcatenationPerformance {
    
    public static void main(String[] args) {
        int n = 10000;
        
        // Method 1: String concatenation (SLOW!)
        long start1 = System.currentTimeMillis();
        String str = "";
        for (int i = 0; i < n; i++) {
            str += i;  // Creates n new String objects!
        }
        long end1 = System.currentTimeMillis();
        System.out.println("String: " + (end1 - start1) + "ms");
        
        // Method 2: StringBuilder (FAST!)
        long start2 = System.currentTimeMillis();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            sb.append(i);  // Modifies same object
        }
        String result = sb.toString();
        long end2 = System.currentTimeMillis();
        System.out.println("StringBuilder: " + (end2 - start2) + "ms");
    }
}
```

**Output:**
```
String: 2341ms
StringBuilder: 3ms
```

**Why?** Each `str += i` creates a new String object → O(n²) time!

---

### StringBuilder Example

```java
public class StringBuilderExample {
    
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        
        // Append operations
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        sb.append(123);
        sb.append(true);
        
        System.out.println(sb);  // "Hello World123true"
        
        // Insert at position
        sb.insert(6, "Beautiful ");
        System.out.println(sb);  // "Hello Beautiful World123true"
        
        // Delete range
        sb.delete(6, 16);
        System.out.println(sb);  // "Hello World123true"
        
        // Reverse
        sb.reverse();
        System.out.println(sb);  // "eurt321dlroW olleH"
        
        // Convert to String
        String result = sb.toString();
        
        // Chain methods
        StringBuilder sb2 = new StringBuilder()
            .append("Java")
            .append(" ")
            .append("17")
            .reverse();
        System.out.println(sb2);  // "71 avaJ"
    }
}
```

---

### StringBuffer Example

```java
public class StringBufferExample {
    
    public static void main(String[] args) {
        // Same API as StringBuilder, but synchronized
        StringBuffer sbf = new StringBuffer("Hello");
        
        sbf.append(" World");
        sbf.insert(0, "Hi! ");
        sbf.reverse();
        
        System.out.println(sbf);  // "dlroW olleH !iH"
        
        // Thread-safe for concurrent access
        // Use when multiple threads modify same buffer
    }
}
```

---

<a name="methods"></a>
## 4. Essential String Methods

### Length and Character Access

```java
public class StringLength {
    public static void main(String[] args) {
        String str = "Hello World";
        
        // Length
        int len = str.length();  // 11
        System.out.println("Length: " + len);
        
        // Character at index
        char c = str.charAt(0);  // 'H'
        System.out.println("First char: " + c);
        
        // Last character
        char last = str.charAt(str.length() - 1);  // 'd'
        System.out.println("Last char: " + last);
        
        // isEmpty
        boolean empty = str.isEmpty();  // false
        System.out.println("Empty: " + empty);
        
        // isBlank (Java 11+)
        String blank = "   ";
        System.out.println("Blank: " + blank.isBlank());  // true
    }
}
```

**Time:** O(1) for all operations

---

### Comparison Methods

```java
public class StringComparison {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "hello";
        String s3 = "Hello";
        
        // equals() - case sensitive
        System.out.println(s1.equals(s2));  // false
        System.out.println(s1.equals(s3));  // true
        
        // equalsIgnoreCase()
        System.out.println(s1.equalsIgnoreCase(s2));  // true
        
        // compareTo() - lexicographic comparison
        System.out.println(s1.compareTo(s2));  // negative (H < h in ASCII)
        System.out.println(s1.compareTo(s3));  // 0 (equal)
        System.out.println("apple".compareTo("banana"));  // negative
        
        // compareToIgnoreCase()
        System.out.println(s1.compareToIgnoreCase(s2));  // 0
        
        // startsWith() and endsWith()
        System.out.println("Hello World".startsWith("Hello"));  // true
        System.out.println("Hello World".endsWith("World"));  // true
        System.out.println("Hello World".startsWith("World", 6));  // true (from index 6)
    }
}
```

---

### Search Methods

```java
public class StringSearch {
    public static void main(String[] args) {
        String str = "Hello World, Hello Java";
        
        // indexOf() - first occurrence
        int index1 = str.indexOf('o');  // 4
        int index2 = str.indexOf("World");  // 6
        int index3 = str.indexOf("Hello", 5);  // 13 (search from index 5)
        int index4 = str.indexOf("Python");  // -1 (not found)
        
        System.out.println("First 'o': " + index1);
        System.out.println("'World': " + index2);
        System.out.println("Second 'Hello': " + index3);
        
        // lastIndexOf() - last occurrence
        int last1 = str.lastIndexOf('o');  // 22
        int last2 = str.lastIndexOf("Hello");  // 13
        
        System.out.println("Last 'o': " + last1);
        System.out.println("Last 'Hello': " + last2);
        
        // contains()
        boolean has = str.contains("Java");  // true
        System.out.println("Contains 'Java': " + has);
    }
}
```

**Time:** O(n × m) where n = string length, m = pattern length

---

### Substring and Extraction

```java
public class StringSubstring {
    public static void main(String[] args) {
        String str = "Hello World";
        
        // substring(start) - from start to end
        String sub1 = str.substring(6);  // "World"
        System.out.println(sub1);
        
        // substring(start, end) - from start to end-1
        String sub2 = str.substring(0, 5);  // "Hello"
        System.out.println(sub2);
        
        // subSequence() - returns CharSequence
        CharSequence seq = str.subSequence(6, 11);  // "World"
        System.out.println(seq);
        
        // toCharArray()
        char[] chars = str.toCharArray();
        System.out.println(Arrays.toString(chars));
        
        // split()
        String csv = "apple,banana,orange";
        String[] fruits = csv.split(",");
        System.out.println(Arrays.toString(fruits));
        // ["apple", "banana", "orange"]
        
        // split with limit
        String text = "a-b-c-d-e";
        String[] parts = text.split("-", 3);
        System.out.println(Arrays.toString(parts));
        // ["a", "b", "c-d-e"]
    }
}
```

---

### Modification Methods (Return New String)

```java
public class StringModification {
    public static void main(String[] args) {
        String str = "  Hello World  ";
        
        // trim() - remove leading/trailing whitespace
        String trimmed = str.trim();  // "Hello World"
        System.out.println("'" + trimmed + "'");
        
        // strip() - Java 11+ (handles Unicode whitespace)
        String stripped = str.strip();
        System.out.println("'" + stripped + "'");
        
        // toLowerCase() and toUpperCase()
        System.out.println(str.toLowerCase());  // "  hello world  "
        System.out.println(str.toUpperCase());  // "  HELLO WORLD  "
        
        // replace() - replace all occurrences
        String s = "Hello World";
        System.out.println(s.replace('o', '0'));  // "Hell0 W0rld"
        System.out.println(s.replace("World", "Java"));  // "Hello Java"
        
        // replaceFirst() - replace first occurrence
        System.out.println(s.replaceFirst("l", "L"));  // "HeLlo World"
        
        // replaceAll() - with regex
        String phone = "123-456-7890";
        System.out.println(phone.replaceAll("-", ""));  // "1234567890"
        
        // concat()
        String s1 = "Hello";
        String s2 = s1.concat(" World");  // "Hello World"
        System.out.println(s2);
        
        // repeat() - Java 11+
        System.out.println("Ha".repeat(3));  // "HaHaHa"
    }
}
```

---

### Type Conversion Methods

```java
public class StringConversion {
    public static void main(String[] args) {
        // String to primitive
        String numStr = "123";
        int num = Integer.parseInt(numStr);
        double d = Double.parseDouble("123.45");
        boolean b = Boolean.parseBoolean("true");
        
        System.out.println(num + 10);  // 133
        System.out.println(d);  // 123.45
        System.out.println(b);  // true
        
        // Primitive to String
        String s1 = String.valueOf(123);  // "123"
        String s2 = String.valueOf(true);  // "true"
        String s3 = String.valueOf(12.34);  // "12.34"
        
        // Alternative: concatenation
        String s4 = 123 + "";  // "123"
        
        // format()
        String formatted = String.format("Name: %s, Age: %d", "Alice", 25);
        System.out.println(formatted);  // "Name: Alice, Age: 25"
        
        // join() - Java 8+
        String joined = String.join(", ", "apple", "banana", "orange");
        System.out.println(joined);  // "apple, banana, orange"
        
        String[] words = {"Hello", "World"};
        String result = String.join(" ", words);  // "Hello World"
        System.out.println(result);
    }
}
```

---

<a name="characters"></a>
## 5. Character Operations

### Character Class Methods

```java
public class CharacterMethods {
    public static void main(String[] args) {
        char c1 = 'A';
        char c2 = '5';
        char c3 = ' ';
        
        // Check character type
        System.out.println(Character.isLetter(c1));  // true
        System.out.println(Character.isDigit(c2));  // true
        System.out.println(Character.isWhitespace(c3));  // true
        System.out.println(Character.isLetterOrDigit(c1));  // true
        System.out.println(Character.isUpperCase(c1));  // true
        System.out.println(Character.isLowerCase('a'));  // true
        
        // Convert case
        System.out.println(Character.toUpperCase('a'));  // 'A'
        System.out.println(Character.toLowerCase('Z'));  // 'z'
        
        // Get numeric value
        System.out.println(Character.getNumericValue('5'));  // 5
        System.out.println(Character.getNumericValue('A'));  // 10 (hex)
        
        // Compare characters
        System.out.println(Character.compare('A', 'B'));  // negative
    }
}
```

---

### Iterating Through String Characters

```java
public class StringIteration {
    
    // Method 1: Using charAt()
    public static void method1(String str) {
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            System.out.print(c + " ");
        }
        System.out.println();
    }
    
    // Method 2: Using toCharArray()
    public static void method2(String str) {
        for (char c : str.toCharArray()) {
            System.out.print(c + " ");
        }
        System.out.println();
    }
    
    // Method 3: Using Stream (Java 8+)
    public static void method3(String str) {
        str.chars()
           .mapToObj(c -> (char) c)
           .forEach(c -> System.out.print(c + " "));
        System.out.println();
    }
    
    // Method 4: Using codePoints for Unicode
    public static void method4(String str) {
        str.codePoints()
           .forEach(cp -> System.out.print((char) cp + " "));
        System.out.println();
    }
    
    public static void main(String[] args) {
        String str = "Hello";
        
        method1(str);
        method2(str);
        method3(str);
        method4(str);
    }
}
```

---

<a name="patterns"></a>
## 6. String Manipulation Patterns

### Pattern 1: Reverse a String

```java
public class ReverseString {
    
    // Method 1: Using StringBuilder
    public static String reverse1(String str) {
        return new StringBuilder(str).reverse().toString();
    }
    
    // Method 2: Using char array
    public static String reverse2(String str) {
        char[] chars = str.toCharArray();
        int left = 0, right = chars.length - 1;
        
        while (left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
        
        return new String(chars);
    }
    
    // Method 3: Using recursion
    public static String reverse3(String str) {
        if (str.isEmpty()) return str;
        return reverse3(str.substring(1)) + str.charAt(0);
    }
    
    public static void main(String[] args) {
        String str = "Hello";
        
        System.out.println(reverse1(str));  // "olleH"
        System.out.println(reverse2(str));  // "olleH"
        System.out.println(reverse3(str));  // "olleH"
    }
}
```

**Time:** O(n) for all methods  
**Space:** O(n) for recursion, O(1) for iterative (excluding output)

---

### Pattern 2: Check Palindrome

```java
public class PalindromeCheck {
    
    public static boolean isPalindrome(String str) {
        int left = 0, right = str.length() - 1;
        
        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // Ignore non-alphanumeric, case-insensitive
    public static boolean isPalindromeAdvanced(String str) {
        int left = 0, right = str.length() - 1;
        
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(str.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(str.charAt(right))) {
                right--;
            }
            
            if (Character.toLowerCase(str.charAt(left)) != 
                Character.toLowerCase(str.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isPalindrome("racecar"));  // true
        System.out.println(isPalindrome("hello"));  // false
        
        System.out.println(isPalindromeAdvanced("A man, a plan, a canal: Panama"));  // true
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3: Count Characters

```java
public class CharacterCount {
    
    // Count specific character
    public static int countChar(String str, char target) {
        int count = 0;
        for (char c : str.toCharArray()) {
            if (c == target) count++;
        }
        return count;
    }
    
    // Count all characters (frequency map)
    public static Map<Character, Integer> frequencyMap(String str) {
        Map<Character, Integer> map = new HashMap<>();
        
        for (char c : str.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        
        return map;
    }
    
    // Count vowels
    public static int countVowels(String str) {
        int count = 0;
        String vowels = "aeiouAEIOU";
        
        for (char c : str.toCharArray()) {
            if (vowels.indexOf(c) != -1) {
                count++;
            }
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        String str = "Hello World";
        
        System.out.println("Count 'l': " + countChar(str, 'l'));  // 3
        System.out.println("Frequency: " + frequencyMap(str));
        System.out.println("Vowels: " + countVowels(str));  // 3
    }
}
```

**Time:** O(n), **Space:** O(k) where k = unique characters

---

### Pattern 4: Remove/Replace Characters

```java
public class RemoveReplace {
    
    // Remove all spaces
    public static String removeSpaces(String str) {
        return str.replaceAll("\\s+", "");
    }
    
    // Remove specific character
    public static String removeChar(String str, char target) {
        StringBuilder sb = new StringBuilder();
        
        for (char c : str.toCharArray()) {
            if (c != target) {
                sb.append(c);
            }
        }
        
        return sb.toString();
    }
    
    // Remove duplicates (keep first occurrence)
    public static String removeDuplicates(String str) {
        StringBuilder sb = new StringBuilder();
        Set<Character> seen = new HashSet<>();
        
        for (char c : str.toCharArray()) {
            if (!seen.contains(c)) {
                sb.append(c);
                seen.add(c);
            }
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(removeSpaces("Hello World"));  // "HelloWorld"
        System.out.println(removeChar("Hello", 'l'));  // "Heo"
        System.out.println(removeDuplicates("programming"));  // "progamin"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Pattern 5: String Rotation Check

```java
public class StringRotation {
    
    public static boolean isRotation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        
        // Concatenate s1 with itself
        String doubled = s1 + s1;
        
        // Check if s2 is substring of doubled
        return doubled.contains(s2);
    }
    
    public static void main(String[] args) {
        System.out.println(isRotation("waterbottle", "erbottlewat"));  // true
        System.out.println(isRotation("hello", "lohel"));  // true
        System.out.println(isRotation("hello", "world"));  // false
    }
}
```

**How it works:**
```
s1 = "waterbottle"
s1 + s1 = "waterbottlewaterbottle"
s2 = "erbottlewat" is substring of doubled!
```

**Time:** O(n), **Space:** O(n)

---

<a name="pitfalls"></a>
## 7. Common Pitfalls

### Pitfall 1: Using == Instead of equals()

```java
// ❌ WRONG - Compares references
String s1 = new String("Hello");
String s2 = new String("Hello");
if (s1 == s2) {  // false
    System.out.println("Equal");
}

// ✅ CORRECT - Compares content
if (s1.equals(s2)) {  // true
    System.out.println("Equal");
}
```

---

### Pitfall 2: String Concatenation in Loop

```java
// ❌ WRONG - O(n²) time complexity
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // Creates 1000 new String objects!
}

// ✅ CORRECT - O(n) time complexity
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

---

### Pitfall 3: Forgetting Immutability

```java
// ❌ WRONG - Thinking string is modified
String str = "hello";
str.toUpperCase();  // Returns new string, doesn't modify str
System.out.println(str);  // Still "hello"

// ✅ CORRECT - Reassign
String str = "hello";
str = str.toUpperCase();
System.out.println(str);  // "HELLO"
```

---

### Pitfall 4: NullPointerException

```java
// ❌ WRONG - No null check
String str = null;
int len = str.length();  // NullPointerException!

// ✅ CORRECT - Check for null
if (str != null && !str.isEmpty()) {
    int len = str.length();
}

// Or use Optional (Java 8+)
Optional<String> opt = Optional.ofNullable(str);
int len = opt.map(String::length).orElse(0);
```

---

### Pitfall 5: substring() Creating New String

```java
// Before Java 7: substring() shared char array (memory leak risk)
// Java 7+: substring() creates new char array

String large = "Very large string...";
String small = large.substring(0, 5);

// In Java 6: 'small' still references entire 'large' char array
// In Java 7+: 'small' has its own char array
```

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the difference between String, StringBuilder, and StringBuffer?

**Answer:**
- **String:** Immutable, thread-safe, slow for concatenation
- **StringBuilder:** Mutable, NOT thread-safe, fast
- **StringBuffer:** Mutable, thread-safe (synchronized), slower than StringBuilder

Use StringBuilder for single-threaded string building.

---

### Q2: Why are Strings immutable in Java?

**Answer:**
1. **String Pool** - Enables memory optimization
2. **Security** - String parameters can't be modified
3. **Thread Safety** - No synchronization needed
4. **Hashcode Caching** - Computed once, reused in HashMap
5. **Class Loading** - Class names are strings

---

### Q3: What is String pool?

**Answer:** Special memory region in heap (since Java 7) where string literals are stored. JVM reuses strings from pool to save memory.

```java
String s1 = "Hello";  // Goes to pool
String s2 = "Hello";  // Reuses from pool
s1 == s2  // true (same reference)
```

---

### Q4: What does intern() do?

**Answer:** Moves string to string pool (if not already there) and returns reference.

```java
String s1 = new String("Hello");  // Heap
String s2 = s1.intern();  // Pool
String s3 = "Hello";  // Pool
s2 == s3  // true
```

---

### Q5: How to compare strings?

**Answer:**
- **equals():** Content comparison (case-sensitive)
- **equalsIgnoreCase():** Content comparison (case-insensitive)
- **compareTo():** Lexicographic comparison, returns int
- **==:** Reference comparison (don't use for content!)

---

### Q6: What's the time complexity of substring()?

**Answer:** **O(n)** since Java 7 (creates new char array).  
Before Java 7: O(1) but risked memory leaks.

---

### Q7: How to reverse a string efficiently?

**Answer:** Use StringBuilder:
```java
String reversed = new StringBuilder(str).reverse().toString();
```
**Time:** O(n), **Space:** O(n)

---

### Q8: Can we modify a String?

**Answer:** **No!** Strings are immutable. Methods like `toUpperCase()` return new strings.

---

### Q9: What's the difference between length() and length?

**Answer:**
- **length():** Method for String (returns int)
- **length:** Field for arrays (int value)

```java
String str = "Hello";
int len1 = str.length();  // Method

int[] arr = {1, 2, 3};
int len2 = arr.length;  // Field
```

---

### Q10: How does String concatenation work internally?

**Answer:** 
- **Java 8 and earlier:** Creates StringBuilder internally
- **Java 9+:** Uses `invokedynamic` with StringConcatFactory for better performance

```java
String s = "Hello" + " " + "World";
// Compiler optimizes to StringBuilder internally
```

---

### Q11: What's the output?

```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");

System.out.println(s1 == s2);  // ?
System.out.println(s1 == s3);  // ?
System.out.println(s1.equals(s3));  // ?
```

**Answer:**
```
true   // s1 and s2 point to same pool object
false  // s3 is separate heap object
true   // Content is same
```

---

### Q12: How to check if string contains only digits?

**Answer:**
```java
// Method 1: Regex
boolean isDigits = str.matches("\\d+");

// Method 2: Character check
boolean isDigits = str.chars().allMatch(Character::isDigit);
```

---

### Q13: What's the difference between trim() and strip()?

**Answer:**
- **trim():** Removes ASCII whitespace (≤ U+0020)
- **strip():** Java 11+, removes Unicode whitespace

```java
String s = "\u2000Hello\u2000";  // Unicode space
s.trim().length()  // Still has spaces
s.strip().length()  // Spaces removed
```

---

### Q14: How to convert String to char array and vice versa?

**Answer:**
```java
// String to char[]
char[] chars = str.toCharArray();

// char[] to String
String str = new String(chars);
String str = String.valueOf(chars);
```

---

### Q15: What's the difference between split() and StringTokenizer?

**Answer:**
- **split():** Uses regex, returns String[]
- **StringTokenizer:** Legacy class, faster but less flexible

```java
String[] parts = str.split(",");  // Preferred
StringTokenizer st = new StringTokenizer(str, ",");  // Legacy
```

---

### Q16: How many objects are created?

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");
```

**Answer:** **2 objects**
1. "Hello" in string pool (shared by s1 and s2)
2. New String object in heap (s3)

---

### Q17: What's the memory usage of String vs char[]?

**Answer:**
- **String:** Object overhead + char[] + length + hashcode cache ≈ 40+ bytes + 2×length
- **char[]:** Array overhead + data ≈ 16 bytes + 2×length

String has more overhead but offers immutability benefits.

---

### Q18: How to handle null strings safely?

**Answer:**
```java
// Method 1: Null check
if (str != null && !str.isEmpty()) { ... }

// Method 2: Optional
Optional.ofNullable(str).ifPresent(s -> ...);

// Method 3: StringUtils (Apache Commons)
StringUtils.isEmpty(str)  // Handles null
```

---

### Q19: What's intern() performance impact?

**Answer:** **Expensive operation!** Searches pool, adds if not found.  
Only use when:
- Many duplicate strings
- Long-lived strings
- Need reference equality

---

### Q20: How to efficiently build large strings?

**Answer:**
```java
// ✅ Best: StringBuilder with initial capacity
StringBuilder sb = new StringBuilder(1000);
for (...) {
    sb.append(data);
}

// Avoids resizing internal array
```

---

<a name="practice-problems"></a>
## 9. Practice Problems

### Problem 1: Reverse String

**Problem:** Reverse string in-place.

```java
public class ReverseStringProblem {
    public static void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        char[] s = {'h', 'e', 'l', 'l', 'o'};
        reverseString(s);
        System.out.println(Arrays.toString(s));  // [o, l, l, e, h]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: First Unique Character

**Problem:** Find first non-repeating character.

```java
public class FirstUniqueChar {
    public static int firstUniqChar(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        
        for (char c : s.toCharArray()) {
            freq.put(c, freq.getOrDefault(c, 0) + 1);
        }
        
        for (int i = 0; i < s.length(); i++) {
            if (freq.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        System.out.println(firstUniqChar("leetcode"));  // 0 ('l')
        System.out.println(firstUniqChar("loveleetcode"));  // 2 ('v')
    }
}
```

**Time:** O(n), **Space:** O(1) - max 26 letters

---

### Problem 3: Valid Anagram

**Problem:** Check if two strings are anagrams.

```java
public class ValidAnagram {
    public static boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] count = new int[26];
        
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isAnagram("anagram", "nagaram"));  // true
        System.out.println(isAnagram("rat", "car"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 4: Reverse Words in String

**Problem:** Reverse word order.

```java
public class ReverseWords {
    public static String reverseWords(String s) {
        String[] words = s.trim().split("\\s+");
        
        int left = 0, right = words.length - 1;
        while (left < right) {
            String temp = words[left];
            words[left] = words[right];
            words[right] = temp;
            left++;
            right--;
        }
        
        return String.join(" ", words);
    }
    
    public static void main(String[] args) {
        System.out.println(reverseWords("  hello world  "));  // "world hello"
        System.out.println(reverseWords("the sky is blue"));  // "blue is sky the"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 5: String to Integer (atoi)

**Problem:** Convert string to integer.

```java
public class StringToInteger {
    public static int myAtoi(String s) {
        s = s.trim();
        if (s.isEmpty()) return 0;
        
        int sign = 1;
        int index = 0;
        
        if (s.charAt(0) == '-' || s.charAt(0) == '+') {
            sign = (s.charAt(0) == '-') ? -1 : 1;
            index++;
        }
        
        long result = 0;
        
        while (index < s.length() && Character.isDigit(s.charAt(index))) {
            result = result * 10 + (s.charAt(index) - '0');
            
            if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;
            if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;
            
            index++;
        }
        
        return (int) (result * sign);
    }
    
    public static void main(String[] args) {
        System.out.println(myAtoi("42"));  // 42
        System.out.println(myAtoi("   -42"));  // -42
        System.out.println(myAtoi("4193 with words"));  // 4193
    }
}
```

**Time:** O(n), **Space:** O(1)

---

## Summary Cheat Sheet

### String Creation

```java
String s1 = "Hello";  // String pool
String s2 = new String("Hello");  // Heap
String s3 = new String(charArray);
String s4 = String.valueOf(123);
```

---

### Common Operations

| Operation | Method | Time |
|-----------|--------|------|
| **Length** | `s.length()` | O(1) |
| **Character at** | `s.charAt(i)` | O(1) |
| **Substring** | `s.substring(i, j)` | O(n) |
| **Index of** | `s.indexOf(c)` | O(n) |
| **Compare** | `s.equals(t)` | O(n) |
| **Split** | `s.split(",")` | O(n) |
| **Replace** | `s.replace(old, new)` | O(n) |

---

### StringBuilder Methods

```java
StringBuilder sb = new StringBuilder();
sb.append("text");        // Add
sb.insert(0, "prefix");   // Insert at position
sb.delete(0, 6);          // Delete range
sb.reverse();             // Reverse
sb.toString();            // Convert to String
```

---

### When to Use What

| Use Case | Use |
|----------|-----|
| **Few modifications** | String |
| **Many modifications, single-thread** | StringBuilder |
| **Many modifications, multi-thread** | StringBuffer |
| **Immutability needed** | String |
| **Performance critical** | StringBuilder |

---

## Key Takeaways

✅ **Strings are immutable** - Methods return new strings  
✅ **Use StringBuilder** for concatenation in loops  
✅ **equals() for content** - Never use == for comparison  
✅ **String pool** saves memory for literals  
✅ **charAt() is O(1)** - Direct array access  
✅ **substring() is O(n)** since Java 7  
✅ **Check for null** before calling methods  
✅ **toCharArray()** for character iteration  
✅ **Know the API** - Rich set of methods  
✅ **40% of interviews** involve string manipulation!  

---

[← Back: Practice Problems](../03-Arrays/3.8-Practice-Problems.md) | [Next: String Manipulation →](./4.2-String-Manipulation.md)
