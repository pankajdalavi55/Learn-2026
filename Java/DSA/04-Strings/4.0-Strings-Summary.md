# 4.0 Strings - Complete Summary & Quick Reference

## Table of Contents
1. [Overview](#overview)
2. [Document Map](#document-map)
3. [Core Concepts](#core-concepts)
4. [Algorithm Comparison](#algorithm-comparison)
5. [Pattern Recognition Guide](#pattern-recognition-guide)
6. [Complexity Cheat Sheet](#complexity-cheat-sheet)
7. [Interview Strategy](#interview-strategy)
8. [Quick Reference](#quick-reference)

---

## Overview

This comprehensive guide covers all essential string algorithms and techniques for competitive programming and technical interviews. Total: **10 documents, 100+ problems, 50+ techniques**.

### Learning Path

```
4.1 String Basics â†’ 4.2 String Manipulation â†’ 4.3 Pattern Matching
                                                      â†“
4.4 String Hashing â† 4.5 KMP Algorithm â† [Foundation Complete]
         â†“
4.6-4.8 Rabin-Karp (3 parts) â†’ 4.9 Anagrams & Palindromes â†’ 4.10 Practice Problems
```

### Coverage Summary

| Topic | Documents | Key Algorithms | LeetCode Problems |
|-------|-----------|----------------|-------------------|
| **Basics** | 4.1-4.2 | StringBuilder, Character manipulation | 10+ |
| **Pattern Matching** | 4.3, 4.5-4.8 | Naive, KMP, Rabin-Karp | 15+ |
| **Hashing** | 4.4, 4.6-4.8 | Rolling hash, Polynomial hash | 20+ |
| **Anagrams/Palindromes** | 4.9 | Frequency count, Expand center | 10+ |
| **Practice** | 4.10 | Mixed techniques | 20 |
| **Total** | 10 docs | 30+ algorithms | 75+ |

---

## Document Map

### 4.1 String Basics
**Focus**: Foundation concepts and operations  
**Key Topics**:
- String immutability in Java
- StringBuilder vs StringBuffer (StringBuilder 40% faster)
- Character operations (isLetter, isDigit, toUpperCase, toLowerCase)
- String comparison (equals vs ==, compareTo)
- Common methods (substring O(n), charAt O(1), indexOf O(n))

**Essential Code**:
```java
// Efficient string building
StringBuilder sb = new StringBuilder();
for (int i = 0; i < n; i++) {
    sb.append(arr[i]); // O(1) amortized
}
String result = sb.toString(); // O(n)

// Character checks
char c = 'A';
boolean isLower = c >= 'a' && c <= 'z'; // Faster than Character.isLowerCase()
int digit = c - '0'; // Convert char to int
```

**When to use**: Every string problem starts here. Use StringBuilder for string construction in loops.

---

### 4.2 String Manipulation
**Focus**: Transformation and processing techniques  
**Key Topics**:
- Reversal techniques (two pointers, StringBuilder, recursion)
- Case conversion and normalization
- Trimming and whitespace handling
- Palindrome checking (3 approaches: two pointers O(n)/O(1), reverse compare O(n)/O(n), recursive O(n)/O(n))
- Rotation algorithms (substring, manual rotation)
- Compression (Run-Length Encoding)

**Essential Code**:
```java
// Reverse in-place
public void reverse(char[] s) {
    int left = 0, right = s.length - 1;
    while (left < right) {
        char temp = s[left];
        s[left++] = s[right];
        s[right--] = temp;
    }
}

// Palindrome check (best approach)
public boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) return false;
    }
    return true;
}

// String rotation check
public boolean isRotation(String s1, String s2) {
    return s1.length() == s2.length() && (s1 + s1).contains(s2);
}
```

**When to use**: String transformation problems, palindrome validation, rotation checking.

---

### 4.3 Pattern Matching
**Focus**: Finding substrings and patterns  
**Key Topics**:
- Naive pattern matching O(n Ã— m)
- Two pointers technique O(n)
- Sliding window O(n)
- Boyer-Moore (theory)
- Z-algorithm O(n + m)
- Aho-Corasick for multiple patterns O(n + m + z)

**Essential Code**:
```java
// Naive search
public int search(String text, String pattern) {
    int n = text.length(), m = pattern.length();
    for (int i = 0; i <= n - m; i++) {
        int j;
        for (j = 0; j < m; j++) {
            if (text.charAt(i + j) != pattern.charAt(j)) break;
        }
        if (j == m) return i;
    }
    return -1;
}

// Sliding window for anagrams
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> result = new ArrayList<>();
    int[] count = new int[26];
    for (char c : p.toCharArray()) count[c - 'a']++;
    
    int[] window = new int[26];
    for (int i = 0; i < s.length(); i++) {
        window[s.charAt(i) - 'a']++;
        if (i >= p.length()) window[s.charAt(i - p.length()) - 'a']--;
        if (Arrays.equals(count, window)) result.add(i - p.length() + 1);
    }
    return result;
}
```

**When to use**: Substring search, anagram detection, pattern occurrence counting.

---

### 4.4 String Hashing
**Focus**: Hash-based string comparison  
**Key Topics**:
- Polynomial rolling hash: `hash = (hash * BASE + c) % MOD`
- Base selection (31 for lowercase, 256 for ASCII)
- Modulus selection (10^9+7, 10^9+9, (2^31)-1)
- Collision handling (double hashing, verification)
- Applications (substring search, duplicate detection, string comparison)

**Essential Code**:
```java
public class StringHash {
    private static final int BASE = 31;
    private static final long MOD = 1_000_000_007;
    
    public long computeHash(String s) {
        long hash = 0;
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + c) % MOD;
        }
        return hash;
    }
    
    // Precompute powers for O(1) updates
    long[] pow = new long[n];
    pow[0] = 1;
    for (int i = 1; i < n; i++) {
        pow[i] = (pow[i-1] * BASE) % MOD;
    }
}
```

**When to use**: Fast string comparison, substring matching with O(1) comparison after O(n) preprocessing.

---

### 4.5 KMP Algorithm
**Focus**: Linear time pattern matching  
**Key Topics**:
- LPS (Longest Prefix Suffix) array computation O(m)
- KMP search O(n + m) guaranteed
- No backtracking in text
- Multiple pattern occurrences
- Applications (period detection, substring matching)

**Essential Code**:
```java
public class KMP {
    // Build LPS array
    private int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        return lps;
    }
    
    // KMP search
    public int search(String text, String pattern) {
        int n = text.length(), m = pattern.length();
        int[] lps = computeLPS(pattern);
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++; j++;
            }
            if (j == m) return i - j;
            else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j > 0) j = lps[j - 1];
                else i++;
            }
        }
        return -1;
    }
}
```

**When to use**: Pattern matching when worst-case O(n+m) is required, period finding, prefix-suffix problems.

---

### 4.6 Rabin-Karp Part 1 (Fundamentals)
**Focus**: Rolling hash basics and implementation  
**Key Topics**:
- Rolling hash formula: `new_hash = (old_hash - s[i] Ã— BASE^(m-1)) Ã— BASE + s[i+m]`
- Hash computation and rolling
- Collision detection and verification
- Basic implementation patterns (find first, find all, helper class)
- Common patterns (exact match, multiple patterns, substring uniqueness)

**Essential Code**:
```java
public class RabinKarp {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    public int search(String text, String pattern) {
        int n = text.length(), m = pattern.length();
        if (m > n) return -1;
        
        // Precompute BASE^(m-1) % MOD
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute pattern hash and first window hash
        long patternHash = 0, textHash = 0;
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash * BASE + pattern.charAt(i)) % MOD;
            textHash = (textHash * BASE + text.charAt(i)) % MOD;
        }
        
        // Slide window
        for (int i = 0; i <= n - m; i++) {
            if (patternHash == textHash) {
                // Verify to avoid spurious hits
                if (text.substring(i, i + m).equals(pattern)) {
                    return i;
                }
            }
            
            if (i < n - m) {
                // Roll hash: remove leading, add trailing
                textHash = (BASE * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                if (textHash < 0) textHash += MOD; // Handle negative
            }
        }
        return -1;
    }
}
```

**When to use**: Multiple pattern search, 2D pattern matching, simple implementation needed.

---

### 4.7 Rabin-Karp Part 2 (Advanced Applications)
**Focus**: Complex RK applications  
**Key Topics**:
- Longest duplicate substring (binary search + RK) - LeetCode 1044
- Repeated DNA sequences (base-4 encoding) - LeetCode 187
- Substring with wildcards (selective hashing)
- Longest common substring (binary search approach)
- 2D pattern matching (row hash â†’ column hash)
- Plagiarism detection (k-grams, winnowing)
- Anagram search (frequency-based hash)

**Essential Code**:
```java
// Longest duplicate substring
public String longestDupSubstring(String s) {
    int left = 1, right = s.length();
    String result = "";
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        String dup = searchDuplicate(s, mid);
        if (dup != null) {
            result = dup;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}

// DNA sequences with base-4
public List<String> findRepeatedDna(String s) {
    Map<Integer, Integer> seen = new HashMap<>();
    Set<String> result = new HashSet<>();
    
    int hash = 0;
    for (int i = 0; i < s.length(); i++) {
        hash = (hash << 2) | (s.charAt(i) & 3); // Base-4 encoding
        if (i >= 9) {
            if (seen.getOrDefault(hash, 0) == 1) {
                result.add(s.substring(i - 9, i + 1));
            }
            seen.put(hash, seen.getOrDefault(hash, 0) + 1);
            hash &= (1 << 20) - 1; // Keep only 10 characters
        }
    }
    return new ArrayList<>(result);
}
```

**When to use**: Optimization problems requiring binary search + hashing, specialized encodings.

---

### 4.8 Rabin-Karp Part 3 (Optimizations & Interview Prep)
**Focus**: Performance optimization and interview techniques  
**Key Topics**:
- Precompute powers optimization
- Avoiding string creation (character comparison)
- Early termination strategies
- Multiple pattern optimization (group by length)
- Double hashing (collision probability ~10^-18)
- Cached hashing for repeated searches
- 20 interview Q&A
- 5+ practice problems

**Essential Code**:
```java
// Optimized with precomputed powers
public class OptimizedRabinKarp {
    private long[] pow;
    private static final int BASE = 31;
    private static final long MOD = 1_000_000_007;
    
    public OptimizedRabinKarp(int maxLen) {
        pow = new long[maxLen];
        pow[0] = 1;
        for (int i = 1; i < maxLen; i++) {
            pow[i] = (pow[i-1] * BASE) % MOD;
        }
    }
    
    // O(1) rolling hash update
    public long rollHash(long hash, char remove, char add, int len) {
        hash = (hash - remove * pow[len - 1]) % MOD;
        if (hash < 0) hash += MOD;
        hash = (hash * BASE + add) % MOD;
        return hash;
    }
}

// Double hashing
public class DoubleHashRK {
    private static final int BASE1 = 31, BASE2 = 37;
    private static final long MOD1 = 1_000_000_007, MOD2 = 1_000_000_009;
    
    public long[] computeDoubleHash(String s) {
        long hash1 = 0, hash2 = 0;
        for (char c : s.toCharArray()) {
            hash1 = (hash1 * BASE1 + c) % MOD1;
            hash2 = (hash2 * BASE2 + c) % MOD2;
        }
        return new long[]{hash1, hash2};
    }
}
```

**When to use**: Performance-critical applications, multiple searches, collision-sensitive scenarios.

---

### 4.9 Anagrams & Palindromes
**Focus**: Two related string concepts  
**Key Topics**:

**Anagrams**:
- 3 detection techniques: Sorting O(n log n), Frequency array O(n), HashMap O(n)
- Group anagrams (frequency-based key)
- Find anagram indices (sliding window with match counter)
- Minimum window substring

**Palindromes**:
- 3 checking techniques: Two pointers O(n)/O(1), Reverse compare, Alphanumeric validation
- Longest palindromic substring (expand-around-center O(nÂ²)/O(1))
- Palindrome partitioning (backtracking + DP)
- Shortest palindrome (KMP approach)

**Essential Code**:
```java
// Anagram check (best for lowercase)
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] count = new int[26];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i) - 'a']++;
        count[t.charAt(i) - 'a']--;
    }
    for (int c : count) if (c != 0) return false;
    return true;
}

// Group anagrams (optimized)
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String s : strs) {
        int[] count = new int[26];
        for (char c : s.toCharArray()) count[c - 'a']++;
        
        StringBuilder key = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            if (count[i] > 0) key.append((char)('a' + i)).append(count[i]);
        }
        map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);
    }
    return new ArrayList<>(map.values());
}

// Longest palindrome (best for interviews)
public String longestPalindrome(String s) {
    int start = 0, maxLen = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expand(s, i, i);
        int len2 = expand(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > maxLen) {
            maxLen = len;
            start = i - (len - 1) / 2;
        }
    }
    return s.substring(start, start + maxLen);
}

private int expand(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--; right++;
    }
    return right - left - 1;
}
```

**When to use**: Anagram problems (grouping, detection), palindrome problems (longest, partitioning, validation).

---

### 4.10 Practice Problems
**Focus**: 20 curated LeetCode problems  
**Categories**:
- **Easy (6)**: Reverse String, Valid Palindrome, First Unique Char, Valid Anagram, Reverse Vowels, Longest Common Prefix
- **Medium (9)**: Group Anagrams, Longest Palindromic Substring, Longest Substring Without Repeat, Find All Anagrams, Minimum Window Substring, Longest Repeating Char Replacement, Palindromic Substrings, String to Integer, Implement strStr()
- **Hard (5)**: Longest Duplicate Substring, Regular Expression Matching, Palindrome Partitioning II, Edit Distance, Distinct Subsequences

**Problem Coverage**:
- String Basics: 3 problems
- Anagrams: 3 problems
- Palindromes: 4 problems
- Sliding Window: 4 problems
- Pattern Matching: 3 problems
- Dynamic Programming: 4 problems

---

## Algorithm Comparison

### Pattern Matching Algorithms

| Algorithm | Time | Space | Best For | Pros | Cons |
|-----------|------|-------|----------|------|------|
| **Naive** | O(nÃ—m) | O(1) | Small texts/patterns | Simple, no preprocessing | Slow for large inputs |
| **KMP** | O(n+m) | O(m) | Single pattern, worst-case guarantee | No backtracking, optimal | Complex LPS computation |
| **Rabin-Karp** | O(n+m) avg<br>O(nÃ—m) worst | O(1) | Multiple patterns, 2D matching | Simple, extensible | Spurious hits possible |
| **Boyer-Moore** | O(n/m) best<br>O(nÃ—m) worst | O(m+Ïƒ) | Large alphabets | Very fast in practice | Complex implementation |
| **Z-Algorithm** | O(n+m) | O(n+m) | Prefix matching | Simple, many applications | Less known |
| **Aho-Corasick** | O(n+m+z) | O(mÃ—Ïƒ) | Multiple patterns | Finds all patterns in one pass | Complex structure |

**Ïƒ** = alphabet size, **z** = total occurrences

### When to Choose

```
Single pattern, worst-case guarantee needed? â†’ KMP
Multiple patterns simultaneously? â†’ Rabin-Karp or Aho-Corasick
2D pattern matching? â†’ Rabin-Karp
Large alphabet (DNA=4, lowercase=26)? â†’ Boyer-Moore
Prefix-suffix problems? â†’ KMP or Z-Algorithm
Simple implementation? â†’ Rabin-Karp or Naive
```

---

## Pattern Recognition Guide

### Problem Type Identification

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STRING PROBLEM DECISION TREE                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Is it about FINDING patterns/substrings?
â”œâ”€ YES â†’ Pattern Matching
â”‚  â”œâ”€ Single pattern? â†’ KMP (worst-case) or Rabin-Karp (average)
â”‚  â”œâ”€ Multiple patterns? â†’ Rabin-Karp or Aho-Corasick
â”‚  â””â”€ 2D pattern? â†’ Rabin-Karp
â”‚
â”œâ”€ Is it about ANAGRAMS?
â”‚  â”œâ”€ Check if two strings are anagrams? â†’ Frequency array O(n)
â”‚  â”œâ”€ Group anagrams? â†’ HashMap with frequency key
â”‚  â””â”€ Find anagram indices? â†’ Sliding window
â”‚
â”œâ”€ Is it about PALINDROMES?
â”‚  â”œâ”€ Check palindrome? â†’ Two pointers O(n)
â”‚  â”œâ”€ Longest palindrome? â†’ Expand around center O(nÂ²)
â”‚  â”œâ”€ Count palindromes? â†’ Expand or DP
â”‚  â””â”€ Partition into palindromes? â†’ Backtracking + DP
â”‚
â”œâ”€ Is it about SUBSTRINGS with constraints?
â”‚  â”œâ”€ Without repeating chars? â†’ Sliding window + HashSet
â”‚  â”œâ”€ With all chars of another? â†’ Sliding window + HashMap
â”‚  â”œâ”€ Longest duplicate? â†’ Binary search + Rabin-Karp
â”‚  â””â”€ With k distinct chars? â†’ Sliding window
â”‚
â”œâ”€ Is it about TRANSFORMATION?
â”‚  â”œâ”€ Edit distance? â†’ DP O(mÃ—n)
â”‚  â”œâ”€ String matching with wildcards? â†’ DP or Rabin-Karp
â”‚  â””â”€ Minimum operations? â†’ DP
â”‚
â””â”€ Is it about COMPARISON?
   â”œâ”€ Fast comparison of many substrings? â†’ String hashing
   â”œâ”€ Lexicographic order? â†’ compareTo()
   â””â”€ Prefix/suffix matching? â†’ KMP or Z-algorithm
```

### Technique Selection by Constraint

| Constraint | Technique | Complexity |
|------------|-----------|------------|
| **Need O(n) solution** | Sliding window, Two pointers, Hashing | O(n) |
| **Small alphabet (26)** | Frequency array | O(n), O(1) space |
| **Large alphabet (Unicode)** | HashMap | O(n), O(k) space |
| **Multiple queries** | Preprocessing + hashing | O(n) preprocess, O(1) query |
| **Substring problems** | Sliding window or DP | O(n) or O(nÂ²) |
| **Pattern matching** | KMP or Rabin-Karp | O(n+m) |
| **Palindrome** | Two pointers or Expand center | O(n) or O(nÂ²) |
| **Anagram** | Frequency count or sorting | O(n) or O(n log n) |

---

## Complexity Cheat Sheet

### Common Operations

| Operation | Array/String | StringBuilder | HashMap | TreeMap |
|-----------|-------------|---------------|---------|---------|
| **Access** | O(1) | O(1) | O(1) avg | O(log n) |
| **Search** | O(n) | O(n) | O(1) avg | O(log n) |
| **Insert** | O(n) | O(1) amortized | O(1) avg | O(log n) |
| **Delete** | O(n) | O(n) | O(1) avg | O(log n) |
| **Concatenation** | O(n+m) | O(m) amortized | - | - |

### String Methods Complexity

| Method | Complexity | Notes |
|--------|------------|-------|
| `s.charAt(i)` | O(1) | Direct access |
| `s.length()` | O(1) | Cached field |
| `s.substring(i, j)` | O(j-i) | Creates new string |
| `s.indexOf(c)` | O(n) | Linear search |
| `s.equals(t)` | O(n) | Character comparison |
| `s.compareTo(t)` | O(min(m,n)) | Lexicographic |
| `s.split(regex)` | O(n) | Plus regex cost |
| `s.replace(old, new)` | O(nÃ—m) | Can be expensive |
| `s.toCharArray()` | O(n) | Copy to array |

### Algorithm Space Complexity

| Algorithm | Space | Reason |
|-----------|-------|--------|
| **Two Pointers** | O(1) | Just indices |
| **Sliding Window** | O(k) | Window state (k = charset/window size) |
| **Frequency Array** | O(Ïƒ) | Ïƒ = alphabet size (typically 26 or 128) |
| **HashMap** | O(k) | k = unique elements |
| **KMP** | O(m) | LPS array |
| **Rabin-Karp** | O(1) | Just hash values |
| **DP (1D)** | O(n) | Single array |
| **DP (2D)** | O(mÃ—n) | Table |

---

## Interview Strategy

### Step-by-Step Approach

**1. Clarify (2 minutes)**
```
âœ“ Character set? (lowercase, ASCII, Unicode)
âœ“ Case sensitivity?
âœ“ Empty strings allowed?
âœ“ Input size? (n â‰¤ 10Â³, 10âµ, 10â¶?)
âœ“ Multiple queries?
âœ“ Space constraints?
```

**2. Examples (3 minutes)**
```
âœ“ Normal case
âœ“ Edge cases (empty, single char, all same, no match)
âœ“ Expected output format
```

**3. Approach (5 minutes)**
```
âœ“ Identify problem type (see Decision Tree)
âœ“ Start with brute force
âœ“ Optimize using appropriate data structure/algorithm
âœ“ State time/space complexity
```

**4. Code (15-20 minutes)**
```
âœ“ Write clean, readable code
âœ“ Handle edge cases
âœ“ Use meaningful variable names
```

**5. Test (5 minutes)**
```
âœ“ Run through examples
âœ“ Check edge cases
âœ“ Trace through code
```

### Common Patterns & Templates

**Pattern 1: Two Pointers**
```java
int left = 0, right = s.length() - 1;
while (left < right) {
    // Process
    // Move pointers based on condition
}
```

**Pattern 2: Sliding Window (Fixed Size)**
```java
for (int i = 0; i < s.length(); i++) {
    // Add current element
    if (i >= k) {
        // Remove element outside window
    }
    // Check window condition
}
```

**Pattern 3: Sliding Window (Variable Size)**
```java
int left = 0;
for (int right = 0; right < s.length(); right++) {
    // Add s[right] to window
    while (window invalid) {
        // Remove s[left] from window
        left++;
    }
    // Update result
}
```

**Pattern 4: Frequency Count**
```java
int[] count = new int[26]; // or HashMap
for (char c : s.toCharArray()) {
    count[c - 'a']++;
}
// Use count array
```

**Pattern 5: Rabin-Karp**
```java
long hash = 0, BASE = 31, MOD = 1_000_000_007;
for (char c : s.toCharArray()) {
    hash = (hash * BASE + c) % MOD;
}
// Roll hash: hash = (hash - old*pow + new) % MOD
```

**Pattern 6: Expand Around Center**
```java
for (int i = 0; i < s.length(); i++) {
    int len1 = expand(s, i, i);     // Odd
    int len2 = expand(s, i, i + 1); // Even
    maxLen = Math.max(maxLen, Math.max(len1, len2));
}
```

### Time Complexity Progression

When optimizing, aim for this progression:

```
O(nÂ³) or O(nÂ²m) â†’ Brute force, nested loops
         â†“
O(nÂ² log n)     â†’ Add sorting or binary search
         â†“
O(nÂ²)           â†’ DP, expand center
         â†“
O(n log n)      â†’ Sorting, divide & conquer
         â†“
O(n)            â†’ Sliding window, two pointers, hashing âœ“ TARGET
         â†“
O(log n)        â†’ Binary search (with preprocessing)
         â†“
O(1)            â†’ Hash lookup, math formula
```

### Common Mistakes to Avoid

âŒ **Don't**:
- Forget null/empty checks
- Use `s1 == s2` for string comparison (use `equals()`)
- Create strings in loops (use StringBuilder)
- Forget to handle negative modulo in rolling hash
- Use substring() excessively (O(n) each call)
- Ignore case sensitivity requirements
- Forget overflow in hash computation

âœ… **Do**:
- Use array instead of HashMap for small fixed alphabets
- Precompute powers for Rabin-Karp
- Verify hash matches to avoid spurious hits
- Use two pointers when possible (O(1) space)
- Consider character encoding (ASCII vs Unicode)
- Test with edge cases (empty, single char, all same)

---

## Quick Reference

### Essential Templates

**1. String Reversal**
```java
public void reverse(char[] s) {
    int l = 0, r = s.length - 1;
    while (l < r) {
        char t = s[l]; s[l++] = s[r]; s[r--] = t;
    }
}
```

**2. Palindrome Check**
```java
public boolean isPalindrome(String s) {
    int l = 0, r = s.length() - 1;
    while (l < r) {
        if (s.charAt(l++) != s.charAt(r--)) return false;
    }
    return true;
}
```

**3. Anagram Check**
```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) return false;
    int[] cnt = new int[26];
    for (int i = 0; i < s.length(); i++) {
        cnt[s.charAt(i) - 'a']++;
        cnt[t.charAt(i) - 'a']--;
    }
    for (int c : cnt) if (c != 0) return false;
    return true;
}
```

**4. KMP Search**
```java
public int kmpSearch(String txt, String pat) {
    int[] lps = buildLPS(pat);
    int i = 0, j = 0;
    while (i < txt.length()) {
        if (txt.charAt(i) == pat.charAt(j)) { i++; j++; }
        if (j == pat.length()) return i - j;
        else if (i < txt.length() && txt.charAt(i) != pat.charAt(j)) {
            if (j > 0) j = lps[j - 1];
            else i++;
        }
    }
    return -1;
}
```

**5. Rabin-Karp Search**
```java
public int rkSearch(String txt, String pat) {
    int n = txt.length(), m = pat.length(), BASE = 31;
    long MOD = 1_000_000_007, h = 1;
    for (int i = 0; i < m - 1; i++) h = (h * BASE) % MOD;
    
    long pHash = 0, tHash = 0;
    for (int i = 0; i < m; i++) {
        pHash = (pHash * BASE + pat.charAt(i)) % MOD;
        tHash = (tHash * BASE + txt.charAt(i)) % MOD;
    }
    
    for (int i = 0; i <= n - m; i++) {
        if (pHash == tHash && txt.substring(i, i + m).equals(pat)) return i;
        if (i < n - m) {
            tHash = (BASE * (tHash - txt.charAt(i) * h) + txt.charAt(i + m)) % MOD;
            if (tHash < 0) tHash += MOD;
        }
    }
    return -1;
}
```

**6. Longest Palindromic Substring**
```java
public String longestPalindrome(String s) {
    int start = 0, maxLen = 0;
    for (int i = 0; i < s.length(); i++) {
        int len = Math.max(expand(s, i, i), expand(s, i, i + 1));
        if (len > maxLen) {
            maxLen = len;
            start = i - (len - 1) / 2;
        }
    }
    return s.substring(start, start + maxLen);
}

private int expand(String s, int l, int r) {
    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
        l--; r++;
    }
    return r - l - 1;
}
```

**7. Group Anagrams**
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String s : strs) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        map.computeIfAbsent(key, k -> new ArrayList<>()).add(s);
    }
    return new ArrayList<>(map.values());
}
```

**8. Minimum Window Substring**
```java
public String minWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>();
    for (char c : t.toCharArray()) need.put(c, need.getOrDefault(c, 0) + 1);
    
    Map<Character, Integer> window = new HashMap<>();
    int left = 0, minLen = Integer.MAX_VALUE, minStart = 0;
    int formed = 0, required = need.size();
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        window.put(c, window.getOrDefault(c, 0) + 1);
        if (need.containsKey(c) && window.get(c).intValue() == need.get(c).intValue()) {
            formed++;
        }
        
        while (left <= right && formed == required) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minStart = left;
            }
            char leftChar = s.charAt(left);
            window.put(leftChar, window.get(leftChar) - 1);
            if (need.containsKey(leftChar) && window.get(leftChar) < need.get(leftChar)) {
                formed--;
            }
            left++;
        }
    }
    return minLen == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLen);
}
```

### Parameter Selection Guide

**Hash Function Parameters**:
```java
// For lowercase letters (a-z)
BASE = 31, MOD = 1_000_000_007

// For ASCII characters
BASE = 256, MOD = 1_000_000_009

// For collision-sensitive applications
BASE = 37, MOD = (1L << 31) - 1  // Mersenne prime

// Double hashing
BASE1 = 31, MOD1 = 1_000_000_007
BASE2 = 37, MOD2 = 1_000_000_009
```

**Array Sizes**:
```java
// Lowercase letters
int[] count = new int[26];

// ASCII
int[] count = new int[128];

// Extended ASCII
int[] count = new int[256];

// For Unicode, use HashMap<Character, Integer>
```

---

## Key Takeaways

### Must-Know Algorithms (Top 5)
1. **Two Pointers** - O(n), O(1) space - Essential for reversal, palindromes
2. **Sliding Window** - O(n) - Core for substring problems
3. **Rabin-Karp** - O(n+m) average - Versatile pattern matching
4. **KMP** - O(n+m) worst-case - When guarantee needed
5. **Expand Around Center** - O(nÂ²) - Palindrome problems

### Most Important Concepts
1. String immutability â†’ Use StringBuilder for construction
2. Character arithmetic â†’ `c - 'a'` for array indexing
3. Hash collision handling â†’ Always verify matches
4. Modulo arithmetic â†’ Handle negative values
5. Sliding window variations â†’ Fixed vs variable size

### Problem-Solving Priority
1. **Identify pattern type** (anagram, palindrome, substring, matching)
2. **Choose right data structure** (array for small alphabet, HashMap for large)
3. **Optimize complexity** (aim for O(n) or O(n log n))
4. **Handle edge cases** (empty, single char, all same)
5. **Test thoroughly** (normal, edge, large inputs)

### Interview Success Formula
```
Understand Problem (20%)
  +
Choose Right Approach (30%)
  +
Clean Implementation (40%)
  +
Test & Debug (10%)
  =
Success! ğŸ¯
```

---

## Document Reading Order

### For Beginners
1. Start: 4.1 String Basics
2. Then: 4.2 String Manipulation
3. Practice: Easy problems from 4.10
4. Continue: 4.3 Pattern Matching
5. Master: 4.9 Anagrams & Palindromes

### For Intermediate
1. Review: 4.4 String Hashing
2. Deep dive: 4.5 KMP Algorithm
3. Master: 4.6-4.8 Rabin-Karp (all parts)
4. Practice: Medium problems from 4.10

### For Advanced/Interview Prep
1. Skim: All documents for patterns
2. Focus: 4.8 (optimizations), 4.9 (techniques)
3. Grind: 4.10 (all 20 problems)
4. Master: Hard problems and optimizations

---

**Total Learning Time Estimate**: 20-30 hours for complete mastery  
**Minimum for Interview Prep**: 10-15 hours (focus on Easy + Medium + Templates)

**Next Steps**: After mastering strings, move to Dynamic Programming or Graphs for comprehensive competitive programming preparation.
