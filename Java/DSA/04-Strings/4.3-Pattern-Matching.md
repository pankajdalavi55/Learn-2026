# Pattern Matching - Complete Guide

## Why Pattern Matching?

**Core skill for text processing and search algorithms!**

- **Critical for:** Search engines, text editors, DNA sequencing
- **Interview favorite:** Google, Amazon, Microsoft ask frequently
- **Foundation for:** Regex, compilers, lexical analysis
- **Real-world:** File search, plagiarism detection, autocomplete

**Master pattern matching = Stand out in interviews!**

---

## Table of Contents

1. [Naive Pattern Matching](#naive)
2. [KMP Algorithm (Knuth-Morris-Pratt)](#kmp)
3. [Rabin-Karp Algorithm](#rabin-karp)
4. [Boyer-Moore Algorithm](#boyer-moore)
5. [Regular Expressions](#regex)
6. [Wildcard Pattern Matching](#wildcard)
7. [Advanced Pattern Problems](#advanced)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="naive"></a>
## 1. Naive Pattern Matching

### Brute Force Approach

**Idea:** Check pattern at every position in text.

```java
public class NaivePatternMatching {
    
    // Find first occurrence
    public static int search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                return i;  // Pattern found at index i
            }
        }
        
        return -1;  // Not found
    }
    
    // Find all occurrences
    public static List<Integer> searchAll(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                result.add(i);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAABA";
        String pattern = "AABA";
        
        System.out.println("First occurrence: " + search(text, pattern));  // 0
        System.out.println("All occurrences: " + searchAll(text, pattern));  // [0, 9, 12]
    }
}
```

**Time Complexity:** O((n - m + 1) × m) = **O(n × m)**  
**Space Complexity:** O(1)

**When to use:** Small patterns, rare mismatches

---

<a name="kmp"></a>
## 2. KMP Algorithm (Knuth-Morris-Pratt)

### Understanding KMP

**Key Idea:** Use information from previous matches to avoid redundant comparisons.

**Preprocessing:** Build LPS (Longest Proper Prefix which is also Suffix) array.

**Example:**
```
Pattern: "AABAAB"
LPS:     [0, 1, 0, 1, 2, 3]

Explanation:
- 'A': No proper prefix/suffix → 0
- 'AA': Prefix 'A' = Suffix 'A' → 1
- 'AAB': No match → 0
- 'AABA': 'A' matches → 1
- 'AABAA': 'AA' matches → 2
- 'AABAAB': 'AAB' matches → 3
```

---

### KMP Implementation

```java
public class KMPAlgorithm {
    
    // Build LPS array
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0;  // Length of previous longest prefix suffix
        int i = 1;
        
        lps[0] = 0;  // LPS of first character is always 0
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];  // Don't increment i
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // KMP search
    public static List<Integer> search(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) return result;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0;  // Index for text
        int j = 0;  // Index for pattern
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                result.add(i - j);  // Pattern found
                j = lps[j - 1];
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAABA";
        String pattern = "AABA";
        
        System.out.println("LPS: " + Arrays.toString(computeLPS(pattern)));
        System.out.println("Occurrences: " + search(text, pattern));
        // [0, 9, 12]
    }
}
```

**Time Complexity:** O(n + m)  
**Space Complexity:** O(m)

**Advantage:** Never re-examines matched characters in text!

---

### KMP Visualization

```
Text:    A A B A A C A A D A A B A A B A
Pattern: A A B A
         ↑ ↑ ↑ ↑
Match found at index 0

Text:    A A B A A C A A D A A B A A B A
Pattern:         A A B A
                 ↑ ↑ X
Mismatch at 'C', use LPS to skip ahead

Text:    A A B A A C A A D A A B A A B A
Pattern:                   A A B A
                           ↑ ↑ ↑ ↑
Match found at index 9
```

---

<a name="rabin-karp"></a>
## 3. Rabin-Karp Algorithm

### Rolling Hash Technique

**Key Idea:** Use hash values to quickly compare pattern with text substrings.

**Hash Function:**
```
hash = (char[0] × d^(m-1) + char[1] × d^(m-2) + ... + char[m-1]) % q

Where:
- d = number of characters in alphabet (256 for ASCII)
- q = prime number
- m = pattern length
```

**Rolling Hash:**
```
Remove leftmost: hash = (hash - text[i] × d^(m-1)) × d
Add rightmost:   hash = hash + text[i + m]
```

---

### Rabin-Karp Implementation

```java
public class RabinKarp {
    
    private static final int d = 256;  // Number of characters
    private static final int q = 101;  // Prime number
    
    public static List<Integer> search(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        int patternHash = 0;
        int textHash = 0;
        int h = 1;
        
        // Calculate h = d^(m-1) % q
        for (int i = 0; i < m - 1; i++) {
            h = (h * d) % q;
        }
        
        // Calculate initial hash values
        for (int i = 0; i < m; i++) {
            patternHash = (d * patternHash + pattern.charAt(i)) % q;
            textHash = (d * textHash + text.charAt(i)) % q;
        }
        
        // Slide pattern over text
        for (int i = 0; i <= n - m; i++) {
            // Check if hash values match
            if (patternHash == textHash) {
                // Verify character by character (avoid spurious hits)
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    result.add(i);
                }
            }
            
            // Calculate hash for next window
            if (i < n - m) {
                textHash = (d * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % q;
                
                // Handle negative hash
                if (textHash < 0) {
                    textHash += q;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "GEEKS FOR GEEKS";
        String pattern = "GEEK";
        
        System.out.println("Occurrences: " + search(text, pattern));
        // [0, 10]
    }
}
```

**Time Complexity:**
- Average: O(n + m)
- Worst: O(n × m) (many spurious hits)

**Space Complexity:** O(1)

**Best for:** Multiple pattern search (can search many patterns simultaneously)

---

### Rolling Hash Example

```
Text:    "ABCDABC"
Pattern: "ABC"

Initial window "ABC":
hash = (A × 256² + B × 256 + C) % 101

Next window "BCD":
Remove 'A': hash = (hash - A × 256²) × 256
Add 'D':    hash = hash + D
```

---

<a name="boyer-moore"></a>
## 4. Boyer-Moore Algorithm

### Bad Character Heuristic

**Key Idea:** Skip alignments that will definitely not match.

**Rule:** On mismatch at position i:
- If mismatched character appears in pattern, align it
- Otherwise, skip entire pattern length

```java
public class BoyerMoore {
    
    private static final int NO_OF_CHARS = 256;
    
    // Bad character heuristic
    private static int[] buildBadCharTable(String pattern) {
        int m = pattern.length();
        int[] badChar = new int[NO_OF_CHARS];
        
        // Initialize all as -1
        Arrays.fill(badChar, -1);
        
        // Fill actual positions
        for (int i = 0; i < m; i++) {
            badChar[pattern.charAt(i)] = i;
        }
        
        return badChar;
    }
    
    public static List<Integer> search(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        int[] badChar = buildBadCharTable(pattern);
        
        int shift = 0;  // Shift of pattern with respect to text
        
        while (shift <= n - m) {
            int j = m - 1;
            
            // Match from right to left
            while (j >= 0 && pattern.charAt(j) == text.charAt(shift + j)) {
                j--;
            }
            
            if (j < 0) {
                // Pattern found
                result.add(shift);
                
                // Shift pattern so next character aligns with last occurrence
                shift += (shift + m < n) ? m - badChar[text.charAt(shift + m)] : 1;
            } else {
                // Shift pattern so bad character aligns with last occurrence
                shift += Math.max(1, j - badChar[text.charAt(shift + j)]);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "ABAAABCD";
        String pattern = "ABC";
        
        System.out.println("Occurrences: " + search(text, pattern));
        // [4]
    }
}
```

**Time Complexity:**
- Best: O(n/m) (sublinear!)
- Worst: O(n × m)
- Average: O(n)

**Space Complexity:** O(k) where k = alphabet size

**Best for:** Large alphabets, long patterns

---

### Boyer-Moore Visualization

```
Text:    "HERE IS A SIMPLE EXAMPLE"
Pattern: "EXAMPLE"

Step 1: Align from right
        H E R E   I S   A   S I M P L E   E X A M P L E
        E X A M P L E
                    ↑ Mismatch at 'A' vs 'E'
        
Step 2: 'A' appears in pattern at position 2
        Shift to align 'A' in text with 'A' in pattern
        H E R E   I S   A   S I M P L E   E X A M P L E
                        E X A M P L E
```

---

<a name="regex"></a>
## 5. Regular Expressions

### Basic Regex Patterns

```java
public class RegexBasics {
    
    public static void main(String[] args) {
        // Literal matching
        System.out.println("hello".matches("hello"));  // true
        
        // Dot (.) - any character
        System.out.println("cat".matches("c.t"));  // true
        System.out.println("cut".matches("c.t"));  // true
        
        // Star (*) - zero or more
        System.out.println("".matches("a*"));  // true
        System.out.println("aaa".matches("a*"));  // true
        
        // Plus (+) - one or more
        System.out.println("a".matches("a+"));  // true
        System.out.println("".matches("a+"));  // false
        
        // Question (?) - zero or one
        System.out.println("color".matches("colou?r"));  // true
        System.out.println("colour".matches("colou?r"));  // true
        
        // Character classes
        System.out.println("5".matches("[0-9]"));  // true
        System.out.println("a".matches("[a-z]"));  // true
        System.out.println("A".matches("[A-Z]"));  // true
        
        // Quantifiers
        System.out.println("123".matches("\\d{3}"));  // true (exactly 3 digits)
        System.out.println("12".matches("\\d{2,4}"));  // true (2 to 4 digits)
        
        // Anchors
        System.out.println("hello".matches("^h.*o$"));  // true (starts with h, ends with o)
    }
}
```

---

### Pattern and Matcher

```java
import java.util.regex.*;

public class PatternMatcherDemo {
    
    public static void main(String[] args) {
        String text = "My phone is 123-456-7890 and office is 987-654-3210";
        String regex = "\\d{3}-\\d{3}-\\d{4}";
        
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(text);
        
        // Find all matches
        while (matcher.find()) {
            System.out.println("Found: " + matcher.group());
            System.out.println("Start: " + matcher.start());
            System.out.println("End: " + matcher.end());
        }
        
        // Replace all
        String replaced = matcher.replaceAll("XXX-XXX-XXXX");
        System.out.println(replaced);
        
        // Split
        String[] parts = text.split("\\s+");
        System.out.println(Arrays.toString(parts));
    }
}
```

**Output:**
```
Found: 123-456-7890
Start: 15
End: 27
Found: 987-654-3210
Start: 41
End: 53
My phone is XXX-XXX-XXXX and office is XXX-XXX-XXXX
```

---

### Common Regex Patterns

```java
public class CommonRegex {
    
    public static void main(String[] args) {
        // Email validation
        String email = "user@example.com";
        String emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";
        System.out.println(email.matches(emailRegex));  // true
        
        // Phone number (US format)
        String phone = "123-456-7890";
        String phoneRegex = "\\d{3}-\\d{3}-\\d{4}";
        System.out.println(phone.matches(phoneRegex));  // true
        
        // URL validation
        String url = "https://www.example.com";
        String urlRegex = "^(https?://)?(www\\.)?[a-zA-Z0-9.-]+\\.[a-z]{2,}$";
        System.out.println(url.matches(urlRegex));  // true
        
        // IP address
        String ip = "192.168.1.1";
        String ipRegex = "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";
        System.out.println(ip.matches(ipRegex));  // true
        
        // Password (min 8 chars, 1 upper, 1 lower, 1 digit)
        String password = "Pass123word";
        String passRegex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$";
        System.out.println(password.matches(passRegex));  // true
    }
}
```

---

<a name="wildcard"></a>
## 6. Wildcard Pattern Matching

### Pattern 6.1: Wildcard Matching (? and *)

**Problem:** Match string with wildcards:
- `?` matches any single character
- `*` matches any sequence (including empty)

```java
public class WildcardMatching {
    
    // Dynamic Programming approach
    public static boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        
        // Empty pattern matches empty string
        dp[0][0] = true;
        
        // Handle patterns starting with *
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 1];
            }
        }
        
        // Fill DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '*') {
                    // * can match empty or one or more characters
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else if (p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1)) {
                    // ? matches any char or characters match
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        
        return dp[m][n];
    }
    
    // Optimized two-pointer approach
    public static boolean isMatchOptimized(String s, String p) {
        int i = 0, j = 0;
        int starIdx = -1, matchIdx = 0;
        
        while (i < s.length()) {
            if (j < p.length() && (p.charAt(j) == '?' || s.charAt(i) == p.charAt(j))) {
                // Characters match or ? wildcard
                i++;
                j++;
            } else if (j < p.length() && p.charAt(j) == '*') {
                // * wildcard - save position
                starIdx = j;
                matchIdx = i;
                j++;
            } else if (starIdx != -1) {
                // Backtrack to last * and try matching more characters
                j = starIdx + 1;
                matchIdx++;
                i = matchIdx;
            } else {
                return false;
            }
        }
        
        // Check remaining pattern characters (should be all *)
        while (j < p.length() && p.charAt(j) == '*') {
            j++;
        }
        
        return j == p.length();
    }
    
    public static void main(String[] args) {
        System.out.println(isMatch("aa", "a"));  // false
        System.out.println(isMatch("aa", "*"));  // true
        System.out.println(isMatch("cb", "?a"));  // false
        System.out.println(isMatch("adceb", "*a*b"));  // true
        System.out.println(isMatch("acdcb", "a*c?b"));  // false
    }
}
```

**Time Complexity:** O(m × n) for DP, O(m × n) worst case for optimized  
**Space Complexity:** O(m × n) for DP, O(1) for optimized

---

### Pattern 6.2: Regular Expression Matching (. and *)

**Problem:** Match with regex wildcards:
- `.` matches any single character
- `*` matches zero or more of preceding element

```java
public class RegexMatching {
    
    public static boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        
        dp[0][0] = true;
        
        // Handle patterns like a*, a*b*, etc.
        for (int j = 2; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    // Two cases:
                    // 1. * matches zero occurrences
                    dp[i][j] = dp[i][j - 2];
                    
                    // 2. * matches one or more occurrences
                    if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                }
            }
        }
        
        return dp[m][n];
    }
    
    public static void main(String[] args) {
        System.out.println(isMatch("aa", "a"));  // false
        System.out.println(isMatch("aa", "a*"));  // true
        System.out.println(isMatch("ab", ".*"));  // true
        System.out.println(isMatch("aab", "c*a*b"));  // true
        System.out.println(isMatch("mississippi", "mis*is*p*."));  // false
    }
}
```

**Time Complexity:** O(m × n)  
**Space Complexity:** O(m × n)

---

<a name="advanced"></a>
## 7. Advanced Pattern Problems

### Pattern 7.1: Implement strStr()

**Problem:** Return index of first occurrence of needle in haystack.

```java
public class ImplementStrStr {
    
    // Using KMP
    public static int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int n = haystack.length();
        int m = needle.length();
        
        // Build LPS array
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (needle.charAt(i) == needle.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        // Search
        i = 0;
        int j = 0;
        
        while (i < n) {
            if (haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && haystack.charAt(i) != needle.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        System.out.println(strStr("hello", "ll"));  // 2
        System.out.println(strStr("aaaaa", "bba"));  // -1
        System.out.println(strStr("", ""));  // 0
    }
}
```

**Time:** O(n + m), **Space:** O(m)

---

### Pattern 7.2: Repeated String Match

**Problem:** Minimum times to repeat string A so B is substring.

```java
public class RepeatedStringMatch {
    
    public static int repeatedStringMatch(String a, String b) {
        int count = 1;
        StringBuilder sb = new StringBuilder(a);
        
        // Minimum repetitions needed
        while (sb.length() < b.length()) {
            sb.append(a);
            count++;
        }
        
        if (sb.toString().contains(b)) return count;
        
        // Try one more time (for overlap cases)
        sb.append(a);
        if (sb.toString().contains(b)) return count + 1;
        
        return -1;
    }
    
    public static void main(String[] args) {
        System.out.println(repeatedStringMatch("abcd", "cdabcdab"));  // 3
        System.out.println(repeatedStringMatch("a", "aa"));  // 2
        System.out.println(repeatedStringMatch("a", "a"));  // 1
    }
}
```

**Time:** O(n × (n + m)), **Space:** O(n)

---

### Pattern 7.3: Shortest Palindrome

**Problem:** Find shortest palindrome by adding characters to front.

```java
public class ShortestPalindrome {
    
    public static String shortestPalindrome(String s) {
        if (s.isEmpty()) return s;
        
        // Find longest palindrome prefix
        String rev = new StringBuilder(s).reverse().toString();
        String combined = s + "#" + rev;
        
        // Build KMP LPS array
        int[] lps = new int[combined.length()];
        
        for (int i = 1; i < combined.length(); i++) {
            int j = lps[i - 1];
            
            while (j > 0 && combined.charAt(i) != combined.charAt(j)) {
                j = lps[j - 1];
            }
            
            if (combined.charAt(i) == combined.charAt(j)) {
                j++;
            }
            
            lps[i] = j;
        }
        
        // Add suffix (reversed) to front
        int palinLen = lps[combined.length() - 1];
        String suffix = s.substring(palinLen);
        
        return new StringBuilder(suffix).reverse().toString() + s;
    }
    
    public static void main(String[] args) {
        System.out.println(shortestPalindrome("aacecaaa"));  // "aaacecaaa"
        System.out.println(shortestPalindrome("abcd"));  // "dcbabcd"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Pattern 7.4: Find All Anagrams in String (Pattern Matching View)

```java
public class FindAnagramsPattern {
    
    public static List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        if (s.length() < p.length()) return result;
        
        int[] pCount = new int[26];
        int[] sCount = new int[26];
        
        // Build pattern frequency
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        for (int i = 0; i < s.length(); i++) {
            sCount[s.charAt(i) - 'a']++;
            
            // Remove leftmost character when window exceeds size
            if (i >= p.length()) {
                sCount[s.charAt(i - p.length()) - 'a']--;
            }
            
            // Check if current window is anagram
            if (i >= p.length() - 1 && Arrays.equals(pCount, sCount)) {
                result.add(i - p.length() + 1);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(findAnagrams("cbaebabacd", "abc"));  // [0, 6]
        System.out.println(findAnagrams("abab", "ab"));  // [0, 1, 2]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the difference between KMP and naive pattern matching?

**Answer:** 
- **Naive:** Re-examines characters on mismatch → O(n × m)
- **KMP:** Uses LPS array to skip redundant comparisons → O(n + m)

---

### Q2: When would you use Rabin-Karp over KMP?

**Answer:** 
- **Multiple pattern search** - Can search many patterns simultaneously
- **Average case** is fast, but worst case (many collisions) is slow
- Good for plagiarism detection

---

### Q3: What's the Boyer-Moore advantage?

**Answer:** 
- **Sublinear time** in best case O(n/m)
- Scans right-to-left, skips large portions
- Best for large alphabets and long patterns

---

### Q4: Explain the LPS array in KMP.

**Answer:** 
LPS[i] = length of longest proper prefix of pattern[0...i] that is also suffix.

Used to determine how much to shift pattern on mismatch without re-examining.

---

### Q5: What's a rolling hash?

**Answer:** 
Hash that can be updated incrementally:
```
hash(i+1) = (hash(i) - leftmost) × d + rightmost
```
Used in Rabin-Karp for O(1) hash updates.

---

### Q6: Difference between wildcard (*) and regex (*)?

**Answer:**
- **Wildcard `*`:** Matches any sequence (like glob patterns)
- **Regex `*`:** Matches zero or more of preceding element

---

### Q7: How to avoid spurious hits in Rabin-Karp?

**Answer:** 
- Use good prime number for modulo
- Verify character-by-character when hashes match
- Use larger hash values

---

### Q8: What's the space complexity of KMP?

**Answer:** O(m) for LPS array, where m = pattern length.

---

### Q9: Can pattern matching be done in O(n) for any pattern?

**Answer:** Yes! KMP guarantees O(n + m) time complexity.

---

### Q10: What's the worst case for naive pattern matching?

**Answer:** 
When pattern and text have many matching prefixes:
```
Text:    "AAAAAAAAAB"
Pattern: "AAAAB"
```
Every position requires O(m) comparisons → O(n × m)

---

### Q11: How does regex `.` differ from wildcard `?`?

**Answer:** They're similar:
- Both match any single character
- `.` is regex syntax
- `?` is wildcard/glob syntax

---

### Q12: What's lookahead in regex?

**Answer:** 
Assertion that matches position, not characters:
```java
// Positive lookahead (?=...)
"(?=.*\\d)" // Must contain digit
```

---

### Q13: How to check if string matches multiple patterns?

**Answer:** 
Use regex alternation:
```java
s.matches("(pattern1|pattern2|pattern3)")
```

---

### Q14: What's greedy vs lazy matching?

**Answer:**
- **Greedy (`.*`):** Matches as much as possible
- **Lazy (`.*?`):** Matches as little as possible

---

### Q15: How to escape special regex characters?

**Answer:**
```java
Pattern.quote(str)  // Escapes all special chars
"\\Q" + str + "\\E"  // Alternative
```

---

### Q16: Can KMP be used for multiple pattern matching?

**Answer:** 
Not directly. Use **Aho-Corasick** algorithm (extension of KMP) for multiple patterns.

---

### Q17: What's the time complexity of `String.contains()`?

**Answer:** O(n × m) - uses naive approach, not KMP!

---

### Q18: How to find longest repeated substring?

**Answer:**
- Build suffix array
- Or use LCP (Longest Common Prefix) with DP
- **Time:** O(n²) with DP

---

### Q19: What's Z-algorithm?

**Answer:** 
Alternative to KMP, builds Z-array:
- Z[i] = length of longest substring starting at i that matches prefix
- **Time:** O(n + m)

---

### Q20: How to validate email with regex?

**Answer:**
```java
String regex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
email.matches(regex);
```

---

<a name="practice-problems"></a>
## 9. Practice Problems

### Problem 1: Implement indexOf() Using KMP

```java
public class IndexOfKMP {
    
    public static int indexOf(String text, String pattern) {
        if (pattern.isEmpty()) return 0;
        
        int n = text.length(), m = pattern.length();
        
        // Build LPS
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        // Search
        i = 0;
        int j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (j == m) return i - j;
            } else if (j > 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        System.out.println(indexOf("hello world", "world"));  // 6
        System.out.println(indexOf("ABABDABACDABABCABAB", "ABABCABAB"));  // 10
    }
}
```

**Time:** O(n + m), **Space:** O(m)

---

### Problem 2: Count Occurrences of Pattern

```java
public class CountOccurrences {
    
    public static int countOccurrences(String text, String pattern) {
        int count = 0;
        int index = 0;
        
        while ((index = text.indexOf(pattern, index)) != -1) {
            count++;
            index += pattern.length();  // Move past current match
        }
        
        return count;
    }
    
    // Non-overlapping count
    public static int countNonOverlapping(String text, String pattern) {
        int count = 0;
        int index = 0;
        
        while ((index = text.indexOf(pattern, index)) != -1) {
            count++;
            index += pattern.length();
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        System.out.println(countOccurrences("aaaa", "aa"));  // 3 (overlapping)
        System.out.println(countNonOverlapping("aaaa", "aa"));  // 2
    }
}
```

**Time:** O(n × m), **Space:** O(1)

---

### Problem 3: Valid IP Address

```java
public class ValidIPAddress {
    
    public static String validIPAddress(String IP) {
        // Check IPv4
        if (isValidIPv4(IP)) return "IPv4";
        
        // Check IPv6
        if (isValidIPv6(IP)) return "IPv6";
        
        return "Neither";
    }
    
    private static boolean isValidIPv4(String IP) {
        if (IP.endsWith(".")) return false;
        
        String[] parts = IP.split("\\.", -1);
        if (parts.length != 4) return false;
        
        for (String part : parts) {
            if (part.isEmpty() || part.length() > 3) return false;
            if (part.length() > 1 && part.charAt(0) == '0') return false;
            
            try {
                int num = Integer.parseInt(part);
                if (num < 0 || num > 255) return false;
            } catch (NumberFormatException e) {
                return false;
            }
        }
        
        return true;
    }
    
    private static boolean isValidIPv6(String IP) {
        if (IP.endsWith(":")) return false;
        
        String[] parts = IP.split(":", -1);
        if (parts.length != 8) return false;
        
        for (String part : parts) {
            if (part.isEmpty() || part.length() > 4) return false;
            
            for (char c : part.toCharArray()) {
                if (!Character.isDigit(c) && 
                    !(c >= 'a' && c <= 'f') && 
                    !(c >= 'A' && c <= 'F')) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(validIPAddress("172.16.254.1"));  // IPv4
        System.out.println(validIPAddress("2001:0db8:85a3:0:0:8A2E:0370:7334"));  // IPv6
        System.out.println(validIPAddress("256.256.256.256"));  // Neither
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 4: Find Substring with Concatenation

**Problem:** Find all start indices where concatenation of all words exists.

```java
public class SubstringConcatenation {
    
    public static List<Integer> findSubstring(String s, String[] words) {
        List<Integer> result = new ArrayList<>();
        if (s.isEmpty() || words.length == 0) return result;
        
        int wordLen = words[0].length();
        int wordCount = words.length;
        int totalLen = wordLen * wordCount;
        
        // Build word frequency map
        Map<String, Integer> wordMap = new HashMap<>();
        for (String word : words) {
            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);
        }
        
        for (int i = 0; i <= s.length() - totalLen; i++) {
            Map<String, Integer> seen = new HashMap<>();
            int j = 0;
            
            while (j < wordCount) {
                int wordStart = i + j * wordLen;
                String word = s.substring(wordStart, wordStart + wordLen);
                
                if (!wordMap.containsKey(word)) break;
                
                seen.put(word, seen.getOrDefault(word, 0) + 1);
                
                if (seen.get(word) > wordMap.get(word)) break;
                
                j++;
            }
            
            if (j == wordCount) {
                result.add(i);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String[] words = {"foo", "bar"};
        System.out.println(findSubstring("barfoothefoobarman", words));  // [0, 9]
    }
}
```

**Time:** O(n × m × k) where k = word length, **Space:** O(m)

---

### Problem 5: Text Justification

```java
public class TextJustification {
    
    public static List<String> fullJustify(String[] words, int maxWidth) {
        List<String> result = new ArrayList<>();
        int i = 0;
        
        while (i < words.length) {
            int lineLength = words[i].length();
            int j = i + 1;
            
            // Find how many words fit in current line
            while (j < words.length && lineLength + words[j].length() + (j - i) <= maxWidth) {
                lineLength += words[j].length();
                j++;
            }
            
            int numWords = j - i;
            StringBuilder line = new StringBuilder();
            
            // Last line or single word - left justify
            if (j == words.length || numWords == 1) {
                for (int k = i; k < j; k++) {
                    line.append(words[k]);
                    if (k < j - 1) line.append(" ");
                }
                while (line.length() < maxWidth) {
                    line.append(" ");
                }
            } else {
                // Fully justify
                int totalSpaces = maxWidth - lineLength;
                int spacesBetween = totalSpaces / (numWords - 1);
                int extraSpaces = totalSpaces % (numWords - 1);
                
                for (int k = i; k < j; k++) {
                    line.append(words[k]);
                    if (k < j - 1) {
                        for (int s = 0; s < spacesBetween; s++) {
                            line.append(" ");
                        }
                        if (k - i < extraSpaces) {
                            line.append(" ");
                        }
                    }
                }
            }
            
            result.add(line.toString());
            i = j;
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String[] words = {"This", "is", "an", "example", "of", "text", "justification."};
        List<String> result = fullJustify(words, 16);
        for (String line : result) {
            System.out.println("'" + line + "'");
        }
    }
}
```

**Time:** O(n), **Space:** O(1)

---

## Summary Cheat Sheet

### Algorithm Comparison

| Algorithm | Time (Best) | Time (Avg) | Time (Worst) | Space | Best For |
|-----------|------------|------------|--------------|-------|----------|
| **Naive** | O(n) | O(n×m) | O(n×m) | O(1) | Small patterns |
| **KMP** | O(n+m) | O(n+m) | O(n+m) | O(m) | General purpose ⭐ |
| **Rabin-Karp** | O(n+m) | O(n+m) | O(n×m) | O(1) | Multiple patterns |
| **Boyer-Moore** | O(n/m) | O(n) | O(n×m) | O(k) | Long patterns |

---

### Pattern Selection Guide

```
Choose Algorithm Based On:

Small pattern (< 10 chars)
  └─> Naive or String.indexOf()

Single pattern, guaranteed linear time
  └─> KMP

Multiple patterns simultaneously
  └─> Rabin-Karp or Aho-Corasick

Large alphabet, long pattern
  └─> Boyer-Moore

Wildcards/Regex
  └─> Dynamic Programming
```

---

### Key Concepts

✅ **KMP:** Build LPS array, never re-examine text characters  
✅ **Rabin-Karp:** Rolling hash for O(1) updates  
✅ **Boyer-Moore:** Right-to-left scan, skip on mismatch  
✅ **Regex:** `.` any char, `*` zero or more, `+` one or more  
✅ **Wildcard:** `?` single char, `*` any sequence  
✅ **DP:** For pattern matching with wildcards/regex  
✅ **LPS:** Longest Proper Prefix which is also Suffix  
✅ **Spurious hit:** Hash match but not actual match  
✅ **String.contains():** Uses naive O(n×m)  
✅ **Pattern matching** appears in 25% of interviews!  

---

[← Back: String Manipulation](./4.2-String-Manipulation.md) | [Next: StringBuilder and StringBuffer →](./4.4-StringBuilder-StringBuffer.md)
