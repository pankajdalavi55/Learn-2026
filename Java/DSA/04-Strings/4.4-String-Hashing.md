# String Hashing - Complete Guide

## Why String Hashing?

**Essential for efficient string comparison and search!**

- **Critical for:** Fast string matching, duplicate detection, rolling hash
- **Interview favorite:** Facebook, Google ask hashing problems
- **Foundation for:** Rabin-Karp, substring search, pattern matching
- **Real-world:** Plagiarism detection, file deduplication, blockchain

**Master hashing = Solve string problems efficiently!**

---

## Table of Contents

1. [What is String Hashing?](#what-is-hashing)
2. [Hash Functions for Strings](#hash-functions)
3. [Polynomial Rolling Hash](#polynomial-hash)
4. [Rabin-Karp Implementation](#rabin-karp)
5. [String Comparison with Hashing](#comparison)
6. [Collision Handling](#collisions)
7. [Multiple Hash Functions](#multiple-hash)
8. [Advanced Hashing Applications](#advanced)
9. [Interview Questions](#interview-questions)
10. [Practice Problems](#practice-problems)

---

<a name="what-is-hashing"></a>
## 1. What is String Hashing?

### Understanding String Hashing

**String Hashing:** Convert string to fixed-size integer value.

**Why?**
- Compare strings in **O(1)** instead of O(n)
- Store/search strings efficiently
- Detect duplicates quickly

**Key Properties:**
1. **Deterministic:** Same string → same hash
2. **Fast:** O(n) to compute, O(1) to compare
3. **Uniform distribution:** Minimize collisions

---

### Basic Hash Example

```java
public class BasicStringHash {
    
    // Simple hash: sum of ASCII values
    public static int simpleHash(String s) {
        int hash = 0;
        for (char c : s.toCharArray()) {
            hash += c;
        }
        return hash;
    }
    
    // Problem: "abc" and "bca" have same hash!
    public static void main(String[] args) {
        System.out.println(simpleHash("abc"));  // 294
        System.out.println(simpleHash("bca"));  // 294 (collision!)
        
        System.out.println(simpleHash("listen"));  // 654
        System.out.println(simpleHash("silent"));  // 654 (collision!)
    }
}
```

**Problem:** Too many collisions! Need better hash function.

---

<a name="hash-functions"></a>
## 2. Hash Functions for Strings

### Method 1: Java's hashCode()

```java
public class JavaHashCode {
    
    public static void main(String[] args) {
        String s1 = "hello";
        String s2 = "hello";
        String s3 = "world";
        
        System.out.println(s1.hashCode());  // 99162322
        System.out.println(s2.hashCode());  // 99162322 (same!)
        System.out.println(s3.hashCode());  // 113318802
        
        // Java's implementation
        // hash = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
    }
}
```

**Java's formula:**
```
hash = s[0] × 31^(n-1) + s[1] × 31^(n-2) + ... + s[n-1]
```

**Time:** O(n), **Space:** O(1)

---

### Method 2: Custom Hash with Prime Base

```java
public class CustomHash {
    
    private static final long MOD = 1000000007;  // Large prime
    private static final int BASE = 31;  // Small prime
    
    public static long hash(String s) {
        long hash = 0;
        long pow = 1;
        
        for (int i = 0; i < s.length(); i++) {
            hash = (hash + (s.charAt(i) - 'a' + 1) * pow) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    // Alternative: compute from left to right
    public static long hashLeftToRight(String s) {
        long hash = 0;
        
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + (c - 'a' + 1)) % MOD;
        }
        
        return hash;
    }
    
    public static void main(String[] args) {
        System.out.println(hash("abc"));  // Different from "bca"
        System.out.println(hash("bca"));
        
        System.out.println(hashLeftToRight("hello"));
        System.out.println(hashLeftToRight("world"));
    }
}
```

**Why BASE = 31?**
- Prime number reduces collisions
- Multiplication by 31 = (x << 5) - x (fast!)
- Good distribution for English text

**Why MOD?**
- Keep hash values in range
- Prevent integer overflow
- Use large prime for better distribution

---

### Method 3: FNV Hash (Fowler-Noll-Vo)

```java
public class FNVHash {
    
    private static final long FNV_OFFSET = 2166136261L;
    private static final long FNV_PRIME = 16777619L;
    
    public static long fnv1aHash(String s) {
        long hash = FNV_OFFSET;
        
        for (byte b : s.getBytes()) {
            hash ^= b;
            hash *= FNV_PRIME;
        }
        
        return hash;
    }
    
    public static void main(String[] args) {
        System.out.println(fnv1aHash("hello"));
        System.out.println(fnv1aHash("world"));
    }
}
```

**Advantages:**
- Fast computation
- Good distribution
- Low collision rate

---

<a name="polynomial-hash"></a>
## 3. Polynomial Rolling Hash

### Understanding Polynomial Hash

**Formula:**
```
hash(s) = (s[0] × p^(n-1) + s[1] × p^(n-2) + ... + s[n-1]) mod m

Where:
- p = prime base (typically 31, 53, or 101)
- m = large prime modulo (typically 10^9 + 7 or 10^9 + 9)
```

**Key Property:** Can update hash in O(1) when sliding window!

---

### Basic Polynomial Hash

```java
public class PolynomialHash {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    // Compute hash of string
    public static long computeHash(String s) {
        long hash = 0;
        long pow = 1;
        
        for (int i = 0; i < s.length(); i++) {
            hash = (hash + (s.charAt(i) - 'a' + 1) * pow) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    // Precompute powers of base
    public static long[] computePowers(int maxLen) {
        long[] powers = new long[maxLen];
        powers[0] = 1;
        
        for (int i = 1; i < maxLen; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
        
        return powers;
    }
    
    // Compute prefix hashes
    public static long[] computePrefixHash(String s) {
        int n = s.length();
        long[] hash = new long[n + 1];
        long[] pow = computePowers(n + 1);
        
        for (int i = 0; i < n; i++) {
            hash[i + 1] = (hash[i] + (s.charAt(i) - 'a' + 1) * pow[i]) % MOD;
        }
        
        return hash;
    }
    
    // Get hash of substring [l, r]
    public static long getSubstringHash(long[] prefixHash, long[] powers, int l, int r) {
        long result = (prefixHash[r + 1] - prefixHash[l] + MOD) % MOD;
        
        // Divide by powers[l] (multiply by modular inverse)
        long inv = modInverse(powers[l], MOD);
        result = (result * inv) % MOD;
        
        return result;
    }
    
    // Modular inverse using Fermat's little theorem
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        
        while (b > 0) {
            if ((b & 1) == 1) {
                result = (result * a) % m;
            }
            a = (a * a) % m;
            b >>= 1;
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String s = "abcdefgh";
        
        long[] prefixHash = computePrefixHash(s);
        long[] powers = computePowers(s.length() + 1);
        
        // Hash of "abc"
        System.out.println(getSubstringHash(prefixHash, powers, 0, 2));
        
        // Hash of "def"
        System.out.println(getSubstringHash(prefixHash, powers, 3, 5));
    }
}
```

**Time Complexity:**
- Preprocessing: O(n)
- Substring hash: O(1) ⭐

**Space Complexity:** O(n)

---

### Rolling Hash (Sliding Window)

```java
public class RollingHash {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static long[] rollingHash(String s, int windowSize) {
        int n = s.length();
        long[] hashes = new long[n - windowSize + 1];
        
        // Compute base^windowSize
        long pow = 1;
        for (int i = 0; i < windowSize; i++) {
            pow = (pow * BASE) % MOD;
        }
        
        // Compute first window hash
        long hash = 0;
        long basePow = 1;
        for (int i = 0; i < windowSize; i++) {
            hash = (hash + (s.charAt(i) - 'a' + 1) * basePow) % MOD;
            basePow = (basePow * BASE) % MOD;
        }
        hashes[0] = hash;
        
        // Slide window
        basePow = basePow / BASE;  // Reset to BASE^(windowSize-1)
        
        for (int i = windowSize; i < n; i++) {
            // Remove leftmost character
            hash = (hash - (s.charAt(i - windowSize) - 'a' + 1) + MOD) % MOD;
            
            // Divide by BASE
            hash = (hash * modInverse(BASE, MOD)) % MOD;
            
            // Add new character
            hash = (hash + (s.charAt(i) - 'a' + 1) * basePow) % MOD;
            
            hashes[i - windowSize + 1] = hash;
        }
        
        return hashes;
    }
    
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        while (b > 0) {
            if ((b & 1) == 1) result = (result * a) % m;
            a = (a * a) % m;
            b >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) {
        String s = "abcdefgh";
        long[] hashes = rollingHash(s, 3);
        
        System.out.println("Hashes of all 3-char substrings:");
        for (int i = 0; i < hashes.length; i++) {
            System.out.println(s.substring(i, i + 3) + ": " + hashes[i]);
        }
    }
}
```

**Time:** O(n), **Space:** O(n - k + 1)

---

<a name="rabin-karp"></a>
## 4. Rabin-Karp Implementation

### Complete Rabin-Karp with Polynomial Hash

```java
public class RabinKarpComplete {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static List<Integer> search(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        // Compute pattern hash
        long patternHash = 0;
        long pow = 1;
        
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash + (pattern.charAt(i) - 'a' + 1) * pow) % MOD;
            if (i < m - 1) {
                pow = (pow * BASE) % MOD;
            }
        }
        
        // Compute first window hash
        long textHash = 0;
        long basePow = 1;
        
        for (int i = 0; i < m; i++) {
            textHash = (textHash + (text.charAt(i) - 'a' + 1) * basePow) % MOD;
            if (i < m - 1) {
                basePow = (basePow * BASE) % MOD;
            }
        }
        
        // Check first window
        if (textHash == patternHash && verify(text, pattern, 0)) {
            result.add(0);
        }
        
        // Precompute modular inverse
        long baseInv = modInverse(BASE, MOD);
        
        // Slide window
        for (int i = m; i < n; i++) {
            // Remove leftmost character
            textHash = (textHash - (text.charAt(i - m) - 'a' + 1) + MOD) % MOD;
            
            // Divide by BASE
            textHash = (textHash * baseInv) % MOD;
            
            // Add new character
            textHash = (textHash + (text.charAt(i) - 'a' + 1) * basePow) % MOD;
            
            // Check match
            if (textHash == patternHash && verify(text, pattern, i - m + 1)) {
                result.add(i - m + 1);
            }
        }
        
        return result;
    }
    
    // Verify actual string match (avoid spurious hits)
    private static boolean verify(String text, String pattern, int start) {
        for (int i = 0; i < pattern.length(); i++) {
            if (text.charAt(start + i) != pattern.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        while (b > 0) {
            if ((b & 1) == 1) result = (result * a) % m;
            a = (a * a) % m;
            b >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) {
        String text = "aabaacaadaabaaba";
        String pattern = "aaba";
        
        List<Integer> matches = search(text, pattern);
        System.out.println("Pattern found at indices: " + matches);
        // [0, 9, 12]
    }
}
```

**Time:** O(n + m) average, O(n × m) worst  
**Space:** O(1)

---

<a name="comparison"></a>
## 5. String Comparison with Hashing

### Fast String Comparison

```java
public class HashComparison {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    static class StringHash {
        String str;
        long hash;
        
        StringHash(String s) {
            this.str = s;
            this.hash = computeHash(s);
        }
        
        private long computeHash(String s) {
            long hash = 0;
            long pow = 1;
            
            for (char c : s.toCharArray()) {
                hash = (hash + (c - 'a' + 1) * pow) % MOD;
                pow = (pow * BASE) % MOD;
            }
            
            return hash;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof StringHash)) return false;
            StringHash other = (StringHash) obj;
            
            // Quick hash check first
            if (this.hash != other.hash) return false;
            
            // Verify actual string (handle collisions)
            return this.str.equals(other.str);
        }
        
        @Override
        public int hashCode() {
            return (int) hash;
        }
    }
    
    public static void main(String[] args) {
        StringHash s1 = new StringHash("hello");
        StringHash s2 = new StringHash("hello");
        StringHash s3 = new StringHash("world");
        
        System.out.println(s1.equals(s2));  // true
        System.out.println(s1.equals(s3));  // false
        
        // Use in HashSet/HashMap
        Set<StringHash> set = new HashSet<>();
        set.add(s1);
        System.out.println(set.contains(s2));  // true
    }
}
```

---

### Find Duplicate Strings

```java
public class FindDuplicates {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static List<String> findDuplicates(String[] strings) {
        Map<Long, String> seen = new HashMap<>();
        List<String> duplicates = new ArrayList<>();
        
        for (String s : strings) {
            long hash = computeHash(s);
            
            if (seen.containsKey(hash)) {
                // Verify it's actually same string (not collision)
                if (seen.get(hash).equals(s)) {
                    duplicates.add(s);
                }
            } else {
                seen.put(hash, s);
            }
        }
        
        return duplicates;
    }
    
    private static long computeHash(String s) {
        long hash = 0;
        long pow = 1;
        
        for (char c : s.toCharArray()) {
            hash = (hash + (c - 'a' + 1) * pow) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    public static void main(String[] args) {
        String[] strings = {"hello", "world", "hello", "java", "world"};
        System.out.println(findDuplicates(strings));  // [hello, world]
    }
}
```

**Time:** O(n × k) where k = avg string length  
**Space:** O(n)

---

<a name="collisions"></a>
## 6. Collision Handling

### Understanding Collisions

**Collision:** Different strings with same hash value.

**Types:**
1. **True collision:** Hash function produces same value
2. **Spurious hit:** Hash matches but strings differ

---

### Collision Detection Example

```java
public class CollisionDemo {
    
    private static final int MOD = 100;  // Small MOD for demo
    private static final int BASE = 31;
    
    public static int simpleHash(String s) {
        int hash = 0;
        int pow = 1;
        
        for (char c : s.toCharArray()) {
            hash = (hash + (c - 'a' + 1) * pow) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
    
    public static void main(String[] args) {
        // Find collisions
        Map<Integer, List<String>> hashMap = new HashMap<>();
        
        String[] words = {"abc", "def", "ghi", "jkl", "mno", "pqr", "stu"};
        
        for (String word : words) {
            int hash = simpleHash(word);
            hashMap.putIfAbsent(hash, new ArrayList<>());
            hashMap.get(hash).add(word);
        }
        
        // Print collisions
        for (Map.Entry<Integer, List<String>> entry : hashMap.entrySet()) {
            if (entry.getValue().size() > 1) {
                System.out.println("Collision at hash " + entry.getKey() + ": " + entry.getValue());
            }
        }
    }
}
```

---

### Collision Reduction Strategies

```java
public class CollisionReduction {
    
    // Strategy 1: Use larger prime modulo
    private static final long MOD1 = 1000000007;  // 10^9 + 7
    private static final long MOD2 = 1000000009;  // 10^9 + 9
    
    // Strategy 2: Use different bases
    private static final int BASE1 = 31;
    private static final int BASE2 = 53;
    
    // Strategy 3: Double hashing
    static class DoubleHash {
        long hash1;
        long hash2;
        
        DoubleHash(String s) {
            this.hash1 = computeHash(s, BASE1, MOD1);
            this.hash2 = computeHash(s, BASE2, MOD2);
        }
        
        private long computeHash(String s, int base, long mod) {
            long hash = 0;
            long pow = 1;
            
            for (char c : s.toCharArray()) {
                hash = (hash + (c - 'a' + 1) * pow) % mod;
                pow = (pow * base) % mod;
            }
            
            return hash;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof DoubleHash)) return false;
            DoubleHash other = (DoubleHash) obj;
            return this.hash1 == other.hash1 && this.hash2 == other.hash2;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(hash1, hash2);
        }
    }
    
    public static void main(String[] args) {
        DoubleHash h1 = new DoubleHash("hello");
        DoubleHash h2 = new DoubleHash("hello");
        DoubleHash h3 = new DoubleHash("world");
        
        System.out.println(h1.equals(h2));  // true
        System.out.println(h1.equals(h3));  // false
    }
}
```

**Collision probability with double hashing:** ~1 / (MOD1 × MOD2) ≈ 10^-18

---

<a name="multiple-hash"></a>
## 7. Multiple Hash Functions

### Using Multiple Hashes

```java
public class MultipleHashFunctions {
    
    private static final long MOD1 = 1000000007;
    private static final long MOD2 = 1000000009;
    private static final int BASE1 = 31;
    private static final int BASE2 = 37;
    
    static class MultiHash {
        long[] hashes;
        
        MultiHash(String s, int numHashes) {
            this.hashes = new long[numHashes];
            
            if (numHashes >= 1) hashes[0] = hash(s, BASE1, MOD1);
            if (numHashes >= 2) hashes[1] = hash(s, BASE2, MOD2);
            // Add more hash functions as needed
        }
        
        private long hash(String s, int base, long mod) {
            long hash = 0;
            long pow = 1;
            
            for (char c : s.toCharArray()) {
                hash = (hash + (c - 'a' + 1) * pow) % mod;
                pow = (pow * base) % mod;
            }
            
            return hash;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof MultiHash)) return false;
            MultiHash other = (MultiHash) obj;
            return Arrays.equals(this.hashes, other.hashes);
        }
        
        @Override
        public int hashCode() {
            return Arrays.hashCode(hashes);
        }
    }
    
    public static void main(String[] args) {
        MultiHash h1 = new MultiHash("hello", 2);
        MultiHash h2 = new MultiHash("hello", 2);
        
        System.out.println(Arrays.toString(h1.hashes));
        System.out.println(h1.equals(h2));  // true
    }
}
```

---

<a name="advanced"></a>
## 8. Advanced Hashing Applications

### Application 1: Longest Duplicate Substring

```java
public class LongestDuplicateSubstring {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static String longestDupSubstring(String s) {
        int n = s.length();
        int left = 1, right = n;
        int start = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int pos = search(s, mid);
            
            if (pos != -1) {
                start = pos;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return s.substring(start, start + left - 1);
    }
    
    private static int search(String s, int len) {
        Map<Long, List<Integer>> seen = new HashMap<>();
        
        long[] powers = new long[len];
        powers[0] = 1;
        for (int i = 1; i < len; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
        
        // Compute first window hash
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash + (s.charAt(i) - 'a' + 1) * powers[i]) % MOD;
        }
        
        seen.putIfAbsent(hash, new ArrayList<>());
        seen.get(hash).add(0);
        
        // Precompute modular inverse
        long baseInv = modInverse(BASE, MOD);
        
        // Slide window
        for (int i = len; i < s.length(); i++) {
            // Remove leftmost
            hash = (hash - (s.charAt(i - len) - 'a' + 1) + MOD) % MOD;
            hash = (hash * baseInv) % MOD;
            
            // Add rightmost
            hash = (hash + (s.charAt(i) - 'a' + 1) * powers[len - 1]) % MOD;
            
            if (seen.containsKey(hash)) {
                // Verify actual match
                String current = s.substring(i - len + 1, i + 1);
                for (int start : seen.get(hash)) {
                    if (s.substring(start, start + len).equals(current)) {
                        return start;
                    }
                }
            }
            
            seen.putIfAbsent(hash, new ArrayList<>());
            seen.get(hash).add(i - len + 1);
        }
        
        return -1;
    }
    
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        while (b > 0) {
            if ((b & 1) == 1) result = (result * a) % m;
            a = (a * a) % m;
            b >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(longestDupSubstring("banana"));  // "ana"
        System.out.println(longestDupSubstring("abcd"));  // ""
    }
}
```

**Time:** O(n log n), **Space:** O(n)

---

### Application 2: Repeated DNA Sequences

```java
public class RepeatedDNASequences {
    
    public static List<String> findRepeatedDnaSequences(String s) {
        Set<String> result = new HashSet<>();
        Set<Integer> seen = new HashSet<>();
        
        // Map DNA chars to numbers
        Map<Character, Integer> map = new HashMap<>();
        map.put('A', 0);
        map.put('C', 1);
        map.put('G', 2);
        map.put('T', 3);
        
        int hash = 0;
        int len = 10;
        
        for (int i = 0; i < s.length(); i++) {
            // Rolling hash with base 4
            hash = ((hash << 2) | map.get(s.charAt(i))) & ((1 << (len * 2)) - 1);
            
            if (i >= len - 1) {
                if (seen.contains(hash)) {
                    result.add(s.substring(i - len + 1, i + 1));
                }
                seen.add(hash);
            }
        }
        
        return new ArrayList<>(result);
    }
    
    public static void main(String[] args) {
        String s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT";
        System.out.println(findRepeatedDnaSequences(s));
        // [AAAAACCCCC, CCCCCAAAAA]
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Application 3: Distinct Substrings Count

```java
public class DistinctSubstrings {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static int countDistinctSubstrings(String s) {
        Set<Long> hashes = new HashSet<>();
        int n = s.length();
        
        // Precompute powers
        long[] powers = new long[n + 1];
        powers[0] = 1;
        for (int i = 1; i <= n; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
        
        // For each length
        for (int len = 1; len <= n; len++) {
            long hash = 0;
            
            // First window
            for (int i = 0; i < len; i++) {
                hash = (hash + (s.charAt(i) - 'a' + 1) * powers[i]) % MOD;
            }
            hashes.add(hash);
            
            // Precompute modular inverse
            long baseInv = modInverse(BASE, MOD);
            
            // Slide window
            for (int i = len; i < n; i++) {
                hash = (hash - (s.charAt(i - len) - 'a' + 1) + MOD) % MOD;
                hash = (hash * baseInv) % MOD;
                hash = (hash + (s.charAt(i) - 'a' + 1) * powers[len - 1]) % MOD;
                hashes.add(hash);
            }
        }
        
        return hashes.size();
    }
    
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        while (b > 0) {
            if ((b & 1) == 1) result = (result * a) % m;
            a = (a * a) % m;
            b >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(countDistinctSubstrings("abc"));  // 6
        System.out.println(countDistinctSubstrings("aaa"));  // 3
    }
}
```

**Time:** O(n²), **Space:** O(n²)

---

<a name="interview-questions"></a>
## 9. Top 20 Interview Questions

### Q1: What is string hashing?

**Answer:** Converting string to fixed-size integer value for fast comparison (O(1) instead of O(n)).

---

### Q2: Why use prime numbers in hash functions?

**Answer:**
- Better distribution of hash values
- Reduces collision probability
- Common primes: 31, 37, 53, 101, 10^9+7, 10^9+9

---

### Q3: What's a rolling hash?

**Answer:** Hash function that can be updated in O(1) when sliding window over string.

**Example:**
```
Remove leftmost: hash = (hash - left_char) / base
Add rightmost: hash = hash + right_char × base^(k-1)
```

---

### Q4: How to handle hash collisions?

**Answer:**
1. Use larger modulo (10^9+7, 10^9+9)
2. Use multiple hash functions (double/triple hashing)
3. Always verify actual string match after hash match

---

### Q5: What's the difference between hashing and encryption?

**Answer:**
- **Hashing:** One-way, deterministic, fast (for equality check)
- **Encryption:** Two-way, secure, slower (for security)

---

### Q6: Why is BASE typically 31 in Java?

**Answer:**
- Prime number (reduces collisions)
- Efficient: 31 × x = (x << 5) - x
- Good distribution for English text

---

### Q7: What's modular inverse and why use it?

**Answer:** 
Division in modular arithmetic: (a/b) mod m = a × b^(-1) mod m

Used in rolling hash to "remove" leftmost character efficiently.

---

### Q8: How to compute substring hash in O(1)?

**Answer:** Precompute prefix hashes:
```
hash[l...r] = (prefixHash[r+1] - prefixHash[l]) / base^l
```

---

### Q9: What's the time complexity of Rabin-Karp?

**Answer:**
- **Average:** O(n + m)
- **Worst:** O(n × m) (many spurious hits)

---

### Q10: How to reduce collision probability?

**Answer:**
1. Use large prime modulo (≥ 10^9)
2. Use double hashing with different bases/modulos
3. Use 64-bit long instead of 32-bit int

---

### Q11: What's a spurious hit?

**Answer:** Hash values match but actual strings differ (false positive). Always verify with string comparison.

---

### Q12: Can two different strings have same hash?

**Answer:** Yes! (Pigeonhole principle) Infinite strings, finite hash values → collisions inevitable.

---

### Q13: What's the space complexity of rolling hash?

**Answer:** O(1) for hash computation, O(k) if storing window hashes.

---

### Q14: How to hash case-insensitive strings?

**Answer:**
```java
// Convert to lowercase first
hash = computeHash(s.toLowerCase());
```

---

### Q15: What's polynomial hash?

**Answer:**
```
hash = s[0]×p^0 + s[1]×p^1 + ... + s[n-1]×p^(n-1)
```
Where p is prime base.

---

### Q16: How to compare two strings in O(1) with hashing?

**Answer:** Precompute hashes, then compare hash values. Always verify actual strings if hashes match.

---

### Q17: What's the best modulo for string hashing?

**Answer:**
- **10^9 + 7** (1000000007) - most common
- **10^9 + 9** (1000000009) - for double hashing
- Use both for very low collision probability

---

### Q18: Can hashing be used for longest common substring?

**Answer:** Yes! Binary search on length + rolling hash to check if substring of that length exists in both strings.

---

### Q19: What's FNV hash?

**Answer:** Fowler-Noll-Vo hash - fast, non-cryptographic hash with good distribution:
```
hash = FNV_OFFSET
for each byte:
    hash = hash XOR byte
    hash = hash × FNV_PRIME
```

---

### Q20: How to handle integer overflow in hashing?

**Answer:**
1. Use modulo after each operation
2. Use long (64-bit) instead of int
3. Apply (a + b) % m = ((a % m) + (b % m)) % m

---

<a name="practice-problems"></a>
## 10. Practice Problems

### Problem 1: Longest Common Substring

```java
public class LongestCommonSubstring {
    
    private static final long MOD = 1000000007;
    private static final long BASE = 31;
    
    public static String longestCommonSubstring(String s1, String s2) {
        int left = 0, right = Math.min(s1.length(), s2.length());
        int maxLen = 0;
        int start = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int pos = hasCommonSubstring(s1, s2, mid);
            
            if (pos != -1) {
                maxLen = mid;
                start = pos;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return s1.substring(start, start + maxLen);
    }
    
    private static int hasCommonSubstring(String s1, String s2, int len) {
        if (len == 0) return 0;
        
        // Get hashes of all substrings of s1
        Set<Long> s1Hashes = getSubstringHashes(s1, len);
        
        // Check s2 substrings
        long[] powers = computePowers(len);
        long hash = 0;
        
        for (int i = 0; i < len && i < s2.length(); i++) {
            hash = (hash + (s2.charAt(i) - 'a' + 1) * powers[i]) % MOD;
        }
        
        if (s1Hashes.contains(hash)) return 0;
        
        long baseInv = modInverse(BASE, MOD);
        
        for (int i = len; i < s2.length(); i++) {
            hash = (hash - (s2.charAt(i - len) - 'a' + 1) + MOD) % MOD;
            hash = (hash * baseInv) % MOD;
            hash = (hash + (s2.charAt(i) - 'a' + 1) * powers[len - 1]) % MOD;
            
            if (s1Hashes.contains(hash)) {
                return i - len + 1;
            }
        }
        
        return -1;
    }
    
    private static Set<Long> getSubstringHashes(String s, int len) {
        Set<Long> hashes = new HashSet<>();
        long[] powers = computePowers(len);
        
        long hash = 0;
        for (int i = 0; i < len && i < s.length(); i++) {
            hash = (hash + (s.charAt(i) - 'a' + 1) * powers[i]) % MOD;
        }
        hashes.add(hash);
        
        long baseInv = modInverse(BASE, MOD);
        
        for (int i = len; i < s.length(); i++) {
            hash = (hash - (s.charAt(i - len) - 'a' + 1) + MOD) % MOD;
            hash = (hash * baseInv) % MOD;
            hash = (hash + (s.charAt(i) - 'a' + 1) * powers[len - 1]) % MOD;
            hashes.add(hash);
        }
        
        return hashes;
    }
    
    private static long[] computePowers(int len) {
        long[] powers = new long[len];
        powers[0] = 1;
        for (int i = 1; i < len; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
        return powers;
    }
    
    private static long modInverse(long a, long m) {
        return power(a, m - 2, m);
    }
    
    private static long power(long a, long b, long m) {
        long result = 1;
        a %= m;
        while (b > 0) {
            if ((b & 1) == 1) result = (result * a) % m;
            a = (a * a) % m;
            b >>= 1;
        }
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(longestCommonSubstring("abcdefgh", "cdefijkl"));  // "cdef"
    }
}
```

**Time:** O((n + m) log min(n, m)), **Space:** O(n)

---

### Problem 2: Group Shifted Strings

```java
public class GroupShiftedStrings {
    
    public static List<List<String>> groupStrings(String[] strings) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strings) {
            String key = getHashKey(s);
            map.putIfAbsent(key, new ArrayList<>());
            map.get(key).add(s);
        }
        
        return new ArrayList<>(map.values());
    }
    
    private static String getHashKey(String s) {
        if (s.isEmpty()) return "";
        
        StringBuilder key = new StringBuilder();
        
        for (int i = 1; i < s.length(); i++) {
            int diff = s.charAt(i) - s.charAt(i - 1);
            if (diff < 0) diff += 26;  // Handle wrap-around
            key.append(diff).append(",");
        }
        
        return key.toString();
    }
    
    public static void main(String[] args) {
        String[] strings = {"abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"};
        System.out.println(groupStrings(strings));
        // [[abc, bcd, xyz], [acef], [az, ba], [a, z]]
    }
}
```

**Time:** O(n × k), **Space:** O(n × k)

---

### Problem 3: Minimum Window Substring with Hashing

```java
public class MinWindowHash {
    
    public static String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        
        Map<Character, Integer> target = new HashMap<>();
        for (char c : t.toCharArray()) {
            target.put(c, target.getOrDefault(c, 0) + 1);
        }
        
        int required = target.size();
        int formed = 0;
        
        Map<Character, Integer> window = new HashMap<>();
        int left = 0, right = 0;
        int[] result = {-1, 0, 0};
        
        while (right < s.length()) {
            char c = s.charAt(right);
            window.put(c, window.getOrDefault(c, 0) + 1);
            
            if (target.containsKey(c) && 
                window.get(c).intValue() == target.get(c).intValue()) {
                formed++;
            }
            
            while (left <= right && formed == required) {
                c = s.charAt(left);
                
                if (result[0] == -1 || right - left + 1 < result[0]) {
                    result[0] = right - left + 1;
                    result[1] = left;
                    result[2] = right;
                }
                
                window.put(c, window.get(c) - 1);
                if (target.containsKey(c) && 
                    window.get(c) < target.get(c)) {
                    formed--;
                }
                
                left++;
            }
            
            right++;
        }
        
        return result[0] == -1 ? "" : s.substring(result[1], result[2] + 1);
    }
    
    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC"));  // "BANC"
    }
}
```

**Time:** O(|S| + |T|), **Space:** O(|S| + |T|)

---

### Problem 4: Find All Concatenated Words

```java
public class ConcatenatedWords {
    
    public static List<String> findAllConcatenatedWordsInADict(String[] words) {
        Set<String> dict = new HashSet<>(Arrays.asList(words));
        List<String> result = new ArrayList<>();
        
        for (String word : words) {
            if (isConcatenated(word, dict)) {
                result.add(word);
            }
        }
        
        return result;
    }
    
    private static boolean isConcatenated(String word, Set<String> dict) {
        int n = word.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        
        for (int i = 1; i <= n; i++) {
            for (int j = (i == n ? 1 : 0); j < i; j++) {
                if (dp[j] && dict.contains(word.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        
        return dp[n];
    }
    
    public static void main(String[] args) {
        String[] words = {"cat", "cats", "catsdogcats", "dog", "dogcatsdog", "hippopotamuses", "rat", "ratcatdogcat"};
        System.out.println(findAllConcatenatedWordsInADict(words));
        // [catsdogcats, dogcatsdog, ratcatdogcat]
    }
}
```

**Time:** O(n × k²), **Space:** O(n × k)

---

## Summary Cheat Sheet

### Hash Function Comparison

| Hash Type | Time | Collision | Best For |
|-----------|------|-----------|----------|
| **Simple sum** | O(n) | Very high | Not recommended |
| **Polynomial** | O(n) | Low | General purpose ⭐ |
| **Rolling** | O(1) update | Low | Sliding window |
| **Double hash** | O(n) | Very low | Critical applications |
| **FNV** | O(n) | Low | Fast hashing |

---

### Key Formulas

**Polynomial Hash:**
```
hash = (s[0]×p^0 + s[1]×p^1 + ... + s[n-1]×p^(n-1)) mod m
```

**Rolling Hash Update:**
```
Remove left: hash = (hash - left_char) × base^(-1)
Add right: hash = hash + right_char × base^(k-1)
```

**Modular Inverse:**
```
a^(-1) mod m = a^(m-2) mod m  (if m is prime)
```

---

### Best Practices

✅ **Use prime modulo:** 10^9+7, 10^9+9  
✅ **Use prime base:** 31, 37, 53  
✅ **Double hash:** For critical applications  
✅ **Verify matches:** Always check actual strings  
✅ **Precompute powers:** For O(1) substring hash  
✅ **Handle overflow:** Use mod after each operation  
✅ **Use long:** 64-bit for larger range  
✅ **Rolling hash:** For sliding window problems  
✅ **Binary search + hash:** For longest substring problems  
✅ **Hashing appears** in 20% of string interviews!  

---

[← Back: Pattern Matching](./4.3-Pattern-Matching.md) | [Next: StringBuilder and StringBuffer →](./4.5-StringBuilder-StringBuffer.md)
