# KMP Algorithm - Complete Guide

## Why KMP Algorithm?

**The gold standard for pattern matching!**

- **Linear time guarantee:** O(n + m) - no worst case slowdown
- **Interview essential:** Asked by Google, Amazon, Microsoft
- **Foundation for:** Text editors, DNA matching, string libraries
- **Real-world:** Find/Replace, grep, search engines

**Master KMP = Ace pattern matching interviews!**

---

## Table of Contents

1. [Understanding KMP](#understanding-kmp)
2. [LPS Array (Longest Prefix Suffix)](#lps-array)
3. [KMP Pattern Matching](#kmp-matching)
4. [Step-by-Step Examples](#examples)
5. [KMP Variants](#variants)
6. [Advanced Applications](#applications)
7. [Optimizations](#optimizations)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="understanding-kmp"></a>
## 1. Understanding KMP

### The Problem with Naive Matching

**Naive Approach:**
```
Text:    AAAAAAAAAB
Pattern: AAAAB

Position 0: AAAA ✓ → B ✗ (4 comparisons)
Position 1: AAAA ✓ → B ✗ (4 comparisons)  ← Redundant!
Position 2: AAAA ✓ → B ✗ (4 comparisons)
...
Total: O(n × m) comparisons
```

**Problem:** Re-examines characters we already know match!

---

### KMP Key Insight

**Insight:** Use information from previous match to skip redundant comparisons.

**Example:**
```
Text:    ABABCABABA
Pattern: ABABD

Match: ABAB ✓ → C ≠ D ✗

Naive: Start over from position 1
KMP: Know "AB" matches, jump to position 2!
```

**Result:** Never re-examine text characters → O(n) time!

---

### KMP Algorithm Overview

**Two Phases:**

1. **Preprocessing:** Build LPS (Longest Proper Prefix which is also Suffix) array
   - Time: O(m)
   - Space: O(m)

2. **Matching:** Search pattern in text using LPS
   - Time: O(n)
   - Never moves text pointer backward!

**Total:** O(n + m) time, O(m) space

---

<a name="lps-array"></a>
## 2. LPS Array (Longest Prefix Suffix)

### What is LPS?

**LPS[i]:** Length of longest proper prefix of pattern[0...i] that is also a suffix.

**Proper prefix:** Prefix that is not the entire string itself.

**Example 1:**
```
Pattern: "AABAAB"
Index:    0 1 2 3 4 5
Char:     A A B A A B
LPS:      0 1 0 1 2 3

Explanation:
- Index 0 ('A'): No proper prefix → 0
- Index 1 ('AA'): Prefix "A" = Suffix "A" → 1
- Index 2 ('AAB'): No match → 0
- Index 3 ('AABA'): Prefix "A" = Suffix "A" → 1
- Index 4 ('AABAA'): Prefix "AA" = Suffix "AA" → 2
- Index 5 ('AABAAB'): Prefix "AAB" = Suffix "AAB" → 3
```

**Example 2:**
```
Pattern: "ABCDE"
Index:    0 1 2 3 4
Char:     A B C D E
LPS:      0 0 0 0 0

No character repeats → all zeros
```

**Example 3:**
```
Pattern: "AAAA"
Index:    0 1 2 3
Char:     A A A A
LPS:      0 1 2 3

Each position extends the match
```

---

### LPS Array Construction

```java
public class LPSConstruction {
    
    public static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        
        int len = 0;  // Length of previous longest prefix suffix
        int i = 1;
        
        lps[0] = 0;  // First character always 0
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                // Characters match - extend the pattern
                len++;
                lps[i] = len;
                i++;
            } else {
                // Mismatch
                if (len != 0) {
                    // Fall back to previous LPS value
                    len = lps[len - 1];
                    // Don't increment i - try again with smaller len
                } else {
                    // No fallback possible
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        String[] patterns = {"AABAAB", "ABCDE", "AAAA", "ABABC"};
        
        for (String pattern : patterns) {
            int[] lps = computeLPS(pattern);
            System.out.println("Pattern: " + pattern);
            System.out.println("LPS:     " + Arrays.toString(lps));
            System.out.println();
        }
    }
}
```

**Output:**
```
Pattern: AABAAB
LPS:     [0, 1, 0, 1, 2, 3]

Pattern: ABCDE
LPS:     [0, 0, 0, 0, 0]

Pattern: AAAA
LPS:     [0, 1, 2, 3]

Pattern: ABABC
LPS:     [0, 0, 1, 2, 0]
```

**Time:** O(m), **Space:** O(m)

---

### LPS Construction Visualization

```
Pattern: "ABABC"

Step 1: i=1, len=0
  A B A B C
  ↑ ↑
  A ≠ B → lps[1] = 0, i=2

Step 2: i=2, len=0
  A B A B C
  ↑   ↑
  A = A → len=1, lps[2]=1, i=3

Step 3: i=3, len=1
  A B A B C
    ↑   ↑
  B = B → len=2, lps[3]=2, i=4

Step 4: i=4, len=2
  A B A B C
      ↑   ↑
  A ≠ C → len=lps[1]=0

Step 5: i=4, len=0
  A B A B C
  ↑       ↑
  A ≠ C → lps[4]=0, i=5

Final LPS: [0, 0, 1, 2, 0]
```

---

<a name="kmp-matching"></a>
## 3. KMP Pattern Matching

### Complete KMP Implementation

```java
public class KMPAlgorithm {
    
    // Build LPS array
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0;
        int i = 1;
        
        lps[0] = 0;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        
        return lps;
    }
    
    // KMP search - find first occurrence
    public static int search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) return 0;
        if (m > n) return -1;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0;  // Index for text
        int j = 0;  // Index for pattern
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                // Pattern found
                return i - j;
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                // Mismatch after j matches
                if (j != 0) {
                    j = lps[j - 1];  // Don't match lps[0...lps[j-1]] chars
                } else {
                    i++;
                }
            }
        }
        
        return -1;  // Not found
    }
    
    // KMP search - find all occurrences
    public static List<Integer> searchAll(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0 || m > n) return result;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0;
        int j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                result.add(i - j);
                j = lps[j - 1];  // Continue searching
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAABA";
        String pattern = "AABA";
        
        System.out.println("Text: " + text);
        System.out.println("Pattern: " + pattern);
        System.out.println("LPS: " + Arrays.toString(computeLPS(pattern)));
        System.out.println("First occurrence: " + search(text, pattern));
        System.out.println("All occurrences: " + searchAll(text, pattern));
    }
}
```

**Output:**
```
Text: AABAACAADAABAABA
Pattern: AABA
LPS: [0, 1, 0, 1]
First occurrence: 0
All occurrences: [0, 9, 12]
```

**Time:** O(n + m), **Space:** O(m)

---

<a name="examples"></a>
## 4. Step-by-Step Examples

### Example 1: Detailed Walkthrough

```
Text:    "ABABDABACDABABCABAB"
Pattern: "ABABCABAB"
LPS:     [0, 0, 1, 2, 0, 1, 2, 3, 4]

Step-by-step matching:

i=0, j=0: A = A ✓ → i=1, j=1
i=1, j=1: B = B ✓ → i=2, j=2
i=2, j=2: A = A ✓ → i=3, j=3
i=3, j=3: B = B ✓ → i=4, j=4
i=4, j=4: D ≠ C ✗
  → j = lps[3] = 2
  → Compare text[4]='D' with pattern[2]='A'

i=4, j=2: D ≠ A ✗
  → j = lps[1] = 0
  → Compare text[4]='D' with pattern[0]='A'

i=4, j=0: D ≠ A ✗
  → j = 0, increment i
  → i=5, j=0

i=5, j=0: A = A ✓ → i=6, j=1
i=6, j=1: B = B ✓ → i=7, j=2
i=7, j=2: A = A ✓ → i=8, j=3
i=8, j=3: C ≠ B ✗
  → j = lps[2] = 1
  
i=8, j=1: C ≠ B ✗
  → j = lps[0] = 0
  
i=8, j=0: C ≠ A ✗ → i=9

i=9, j=0: D ≠ A ✗ → i=10
i=10, j=0: A = A ✓ → i=11, j=1
i=11, j=1: B = B ✓ → i=12, j=2
i=12, j=2: A = A ✓ → i=13, j=3
i=13, j=3: B = B ✓ → i=14, j=4
i=14, j=4: C = C ✓ → i=15, j=5
i=15, j=5: A = A ✓ → i=16, j=6
i=16, j=6: B = B ✓ → i=17, j=7
i=17, j=7: A = A ✓ → i=18, j=8
i=18, j=8: B = B ✓ → i=19, j=9

j=9 (pattern length) → MATCH at index 10!
```

---

### Example 2: Why LPS Works

```
Text:    "AAACAAAA"
Pattern: "AAAA"
LPS:     [0, 1, 2, 3]

i=0, j=0: A = A ✓ → i=1, j=1
i=1, j=1: A = A ✓ → i=2, j=2
i=2, j=2: A = A ✓ → i=3, j=3
i=3, j=3: C ≠ A ✗

Without LPS: Start over from position 1 (wasteful!)
With LPS: j = lps[2] = 2
  → We know text[1..2] = "AA" matches pattern[0..1]
  → Only need to check text[3] vs pattern[2]

i=3, j=2: C ≠ A ✗
  → j = lps[1] = 1

i=3, j=1: C ≠ A ✗
  → j = lps[0] = 0

i=3, j=0: C ≠ A ✗ → i=4

i=4, j=0: A = A ✓ → i=5, j=1
i=5, j=1: A = A ✓ → i=6, j=2
i=6, j=2: A = A ✓ → i=7, j=3
i=7, j=3: A = A ✓ → i=8, j=4

j=4 → MATCH at index 4!
```

---

### Example 3: Overlapping Matches

```java
public class OverlappingMatches {
    
    public static List<Integer> findOverlapping(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                result.add(i - j);
                // Key: Use LPS to find overlapping matches
                j = lps[j - 1];
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return result;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(findOverlapping("AAAA", "AA"));  // [0, 1, 2]
        System.out.println(findOverlapping("ABABABA", "ABA"));  // [0, 2, 4]
    }
}
```

---

<a name="variants"></a>
## 5. KMP Variants

### Variant 1: Count Occurrences

```java
public class CountOccurrences {
    
    public static int countPattern(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return 0;
        
        int[] lps = computeLPS(pattern);
        
        int count = 0;
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                count++;
                j = lps[j - 1];
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return count;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(countPattern("AABAACAADAABAABA", "AABA"));  // 3
        System.out.println(countPattern("AAAA", "AA"));  // 3 (overlapping)
    }
}
```

---

### Variant 2: Case-Insensitive KMP

```java
public class CaseInsensitiveKMP {
    
    public static int searchIgnoreCase(String text, String pattern) {
        text = text.toLowerCase();
        pattern = pattern.toLowerCase();
        
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return -1;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(searchIgnoreCase("Hello World", "WORLD"));  // 6
        System.out.println(searchIgnoreCase("ABC", "abc"));  // 0
    }
}
```

---

### Variant 3: Multiple Pattern Search

```java
public class MultiplePatternKMP {
    
    public static Map<String, List<Integer>> searchMultiple(String text, String[] patterns) {
        Map<String, List<Integer>> result = new HashMap<>();
        
        for (String pattern : patterns) {
            result.put(pattern, searchAll(text, pattern));
        }
        
        return result;
    }
    
    private static List<Integer> searchAll(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                result.add(i - j);
                j = lps[j - 1];
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return result;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String[] patterns = {"AB", "ABA", "ABAB"};
        
        Map<String, List<Integer>> result = searchMultiple(text, patterns);
        for (Map.Entry<String, List<Integer>> entry : result.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

---

<a name="applications"></a>
## 6. Advanced Applications

### Application 1: Shortest Palindrome

**Problem:** Find shortest palindrome by adding characters to front.

```java
public class ShortestPalindrome {
    
    public static String shortestPalindrome(String s) {
        if (s == null || s.isEmpty()) return s;
        
        // Create string: s + "#" + reverse(s)
        String rev = new StringBuilder(s).reverse().toString();
        String combined = s + "#" + rev;
        
        // Build LPS array
        int[] lps = computeLPS(combined);
        
        // LPS[end] tells us longest palindrome prefix
        int palindromeLen = lps[combined.length() - 1];
        
        // Add non-palindrome suffix (reversed) to front
        String suffix = s.substring(palindromeLen);
        return new StringBuilder(suffix).reverse().toString() + s;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(shortestPalindrome("aacecaaa"));  // "aaacecaaa"
        System.out.println(shortestPalindrome("abcd"));  // "dcbabcd"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Application 2: Repeated Substring Pattern

**Problem:** Check if string can be constructed by repeating substring.

```java
public class RepeatedSubstringPattern {
    
    public static boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        int[] lps = computeLPS(s);
        
        // If LPS[n-1] > 0 and n is divisible by (n - LPS[n-1])
        int len = lps[n - 1];
        return len > 0 && n % (n - len) == 0;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(repeatedSubstringPattern("abab"));  // true ("ab" × 2)
        System.out.println(repeatedSubstringPattern("aba"));  // false
        System.out.println(repeatedSubstringPattern("abcabcabcabc"));  // true
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Application 3: Longest Happy Prefix

**Problem:** Find longest prefix that is also suffix (but not entire string).

```java
public class LongestHappyPrefix {
    
    public static String longestPrefix(String s) {
        int[] lps = computeLPS(s);
        int len = lps[s.length() - 1];
        return s.substring(0, len);
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(longestPrefix("level"));  // "l"
        System.out.println(longestPrefix("ababab"));  // "abab"
        System.out.println(longestPrefix("leetcodeleet"));  // "leet"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

<a name="optimizations"></a>
## 7. Optimizations

### Optimization 1: Space-Optimized KMP

```java
public class SpaceOptimizedKMP {
    
    // Don't store LPS, compute on-the-fly (if needed once)
    public static boolean contains(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return false;
        
        // Build LPS on the fly during matching
        int i = 0, j = 0;
        int[] lps = new int[m];
        
        // Compute LPS for pattern
        int len = 0, k = 1;
        while (k < m) {
            if (pattern.charAt(k) == pattern.charAt(len)) {
                lps[k++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[k++] = 0;
            }
        }
        
        // Match
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) return true;
            
            if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        System.out.println(contains("ABABDABACDABABCABAB", "ABABCABAB"));  // true
        System.out.println(contains("hello world", "xyz"));  // false
    }
}
```

---

### Optimization 2: Early Termination

```java
public class EarlyTerminationKMP {
    
    // Stop after finding first match
    public static int findFirst(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return -1;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                
                // Early termination
                if (j == m) return i - j;
            } else if (j > 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
        
        return -1;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(findFirst("AABAACAADAABAABA", "AABA"));  // 0
    }
}
```

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the time complexity of KMP?

**Answer:** O(n + m) where n = text length, m = pattern length.  
- Preprocessing (LPS): O(m)
- Matching: O(n)

---

### Q2: Why is KMP better than naive approach?

**Answer:** 
- **Naive:** O(n × m) in worst case
- **KMP:** O(n + m) guaranteed
- KMP never re-examines text characters

---

### Q3: What does LPS array represent?

**Answer:** LPS[i] = length of longest proper prefix of pattern[0...i] that is also a suffix.

Used to determine how much to shift pattern on mismatch.

---

### Q4: Can LPS array have all zeros?

**Answer:** Yes! When no character repeats.  
Example: "ABCDE" → LPS = [0, 0, 0, 0, 0]

---

### Q5: What's the space complexity of KMP?

**Answer:** O(m) for LPS array.

---

### Q6: How does KMP handle overlapping matches?

**Answer:** After finding match, set j = lps[j-1] instead of j = 0.  
This allows finding overlapping occurrences.

---

### Q7: Why use `j = lps[j-1]` on mismatch?

**Answer:** lps[j-1] tells us the longest prefix that matches suffix up to mismatch point. We can skip re-comparing those characters.

---

### Q8: Can KMP be used for multiple patterns?

**Answer:** Yes, but inefficient (run separately for each).  
Use **Aho-Corasick** algorithm (trie + KMP) for multiple patterns.

---

### Q9: What's the worst case for naive matching?

**Answer:**
```
Text:    "AAAAAAAAAB"
Pattern: "AAAAB"
```
Every position requires O(m) comparisons → O(n × m)

---

### Q10: How to build LPS array?

**Answer:** Two-pointer approach:
- len: tracks current match length
- i: current position
- Match: extend len
- Mismatch: fallback to lps[len-1]

---

### Q11: Can KMP work with wildcards?

**Answer:** Not directly. Need to modify matching logic to handle wildcards (? and *).

---

### Q12: What's the relationship between KMP and Z-algorithm?

**Answer:** Both achieve O(n+m) pattern matching.  
- **KMP:** Uses LPS array
- **Z-algorithm:** Uses Z-array (longest substring from i matching prefix)

---

### Q13: How to implement case-insensitive KMP?

**Answer:** Convert both text and pattern to lowercase before matching.

---

### Q14: Can LPS be computed in less than O(m)?

**Answer:** No. Must examine each character at least once → Ω(m).

---

### Q15: What happens when pattern is empty?

**Answer:** Convention: return 0 (match at beginning).

---

### Q16: How does KMP ensure O(n) matching?

**Answer:** Text pointer `i` only moves forward, never backward.  
Pattern pointer `j` can reset using LPS, but doesn't affect `i`.

---

### Q17: Can KMP be parallelized?

**Answer:** LPS construction is sequential. Matching can be parallelized by dividing text into chunks.

---

### Q18: What's the maximum value in LPS array?

**Answer:** m - 1 (when entire prefix except last char is also suffix).  
Example: "AAAA" → LPS = [0, 1, 2, 3]

---

### Q19: How to count non-overlapping occurrences?

**Answer:** After finding match, set j = 0 instead of j = lps[j-1].

---

### Q20: Why is KMP taught in interviews?

**Answer:** 
- Classic algorithm (1977)
- Demonstrates dynamic programming
- Real-world applications (grep, text editors)
- Tests understanding of string processing

---

<a name="practice-problems"></a>
## 9. Practice Problems

### Problem 1: Implement strStr() (LeetCode 28)

```java
public class ImplementStrStr {
    
    public static int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int n = haystack.length();
        int m = needle.length();
        
        if (m > n) return -1;
        
        int[] lps = computeLPS(needle);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                return i - j;
            } else if (i < n && haystack.charAt(i) != needle.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(strStr("hello", "ll"));  // 2
        System.out.println(strStr("aaaaa", "bba"));  // -1
    }
}
```

**Time:** O(n + m), **Space:** O(m)

---

### Problem 2: Rotate String (LeetCode 796)

```java
public class RotateString {
    
    public static boolean rotateString(String s, String goal) {
        if (s.length() != goal.length()) return false;
        
        // s is rotation of goal if goal is substring of s+s
        String doubled = s + s;
        return kmpSearch(doubled, goal) != -1;
    }
    
    private static int kmpSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) return i - j;
            
            if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return -1;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(rotateString("abcde", "cdeab"));  // true
        System.out.println(rotateString("abcde", "abced"));  // false
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 3: Find All Occurrences with Details

```java
public class FindAllOccurrences {
    
    static class Match {
        int start;
        int end;
        
        Match(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        @Override
        public String toString() {
            return "[" + start + ", " + end + "]";
        }
    }
    
    public static List<Match> findAll(String text, String pattern) {
        List<Match> matches = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return matches;
        
        int[] lps = computeLPS(pattern);
        
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) {
                matches.add(new Match(i - j, i - 1));
                j = lps[j - 1];
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1];
                } else {
                    i++;
                }
            }
        }
        
        return matches;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                lps[i++] = ++len;
            } else if (len > 0) {
                len = lps[len - 1];
            } else {
                lps[i++] = 0;
            }
        }
        
        return lps;
    }
    
    public static void main(String[] args) {
        System.out.println(findAll("AABAACAADAABAABA", "AABA"));
        // [[0, 3], [9, 12], [12, 15]]
    }
}
```

**Time:** O(n + m), **Space:** O(m)

---

## Summary Cheat Sheet

### KMP Algorithm Steps

```
1. Build LPS array: O(m)
   - Track longest prefix-suffix match
   - Use fallback on mismatch

2. Pattern matching: O(n)
   - Compare text[i] with pattern[j]
   - On match: increment both
   - On mismatch: use LPS to skip

3. Never move text pointer backward!
```

---

### LPS Construction Pattern

```java
len = 0, i = 1
while i < m:
    if pattern[i] == pattern[len]:
        len++
        lps[i] = len
        i++
    else if len > 0:
        len = lps[len-1]  // Fallback
    else:
        lps[i] = 0
        i++
```

---

### Common Mistakes

❌ Moving text pointer backward  
❌ Forgetting to check `i < n` before `text[i]`  
❌ Not handling empty pattern  
❌ Setting `j = 0` instead of `j = lps[j-1]`  
❌ Off-by-one in LPS indexing  

---

### When to Use KMP

✅ **Linear time guarantee** needed  
✅ **Pattern reused** multiple times  
✅ **Large text** files  
✅ **Worst-case performance** critical  
✅ **Streaming data** (text comes incrementally)  

---

## Key Takeaways

✅ **KMP guarantees O(n+m)** - no worst case slowdown  
✅ **LPS array is key** - enables skipping redundant comparisons  
✅ **Never re-examine text** - text pointer only moves forward  
✅ **Space: O(m)** - only pattern space needed  
✅ **Handles overlapping** - set j=lps[j-1] after match  
✅ **Foundation algorithm** - basis for Aho-Corasick  
✅ **Real-world use** - grep, text editors, DNA matching  
✅ **Interview favorite** - tests DP and string understanding  
✅ **25% of pattern matching** problems use KMP!  
✅ **Master this** - unlock many string algorithms!  

---

[← Back: String Hashing](./4.4-String-Hashing.md) | [Next: Practice Problems →](./4.8-Practice-Problems.md)
