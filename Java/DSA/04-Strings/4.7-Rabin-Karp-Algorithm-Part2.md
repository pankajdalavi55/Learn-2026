# 4.7 Rabin-Karp Algorithm - Part 2: Advanced Applications

## Table of Contents
1. [Advanced Applications Overview](#advanced-applications-overview)
2. [Longest Duplicate Substring](#longest-duplicate-substring)
3. [Repeated DNA Sequences](#repeated-dna-sequences)
4. [Substring Search with Wildcards](#substring-search-with-wildcards)
5. [Longest Common Substring](#longest-common-substring)
6. [2D Pattern Matching](#2d-pattern-matching)
7. [Plagiarism Detection](#plagiarism-detection)
8. [String Deduplication](#string-deduplication)
9. [Advanced Pattern Variations](#advanced-pattern-variations)

---

## Advanced Applications Overview

Rabin-Karp's rolling hash technique enables efficient solutions to complex string problems beyond simple pattern matching.

### Key Applications

| Problem | Technique | Time Complexity |
|---------|-----------|-----------------|
| **Longest Duplicate Substring** | Binary search + hash | O(n log n) |
| **Repeated DNA** | Rolling hash with base-4 | O(n) |
| **2D Pattern Matching** | Row hash → Column hash | O(n × m) |
| **Plagiarism Detection** | K-gram hashing | O(n × k) |
| **Longest Common Substring** | Hash all substrings | O(n² log n) |
| **Multiple Pattern Search** | Hash set lookup | O(n + p × m) |

---

## Longest Duplicate Substring

### Problem Statement

**LeetCode 1044**: Find the longest substring that appears at least twice in a string.

```
Input: s = "banana"
Output: "ana"
Explanation: "ana" appears at positions 1 and 3

Input: s = "abcd"
Output: ""
Explanation: No duplicate substring
```

### Approach: Binary Search + Rabin-Karp

**Key Insight**: If there exists a duplicate substring of length k, there also exists one of length k-1.

**Strategy**:
1. Binary search on substring length (1 to n)
2. For each length, use Rabin-Karp to check if duplicate exists
3. Return longest duplicate found

### Complete Implementation

```java
public class LongestDuplicateSubstring {
    private static final int BASE = 26;
    private static final long MOD = (1L << 31) - 1; // 2^31 - 1
    
    public String longestDupSubstring(String s) {
        int n = s.length();
        
        // Binary search on length
        int left = 1, right = n;
        int start = -1;
        int maxLen = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            int pos = search(s, mid);
            
            if (pos != -1) {
                // Found duplicate of length mid
                start = pos;
                maxLen = mid;
                left = mid + 1; // Try longer
            } else {
                right = mid - 1; // Try shorter
            }
        }
        
        return start == -1 ? "" : s.substring(start, start + maxLen);
    }
    
    // Search for duplicate substring of given length
    private int search(String s, int len) {
        if (len == 0) return -1;
        
        int n = s.length();
        
        // Compute BASE^(len-1) % MOD
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Map: hash -> list of start indices
        Map<Long, List<Integer>> hashMap = new HashMap<>();
        
        // Compute hash of first window
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + (s.charAt(i) - 'a')) % MOD;
        }
        
        hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(0);
        
        // Slide window
        for (int i = 1; i <= n - len; i++) {
            // Remove first character of previous window
            hash = (hash - (s.charAt(i - 1) - 'a') * h % MOD + MOD) % MOD;
            
            // Add last character of current window
            hash = (hash * BASE + (s.charAt(i + len - 1) - 'a')) % MOD;
            
            // Check if this hash was seen before
            if (hashMap.containsKey(hash)) {
                String current = s.substring(i, i + len);
                
                // Verify against all previous occurrences with same hash
                for (int prevStart : hashMap.get(hash)) {
                    String prev = s.substring(prevStart, prevStart + len);
                    if (current.equals(prev)) {
                        return i; // Found duplicate
                    }
                }
            }
            
            hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(i);
        }
        
        return -1; // No duplicate of this length
    }
    
    public static void main(String[] args) {
        LongestDuplicateSubstring solution = new LongestDuplicateSubstring();
        
        // Test case 1
        String s1 = "banana";
        System.out.println("Input: " + s1);
        System.out.println("Output: " + solution.longestDupSubstring(s1));
        // Output: "ana"
        
        // Test case 2
        String s2 = "abcd";
        System.out.println("\nInput: " + s2);
        System.out.println("Output: " + solution.longestDupSubstring(s2));
        // Output: ""
        
        // Test case 3
        String s3 = "aaaaa";
        System.out.println("\nInput: " + s3);
        System.out.println("Output: " + solution.longestDupSubstring(s3));
        // Output: "aaaa"
    }
}
```

### Step-by-Step Example

```
Input: s = "banana"
n = 6

Binary Search:
left = 1, right = 6

Iteration 1: mid = 3
  Search for duplicate of length 3:
  - Substrings: "ban", "ana", "nan", "ana"
  - Hash values: hash("ana") appears twice!
  - Found duplicate at position 1
  Result: Found
  Update: start = 1, maxLen = 3, left = 4

Iteration 2: mid = 5
  Search for duplicate of length 5:
  - Substrings: "banan", "anana"
  - No duplicates
  Result: Not found
  Update: right = 4

Iteration 3: mid = 4
  Search for duplicate of length 4:
  - Substrings: "bana", "anan", "nana"
  - No duplicates
  Result: Not found
  Update: right = 3

Iteration 4: left = 4, right = 3 → Stop

Return: s.substring(1, 1 + 3) = "ana"
```

### Complexity Analysis

**Time Complexity**: 
- Binary search: O(log n)
- Each search: O(n) with rolling hash
- Total: **O(n log n)**

**Space Complexity**: O(n) for hash map

### Optimization: Double Hashing

```java
private int searchDoubleHash(String s, int len) {
    int n = s.length();
    
    // Use two hash functions
    long hash1 = 0, hash2 = 0;
    long h1 = 1, h2 = 1;
    int BASE1 = 26, BASE2 = 27;
    long MOD1 = 1_000_000_007;
    long MOD2 = 1_000_000_009;
    
    for (int i = 0; i < len - 1; i++) {
        h1 = (h1 * BASE1) % MOD1;
        h2 = (h2 * BASE2) % MOD2;
    }
    
    // Map: (hash1, hash2) -> start index
    Map<Pair<Long, Long>, Integer> seen = new HashMap<>();
    
    // First window
    for (int i = 0; i < len; i++) {
        int c = s.charAt(i) - 'a';
        hash1 = (hash1 * BASE1 + c) % MOD1;
        hash2 = (hash2 * BASE2 + c) % MOD2;
    }
    
    seen.put(new Pair<>(hash1, hash2), 0);
    
    // Slide window
    for (int i = 1; i <= n - len; i++) {
        int oldC = s.charAt(i - 1) - 'a';
        int newC = s.charAt(i + len - 1) - 'a';
        
        hash1 = (BASE1 * (hash1 - oldC * h1 % MOD1 + MOD1) % MOD1 + newC) % MOD1;
        hash2 = (BASE2 * (hash2 - oldC * h2 % MOD2 + MOD2) % MOD2 + newC) % MOD2;
        
        Pair<Long, Long> key = new Pair<>(hash1, hash2);
        
        if (seen.containsKey(key)) {
            return i; // Very high confidence (no verification needed)
        }
        
        seen.put(key, i);
    }
    
    return -1;
}

// Helper Pair class
class Pair<K, V> {
    K first;
    V second;
    
    Pair(K first, V second) {
        this.first = first;
        this.second = second;
    }
    
    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Pair)) return false;
        Pair<?, ?> p = (Pair<?, ?>) o;
        return first.equals(p.first) && second.equals(p.second);
    }
    
    @Override
    public int hashCode() {
        return 31 * first.hashCode() + second.hashCode();
    }
}
```

---

## Repeated DNA Sequences

### Problem Statement

**LeetCode 187**: Find all 10-letter DNA sequences that occur more than once.

```
Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
Output: ["AAAAACCCCC", "CCCCCAAAAA"]

DNA contains only: A, C, G, T
```

### Approach: Base-4 Rolling Hash

**Key Insight**: DNA has 4 letters → use base-4 encoding
- A = 0, C = 1, G = 2, T = 3

### Complete Implementation

```java
import java.util.*;

public class RepeatedDNA {
    
    // Solution 1: Standard Rabin-Karp
    public List<String> findRepeatedDnaSequences(String s) {
        Set<String> result = new HashSet<>();
        Set<String> seen = new HashSet<>();
        
        int n = s.length();
        int len = 10;
        
        if (n < len) return new ArrayList<>();
        
        for (int i = 0; i <= n - len; i++) {
            String substring = s.substring(i, i + len);
            
            if (seen.contains(substring)) {
                result.add(substring);
            } else {
                seen.add(substring);
            }
        }
        
        return new ArrayList<>(result);
    }
    
    // Solution 2: Optimized with rolling hash
    public List<String> findRepeatedDnaSequencesOptimized(String s) {
        Set<String> result = new HashSet<>();
        Set<Integer> seen = new HashSet<>();
        
        int n = s.length();
        int len = 10;
        
        if (n < len) return new ArrayList<>();
        
        // Map DNA characters to integers
        Map<Character, Integer> map = new HashMap<>();
        map.put('A', 0);
        map.put('C', 1);
        map.put('G', 2);
        map.put('T', 3);
        
        // Compute hash of first window (base-4)
        int hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash << 2) | map.get(s.charAt(i));
        }
        
        seen.add(hash);
        
        // Slide window
        int mask = (1 << (len * 2)) - 1; // Keep only last 20 bits (10 chars × 2 bits)
        
        for (int i = len; i < n; i++) {
            // Remove leftmost character and add new character
            hash = ((hash << 2) | map.get(s.charAt(i))) & mask;
            
            if (seen.contains(hash)) {
                result.add(s.substring(i - len + 1, i + 1));
            }
            
            seen.add(hash);
        }
        
        return new ArrayList<>(result);
    }
    
    // Solution 3: Using polynomial rolling hash
    public List<String> findRepeatedDnaSequencesRK(String s) {
        Set<String> result = new HashSet<>();
        Map<Long, List<Integer>> hashMap = new HashMap<>();
        
        int n = s.length();
        int len = 10;
        
        if (n < len) return new ArrayList<>();
        
        int BASE = 4;
        long MOD = 1_000_000_007;
        
        // Character encoding
        Map<Character, Integer> charToInt = new HashMap<>();
        charToInt.put('A', 0);
        charToInt.put('C', 1);
        charToInt.put('G', 2);
        charToInt.put('T', 3);
        
        // Compute BASE^(len-1) % MOD
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute hash of first window
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + charToInt.get(s.charAt(i))) % MOD;
        }
        
        hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(0);
        
        // Slide window
        for (int i = 1; i <= n - len; i++) {
            // Roll hash
            hash = (hash - charToInt.get(s.charAt(i - 1)) * h % MOD + MOD) % MOD;
            hash = (hash * BASE + charToInt.get(s.charAt(i + len - 1))) % MOD;
            
            // Check if seen before
            if (hashMap.containsKey(hash)) {
                String current = s.substring(i, i + len);
                
                for (int prevIdx : hashMap.get(hash)) {
                    String prev = s.substring(prevIdx, prevIdx + len);
                    if (current.equals(prev)) {
                        result.add(current);
                        break;
                    }
                }
            }
            
            hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(i);
        }
        
        return new ArrayList<>(result);
    }
    
    public static void main(String[] args) {
        RepeatedDNA solution = new RepeatedDNA();
        
        String s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT";
        
        System.out.println("Standard: " + solution.findRepeatedDnaSequences(s));
        System.out.println("Optimized: " + solution.findRepeatedDnaSequencesOptimized(s));
        System.out.println("Rabin-Karp: " + solution.findRepeatedDnaSequencesRK(s));
    }
}
```

**Output**:
```
Standard: [AAAAACCCCC, CCCCCAAAAA]
Optimized: [AAAAACCCCC, CCCCCAAAAA]
Rabin-Karp: [AAAAACCCCC, CCCCCAAAAA]
```

### Bit Manipulation Optimization

```java
public class DNABitManipulation {
    
    public List<String> findRepeatedDnaSequences(String s) {
        Set<String> result = new HashSet<>();
        Set<Integer> seen = new HashSet<>();
        
        int n = s.length();
        if (n < 10) return new ArrayList<>();
        
        // Encode: A=00, C=01, G=10, T=11 (2 bits each)
        int[] encoding = new int[26];
        encoding['A' - 'A'] = 0; // 00
        encoding['C' - 'A'] = 1; // 01
        encoding['G' - 'A'] = 2; // 10
        encoding['T' - 'A'] = 3; // 11
        
        int hash = 0;
        
        // Build first 10-character hash (20 bits)
        for (int i = 0; i < 10; i++) {
            hash = (hash << 2) | encoding[s.charAt(i) - 'A'];
        }
        
        seen.add(hash);
        
        // Mask to keep only last 20 bits
        int mask = (1 << 20) - 1; // 0xFFFFF
        
        for (int i = 10; i < n; i++) {
            // Shift left 2 bits, add new character, mask to 20 bits
            hash = ((hash << 2) | encoding[s.charAt(i) - 'A']) & mask;
            
            if (seen.contains(hash)) {
                result.add(s.substring(i - 9, i + 1));
            }
            
            seen.add(hash);
        }
        
        return new ArrayList<>(result);
    }
    
    public static void main(String[] args) {
        DNABitManipulation solution = new DNABitManipulation();
        
        String s = "AAAAAAAAAAAAA"; // All A's
        System.out.println(solution.findRepeatedDnaSequences(s));
        // Output: [AAAAAAAAAA]
    }
}
```

### Complexity Analysis

**Time Complexity**: 
- Standard: O(n × L) where L = 10
- Optimized: **O(n)** with bit manipulation

**Space Complexity**: O(n) for seen set

---

## Substring Search with Wildcards

### Problem Statement

Search for pattern with wildcard character '?' (matches any single character).

```
Text: "ABCDEFGH"
Pattern: "C?E"
Output: 2 (matches "CDE")

Pattern: "A?C"
Output: 0 (matches "ABC")
```

### Implementation

```java
public class WildcardSearch {
    private static final int BASE = 256;
    private static final int MOD = 1_000_000_007;
    
    public List<Integer> searchWithWildcard(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        // For patterns with wildcards, we can't use simple hash comparison
        // Instead, compute hash for non-wildcard positions only
        
        for (int i = 0; i <= n - m; i++) {
            if (matchesWithWildcard(text, i, pattern)) {
                result.add(i);
            }
        }
        
        return result;
    }
    
    private boolean matchesWithWildcard(String text, int start, String pattern) {
        for (int i = 0; i < pattern.length(); i++) {
            if (pattern.charAt(i) != '?' && 
                text.charAt(start + i) != pattern.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    
    // Optimized: Hash only non-wildcard positions
    public List<Integer> searchWithWildcardOptimized(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        // Precompute positions that are not wildcards
        List<Integer> nonWildcardPos = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            if (pattern.charAt(i) != '?') {
                nonWildcardPos.add(i);
            }
        }
        
        // If all wildcards, match everything
        if (nonWildcardPos.isEmpty()) {
            for (int i = 0; i <= n - m; i++) {
                result.add(i);
            }
            return result;
        }
        
        // Compute hash for pattern (non-wildcard positions only)
        long patternHash = computePartialHash(pattern, nonWildcardPos);
        
        // Slide through text
        for (int i = 0; i <= n - m; i++) {
            long textHash = computePartialHashFromText(text, i, nonWildcardPos);
            
            if (textHash == patternHash) {
                // Verify (though with selective hashing, collisions are rare)
                if (matchesWithWildcard(text, i, pattern)) {
                    result.add(i);
                }
            }
        }
        
        return result;
    }
    
    private long computePartialHash(String s, List<Integer> positions) {
        long hash = 0;
        for (int pos : positions) {
            hash = (hash * BASE + s.charAt(pos)) % MOD;
        }
        return hash;
    }
    
    private long computePartialHashFromText(String text, int start, List<Integer> positions) {
        long hash = 0;
        for (int pos : positions) {
            hash = (hash * BASE + text.charAt(start + pos)) % MOD;
        }
        return hash;
    }
    
    public static void main(String[] args) {
        WildcardSearch ws = new WildcardSearch();
        
        String text = "ABCDEFGH";
        
        System.out.println("Pattern 'C?E': " + ws.searchWithWildcard(text, "C?E"));
        // Output: [2]
        
        System.out.println("Pattern 'A?C': " + ws.searchWithWildcard(text, "A?C"));
        // Output: [0]
        
        System.out.println("Pattern '??E': " + ws.searchWithWildcard(text, "??E"));
        // Output: [2] (CDE)
        
        System.out.println("Pattern '???': " + ws.searchWithWildcard(text, "???"));
        // Output: [0, 1, 2, 3, 4, 5] (all 3-char substrings)
    }
}
```

### Multiple Wildcards Example

```java
public class MultipleWildcards {
    
    public List<Integer> search(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        // Example: pattern = "A?C?E"
        // Only check positions 0, 2, 4
        
        for (int i = 0; i <= n - m; i++) {
            boolean match = true;
            
            for (int j = 0; j < m; j++) {
                if (pattern.charAt(j) != '?') {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
            }
            
            if (match) {
                result.add(i);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        MultipleWildcards mw = new MultipleWildcards();
        
        String text = "ABCDEFGHIJKLMNOP";
        String pattern = "?E?G?";
        
        List<Integer> matches = mw.search(text, pattern);
        System.out.println("Matches at: " + matches);
        
        for (int idx : matches) {
            System.out.println("  " + text.substring(idx, idx + pattern.length()));
        }
    }
}
```

---

## Longest Common Substring

### Problem Statement

Find the longest common substring between two strings.

```
Input: s1 = "abcdef", s2 = "zabcf"
Output: "abc"

Input: s1 = "GeeksforGeeks", s2 = "GeeksQuiz"
Output: "Geeks"
```

### Approach: Rabin-Karp + Binary Search

```java
public class LongestCommonSubstring {
    private static final int BASE = 26;
    private static final long MOD = 1_000_000_007;
    
    public String longestCommonSubstring(String s1, String s2) {
        int n1 = s1.length();
        int n2 = s2.length();
        
        // Binary search on length
        int left = 0, right = Math.min(n1, n2);
        int maxLen = 0;
        String result = "";
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            String common = getCommonSubstring(s1, s2, mid);
            
            if (common != null) {
                maxLen = mid;
                result = common;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // Check if there's a common substring of given length
    private String getCommonSubstring(String s1, String s2, int len) {
        if (len == 0) return "";
        
        // Get all substrings of s1 with given length
        Set<Long> s1Hashes = getHashSet(s1, len);
        
        // Check substrings of s2
        int n = s2.length();
        if (len > n) return null;
        
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + (s2.charAt(i) - 'a')) % MOD;
        }
        
        if (s1Hashes.contains(hash)) {
            return s2.substring(0, len);
        }
        
        for (int i = 1; i <= n - len; i++) {
            hash = (hash - (s2.charAt(i - 1) - 'a') * h % MOD + MOD) % MOD;
            hash = (hash * BASE + (s2.charAt(i + len - 1) - 'a')) % MOD;
            
            if (s1Hashes.contains(hash)) {
                return s2.substring(i, i + len);
            }
        }
        
        return null;
    }
    
    private Set<Long> getHashSet(String s, int len) {
        Set<Long> hashes = new HashSet<>();
        int n = s.length();
        
        if (len > n) return hashes;
        
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + (s.charAt(i) - 'a')) % MOD;
        }
        
        hashes.add(hash);
        
        for (int i = 1; i <= n - len; i++) {
            hash = (hash - (s.charAt(i - 1) - 'a') * h % MOD + MOD) % MOD;
            hash = (hash * BASE + (s.charAt(i + len - 1) - 'a')) % MOD;
            hashes.add(hash);
        }
        
        return hashes;
    }
    
    public static void main(String[] args) {
        LongestCommonSubstring lcs = new LongestCommonSubstring();
        
        System.out.println(lcs.longestCommonSubstring("abcdef", "zabcf"));
        // Output: "abc"
        
        System.out.println(lcs.longestCommonSubstring("GeeksforGeeks", "GeeksQuiz"));
        // Output: "Geeks"
        
        System.out.println(lcs.longestCommonSubstring("abcdxyz", "xyzabcd"));
        // Output: "abcd" or "xyz" (both length 3, could be either)
    }
}
```

### Alternative: Hash All Substrings

```java
public class LCSAllSubstrings {
    
    public String longestCommonSubstring(String s1, String s2) {
        int n1 = s1.length();
        int n2 = s2.length();
        
        // Store all substrings of s1 with their hashes
        Map<Long, List<String>> s1Substrings = getAllSubstringHashes(s1);
        
        String longest = "";
        
        // Check all substrings of s2
        for (int len = 1; len <= n2; len++) {
            for (int i = 0; i <= n2 - len; i++) {
                String sub = s2.substring(i, i + len);
                long hash = computeHash(sub);
                
                if (s1Substrings.containsKey(hash)) {
                    for (String s1Sub : s1Substrings.get(hash)) {
                        if (s1Sub.equals(sub) && sub.length() > longest.length()) {
                            longest = sub;
                        }
                    }
                }
            }
        }
        
        return longest;
    }
    
    private Map<Long, List<String>> getAllSubstringHashes(String s) {
        Map<Long, List<String>> map = new HashMap<>();
        int n = s.length();
        
        for (int len = 1; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                String sub = s.substring(i, i + len);
                long hash = computeHash(sub);
                map.computeIfAbsent(hash, k -> new ArrayList<>()).add(sub);
            }
        }
        
        return map;
    }
    
    private long computeHash(String s) {
        long hash = 0;
        int BASE = 26;
        long MOD = 1_000_000_007;
        
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + (c - 'a')) % MOD;
        }
        
        return hash;
    }
}
```

**Complexity**:
- Binary search approach: O((n1 + n2) log min(n1, n2))
- All substrings approach: O(n1² + n2²)

---

## 2D Pattern Matching

### Problem Statement

Find a 2D pattern (matrix) within a larger 2D text matrix.

```
Text:
A B C D
E F G H
I J K L
M N O P

Pattern:
F G
J K

Output: Position (1, 1)
```

### Approach: Row Hash + Column Hash

**Strategy**:
1. Compute hash for each row of pattern
2. Compute hash for each row of text
3. Use rolling hash to slide pattern vertically

### Implementation

```java
public class Pattern2D {
    private static final int BASE = 256;
    private static final int MOD = 1_000_000_007;
    
    public int[] search2D(char[][] text, char[][] pattern) {
        int textRows = text.length;
        int textCols = text[0].length;
        int patRows = pattern.length;
        int patCols = pattern[0].length;
        
        if (patRows > textRows || patCols > textCols) {
            return new int[]{-1, -1};
        }
        
        // Step 1: Compute hash for each row of pattern
        long[] patternRowHashes = new long[patRows];
        for (int i = 0; i < patRows; i++) {
            patternRowHashes[i] = computeRowHash(pattern[i]);
        }
        
        // Step 2: Compute hash of pattern row hashes (column hash)
        long patternHash = computeArrayHash(patternRowHashes);
        
        // Step 3: Slide through text
        // First, compute row hashes for all rows of text
        long[][] textRowHashes = new long[textRows][textCols - patCols + 1];
        
        for (int row = 0; row < textRows; row++) {
            // For each row, compute rolling hash for all possible column positions
            textRowHashes[row] = computeAllRowHashes(text[row], patCols);
        }
        
        // Step 4: For each column position, slide vertically
        for (int col = 0; col <= textCols - patCols; col++) {
            // Extract column of row hashes
            long[] columnHashes = new long[patRows];
            for (int i = 0; i < patRows; i++) {
                columnHashes[i] = textRowHashes[i][col];
            }
            
            long textHash = computeArrayHash(columnHashes);
            
            // Check first position
            if (textHash == patternHash && verify2D(text, pattern, 0, col)) {
                return new int[]{0, col};
            }
            
            // Slide down
            long h = 1;
            for (int i = 0; i < patRows - 1; i++) {
                h = (h * BASE) % MOD;
            }
            
            for (int row = 1; row <= textRows - patRows; row++) {
                // Remove top row, add bottom row
                textHash = (textHash - textRowHashes[row - 1][col] * h % MOD + MOD) % MOD;
                textHash = (textHash * BASE + textRowHashes[row + patRows - 1][col]) % MOD;
                
                if (textHash == patternHash && verify2D(text, pattern, row, col)) {
                    return new int[]{row, col};
                }
            }
        }
        
        return new int[]{-1, -1};
    }
    
    private long computeRowHash(char[] row) {
        long hash = 0;
        for (char c : row) {
            hash = (hash * BASE + c) % MOD;
        }
        return hash;
    }
    
    private long computeArrayHash(long[] arr) {
        long hash = 0;
        for (long val : arr) {
            hash = (hash * BASE + val) % MOD;
        }
        return hash;
    }
    
    private long[] computeAllRowHashes(char[] row, int windowSize) {
        int n = row.length;
        long[] hashes = new long[n - windowSize + 1];
        
        if (windowSize > n) return hashes;
        
        // Compute h = BASE^(windowSize-1)
        long h = 1;
        for (int i = 0; i < windowSize - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // First window
        long hash = 0;
        for (int i = 0; i < windowSize; i++) {
            hash = (hash * BASE + row[i]) % MOD;
        }
        hashes[0] = hash;
        
        // Rolling hash
        for (int i = 1; i <= n - windowSize; i++) {
            hash = (hash - row[i - 1] * h % MOD + MOD) % MOD;
            hash = (hash * BASE + row[i + windowSize - 1]) % MOD;
            hashes[i] = hash;
        }
        
        return hashes;
    }
    
    private boolean verify2D(char[][] text, char[][] pattern, int row, int col) {
        for (int i = 0; i < pattern.length; i++) {
            for (int j = 0; j < pattern[0].length; j++) {
                if (text[row + i][col + j] != pattern[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public static void main(String[] args) {
        Pattern2D p2d = new Pattern2D();
        
        char[][] text = {
            {'A', 'B', 'C', 'D'},
            {'E', 'F', 'G', 'H'},
            {'I', 'J', 'K', 'L'},
            {'M', 'N', 'O', 'P'}
        };
        
        char[][] pattern = {
            {'F', 'G'},
            {'J', 'K'}
        };
        
        int[] result = p2d.search2D(text, pattern);
        System.out.println("Pattern found at: (" + result[0] + ", " + result[1] + ")");
        // Output: Pattern found at: (1, 1)
    }
}
```

### Visual Example

```
Text (4×4):
  0 1 2 3
0 A B C D
1 E F G H
2 I J K L
3 M N O P

Pattern (2×2):
  0 1
0 F G
1 J K

Step 1: Pattern row hashes
Row 0: hash("FG") = h1
Row 1: hash("JK") = h2
Pattern hash: hash([h1, h2]) = H_pattern

Step 2: Text row hashes at each column
Row 0: [hash("AB"), hash("BC"), hash("CD")]
Row 1: [hash("EF"), hash("FG"), hash("GH")]
Row 2: [hash("IJ"), hash("JK"), hash("KL")]
Row 3: [hash("MN"), hash("NO"), hash("OP")]

Step 3: Check column 0
Rows 0-1: hash([hash("AB"), hash("EF")]) ≠ H_pattern
Rows 1-2: hash([hash("EF"), hash("IJ")]) ≠ H_pattern
Rows 2-3: hash([hash("IJ"), hash("MN")]) ≠ H_pattern

Step 4: Check column 1
Rows 0-1: hash([hash("BC"), hash("FG")]) ≠ H_pattern
Rows 1-2: hash([hash("FG"), hash("JK")]) = H_pattern ✓
  Verify: text[1][1..2] = "FG" ✓, text[2][1..2] = "JK" ✓
  MATCH at (1, 1)!
```

---

## Plagiarism Detection

### Problem Statement

Detect if document contains copied text from source documents using k-gram matching.

```
Source: "The quick brown fox jumps over the lazy dog"
Document: "A quick brown fox jumped over a lazy dog"

K-gram size: 3
Common 3-grams: "quick brown", "brown fox", "over the", "lazy dog"
```

### K-Gram Approach

```java
import java.util.*;

public class PlagiarismDetector {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    // Split text into words
    private List<String> tokenize(String text) {
        return Arrays.asList(text.toLowerCase().split("\\s+"));
    }
    
    // Compute similarity using k-grams
    public double computeSimilarity(String source, String document, int k) {
        List<String> sourceWords = tokenize(source);
        List<String> docWords = tokenize(document);
        
        if (sourceWords.size() < k || docWords.size() < k) {
            return 0.0;
        }
        
        // Get all k-grams from source
        Set<Long> sourceKGrams = getKGramHashes(sourceWords, k);
        
        // Get all k-grams from document
        Set<Long> docKGrams = getKGramHashes(docWords, k);
        
        // Compute Jaccard similarity
        Set<Long> intersection = new HashSet<>(sourceKGrams);
        intersection.retainAll(docKGrams);
        
        Set<Long> union = new HashSet<>(sourceKGrams);
        union.addAll(docKGrams);
        
        return (double) intersection.size() / union.size();
    }
    
    private Set<Long> getKGramHashes(List<String> words, int k) {
        Set<Long> hashes = new HashSet<>();
        
        for (int i = 0; i <= words.size() - k; i++) {
            // Compute hash of k-gram
            long hash = 0;
            for (int j = 0; j < k; j++) {
                hash = (hash * BASE + words.get(i + j).hashCode()) % MOD;
            }
            hashes.add(hash);
        }
        
        return hashes;
    }
    
    // Find copied segments
    public List<String> findCopiedSegments(String source, String document, int k, double threshold) {
        List<String> result = new ArrayList<>();
        List<String> sourceWords = tokenize(source);
        List<String> docWords = tokenize(document);
        
        Set<Long> sourceKGrams = getKGramHashesWithText(sourceWords, k);
        
        for (int i = 0; i <= docWords.size() - k; i++) {
            long hash = computeKGramHash(docWords, i, k);
            
            if (sourceKGrams.contains(hash)) {
                // Found matching k-gram
                String segment = String.join(" ", docWords.subList(i, i + k));
                result.add(segment);
            }
        }
        
        return result;
    }
    
    private Set<Long> getKGramHashesWithText(List<String> words, int k) {
        Set<Long> hashes = new HashSet<>();
        
        for (int i = 0; i <= words.size() - k; i++) {
            long hash = computeKGramHash(words, i, k);
            hashes.add(hash);
        }
        
        return hashes;
    }
    
    private long computeKGramHash(List<String> words, int start, int k) {
        long hash = 0;
        for (int i = 0; i < k; i++) {
            hash = (hash * BASE + words.get(start + i).hashCode()) % MOD;
        }
        return hash;
    }
    
    public static void main(String[] args) {
        PlagiarismDetector detector = new PlagiarismDetector();
        
        String source = "The quick brown fox jumps over the lazy dog";
        String doc1 = "A quick brown fox jumped over a lazy dog";
        String doc2 = "The cat sat on the mat";
        
        System.out.println("Similarity (doc1): " + 
                         detector.computeSimilarity(source, doc1, 3));
        System.out.println("Similarity (doc2): " + 
                         detector.computeSimilarity(source, doc2, 3));
        
        System.out.println("\nCopied segments from doc1:");
        List<String> copied = detector.findCopiedSegments(source, doc1, 3, 0.5);
        for (String segment : copied) {
            System.out.println("  - " + segment);
        }
    }
}
```

**Output**:
```
Similarity (doc1): 0.47
Similarity (doc2): 0.06

Copied segments from doc1:
  - quick brown fox
  - lazy dog
```

### Winnowing Algorithm

```java
public class Winnowing {
    private static final int K = 5;  // K-gram size
    private static final int WINDOW_SIZE = 4;
    
    // Compute fingerprints using winnowing
    public Set<Long> computeFingerprints(String text) {
        List<String> words = Arrays.asList(text.toLowerCase().split("\\s+"));
        
        if (words.size() < K) return new HashSet<>();
        
        // Step 1: Compute all k-gram hashes
        List<Long> kGramHashes = new ArrayList<>();
        for (int i = 0; i <= words.size() - K; i++) {
            kGramHashes.add(computeKGramHash(words, i));
        }
        
        // Step 2: Select minimum hash in each window
        Set<Long> fingerprints = new HashSet<>();
        
        for (int i = 0; i <= kGramHashes.size() - WINDOW_SIZE; i++) {
            long minHash = Long.MAX_VALUE;
            
            for (int j = 0; j < WINDOW_SIZE; j++) {
                minHash = Math.min(minHash, kGramHashes.get(i + j));
            }
            
            fingerprints.add(minHash);
        }
        
        return fingerprints;
    }
    
    private long computeKGramHash(List<String> words, int start) {
        long hash = 0;
        for (int i = 0; i < K; i++) {
            hash = (hash * 31 + words.get(start + i).hashCode()) % 1_000_000_007;
        }
        return hash;
    }
    
    public double compareDocs(String doc1, String doc2) {
        Set<Long> fp1 = computeFingerprints(doc1);
        Set<Long> fp2 = computeFingerprints(doc2);
        
        Set<Long> intersection = new HashSet<>(fp1);
        intersection.retainAll(fp2);
        
        Set<Long> union = new HashSet<>(fp1);
        union.addAll(fp2);
        
        return (double) intersection.size() / union.size();
    }
}
```

---

## String Deduplication

### Problem Statement

Remove duplicate strings from a large collection efficiently.

```java
public class StringDeduplication {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    // Deduplicate using hash set
    public List<String> deduplicate(List<String> strings) {
        Set<Long> seen = new HashSet<>();
        List<String> result = new ArrayList<>();
        
        for (String s : strings) {
            long hash = computeHash(s);
            
            if (!seen.contains(hash)) {
                seen.add(hash);
                result.add(s);
            }
        }
        
        return result;
    }
    
    // Deduplicate with collision handling
    public List<String> deduplicateSafe(List<String> strings) {
        Map<Long, List<String>> hashMap = new HashMap<>();
        List<String> result = new ArrayList<>();
        
        for (String s : strings) {
            long hash = computeHash(s);
            
            if (!hashMap.containsKey(hash)) {
                hashMap.put(hash, new ArrayList<>());
                hashMap.get(hash).add(s);
                result.add(s);
            } else {
                boolean found = false;
                for (String existing : hashMap.get(hash)) {
                    if (existing.equals(s)) {
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    hashMap.get(hash).add(s);
                    result.add(s);
                }
            }
        }
        
        return result;
    }
    
    private long computeHash(String s) {
        long hash = 0;
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + c) % MOD;
        }
        return hash;
    }
    
    public static void main(String[] args) {
        StringDeduplication sd = new StringDeduplication();
        
        List<String> strings = Arrays.asList(
            "hello", "world", "hello", "java", "world", "python", "java"
        );
        
        System.out.println("Original: " + strings);
        System.out.println("Deduplicated: " + sd.deduplicateSafe(strings));
    }
}
```

**Output**:
```
Original: [hello, world, hello, java, world, python, java]
Deduplicated: [hello, world, java, python]
```

---

## Advanced Pattern Variations

### Variation 1: Anagram Search

Find all occurrences of anagrams of a pattern.

```java
public class AnagramSearch {
    
    public List<Integer> findAnagrams(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        // Frequency-based hash (order-independent)
        int[] patternFreq = new int[26];
        int[] windowFreq = new int[26];
        
        for (char c : pattern.toCharArray()) {
            patternFreq[c - 'a']++;
        }
        
        // First window
        for (int i = 0; i < m; i++) {
            windowFreq[text.charAt(i) - 'a']++;
        }
        
        if (Arrays.equals(patternFreq, windowFreq)) {
            result.add(0);
        }
        
        // Slide window
        for (int i = m; i < n; i++) {
            windowFreq[text.charAt(i) - 'a']++;
            windowFreq[text.charAt(i - m) - 'a']--;
            
            if (Arrays.equals(patternFreq, windowFreq)) {
                result.add(i - m + 1);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        AnagramSearch as = new AnagramSearch();
        
        String text = "cbaebabacd";
        String pattern = "abc";
        
        System.out.println("Anagram positions: " + as.findAnagrams(text, pattern));
        // Output: [0, 6] ("cba" and "bac")
    }
}
```

### Variation 2: Permutation in String

```java
public class PermutationInString {
    
    public boolean checkInclusion(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        
        if (m > n) return false;
        
        int[] s1Freq = new int[26];
        int[] windowFreq = new int[26];
        
        for (char c : s1.toCharArray()) {
            s1Freq[c - 'a']++;
        }
        
        for (int i = 0; i < m; i++) {
            windowFreq[s2.charAt(i) - 'a']++;
        }
        
        if (Arrays.equals(s1Freq, windowFreq)) return true;
        
        for (int i = m; i < n; i++) {
            windowFreq[s2.charAt(i) - 'a']++;
            windowFreq[s2.charAt(i - m) - 'a']--;
            
            if (Arrays.equals(s1Freq, windowFreq)) return true;
        }
        
        return false;
    }
}
```

### Variation 3: String Matching with K Mismatches

```java
public class KMismatchSearch {
    
    public List<Integer> searchWithMismatches(String text, String pattern, int k) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int mismatches = 0;
            
            for (int j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    mismatches++;
                    if (mismatches > k) break;
                }
            }
            
            if (mismatches <= k) {
                result.add(i);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        KMismatchSearch kms = new KMismatchSearch();
        
        String text = "ABCDEFGH";
        String pattern = "ACE";
        
        System.out.println("Matches with 0 mismatches: " + 
                         kms.searchWithMismatches(text, pattern, 0));
        System.out.println("Matches with 1 mismatch: " + 
                         kms.searchWithMismatches(text, pattern, 1));
        System.out.println("Matches with 2 mismatches: " + 
                         kms.searchWithMismatches(text, pattern, 2));
    }
}
```

---

## Summary

### Part 2 Covered:
✅ Longest duplicate substring (binary search + RK)  
✅ Repeated DNA sequences (base-4 encoding)  
✅ Substring search with wildcards  
✅ Longest common substring  
✅ 2D pattern matching  
✅ Plagiarism detection (k-grams, winnowing)  
✅ String deduplication  
✅ Advanced variations (anagrams, k-mismatches)  

### Key Takeaways:

1. **Binary Search + RK**: Powerful combination for optimization problems
2. **Custom Encoding**: DNA uses base-4, can optimize for specific alphabets
3. **2D Extension**: Row hash → column hash pattern
4. **K-Grams**: Fundamental for plagiarism and similarity detection
5. **Collision Handling**: Always verify matches for correctness

### Coming in Part 3:
- Optimization techniques and tricks
- Time/space tradeoffs
- 20 comprehensive interview Q&A
- 5 practice problems with complete solutions
- Performance comparison and benchmarking

---

**Previous**: [4.6-Rabin-Karp-Algorithm-Part1.md](4.6-Rabin-Karp-Algorithm-Part1.md)  
**Next**: [4.8-Rabin-Karp-Algorithm-Part3.md](4.8-Rabin-Karp-Algorithm-Part3.md)
