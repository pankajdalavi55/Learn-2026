# 4.10 Strings - Practice Problems

## Table of Contents
1. [Easy Problems](#easy-problems)
2. [Medium Problems](#medium-problems)
3. [Hard Problems](#hard-problems)
4. [Problem Categories](#problem-categories)
5. [Summary](#summary)

---

## Easy Problems

### Problem 1: Reverse String (LeetCode 344)

**Description**: Reverse a string in-place.

**Solution**:
```java
public class ReverseString {
    public void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
    
    // Test
    public static void main(String[] args) {
        ReverseString rs = new ReverseString();
        
        char[] s1 = {'h', 'e', 'l', 'l', 'o'};
        rs.reverseString(s1);
        System.out.println(s1); // "olleh"
        
        char[] s2 = {'H', 'a', 'n', 'n', 'a', 'h'};
        rs.reverseString(s2);
        System.out.println(s2); // "hannaH"
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Two pointers

---

### Problem 2: Valid Palindrome (LeetCode 125)

**Description**: Check if string is palindrome considering only alphanumeric characters.

**Solution**:
```java
public class ValidPalindrome {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            // Skip non-alphanumeric
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            // Compare
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        ValidPalindrome vp = new ValidPalindrome();
        
        System.out.println(vp.isPalindrome("A man, a plan, a canal: Panama")); // true
        System.out.println(vp.isPalindrome("race a car")); // false
        System.out.println(vp.isPalindrome(" ")); // true
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Two pointers with character filtering

---

### Problem 3: First Unique Character (LeetCode 387)

**Description**: Find the first non-repeating character in a string.

**Solution**:
```java
public class FirstUniqueCharacter {
    public int firstUniqChar(String s) {
        int[] count = new int[26];
        
        // Count frequencies
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        // Find first unique
        for (int i = 0; i < s.length(); i++) {
            if (count[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        FirstUniqueCharacter fuc = new FirstUniqueCharacter();
        
        System.out.println(fuc.firstUniqChar("leetcode")); // 0 ('l')
        System.out.println(fuc.firstUniqChar("loveleetcode")); // 2 ('v')
        System.out.println(fuc.firstUniqChar("aabb")); // -1
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Frequency counting

---

### Problem 4: Valid Anagram (LeetCode 242)

**Description**: Check if two strings are anagrams.

**Solution**:
```java
public class ValidAnagram {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;
        
        int[] count = new int[26];
        
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        ValidAnagram va = new ValidAnagram();
        
        System.out.println(va.isAnagram("anagram", "nagaram")); // true
        System.out.println(va.isAnagram("rat", "car")); // false
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Frequency array

---

### Problem 5: Reverse Vowels (LeetCode 345)

**Description**: Reverse only the vowels in a string.

**Solution**:
```java
public class ReverseVowels {
    public String reverseVowels(String s) {
        char[] chars = s.toCharArray();
        int left = 0, right = chars.length - 1;
        String vowels = "aeiouAEIOU";
        
        while (left < right) {
            // Find vowel from left
            while (left < right && vowels.indexOf(chars[left]) == -1) {
                left++;
            }
            
            // Find vowel from right
            while (left < right && vowels.indexOf(chars[right]) == -1) {
                right--;
            }
            
            // Swap vowels
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            
            left++;
            right--;
        }
        
        return new String(chars);
    }
    
    // Test
    public static void main(String[] args) {
        ReverseVowels rv = new ReverseVowels();
        
        System.out.println(rv.reverseVowels("hello")); // "holle"
        System.out.println(rv.reverseVowels("leetcode")); // "leotcede"
    }
}
```

**Complexity**: O(n) time, O(n) space

**Key Technique**: Two pointers with filtering

---

### Problem 6: Longest Common Prefix (LeetCode 14)

**Description**: Find the longest common prefix among strings.

**Solution**:
```java
public class LongestCommonPrefix {
    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0) return "";
        
        // Use first string as reference
        String prefix = strs[0];
        
        for (int i = 1; i < strs.length; i++) {
            // Reduce prefix until it matches start of strs[i]
            while (strs[i].indexOf(prefix) != 0) {
                prefix = prefix.substring(0, prefix.length() - 1);
                if (prefix.isEmpty()) return "";
            }
        }
        
        return prefix;
    }
    
    // Alternative: Vertical scanning
    public String longestCommonPrefixVertical(String[] strs) {
        if (strs == null || strs.length == 0) return "";
        
        for (int i = 0; i < strs[0].length(); i++) {
            char c = strs[0].charAt(i);
            
            for (int j = 1; j < strs.length; j++) {
                if (i >= strs[j].length() || strs[j].charAt(i) != c) {
                    return strs[0].substring(0, i);
                }
            }
        }
        
        return strs[0];
    }
    
    // Test
    public static void main(String[] args) {
        LongestCommonPrefix lcp = new LongestCommonPrefix();
        
        System.out.println(lcp.longestCommonPrefix(new String[]{"flower", "flow", "flight"})); // "fl"
        System.out.println(lcp.longestCommonPrefix(new String[]{"dog", "racecar", "car"})); // ""
    }
}
```

**Complexity**: O(S) where S = sum of all characters, O(1) space

**Key Technique**: String comparison

---

## Medium Problems

### Problem 7: Group Anagrams (LeetCode 49)

**Description**: Group strings that are anagrams.

**Solution**:
```java
import java.util.*;

public class GroupAnagrams {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map = new HashMap<>();
        
        for (String s : strs) {
            // Create frequency-based key
            int[] count = new int[26];
            for (char c : s.toCharArray()) {
                count[c - 'a']++;
            }
            
            StringBuilder key = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (count[i] > 0) {
                    key.append((char)('a' + i)).append(count[i]);
                }
            }
            
            map.computeIfAbsent(key.toString(), k -> new ArrayList<>()).add(s);
        }
        
        return new ArrayList<>(map.values());
    }
    
    // Test
    public static void main(String[] args) {
        GroupAnagrams ga = new GroupAnagrams();
        
        String[] strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
        System.out.println(ga.groupAnagrams(strs));
        // Output: [["bat"], ["nat","tan"], ["ate","eat","tea"]]
    }
}
```

**Complexity**: O(n × k) time where k = max string length, O(n × k) space

**Key Technique**: HashMap with frequency-based key

---

### Problem 8: Longest Palindromic Substring (LeetCode 5)

**Description**: Find the longest palindromic substring.

**Solution**:
```java
public class LongestPalindromicSubstring {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) return "";
        
        int start = 0, end = 0;
        
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);     // Odd
            int len2 = expandAroundCenter(s, i, i + 1); // Even
            int len = Math.max(len1, len2);
            
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        
        return s.substring(start, end + 1);
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
    
    // Test
    public static void main(String[] args) {
        LongestPalindromicSubstring lps = new LongestPalindromicSubstring();
        
        System.out.println(lps.longestPalindrome("babad")); // "bab" or "aba"
        System.out.println(lps.longestPalindrome("cbbd"));  // "bb"
    }
}
```

**Complexity**: O(n²) time, O(1) space

**Key Technique**: Expand around center

---

### Problem 9: Longest Substring Without Repeating Characters (LeetCode 3)

**Description**: Find length of longest substring without repeating characters.

**Solution**:
```java
import java.util.*;

public class LongestSubstringWithoutRepeat {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            
            // If character seen before and within current window
            if (map.containsKey(c) && map.get(c) >= left) {
                left = map.get(c) + 1;
            }
            
            map.put(c, right);
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
    
    // Alternative: Using array for ASCII
    public int lengthOfLongestSubstringArray(String s) {
        int[] lastIndex = new int[128];
        Arrays.fill(lastIndex, -1);
        
        int maxLen = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            
            if (lastIndex[c] >= left) {
                left = lastIndex[c] + 1;
            }
            
            lastIndex[c] = right;
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
    
    // Test
    public static void main(String[] args) {
        LongestSubstringWithoutRepeat ls = new LongestSubstringWithoutRepeat();
        
        System.out.println(ls.lengthOfLongestSubstring("abcabcbb")); // 3 ("abc")
        System.out.println(ls.lengthOfLongestSubstring("bbbbb"));    // 1 ("b")
        System.out.println(ls.lengthOfLongestSubstring("pwwkew"));   // 3 ("wke")
    }
}
```

**Complexity**: O(n) time, O(min(n, m)) space where m = charset size

**Key Technique**: Sliding window with HashMap

---

### Problem 10: Find All Anagrams (LeetCode 438)

**Description**: Find all start indices of anagrams of pattern in string.

**Solution**:
```java
import java.util.*;

public class FindAllAnagrams {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (s.length() < p.length()) return result;
        
        int[] pCount = new int[26];
        int[] sCount = new int[26];
        
        // Count pattern
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        for (int i = 0; i < s.length(); i++) {
            // Add current character
            sCount[s.charAt(i) - 'a']++;
            
            // Remove character outside window
            if (i >= p.length()) {
                sCount[s.charAt(i - p.length()) - 'a']--;
            }
            
            // Check if anagram
            if (Arrays.equals(pCount, sCount)) {
                result.add(i - p.length() + 1);
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindAllAnagrams faa = new FindAllAnagrams();
        
        System.out.println(faa.findAnagrams("cbaebabacd", "abc")); // [0, 6]
        System.out.println(faa.findAnagrams("abab", "ab"));         // [0, 1, 2]
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Sliding window with frequency matching

---

### Problem 11: Minimum Window Substring (LeetCode 76)

**Description**: Find minimum window in s containing all characters of t.

**Solution**:
```java
import java.util.*;

public class MinimumWindowSubstring {
    public String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        
        Map<Character, Integer> tCount = new HashMap<>();
        for (char c : t.toCharArray()) {
            tCount.put(c, tCount.getOrDefault(c, 0) + 1);
        }
        
        int required = tCount.size();
        int formed = 0;
        
        Map<Character, Integer> windowCounts = new HashMap<>();
        
        int left = 0;
        int minLen = Integer.MAX_VALUE;
        int minLeft = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);
            
            if (tCount.containsKey(c) && 
                windowCounts.get(c).intValue() == tCount.get(c).intValue()) {
                formed++;
            }
            
            // Contract window
            while (left <= right && formed == required) {
                // Update result
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minLeft = left;
                }
                
                char leftChar = s.charAt(left);
                windowCounts.put(leftChar, windowCounts.get(leftChar) - 1);
                
                if (tCount.containsKey(leftChar) && 
                    windowCounts.get(leftChar) < tCount.get(leftChar)) {
                    formed--;
                }
                
                left++;
            }
        }
        
        return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);
    }
    
    // Test
    public static void main(String[] args) {
        MinimumWindowSubstring mws = new MinimumWindowSubstring();
        
        System.out.println(mws.minWindow("ADOBECODEBANC", "ABC")); // "BANC"
        System.out.println(mws.minWindow("a", "a"));                // "a"
        System.out.println(mws.minWindow("a", "aa"));               // ""
    }
}
```

**Complexity**: O(|S| + |T|) time, O(|S| + |T|) space

**Key Technique**: Sliding window with two pointers

---

### Problem 12: Longest Repeating Character Replacement (LeetCode 424)

**Description**: Find length of longest substring with same letter after k replacements.

**Solution**:
```java
public class LongestRepeatingCharReplacement {
    public int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int maxCount = 0;
        int maxLen = 0;
        int left = 0;
        
        for (int right = 0; right < s.length(); right++) {
            count[s.charAt(right) - 'A']++;
            maxCount = Math.max(maxCount, count[s.charAt(right) - 'A']);
            
            // If window size - max frequency > k, shrink window
            while (right - left + 1 - maxCount > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }
            
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
    
    // Test
    public static void main(String[] args) {
        LongestRepeatingCharReplacement lr = new LongestRepeatingCharReplacement();
        
        System.out.println(lr.characterReplacement("ABAB", 2));     // 4
        System.out.println(lr.characterReplacement("AABABBA", 1));  // 4
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: Sliding window with frequency tracking

---

### Problem 13: Palindromic Substrings (LeetCode 647)

**Description**: Count all palindromic substrings.

**Solution**:
```java
public class PalindromicSubstrings {
    public int countSubstrings(String s) {
        int count = 0;
        
        for (int i = 0; i < s.length(); i++) {
            // Odd length palindromes
            count += expandAroundCenter(s, i, i);
            // Even length palindromes
            count += expandAroundCenter(s, i, i + 1);
        }
        
        return count;
    }
    
    private int expandAroundCenter(String s, int left, int right) {
        int count = 0;
        
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            count++;
            left--;
            right++;
        }
        
        return count;
    }
    
    // Test
    public static void main(String[] args) {
        PalindromicSubstrings ps = new PalindromicSubstrings();
        
        System.out.println(ps.countSubstrings("abc"));  // 3 (a, b, c)
        System.out.println(ps.countSubstrings("aaa"));  // 6 (a, a, a, aa, aa, aaa)
    }
}
```

**Complexity**: O(n²) time, O(1) space

**Key Technique**: Expand around center

---

### Problem 14: String to Integer (atoi) (LeetCode 8)

**Description**: Implement atoi to convert string to integer.

**Solution**:
```java
public class StringToInteger {
    public int myAtoi(String s) {
        if (s == null || s.length() == 0) return 0;
        
        int i = 0, n = s.length();
        
        // Skip whitespace
        while (i < n && s.charAt(i) == ' ') {
            i++;
        }
        
        if (i == n) return 0;
        
        // Check sign
        int sign = 1;
        if (s.charAt(i) == '+' || s.charAt(i) == '-') {
            sign = (s.charAt(i) == '-') ? -1 : 1;
            i++;
        }
        
        // Convert digits
        long result = 0;
        
        while (i < n && Character.isDigit(s.charAt(i))) {
            result = result * 10 + (s.charAt(i) - '0');
            
            // Check overflow
            if (result * sign > Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }
            if (result * sign < Integer.MIN_VALUE) {
                return Integer.MIN_VALUE;
            }
            
            i++;
        }
        
        return (int)(result * sign);
    }
    
    // Test
    public static void main(String[] args) {
        StringToInteger sti = new StringToInteger();
        
        System.out.println(sti.myAtoi("42"));           // 42
        System.out.println(sti.myAtoi("   -42"));       // -42
        System.out.println(sti.myAtoi("4193 with words")); // 4193
        System.out.println(sti.myAtoi("words and 987")); // 0
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Technique**: State machine parsing

---

### Problem 15: Implement strStr() (LeetCode 28)

**Description**: Find first occurrence of needle in haystack.

**Solution**:
```java
public class ImplementStrStr {
    // Solution 1: Naive
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int n = haystack.length();
        int m = needle.length();
        
        for (int i = 0; i <= n - m; i++) {
            if (haystack.substring(i, i + m).equals(needle)) {
                return i;
            }
        }
        
        return -1;
    }
    
    // Solution 2: Rabin-Karp
    public int strStrRK(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int n = haystack.length();
        int m = needle.length();
        if (m > n) return -1;
        
        int BASE = 31, MOD = 1_000_000_007;
        
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long needleHash = 0, hayHash = 0;
        for (int i = 0; i < m; i++) {
            needleHash = (needleHash * BASE + needle.charAt(i)) % MOD;
            hayHash = (hayHash * BASE + haystack.charAt(i)) % MOD;
        }
        
        for (int i = 0; i <= n - m; i++) {
            if (needleHash == hayHash) {
                if (haystack.substring(i, i + m).equals(needle)) {
                    return i;
                }
            }
            
            if (i < n - m) {
                hayHash = (BASE * (hayHash - haystack.charAt(i) * h) + haystack.charAt(i + m)) % MOD;
                if (hayHash < 0) hayHash += MOD;
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        ImplementStrStr iss = new ImplementStrStr();
        
        System.out.println(iss.strStr("hello", "ll"));   // 2
        System.out.println(iss.strStr("aaaaa", "bba"));  // -1
        System.out.println(iss.strStrRK("hello", "ll")); // 2
    }
}
```

**Complexity**: 
- Naive: O(n × m) time
- Rabin-Karp: O(n + m) average

**Key Technique**: Pattern matching algorithms

---

## Hard Problems

### Problem 16: Longest Duplicate Substring (LeetCode 1044)

**Description**: Find longest substring that appears at least twice.

**Solution**:
```java
import java.util.*;

public class LongestDuplicateSubstring {
    private static final int BASE = 26;
    private static final long MOD = (1L << 31) - 1;
    
    public String longestDupSubstring(String s) {
        int left = 1, right = s.length();
        String result = "";
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            String dup = search(s, mid);
            
            if (dup != null) {
                result = dup;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    private String search(String s, int len) {
        Map<Long, List<Integer>> seen = new HashMap<>();
        
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + (s.charAt(i) - 'a')) % MOD;
        }
        
        seen.computeIfAbsent(hash, k -> new ArrayList<>()).add(0);
        
        for (int i = 1; i <= s.length() - len; i++) {
            hash = (hash - (s.charAt(i - 1) - 'a') * h % MOD + MOD) % MOD;
            hash = (hash * BASE + (s.charAt(i + len - 1) - 'a')) % MOD;
            
            if (seen.containsKey(hash)) {
                String current = s.substring(i, i + len);
                for (int prev : seen.get(hash)) {
                    if (s.substring(prev, prev + len).equals(current)) {
                        return current;
                    }
                }
            }
            
            seen.computeIfAbsent(hash, k -> new ArrayList<>()).add(i);
        }
        
        return null;
    }
    
    // Test
    public static void main(String[] args) {
        LongestDuplicateSubstring lds = new LongestDuplicateSubstring();
        
        System.out.println(lds.longestDupSubstring("banana"));  // "ana"
        System.out.println(lds.longestDupSubstring("abcd"));    // ""
    }
}
```

**Complexity**: O(n log n) time, O(n) space

**Key Technique**: Binary search + Rabin-Karp hashing

---

### Problem 17: Regular Expression Matching (LeetCode 10)

**Description**: Implement regex matching with '.' and '*'.

**Solution**:
```java
public class RegexMatching {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] dp = new boolean[m + 1][n + 1];
        
        dp[0][0] = true;
        
        // Handle patterns like a*, a*b*, etc.
        for (int j = 2; j <= n; j++) {
            if (p.charAt(j - 1) == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                char sc = s.charAt(i - 1);
                char pc = p.charAt(j - 1);
                
                if (pc == '*') {
                    // Check pattern before '*'
                    char prevP = p.charAt(j - 2);
                    
                    // Zero occurrences
                    dp[i][j] = dp[i][j - 2];
                    
                    // One or more occurrences
                    if (prevP == '.' || prevP == sc) {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                } else if (pc == '.' || pc == sc) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        
        return dp[m][n];
    }
    
    // Test
    public static void main(String[] args) {
        RegexMatching rm = new RegexMatching();
        
        System.out.println(rm.isMatch("aa", "a"));      // false
        System.out.println(rm.isMatch("aa", "a*"));     // true
        System.out.println(rm.isMatch("ab", ".*"));     // true
        System.out.println(rm.isMatch("aab", "c*a*b")); // true
    }
}
```

**Complexity**: O(m × n) time and space

**Key Technique**: Dynamic programming

---

### Problem 18: Palindrome Partitioning II (LeetCode 132)

**Description**: Find minimum cuts needed to partition string into palindromes.

**Solution**:
```java
public class PalindromePartitioningII {
    public int minCut(String s) {
        int n = s.length();
        
        // Precompute palindromes
        boolean[][] isPalin = new boolean[n][n];
        
        for (int i = 0; i < n; i++) {
            isPalin[i][i] = true;
        }
        
        for (int i = 0; i < n - 1; i++) {
            isPalin[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));
        }
        
        for (int len = 3; len <= n; len++) {
            for (int i = 0; i <= n - len; i++) {
                int j = i + len - 1;
                isPalin[i][j] = (s.charAt(i) == s.charAt(j)) && isPalin[i + 1][j - 1];
            }
        }
        
        // DP for minimum cuts
        int[] dp = new int[n];
        
        for (int i = 0; i < n; i++) {
            if (isPalin[0][i]) {
                dp[i] = 0; // Entire substring is palindrome
            } else {
                dp[i] = i; // Worst case: cut between every character
                
                for (int j = 1; j <= i; j++) {
                    if (isPalin[j][i]) {
                        dp[i] = Math.min(dp[i], dp[j - 1] + 1);
                    }
                }
            }
        }
        
        return dp[n - 1];
    }
    
    // Test
    public static void main(String[] args) {
        PalindromePartitioningII pp = new PalindromePartitioningII();
        
        System.out.println(pp.minCut("aab"));    // 1 (a|ab)
        System.out.println(pp.minCut("a"));      // 0
        System.out.println(pp.minCut("ab"));     // 1
    }
}
```

**Complexity**: O(n²) time and space

**Key Technique**: Dynamic programming with precomputation

---

### Problem 19: Edit Distance (LeetCode 72)

**Description**: Find minimum operations to convert word1 to word2.

**Solution**:
```java
public class EditDistance {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        
        int[][] dp = new int[m + 1][n + 1];
        
        // Base cases
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i; // Delete all from word1
        }
        
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j; // Insert all from word2
        }
        
        // Fill DP table
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1]; // No operation needed
                } else {
                    dp[i][j] = 1 + Math.min(
                        dp[i - 1][j - 1], // Replace
                        Math.min(
                            dp[i - 1][j],  // Delete
                            dp[i][j - 1]   // Insert
                        )
                    );
                }
            }
        }
        
        return dp[m][n];
    }
    
    // Test
    public static void main(String[] args) {
        EditDistance ed = new EditDistance();
        
        System.out.println(ed.minDistance("horse", "ros"));      // 3
        System.out.println(ed.minDistance("intention", "execution")); // 5
    }
}
```

**Complexity**: O(m × n) time and space

**Key Technique**: Classic DP problem

---

### Problem 20: Distinct Subsequences (LeetCode 115)

**Description**: Count distinct subsequences of s which equals t.

**Solution**:
```java
public class DistinctSubsequences {
    public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        
        long[][] dp = new long[m + 1][n + 1];
        
        // Base case: empty t can be formed by any prefix of s
        for (int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // Don't use s[i-1]
                dp[i][j] = dp[i - 1][j];
                
                // Use s[i-1] if it matches t[j-1]
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        
        return (int)dp[m][n];
    }
    
    // Space optimized
    public int numDistinctOptimized(String s, String t) {
        int m = s.length();
        int n = t.length();
        
        long[] dp = new long[n + 1];
        dp[0] = 1;
        
        for (int i = 1; i <= m; i++) {
            for (int j = n; j >= 1; j--) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[j] += dp[j - 1];
                }
            }
        }
        
        return (int)dp[n];
    }
    
    // Test
    public static void main(String[] args) {
        DistinctSubsequences ds = new DistinctSubsequences();
        
        System.out.println(ds.numDistinct("rabbbit", "rabbit")); // 3
        System.out.println(ds.numDistinct("babgbag", "bag"));    // 5
    }
}
```

**Complexity**: O(m × n) time, O(n) space (optimized)

**Key Technique**: Dynamic programming

---

## Problem Categories

### By Topic

**String Basics**:
- Reverse String (#1)
- Longest Common Prefix (#6)
- String to Integer (#14)

**Anagrams**:
- Valid Anagram (#4)
- Group Anagrams (#7)
- Find All Anagrams (#10)

**Palindromes**:
- Valid Palindrome (#2)
- Longest Palindromic Substring (#8)
- Palindromic Substrings (#13)
- Palindrome Partitioning II (#18)

**Sliding Window**:
- Longest Substring Without Repeat (#9)
- Minimum Window Substring (#11)
- Longest Repeating Character Replacement (#12)

**Pattern Matching**:
- Implement strStr() (#15)
- Longest Duplicate Substring (#16)
- Regular Expression Matching (#17)

**Dynamic Programming**:
- Edit Distance (#19)
- Distinct Subsequences (#20)

### By Technique

| Technique | Problems |
|-----------|----------|
| **Two Pointers** | #1, #2, #5 |
| **Frequency Count** | #3, #4, #7 |
| **Sliding Window** | #9, #10, #11, #12 |
| **Expand Around Center** | #8, #13 |
| **Rabin-Karp Hashing** | #15, #16 |
| **Dynamic Programming** | #17, #18, #19, #20 |
| **HashMap** | #7, #9, #11 |

### By Difficulty

**Easy (6)**: #1, #2, #3, #4, #5, #6  
**Medium (9)**: #7, #8, #9, #10, #11, #12, #13, #14, #15  
**Hard (5)**: #16, #17, #18, #19, #20

---

## Summary

### Key Patterns

1. **Two Pointers**: Use for reversing, palindrome checking, finding pairs
2. **Sliding Window**: Use for substring problems with constraints
3. **Frequency Counting**: Use for anagrams, character matching
4. **Expand Around Center**: Use for palindrome finding
5. **Hashing**: Use for fast substring matching, duplicate detection
6. **Dynamic Programming**: Use for optimization problems, subsequences

### Time Complexities

| Pattern | Typical Complexity |
|---------|-------------------|
| Two Pointers | O(n) |
| Sliding Window | O(n) |
| Frequency Count | O(n) |
| Expand Around Center | O(n²) |
| Rabin-Karp | O(n + m) average |
| KMP | O(n + m) worst case |
| Dynamic Programming | O(n²) or O(m × n) |

### Common Optimizations

1. **Use array instead of HashMap** for lowercase/ASCII (O(1) space)
2. **Precompute palindromes** for multiple queries
3. **Binary search + hashing** for substring problems
4. **Rolling hash** for pattern matching
5. **Space optimization in DP** (use 1D array instead of 2D)

### Interview Tips

✅ **Always clarify**:
- Character set (lowercase, ASCII, Unicode?)
- Case sensitivity
- Empty string handling
- Input size constraints

✅ **Start simple**:
- Begin with brute force O(n²) or O(n³)
- Optimize to O(n log n) or O(n)
- Discuss tradeoffs

✅ **Common mistakes to avoid**:
- Forgetting null/empty checks
- Off-by-one errors in substring
- Not handling overflow in hashing
- Incorrect sliding window boundaries

---

**Master these 20 problems and you'll be well-prepared for string-related interviews!**
