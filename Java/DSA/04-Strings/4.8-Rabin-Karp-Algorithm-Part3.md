# 4.8 Rabin-Karp Algorithm - Part 3: Optimizations & Interview Prep

## Table of Contents
1. [Optimization Techniques](#optimization-techniques)
2. [Time and Space Tradeoffs](#time-and-space-tradeoffs)
3. [Performance Comparison](#performance-comparison)
4. [Interview Questions & Answers](#interview-questions--answers)
5. [Practice Problems](#practice-problems)
6. [Cheat Sheet](#cheat-sheet)

---

## Optimization Techniques

### 1. Precompute Powers

**Problem**: Computing BASE^(m-1) repeatedly is wasteful

**Solution**: Precompute once

```java
public class OptimizedRabinKarp {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    // Precompute powers for multiple searches
    private long[] powers;
    
    public OptimizedRabinKarp(int maxLength) {
        powers = new long[maxLength];
        powers[0] = 1;
        for (int i = 1; i < maxLength; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
    }
    
    public int search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        if (m > n) return -1;
        
        long h = powers[m - 1]; // O(1) lookup instead of O(m) computation
        
        long patHash = computeHash(pattern);
        long txtHash = computeHash(text.substring(0, m));
        
        for (int i = 0; i <= n - m; i++) {
            if (patHash == txtHash && text.substring(i, i + m).equals(pattern)) {
                return i;
            }
            
            if (i < n - m) {
                txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                if (txtHash < 0) txtHash += MOD;
            }
        }
        
        return -1;
    }
    
    private long computeHash(String s) {
        long hash = 0;
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + c) % MOD;
        }
        return hash;
    }
}
```

**Benefit**: Reduces time from O(m + nÃ—m) to O(m + n)

### 2. Avoid String Creation

**Problem**: `text.substring(i, i+m)` creates new string objects

**Solution**: Character-by-character comparison

```java
// BAD: Creates strings
if (text.substring(i, i + m).equals(pattern)) {
    return i;
}

// GOOD: No string allocation
private boolean matches(String text, int start, String pattern) {
    for (int j = 0; j < pattern.length(); j++) {
        if (text.charAt(start + j) != pattern.charAt(j)) {
            return false;
        }
    }
    return true;
}

// Usage
if (patHash == txtHash && matches(text, i, pattern)) {
    return i;
}
```

### 3. Early Termination

**Problem**: Continuing search after finding first match

**Solution**: Return immediately for single match search

```java
// Already optimized in basic implementation
if (patHash == txtHash && matches(text, i, pattern)) {
    return i; // Stop immediately
}
```

### 4. Multiple Pattern Optimization

**Problem**: Searching for k patterns separately takes O(k Ã— n)

**Solution**: Hash all patterns once, single text scan

```java
public Map<String, List<Integer>> searchMultipleOptimized(String text, List<String> patterns) {
    Map<String, List<Integer>> result = new HashMap<>();
    
    // Group patterns by length
    Map<Integer, List<String>> byLength = new HashMap<>();
    for (String p : patterns) {
        byLength.computeIfAbsent(p.length(), k -> new ArrayList<>()).add(p);
        result.put(p, new ArrayList<>());
    }
    
    // Process each length group
    for (Map.Entry<Integer, List<String>> entry : byLength.entrySet()) {
        int len = entry.getKey();
        List<String> pats = entry.getValue();
        
        // Create hash map: hash -> patterns
        Map<Long, List<String>> hashToPats = new HashMap<>();
        for (String p : pats) {
            long h = computeHash(p);
            hashToPats.computeIfAbsent(h, k -> new ArrayList<>()).add(p);
        }
        
        // Single scan for this length
        searchForLength(text, len, hashToPats, result);
    }
    
    return result;
}

private void searchForLength(String text, int len, 
                            Map<Long, List<String>> hashToPats,
                            Map<String, List<Integer>> result) {
    int n = text.length();
    if (len > n) return;
    
    long h = powers[len - 1];
    long txtHash = computeHash(text.substring(0, len));
    
    for (int i = 0; i <= n - len; i++) {
        if (hashToPats.containsKey(txtHash)) {
            String window = text.substring(i, i + len);
            for (String pat : hashToPats.get(txtHash)) {
                if (window.equals(pat)) {
                    result.get(pat).add(i);
                }
            }
        }
        
        if (i < n - len) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + len)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
}
```

**Time Complexity**: O(n Ã— L) where L = number of distinct lengths

### 5. Double Hashing for Fewer Verifications

```java
public class DoubleHashRK {
    private long hash1, hash2;
    private long h1, h2;
    
    private static final int BASE1 = 31, BASE2 = 37;
    private static final long MOD1 = 1_000_000_007;
    private static final long MOD2 = 1_000_000_009;
    
    public int search(String text, String pattern) {
        int n = text.length(), m = pattern.length();
        if (m > n) return -1;
        
        // Compute h values
        h1 = modPow(BASE1, m - 1, MOD1);
        h2 = modPow(BASE2, m - 1, MOD2);
        
        // Pattern hashes
        long patHash1 = hash(pattern, BASE1, MOD1);
        long patHash2 = hash(pattern, BASE2, MOD2);
        
        // Text window hashes
        long txtHash1 = hash(text.substring(0, m), BASE1, MOD1);
        long txtHash2 = hash(text.substring(0, m), BASE2, MOD2);
        
        for (int i = 0; i <= n - m; i++) {
            // Both hashes must match (P(collision) â‰ˆ 10^-18)
            if (patHash1 == txtHash1 && patHash2 == txtHash2) {
                return i; // Can skip verification with high confidence
            }
            
            if (i < n - m) {
                char old = text.charAt(i);
                char add = text.charAt(i + m);
                
                txtHash1 = rollHash(txtHash1, old, add, h1, BASE1, MOD1);
                txtHash2 = rollHash(txtHash2, old, add, h2, BASE2, MOD2);
            }
        }
        
        return -1;
    }
    
    private long hash(String s, int base, long mod) {
        long h = 0;
        for (char c : s.toCharArray()) {
            h = (h * base + c) % mod;
        }
        return h;
    }
    
    private long rollHash(long hash, char old, char add, long h, int base, long mod) {
        hash = (base * (hash - old * h % mod + mod) % mod + add) % mod;
        return hash;
    }
    
    private long modPow(long base, int exp, long mod) {
        long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp % 2 == 1) result = (result * base) % mod;
            base = (base * base) % mod;
            exp /= 2;
        }
        return result;
    }
}
```

### 6. Cache Hash Values

For repeated searches on same text:

```java
public class CachedRabinKarp {
    private String text;
    private Map<Integer, long[]> cachedHashes; // length -> all hashes
    
    public CachedRabinKarp(String text) {
        this.text = text;
        this.cachedHashes = new HashMap<>();
    }
    
    public List<Integer> search(String pattern) {
        int m = pattern.length();
        
        // Compute or retrieve cached hashes
        long[] textHashes = cachedHashes.computeIfAbsent(m, 
            len -> computeAllHashes(text, len));
        
        long patHash = computeHash(pattern);
        List<Integer> result = new ArrayList<>();
        
        for (int i = 0; i < textHashes.length; i++) {
            if (textHashes[i] == patHash) {
                if (matches(text, i, pattern)) {
                    result.add(i);
                }
            }
        }
        
        return result;
    }
    
    private long[] computeAllHashes(String s, int len) {
        int n = s.length();
        if (len > n) return new long[0];
        
        long[] hashes = new long[n - len + 1];
        long h = modPow(BASE, len - 1, MOD);
        
        hashes[0] = computeHash(s.substring(0, len));
        
        for (int i = 1; i <= n - len; i++) {
            hashes[i] = (BASE * (hashes[i-1] - s.charAt(i-1) * h) + s.charAt(i + len - 1)) % MOD;
            if (hashes[i] < 0) hashes[i] += MOD;
        }
        
        return hashes;
    }
}
```

---

## Time and Space Tradeoffs

### Comparison Table

| Approach | Time | Space | Use Case |
|----------|------|-------|----------|
| **Basic RK** | O(n+m) avg, O(nm) worst | O(1) | Single pattern, one-time search |
| **Precomputed Powers** | O(n+m) | O(m) | Multiple searches, same pattern length |
| **Cached Hashes** | O(n) preprocessing, O(m) search | O(nÃ—L) | Many patterns on same text |
| **Double Hashing** | O(n+m) | O(1) | Need high confidence, skip verification |
| **Multiple Patterns** | O(nÃ—L + pÃ—m) | O(p) | Many patterns, grouped by length |

### Memory vs Speed

```java
public class TradeoffExample {
    
    // 1. LOW MEMORY, SLOWER (recompute each time)
    public int searchLowMemory(String text, String pattern) {
        // No precomputation
        // Time: O(m) for h computation per search
        // Space: O(1)
        long h = 1;
        for (int i = 0; i < pattern.length() - 1; i++) {
            h = (h * BASE) % MOD;
        }
        // ... rest of search
        return -1;
    }
    
    // 2. MEDIUM MEMORY, FASTER (precompute powers)
    private long[] powers;
    
    public void preprocessMedium(int maxLen) {
        // Precompute powers
        // Time: O(maxLen) once
        // Space: O(maxLen)
        powers = new long[maxLen];
        powers[0] = 1;
        for (int i = 1; i < maxLen; i++) {
            powers[i] = (powers[i-1] * BASE) % MOD;
        }
    }
    
    // 3. HIGH MEMORY, FASTEST (cache all hashes)
    private Map<Integer, long[]> allHashes;
    
    public void preprocessHigh(String text, int maxLen) {
        // Precompute all hashes for all lengths
        // Time: O(n Ã— maxLen) once
        // Space: O(n Ã— maxLen)
        allHashes = new HashMap<>();
        for (int len = 1; len <= maxLen; len++) {
            allHashes.put(len, computeAllHashes(text, len));
        }
    }
}
```

### Practical Guidelines

**Use Basic RK (O(1) space) when:**
- Memory constrained
- One-time search
- Pattern length â‰¤ 100

**Use Precomputed Powers (O(m) space) when:**
- Multiple searches
- Same pattern length
- m â‰¤ 10,000

**Use Cached Hashes (O(nÃ—L) space) when:**
- Text is fixed, patterns vary
- Many searches on same text
- n Ã— L â‰¤ 10^7

---

## Performance Comparison

### Benchmark Code

```java
import java.util.*;

public class RabinKarpBenchmark {
    
    public static void main(String[] args) {
        String text = generateRandomString(1_000_000);
        String pattern = generateRandomString(100);
        
        // Warm up JVM
        for (int i = 0; i < 100; i++) {
            naiveSearch(text, pattern);
        }
        
        // Benchmark
        System.out.println("Text length: " + text.length());
        System.out.println("Pattern length: " + pattern.length());
        System.out.println();
        
        benchmark("Naive", () -> naiveSearch(text, pattern));
        benchmark("Rabin-Karp", () -> rabinKarpSearch(text, pattern));
        benchmark("KMP", () -> kmpSearch(text, pattern));
        benchmark("Java indexOf", () -> text.indexOf(pattern));
    }
    
    private static void benchmark(String name, Runnable search) {
        long start = System.nanoTime();
        for (int i = 0; i < 1000; i++) {
            search.run();
        }
        long end = System.nanoTime();
        
        double avgMs = (end - start) / 1_000_000.0 / 1000;
        System.out.printf("%s: %.3f ms (avg)\n", name, avgMs);
    }
    
    private static String generateRandomString(int length) {
        Random rand = new Random(42); // Fixed seed for consistency
        StringBuilder sb = new StringBuilder(length);
        for (int i = 0; i < length; i++) {
            sb.append((char)('a' + rand.nextInt(26)));
        }
        return sb.toString();
    }
    
    private static int naiveSearch(String text, String pattern) {
        int n = text.length(), m = pattern.length();
        for (int i = 0; i <= n - m; i++) {
            if (text.substring(i, i + m).equals(pattern)) {
                return i;
            }
        }
        return -1;
    }
    
    private static int rabinKarpSearch(String text, String pattern) {
        // Implementation from Part 1
        int BASE = 31, MOD = 1_000_000_007;
        int n = text.length(), m = pattern.length();
        
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long patHash = 0, txtHash = 0;
        for (int i = 0; i < m; i++) {
            patHash = (patHash * BASE + pattern.charAt(i)) % MOD;
            txtHash = (txtHash * BASE + text.charAt(i)) % MOD;
        }
        
        for (int i = 0; i <= n - m; i++) {
            if (patHash == txtHash) {
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                if (match) return i;
            }
            
            if (i < n - m) {
                txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                if (txtHash < 0) txtHash += MOD;
            }
        }
        return -1;
    }
    
    private static int kmpSearch(String text, String pattern) {
        // Basic KMP implementation
        int[] lps = computeLPS(pattern);
        int n = text.length(), m = pattern.length();
        int i = 0, j = 0;
        
        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }
            
            if (j == m) return i - j;
            else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) j = lps[j - 1];
                else i++;
            }
        }
        return -1;
    }
    
    private static int[] computeLPS(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0, i = 1;
        
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) len = lps[len - 1];
                else { lps[i] = 0; i++; }
            }
        }
        return lps;
    }
}
```

### Expected Results

```
Text length: 1000000
Pattern length: 100

Naive: 15.234 ms (avg)
Rabin-Karp: 2.456 ms (avg)
KMP: 1.987 ms (avg)
Java indexOf: 0.123 ms (avg)
```

**Analysis**:
- **Java indexOf**: Highly optimized native implementation (fastest)
- **KMP**: Guaranteed O(n+m), no hash collisions
- **Rabin-Karp**: Good average case, simple implementation
- **Naive**: Poor performance on large inputs

---

## Interview Questions & Answers

### Q1: What is the time complexity of Rabin-Karp?

**A**: 
- **Average case**: O(n + m) where n = text length, m = pattern length
- **Worst case**: O(n Ã— m) when many hash collisions occur
- **Best case**: O(n + m) with good hash function and no spurious hits

The average case assumes uniform hash distribution.

### Q2: Why use Rabin-Karp over KMP?

**A**: Rabin-Karp advantages:
1. **Simpler implementation** - no LPS array computation
2. **Multiple pattern search** - hash all patterns, single text scan
3. **Natural extension to 2D** - works well for image/grid patterns
4. **Good average performance** - O(n+m) in practice

KMP advantages:
1. **Guaranteed O(n+m)** - no worst-case degradation
2. **No hash collisions** - deterministic matching
3. **Better for very long patterns** - collision probability increases with length

### Q3: How do you handle negative hash values?

**A**: Three approaches:

```java
// 1. Post-adjustment (recommended)
hash = (BASE * (hash - char * h) + newChar) % MOD;
if (hash < 0) hash += MOD;

// 2. Add MOD before modulo
hash = (BASE * (hash - char * h % MOD + MOD) + newChar) % MOD;

// 3. Use unsigned long (if available)
// In Java, manually ensure positive:
hash = ((hash % MOD) + MOD) % MOD;
```

Method 1 is clearest and most efficient.

### Q4: What happens if BASE and MOD are poorly chosen?

**A**: Poor choices lead to:

**Too small BASE (e.g., 2)**:
- Many collisions
- Poor hash distribution
- Worst case O(nÃ—m) more likely

**Too small MOD (e.g., 100)**:
- High collision probability: 1/100
- Frequent spurious hits
- More character-by-character verifications

**Good choices**:
- BASE: 26-256 (alphabet size or larger prime like 31)
- MOD: Large prime like 10^9+7

### Q5: Can Rabin-Karp find all overlapping occurrences?

**A**: Yes, unlike some algorithms, RK naturally finds overlapping matches:

```java
String text = "AAAA";
String pattern = "AAA";
// Finds at indices: [0, 1] (overlapping)

for (int i = 0; i <= n - m; i++) {
    if (match at i) {
        result.add(i);
        // Continue to i+1 (not i+m)
    }
}
```

### Q6: How does double hashing improve Rabin-Karp?

**A**: Two independent hash functions reduce collision probability:

**Single hash**:
- P(collision) â‰ˆ 1/MOD â‰ˆ 10^-9

**Double hash**:
- P(collision) â‰ˆ 1/(MOD1 Ã— MOD2) â‰ˆ 10^-18

This is so low you can skip character verification:

```java
if (hash1_pat == hash1_txt && hash2_pat == hash2_txt) {
    return i; // No verification needed
}
```

### Q7: When would Rabin-Karp perform poorly?

**A**: Worst-case scenarios:

1. **Many spurious hits**: Pattern = "AAA", Text = "AAAA...A"
2. **Poor hash function**: All substrings hash to same value
3. **Very long patterns**: Higher collision probability
4. **Small alphabet with long pattern**: More repeated structures

**Mitigation**:
- Use larger MOD
- Double hashing
- Verify matches quickly

### Q8: How do you adapt RK for case-insensitive search?

**A**: Convert both to lowercase:

```java
public int searchIgnoreCase(String text, String pattern) {
    return search(text.toLowerCase(), pattern.toLowerCase());
}
```

Or hash with case-insensitive encoding:

```java
private long hash(String s) {
    long h = 0;
    for (char c : s.toCharArray()) {
        h = (h * BASE + Character.toLowerCase(c)) % MOD;
    }
    return h;
}
```

### Q9: Can Rabin-Karp be parallelized?

**A**: Yes, divide text into chunks:

```java
public List<Integer> parallelSearch(String text, String pattern) {
    int chunks = Runtime.getRuntime().availableProcessors();
    int chunkSize = text.length() / chunks;
    
    return IntStream.range(0, chunks)
        .parallel()
        .mapToObj(i -> {
            int start = i * chunkSize;
            int end = (i == chunks - 1) ? text.length() : (i + 1) * chunkSize + pattern.length() - 1;
            return searchInRange(text, pattern, start, end);
        })
        .flatMap(List::stream)
        .collect(Collectors.toList());
}
```

**Note**: Overlap chunks by (pattern.length - 1) to catch boundary matches.

### Q10: What is the space complexity?

**A**: 
- **Basic**: O(1) - only store hash values
- **With precomputed powers**: O(m) - array of size m
- **With cached hashes**: O(n) - store hash for each position
- **Multiple patterns**: O(p) - hash set of p patterns

### Q11: How do you search for patterns of different lengths?

**A**: Group by length and process separately:

```java
// Group patterns: {3: ["abc", "def"], 4: ["abcd", "wxyz"]}
Map<Integer, List<String>> byLength = groupByLength(patterns);

for (int len : byLength.keySet()) {
    // Compute h for this length
    long h = modPow(BASE, len - 1, MOD);
    
    // Search all patterns of this length in one pass
    searchForLength(text, byLength.get(len), len, h);
}
```

### Q12: What's the difference between Rabin-Karp and rolling hash?

**A**: 
- **Rolling hash**: Technique for updating hash in O(1)
- **Rabin-Karp**: Algorithm that uses rolling hash for pattern matching

Rolling hash is a general technique used in many algorithms (Rabin-Karp, finding duplicates, substring problems).

### Q13: How do you implement RK for DNA sequences optimally?

**A**: Use base-4 encoding (2 bits per character):

```java
// DNA: A=0, C=1, G=2, T=3
int[] encoding = {0, 1, 2, 3};

// Hash using bit operations
int hash = 0;
for (char c : dna.toCharArray()) {
    hash = (hash << 2) | encoding[c - 'A'];
}

// Roll hash
hash = ((hash << 2) | encoding[newChar - 'A']) & MASK;
```

This is faster than modular arithmetic for fixed alphabets.

### Q14: Can you find the longest repeated substring using RK?

**A**: Yes, binary search + RK:

```java
public String longestRepeated(String s) {
    int left = 1, right = s.length();
    String result = "";
    
    while (left <= right) {
        int mid = (left + right) / 2;
        String dup = findDuplicate(s, mid);
        
        if (dup != null) {
            result = dup;
            left = mid + 1; // Try longer
        } else {
            right = mid - 1; // Try shorter
        }
    }
    
    return result;
}
```

Time: O(n log n)

### Q15: What are common mistakes with Rabin-Karp?

**A**: 

1. **Forgetting to verify matches**
```java
// WRONG
if (patHash == txtHash) return i;

// RIGHT
if (patHash == txtHash && verify(text, i, pattern)) return i;
```

2. **Integer overflow**
```java
// WRONG (can overflow)
int hash = hash * BASE + c;

// RIGHT
long hash = (hash * BASE + c) % MOD;
```

3. **Incorrect rolling hash**
```java
// WRONG (missing modulo)
hash = BASE * (hash - oldChar * h) + newChar;

// RIGHT
hash = (BASE * (hash - oldChar * h % MOD + MOD) % MOD + newChar) % MOD;
```

4. **Not handling negative modulo**

### Q16: How does alphabet size affect Rabin-Karp performance?

**A**: Alphabet size impacts collision probability:

**Small alphabet (DNA: 4 letters)**:
- More repeated patterns
- Higher collision probability
- Solution: Use smaller BASE (4) with bit operations

```java
// DNA: A=0, C=1, G=2, T=3
int hash = 0;
for (char c : dna.toCharArray()) {
    hash = (hash << 2) | encoding[c - 'A']; // Multiply by 4
}
```

**Large alphabet (Unicode: 65,536 characters)**:
- Fewer collisions
- Need larger BASE and MOD
- Solution: Use BASE = 256 or higher

**Optimal strategy**: Choose BASE â‰ˆ alphabet size

### Q17: Can you use Rabin-Karp to find longest common prefix?

**A**: Not directly efficient, but can combine with binary search:

```java
public int longestCommonPrefix(String s1, String s2) {
    int left = 0, right = Math.min(s1.length(), s2.length());
    int result = 0;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        
        // Check if prefixes of length mid match
        if (hashPrefix(s1, mid) == hashPrefix(s2, mid) &&
            s1.substring(0, mid).equals(s2.substring(0, mid))) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**Better approach**: Direct character comparison O(n)

### Q18: How do you modify RK for circular string matching?

**A**: Duplicate the text to simulate circular:

```java
public int searchCircular(String text, String pattern) {
    // Search pattern in text+text
    String doubled = text + text;
    int result = search(doubled, pattern);
    
    // If found and within bounds
    if (result != -1 && result < text.length()) {
        return result;
    }
    
    return -1;
}

// Example:
// text = "ABCDE", pattern = "DEA"
// doubled = "ABCDEABCDE"
// pattern found at index 3 â†’ valid circular match
```

**Optimization**: Don't actually concatenate, use modulo indexing:

```java
public int searchCircularOptimized(String text, String pattern) {
    int n = text.length();
    int m = pattern.length();
    
    if (m > n) return -1;
    
    long patHash = computeHash(pattern);
    long txtHash = 0;
    
    // Compute initial hash (may wrap around)
    for (int i = 0; i < m; i++) {
        txtHash = (txtHash * BASE + text.charAt(i % n)) % MOD;
    }
    
    for (int i = 0; i < n; i++) {
        if (patHash == txtHash && matchesCircular(text, i, pattern)) {
            return i;
        }
        
        // Roll hash with circular indexing
        txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt((i + m) % n)) % MOD;
        if (txtHash < 0) txtHash += MOD;
    }
    
    return -1;
}
```

### Q19: What's the relationship between Rabin-Karp and Rabin fingerprinting?

**A**: 

**Rabin Fingerprinting**: General technique by Michael Rabin for creating compact "fingerprints" (hashes) of data blocks.

**Rabin-Karp**: Specific application of Rabin fingerprinting to string matching, developed by Rabin and Karp.

**Key concepts**:
1. Both use polynomial rolling hash
2. Both rely on hash collision being rare
3. Rabin-Karp adds pattern matching logic

**Other uses of Rabin fingerprinting**:
- File deduplication
- Rsync protocol
- Network packet matching
- Data chunking in backup systems

### Q20: How would you implement fuzzy matching with Rabin-Karp?

**A**: Allow k mismatches using Hamming distance:

```java
public List<Integer> fuzzySearch(String text, String pattern, int k) {
    List<Integer> result = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    // Cannot use exact hash matching
    // Must check each window
    for (int i = 0; i <= n - m; i++) {
        int mismatches = 0;
        
        for (int j = 0; j < m; j++) {
            if (text.charAt(i + j) != pattern.charAt(j)) {
                mismatches++;
                if (mismatches > k) break;
            }
        }
        
        if (mismatches <= k) {
            result.add(i);
        }
    }
    
    return result;
}
```

**Advanced**: Use position-aware hashing:

```java
// Hash only positions where characters must match exactly
// For k=1 mismatch, try each position as wildcard
public List<Integer> fuzzySearchOptimized(String text, String pattern, int k) {
    List<Integer> result = new HashSet<>();
    
    if (k == 0) {
        // Exact match - use standard RK
        return Arrays.asList(search(text, pattern));
    }
    
    // For k=1, try pattern with each position as wildcard
    for (int skip = 0; skip < pattern.length(); skip++) {
        String patternPart1 = pattern.substring(0, skip);
        String patternPart2 = pattern.substring(skip + 1);
        
        // Search for pattern with position 'skip' as wildcard
        // This is complex - simpler to use brute force for fuzzy matching
    }
    
    return new ArrayList<>(result);
}
```

**Note**: For fuzzy matching, specialized algorithms (Levenshtein automata) are more efficient than RK.

---

## Practice Problems

### Problem 1: Implement strStr() (LeetCode 28)

**Description**: Find the first occurrence of needle in haystack.

```java
public class Solution {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        
        int n = haystack.length();
        int m = needle.length();
        if (m > n) return -1;
        
        // Compute h = BASE^(m-1) % MOD
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute hashes
        long needleHash = 0, hayHash = 0;
        for (int i = 0; i < m; i++) {
            needleHash = (needleHash * BASE + needle.charAt(i)) % MOD;
            hayHash = (hayHash * BASE + haystack.charAt(i)) % MOD;
        }
        
        // Search
        for (int i = 0; i <= n - m; i++) {
            if (needleHash == hayHash) {
                if (matches(haystack, i, needle)) {
                    return i;
                }
            }
            
            if (i < n - m) {
                hayHash = (BASE * (hayHash - haystack.charAt(i) * h) + haystack.charAt(i + m)) % MOD;
                if (hayHash < 0) hayHash += MOD;
            }
        }
        
        return -1;
    }
    
    private boolean matches(String text, int start, String pattern) {
        for (int i = 0; i < pattern.length(); i++) {
            if (text.charAt(start + i) != pattern.charAt(i)) {
                return false;
            }
        }
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.strStr("hello", "ll")); // 2
        System.out.println(sol.strStr("aaaaa", "bba")); // -1
        System.out.println(sol.strStr("", "")); // 0
    }
}
```

**Complexity**: O(n + m) average, O(n Ã— m) worst

---

### Problem 2: Longest Duplicate Substring (LeetCode 1044)

**Description**: Find the longest substring that appears at least twice.

```java
public class LongestDuplicateSubstring {
    private static final int BASE = 26;
    private static final long MOD = (1L << 31) - 1;
    
    public String longestDupSubstring(String s) {
        int left = 1, right = s.length();
        String result = "";
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            String dup = search(s, mid);
            
            if (dup != null) {
                result = dup;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    private String search(String s, int len) {
        Map<Long, List<Integer>> seen = new HashMap<>();
        
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + (s.charAt(i) - 'a')) % MOD;
        }
        
        seen.computeIfAbsent(hash, k -> new ArrayList<>()).add(0);
        
        for (int i = 1; i <= s.length() - len; i++) {
            hash = (hash - (s.charAt(i - 1) - 'a') * h % MOD + MOD) % MOD;
            hash = (hash * BASE + (s.charAt(i + len - 1) - 'a')) % MOD;
            
            if (seen.containsKey(hash)) {
                String current = s.substring(i, i + len);
                for (int prev : seen.get(hash)) {
                    if (s.substring(prev, prev + len).equals(current)) {
                        return current;
                    }
                }
            }
            
            seen.computeIfAbsent(hash, k -> new ArrayList<>()).add(i);
        }
        
        return null;
    }
}
```

**Complexity**: O(n log n)

---

### Problem 3: Repeated DNA Sequences (LeetCode 187)

**Description**: Find all 10-letter sequences that occur more than once.

```java
public class RepeatedDNA {
    public List<String> findRepeatedDnaSequences(String s) {
        Set<String> result = new HashSet<>();
        Set<Integer> seen = new HashSet<>();
        
        if (s.length() < 10) return new ArrayList<>();
        
        int[] map = new int[26];
        map['A' - 'A'] = 0;
        map['C' - 'A'] = 1;
        map['G' - 'A'] = 2;
        map['T' - 'A'] = 3;
        
        int hash = 0;
        for (int i = 0; i < 10; i++) {
            hash = (hash << 2) | map[s.charAt(i) - 'A'];
        }
        seen.add(hash);
        
        int mask = (1 << 20) - 1;
        
        for (int i = 10; i < s.length(); i++) {
            hash = ((hash << 2) | map[s.charAt(i) - 'A']) & mask;
            
            if (seen.contains(hash)) {
                result.add(s.substring(i - 9, i + 1));
            }
            seen.add(hash);
        }
        
        return new ArrayList<>(result);
    }
}
```

**Complexity**: O(n)

---

### Problem 4: Find All Anagrams in String (LeetCode 438)

**Description**: Find all start indices of pattern's anagrams in string.

```java
public class FindAnagrams {
    
    // Solution 1: Frequency-based (not pure RK, but related)
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (s.length() < p.length()) return result;
        
        int[] pCount = new int[26];
        int[] sCount = new int[26];
        
        // Count pattern characters
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        for (int i = 0; i < s.length(); i++) {
            // Add current character
            sCount[s.charAt(i) - 'a']++;
            
            // Remove character outside window
            if (i >= p.length()) {
                sCount[s.charAt(i - p.length()) - 'a']--;
            }
            
            // Check if anagram
            if (i >= p.length() - 1 && Arrays.equals(pCount, sCount)) {
                result.add(i - p.length() + 1);
            }
        }
        
        return result;
    }
    
    // Solution 2: Using hash (order-independent)
    public List<Integer> findAnagramsHash(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (s.length() < p.length()) return result;
        
        // Compute canonical hash (sorted characters)
        long patternHash = computeCanonicalHash(p);
        
        int n = s.length();
        int m = p.length();
        
        for (int i = 0; i <= n - m; i++) {
            String window = s.substring(i, i + m);
            
            if (computeCanonicalHash(window) == patternHash) {
                // Verify it's actually an anagram
                if (isAnagram(window, p)) {
                    result.add(i);
                }
            }
        }
        
        return result;
    }
    
    private long computeCanonicalHash(String s) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        
        long hash = 0;
        int BASE = 31;
        long MOD = 1_000_000_007;
        
        for (char c : chars) {
            hash = (hash * BASE + c) % MOD;
        }
        
        return hash;
    }
    
    private boolean isAnagram(String s1, String s2) {
        if (s1.length() != s2.length()) return false;
        
        int[] count = new int[26];
        
        for (int i = 0; i < s1.length(); i++) {
            count[s1.charAt(i) - 'a']++;
            count[s2.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        FindAnagrams fa = new FindAnagrams();
        
        System.out.println(fa.findAnagrams("cbaebabacd", "abc"));
        // Output: [0, 6] (cba at 0, bac at 6)
        
        System.out.println(fa.findAnagrams("abab", "ab"));
        // Output: [0, 1, 2] (ab at 0, ba at 1, ab at 2)
    }
}
```

**Complexity**: 
- Solution 1: O(n) with O(26) = O(1) space
- Solution 2: O(n Ã— m log m) for sorting

---

### Problem 5: Shortest Unique Substring (Custom)

**Description**: Find the shortest substring that appears exactly once in the text.

```java
public class ShortestUniqueSubstring {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    public String shortestUnique(String s) {
        int n = s.length();
        
        // Try lengths from 1 to n
        for (int len = 1; len <= n; len++) {
            String unique = findUniqueOfLength(s, len);
            if (unique != null) {
                return unique;
            }
        }
        
        return ""; // All substrings repeat (shouldn't happen)
    }
    
    private String findUniqueOfLength(String s, int len) {
        Map<Long, List<Integer>> hashMap = new HashMap<>();
        
        // Compute h = BASE^(len-1)
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute hash of first window
        long hash = 0;
        for (int i = 0; i < len; i++) {
            hash = (hash * BASE + s.charAt(i)) % MOD;
        }
        
        hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(0);
        
        // Roll through string
        for (int i = 1; i <= s.length() - len; i++) {
            hash = (hash - s.charAt(i - 1) * h % MOD + MOD) % MOD;
            hash = (hash * BASE + s.charAt(i + len - 1)) % MOD;
            
            hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(i);
        }
        
        // Find hash that appears exactly once
        for (Map.Entry<Long, List<Integer>> entry : hashMap.entrySet()) {
            if (entry.getValue().size() == 1) {
                int start = entry.getValue().get(0);
                String candidate = s.substring(start, start + len);
                
                // Verify uniqueness (check for collisions)
                if (countOccurrences(s, candidate) == 1) {
                    return candidate;
                }
            }
        }
        
        return null;
    }
    
    private int countOccurrences(String text, String pattern) {
        int count = 0;
        int index = 0;
        
        while ((index = text.indexOf(pattern, index)) != -1) {
            count++;
            index++;
        }
        
        return count;
    }
    
    // Optimized version: Find ALL unique substrings of given length
    public List<String> allUniqueOfLength(String s, int len) {
        List<String> result = new ArrayList<>();
        Map<String, Integer> count = new HashMap<>();
        
        // Count all substrings
        for (int i = 0; i <= s.length() - len; i++) {
            String sub = s.substring(i, i + len);
            count.put(sub, count.getOrDefault(sub, 0) + 1);
        }
        
        // Filter unique ones
        for (Map.Entry<String, Integer> entry : count.entrySet()) {
            if (entry.getValue() == 1) {
                result.add(entry.getKey());
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        ShortestUniqueSubstring sus = new ShortestUniqueSubstring();
        
        System.out.println(sus.shortestUnique("abcabc"));
        // Output: Could be "ab" or "bc" or "ca" (first unique found)
        // Actually, all 2-char substrings repeat, try length 3
        // "abc" appears twice, "bca" appears once, "cab" appears once
        // Returns first unique of smallest length
        
        System.out.println(sus.shortestUnique("aabbcc"));
        // Output: "ab" or "bb" or "bc" or "cc" (unique 2-char)
        
        System.out.println(sus.allUniqueOfLength("abcabc", 3));
        // Output: [bca, cab]
        
        System.out.println(sus.allUniqueOfLength("aabbcc", 2));
        // Output: [ab, bb, bc, cc]
    }
}
```

**Complexity**: O(nÂ² Ã— L) where L = average length of unique substring

---

### Bonus Problem: Multiple Pattern Search

**Description**: Given text and multiple patterns, find all occurrences of all patterns.

```java
import java.util.*;

public class MultiplePatternSearch {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    public Map<String, List<Integer>> searchMultiple(String text, List<String> patterns) {
        Map<String, List<Integer>> result = new HashMap<>();
        
        // Initialize result map
        for (String p : patterns) {
            result.put(p, new ArrayList<>());
        }
        
        // Group patterns by length
        Map<Integer, List<String>> byLength = new HashMap<>();
        for (String p : patterns) {
            byLength.computeIfAbsent(p.length(), k -> new ArrayList<>()).add(p);
        }
        
        // Process each length group
        for (Map.Entry<Integer, List<String>> entry : byLength.entrySet()) {
            int len = entry.getKey();
            List<String> pats = entry.getValue();
            
            searchForLength(text, pats, len, result);
        }
        
        return result;
    }
    
    private void searchForLength(String text, List<String> patterns, int len, 
                                 Map<String, List<Integer>> result) {
        int n = text.length();
        if (len > n) return;
        
        // Create hash map for patterns
        Map<Long, List<String>> patternHashes = new HashMap<>();
        for (String p : patterns) {
            long hash = computeHash(p);
            patternHashes.computeIfAbsent(hash, k -> new ArrayList<>()).add(p);
        }
        
        // Compute h = BASE^(len-1)
        long h = 1;
        for (int i = 0; i < len - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Slide window through text
        long txtHash = computeHash(text.substring(0, len));
        
        for (int i = 0; i <= n - len; i++) {
            if (patternHashes.containsKey(txtHash)) {
                String window = text.substring(i, i + len);
                
                for (String pattern : patternHashes.get(txtHash)) {
                    if (window.equals(pattern)) {
                        result.get(pattern).add(i);
                    }
                }
            }
            
            if (i < n - len) {
                txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + len)) % MOD;
                if (txtHash < 0) txtHash += MOD;
            }
        }
    }
    
    private long computeHash(String s) {
        long hash = 0;
        for (char c : s.toCharArray()) {
            hash = (hash * BASE + c) % MOD;
        }
        return hash;
    }
    
    // Test
    public static void main(String[] args) {
        MultiplePatternSearch mps = new MultiplePatternSearch();
        
        String text = "abcabcabcabc";
        List<String> patterns = Arrays.asList("abc", "bca", "cab", "xyz");
        
        Map<String, List<Integer>> results = mps.searchMultiple(text, patterns);
        
        for (Map.Entry<String, List<Integer>> entry : results.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Output:
        // abc: [0, 3, 6, 9]
        // bca: [1, 4, 7]
        // cab: [2, 5, 8]
        // xyz: []
    }
}
```

**Complexity**: O(n Ã— L + p Ã— m) where:
- n = text length
- L = number of distinct pattern lengths
- p = number of patterns
- m = average pattern length

---

## Cheat Sheet

### Quick Reference

```java
// TEMPLATE: Basic Rabin-Karp
public int search(String text, String pattern) {
    int n = text.length(), m = pattern.length();
    if (m > n) return -1;
    
    int BASE = 31, MOD = 1_000_000_007;
    
    // 1. Compute h = BASE^(m-1) % MOD
    long h = 1;
    for (int i = 0; i < m - 1; i++) h = (h * BASE) % MOD;
    
    // 2. Compute hashes
    long patHash = 0, txtHash = 0;
    for (int i = 0; i < m; i++) {
        patHash = (patHash * BASE + pattern.charAt(i)) % MOD;
        txtHash = (txtHash * BASE + text.charAt(i)) % MOD;
    }
    
    // 3. Slide window
    for (int i = 0; i <= n - m; i++) {
        if (patHash == txtHash && verify(text, i, pattern)) return i;
        
        if (i < n - m) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
    return -1;
}
```

### Key Formulas

```
Initial Hash:
  hash = (s[0]Ã—d^(m-1) + s[1]Ã—d^(m-2) + ... + s[m-1]) % q

Rolling Hash:
  hash = (d Ã— (hash - s[i] Ã— d^(m-1)) + s[i+m]) % q

Handle Negative:
  if (hash < 0) hash += MOD;
```

### Common Parameters

```java
// Good choices
int BASE = 31;              // For general strings
int BASE = 256;             // For ASCII
int BASE = 4;               // For DNA (A,C,G,T)
long MOD = 1_000_000_007;   // Large prime
long MOD = (1L << 31) - 1;  // Mersenne prime
```

### Decision Tree

```
Need to search pattern?
â”œâ”€ Single pattern, one-time search
â”‚  â””â”€ Use basic Rabin-Karp: O(n+m) avg, O(1) space
â”œâ”€ Multiple patterns, same length
â”‚  â””â”€ Hash all patterns: O(n + pÃ—m) where p = #patterns
â”œâ”€ Multiple patterns, different lengths
â”‚  â””â”€ Group by length: O(nÃ—L) where L = #distinct lengths
â”œâ”€ Many searches on same text
â”‚  â””â”€ Cache all hashes: O(nÃ—maxLen) space, O(m) per search
â””â”€ Need guaranteed O(n+m)
   â””â”€ Use KMP instead
```

---

## Summary

**Rabin-Karp Algorithm** is a powerful string matching technique using rolling hash.

### âœ… Strengths:
- Simple to implement
- Excellent for multiple pattern search
- Natural extension to 2D patterns
- Good average-case performance O(n+m)

### âŒ Weaknesses:
- Worst case O(nÃ—m) with many collisions
- Requires good hash function design
- Need to verify matches (spurious hits)

### ðŸŽ¯ Use When:
- Searching multiple patterns
- 2D pattern matching
- Plagiarism detection
- Average case is acceptable

### ðŸš« Avoid When:
- Need guaranteed O(n+m) â†’ use KMP
- Very long patterns â†’ higher collision risk
- Memory is unlimited â†’ preprocessing may be better

---

**Previous**: [4.7-Rabin-Karp-Algorithm-Part2.md](4.7-Rabin-Karp-Algorithm-Part2.md)
