# 4.6 Rabin-Karp Algorithm - Part 1: Fundamentals

## Table of Contents
1. [Introduction](#introduction)
2. [Why Rabin-Karp?](#why-rabin-karp)
3. [Core Concept: Rolling Hash](#core-concept-rolling-hash)
4. [Hash Function Design](#hash-function-design)
5. [Basic Implementation](#basic-implementation)
6. [Step-by-Step Examples](#step-by-step-examples)
7. [Rolling Hash in Detail](#rolling-hash-in-detail)
8. [Handling Hash Collisions](#handling-hash-collisions)
9. [Common Patterns](#common-patterns)

---

## Introduction

**Rabin-Karp** is a string pattern matching algorithm that uses **hashing** to find patterns in text efficiently.

### Key Features
- **Average Time Complexity**: O(n + m) where n = text length, m = pattern length
- **Worst Case**: O(n × m) due to hash collisions
- **Space Complexity**: O(1)
- **Best Use Cases**: Multiple pattern search, plagiarism detection, substring search

### Algorithm Overview
```
1. Compute hash of pattern (length m)
2. Compute hash of first m characters of text
3. Slide window through text:
   - If hashes match → verify character by character
   - Update hash using rolling hash formula
   - Move to next position
```

### Rabin-Karp vs Other Algorithms

| Algorithm | Time Complexity | Space | Best For |
|-----------|----------------|-------|----------|
| **Naive** | O(n × m) | O(1) | Simple searches |
| **KMP** | O(n + m) | O(m) | Guaranteed linear time |
| **Rabin-Karp** | O(n + m) avg | O(1) | Multiple patterns, simple implementation |
| **Boyer-Moore** | O(n/m) best | O(m) | Large alphabets |

---

## Why Rabin-Karp?

### Advantages

1. **Simple Implementation**
```java
// Rabin-Karp is conceptually simpler than KMP
// No need for LPS array or complex preprocessing
int patternHash = computeHash(pattern);
int windowHash = computeHash(text.substring(0, m));

for (int i = 0; i <= n - m; i++) {
    if (patternHash == windowHash) {
        if (text.substring(i, i + m).equals(pattern)) {
            return i; // Match found
        }
    }
    // Roll hash for next window
    if (i < n - m) {
        windowHash = rollHash(windowHash, text, i, m);
    }
}
```

2. **Excellent for Multiple Pattern Search**
```java
// Search for multiple patterns simultaneously
Set<Integer> patternHashes = new HashSet<>();
for (String pattern : patterns) {
    patternHashes.add(computeHash(pattern));
}

// Single pass through text
int windowHash = computeHash(text.substring(0, m));
for (int i = 0; i <= n - m; i++) {
    if (patternHashes.contains(windowHash)) {
        // Check which pattern(s) matched
        verifyMatches(text, i, patterns);
    }
    windowHash = rollHash(windowHash, text, i, m);
}
```

3. **Natural for 2D Pattern Matching**
```java
// Can extend to search patterns in 2D grids
// Example: Finding image in larger image
// Each row → 1D hash, then hash of row hashes
```

### When to Use Rabin-Karp

✅ **Use When:**
- Searching for multiple patterns in same text
- Average case performance is acceptable
- Simple implementation is prioritized
- Need to find all occurrences quickly
- Working with plagiarism detection systems

❌ **Avoid When:**
- Guaranteed O(n + m) is required (use KMP)
- Pattern changes frequently (preprocessing overhead)
- Working with very long patterns (hash collisions increase)

---

## Core Concept: Rolling Hash

The **rolling hash** is the heart of Rabin-Karp algorithm.

### What is Rolling Hash?

**Definition**: A hash function that can be efficiently updated when sliding a window through a sequence.

### Example: Understanding Rolling Hash

```
Text:    "ABCDEFGH"
Pattern: "CDE" (length = 3)

Window 1: "ABC" → hash1
Window 2: "BCD" → hash2
Window 3: "CDE" → hash3
Window 4: "DEF" → hash4
```

**Naive Approach**: Compute each hash from scratch
```java
hash1 = hash("ABC") // O(m)
hash2 = hash("BCD") // O(m)
hash3 = hash("CDE") // O(m)
// Total: O(n × m)
```

**Rolling Hash Approach**: Update hash incrementally
```java
hash1 = hash("ABC")           // O(m) - initial
hash2 = rollHash(hash1, ...)  // O(1) - remove 'A', add 'D'
hash3 = rollHash(hash2, ...)  // O(1) - remove 'B', add 'E'
// Total: O(n)
```

### Rolling Hash Formula

For a string s = "s₀s₁s₂...sₘ₋₁" with base d:

**Initial Hash**:
```
hash = (s₀ × d^(m-1) + s₁ × d^(m-2) + ... + sₘ₋₁ × d^0) % q
```

**Rolling Update** (remove s[i], add s[i+m]):
```
hash = ((hash - s[i] × d^(m-1)) × d + s[i+m]) % q
```

### Visual Example

```
Text: "12345"
Pattern length m = 3
Base d = 10
Prime q = 101

Window 1: "123"
hash = (1×10² + 2×10¹ + 3×10⁰) % 101
     = (100 + 20 + 3) % 101
     = 123 % 101
     = 22

Window 2: "234" (remove '1', add '4')
hash = ((22 - 1×10²) × 10 + 4) % 101
     = ((22 - 100) × 10 + 4) % 101
     = (-78 × 10 + 4) % 101
     = (-780 + 4) % 101
     = -776 % 101
     = 22  (after modulo adjustment)

Actual: (2×10² + 3×10¹ + 4×10⁰) % 101 = 234 % 101 = 32
```

**Note**: Need to handle negative values in modulo arithmetic!

---

## Hash Function Design

### Requirements for Good Hash Function

1. **Uniform Distribution**: Minimize collisions
2. **Efficient Computation**: O(1) rolling update
3. **Large Hash Space**: Reduce collision probability
4. **Modulo Arithmetic**: Prevent integer overflow

### Polynomial Hash Function

**Standard Approach**:
```java
public class PolynomialHash {
    private static final int BASE = 256;  // For ASCII characters
    private static final int MOD = 1_000_000_007; // Large prime
    
    public static long computeHash(String s) {
        long hash = 0;
        long pow = 1;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            hash = (hash + (s.charAt(i) * pow) % MOD) % MOD;
            pow = (pow * BASE) % MOD;
        }
        
        return hash;
    }
}
```

### Choosing Base and Modulus

**Base Selection**:
```java
// Option 1: Alphabet size
int BASE = 26;  // For lowercase letters only
int BASE = 52;  // For upper + lowercase
int BASE = 256; // For all ASCII characters

// Option 2: Small prime
int BASE = 31;  // Java's String.hashCode() uses 31
int BASE = 37;
```

**Modulus Selection**:
```java
// Option 1: Large prime (recommended)
int MOD = 1_000_000_007; // 10^9 + 7 (common in competitive programming)
int MOD = 1_000_000_009; // 10^9 + 9
int MOD = 2_147_483_647; // 2^31 - 1 (Mersenne prime)

// Option 2: Power of 2 (faster but more collisions)
long MOD = (1L << 61) - 1; // 2^61 - 1
```

### Example: Different Hash Functions

```java
public class HashFunctions {
    
    // 1. Simple ASCII sum (BAD - many collisions)
    public static int simpleHash(String s) {
        int hash = 0;
        for (char c : s.toCharArray()) {
            hash += c;
        }
        return hash;
        // Problem: "abc" and "bac" have same hash!
    }
    
    // 2. Position-weighted (BETTER)
    public static int positionHash(String s) {
        int hash = 0;
        for (int i = 0; i < s.length(); i++) {
            hash += s.charAt(i) * (i + 1);
        }
        return hash;
        // Better, but still has collisions
    }
    
    // 3. Polynomial hash (BEST)
    public static long polynomialHash(String s, int base, int mod) {
        long hash = 0;
        long pow = 1;
        
        for (int i = s.length() - 1; i >= 0; i--) {
            hash = (hash + (s.charAt(i) * pow) % mod) % mod;
            pow = (pow * base) % mod;
        }
        
        return hash;
    }
    
    // 4. Rolling hash with precomputed powers (OPTIMAL)
    public static long rollingHash(String s, int base, int mod, long[] powers) {
        long hash = 0;
        
        for (int i = 0; i < s.length(); i++) {
            hash = (hash + (s.charAt(i) * powers[s.length() - 1 - i]) % mod) % mod;
        }
        
        return hash;
    }
}
```

### Precomputing Powers

```java
public class PowerPrecomputation {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    // Precompute base^0, base^1, base^2, ... base^maxLen
    public static long[] computePowers(int maxLen) {
        long[] powers = new long[maxLen];
        powers[0] = 1;
        
        for (int i = 1; i < maxLen; i++) {
            powers[i] = (powers[i - 1] * BASE) % MOD;
        }
        
        return powers;
    }
    
    // Example usage
    public static void main(String[] args) {
        long[] powers = computePowers(100);
        
        // base^5 = powers[5]
        System.out.println("31^5 mod 10^9+7 = " + powers[5]);
        // Output: 28629151
    }
}
```

---

## Basic Implementation

### Template 1: Find First Occurrence

```java
public class RabinKarp {
    private static final int BASE = 256;
    private static final int MOD = 1_000_000_007;
    
    public static int search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return -1;
        
        // Precompute BASE^(m-1) % MOD
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute hash of pattern and first window
        long patternHash = 0;
        long textHash = 0;
        
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash * BASE + pattern.charAt(i)) % MOD;
            textHash = (textHash * BASE + text.charAt(i)) % MOD;
        }
        
        // Slide window through text
        for (int i = 0; i <= n - m; i++) {
            // Check if hashes match
            if (patternHash == textHash) {
                // Verify actual characters (handle spurious hits)
                if (text.substring(i, i + m).equals(pattern)) {
                    return i; // Match found
                }
            }
            
            // Compute hash for next window
            if (i < n - m) {
                textHash = (BASE * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                
                // Handle negative hash
                if (textHash < 0) {
                    textHash += MOD;
                }
            }
        }
        
        return -1; // Not found
    }
    
    public static void main(String[] args) {
        String text = "ABCDEFGHIJKLMNOP";
        String pattern = "DEFG";
        
        int index = search(text, pattern);
        
        if (index != -1) {
            System.out.println("Pattern found at index: " + index);
        } else {
            System.out.println("Pattern not found");
        }
    }
}
```

**Output**:
```
Pattern found at index: 3
```

### Template 2: Find All Occurrences

```java
import java.util.*;

public class RabinKarpAllOccurrences {
    private static final int BASE = 31;
    private static final int MOD = 1_000_000_007;
    
    public static List<Integer> searchAll(String text, String pattern) {
        List<Integer> result = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return result;
        
        // Precompute BASE^(m-1) % MOD
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        
        // Compute hash of pattern and first window
        long patternHash = 0;
        long textHash = 0;
        
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash * BASE + pattern.charAt(i)) % MOD;
            textHash = (textHash * BASE + text.charAt(i)) % MOD;
        }
        
        // Slide window through text
        for (int i = 0; i <= n - m; i++) {
            // Check if hashes match
            if (patternHash == textHash) {
                // Verify actual characters
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    result.add(i);
                }
            }
            
            // Compute hash for next window
            if (i < n - m) {
                textHash = (BASE * (textHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
                
                if (textHash < 0) {
                    textHash += MOD;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        String text = "AABAACAADAABAABA";
        String pattern = "AABA";
        
        List<Integer> indices = searchAll(text, pattern);
        
        System.out.println("Pattern found at indices: " + indices);
    }
}
```

**Output**:
```
Pattern found at indices: [0, 9, 12]
```

### Template 3: With Helper Class

```java
public class RabinKarpHelper {
    private final int BASE;
    private final int MOD;
    
    public RabinKarpHelper(int base, int mod) {
        this.BASE = base;
        this.MOD = mod;
    }
    
    // Compute hash of string
    public long computeHash(String s) {
        long hash = 0;
        for (int i = 0; i < s.length(); i++) {
            hash = (hash * BASE + s.charAt(i)) % MOD;
        }
        return hash;
    }
    
    // Compute hash of string with given length
    public long computeHash(String s, int start, int len) {
        long hash = 0;
        for (int i = start; i < start + len; i++) {
            hash = (hash * BASE + s.charAt(i)) % MOD;
        }
        return hash;
    }
    
    // Roll hash: remove oldChar, add newChar
    public long rollHash(long oldHash, char oldChar, char newChar, long power) {
        long hash = (BASE * (oldHash - oldChar * power) + newChar) % MOD;
        if (hash < 0) hash += MOD;
        return hash;
    }
    
    // Compute BASE^exp % MOD
    public long power(int exp) {
        long result = 1;
        long base = BASE;
        
        while (exp > 0) {
            if (exp % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            exp /= 2;
        }
        
        return result;
    }
    
    // Search pattern in text
    public int search(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m > n) return -1;
        
        long h = power(m - 1);
        long patternHash = computeHash(pattern);
        long textHash = computeHash(text, 0, m);
        
        for (int i = 0; i <= n - m; i++) {
            if (patternHash == textHash) {
                if (text.substring(i, i + m).equals(pattern)) {
                    return i;
                }
            }
            
            if (i < n - m) {
                textHash = rollHash(textHash, text.charAt(i), text.charAt(i + m), h);
            }
        }
        
        return -1;
    }
}

// Usage
class Main {
    public static void main(String[] args) {
        RabinKarpHelper rk = new RabinKarpHelper(31, 1_000_000_007);
        
        String text = "Hello World";
        String pattern = "World";
        
        int index = rk.search(text, pattern);
        System.out.println("Pattern found at: " + index); // Output: 6
    }
}
```

---

## Step-by-Step Examples

### Example 1: Detailed Walkthrough

**Problem**: Find "DE" in "ABCDEFGH"

```
Text:    A B C D E F G H
Index:   0 1 2 3 4 5 6 7

Pattern: D E
Length m = 2
BASE = 10 (for simplicity)
MOD = 13
```

**Step 1: Compute Pattern Hash**
```
Pattern: "DE"
D = 68 (ASCII), E = 69

patternHash = (D × BASE¹ + E × BASE⁰) % MOD
            = (68 × 10 + 69 × 1) % 13
            = (680 + 69) % 13
            = 749 % 13
            = 8
```

**Step 2: Compute Initial Window Hash**
```
Window: "AB"
A = 65, B = 66

textHash = (65 × 10 + 66 × 1) % 13
         = (650 + 66) % 13
         = 716 % 13
         = 1
```

**Step 3: Precompute h = BASE^(m-1) % MOD**
```
h = 10^(2-1) % 13
  = 10^1 % 13
  = 10
```

**Step 4: Slide Window**

**Position i = 0**: Window "AB"
```
textHash = 1
patternHash = 8
1 ≠ 8 → No match

Roll hash (remove A, add C):
textHash = (10 × (1 - 65 × 10) + 67) % 13
         = (10 × (1 - 650) + 67) % 13
         = (10 × (-649) + 67) % 13
         = (-6490 + 67) % 13
         = -6423 % 13
         = 6  (after modulo adjustment: -6423 + 494×13 = 6)
```

**Position i = 1**: Window "BC"
```
textHash = 6
patternHash = 8
6 ≠ 8 → No match

Roll hash (remove B, add D):
textHash = (10 × (6 - 66 × 10) + 68) % 13
         = (10 × (6 - 660) + 68) % 13
         = (10 × (-654) + 68) % 13
         = (-6540 + 68) % 13
         = -6472 % 13
         = 11
```

**Position i = 2**: Window "CD"
```
textHash = 11
patternHash = 8
11 ≠ 8 → No match

Roll hash (remove C, add E):
textHash = (10 × (11 - 67 × 10) + 69) % 13
         = (10 × (11 - 670) + 69) % 13
         = (10 × (-659) + 69) % 13
         = (-6590 + 69) % 13
         = -6521 % 13
         = 8
```

**Position i = 3**: Window "DE"
```
textHash = 8
patternHash = 8
8 == 8 → Hash match!

Verify characters:
text[3] = 'D', pattern[0] = 'D' ✓
text[4] = 'E', pattern[1] = 'E' ✓

MATCH FOUND at index 3!
```

### Example 2: Hash Collision

**Problem**: Demonstrate spurious hit (false positive)

```
Text: "ABCXYZ"
Pattern: "XY"

BASE = 10
MOD = 13

Assume:
- Hash("AB") = 8
- Hash("XY") = 8  (collision!)
```

**What Happens**:
```
Position 0: Window "AB"
textHash = 8
patternHash = 8
8 == 8 → Hash match!

Verify characters:
text[0] = 'A', pattern[0] = 'X'
'A' ≠ 'X' → Spurious hit! Continue searching...

Position 4: Window "XY"
textHash = 8
patternHash = 8
8 == 8 → Hash match!

Verify characters:
text[4] = 'X', pattern[0] = 'X' ✓
text[5] = 'Y', pattern[1] = 'Y' ✓

REAL MATCH at index 4!
```

**Lesson**: Always verify character-by-character when hashes match!

### Example 3: Complete Execution Trace

```java
public class RabinKarpTrace {
    public static void main(String[] args) {
        String text = "AABAAB";
        String pattern = "AAB";
        int BASE = 26;
        int MOD = 101;
        
        int n = text.length();  // 6
        int m = pattern.length(); // 3
        
        // Compute h = BASE^(m-1) % MOD
        long h = 1;
        for (int i = 0; i < m - 1; i++) {
            h = (h * BASE) % MOD;
        }
        System.out.println("h = " + h); // 676 % 101 = 70
        
        // Compute pattern hash
        long patternHash = 0;
        for (int i = 0; i < m; i++) {
            patternHash = (patternHash * BASE + (pattern.charAt(i) - 'A')) % MOD;
        }
        System.out.println("Pattern hash: " + patternHash);
        // (0×26+0)×26+1 = 1
        
        // Compute first window hash
        long textHash = 0;
        for (int i = 0; i < m; i++) {
            textHash = (textHash * BASE + (text.charAt(i) - 'A')) % MOD;
        }
        System.out.println("Initial window hash: " + textHash);
        
        // Slide window
        for (int i = 0; i <= n - m; i++) {
            System.out.println("\nPosition " + i + ": " + text.substring(i, i + m));
            System.out.println("  Text hash: " + textHash);
            System.out.println("  Pattern hash: " + patternHash);
            
            if (patternHash == textHash) {
                boolean match = true;
                for (int j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j)) {
                        match = false;
                        break;
                    }
                }
                
                if (match) {
                    System.out.println("  ✓ MATCH!");
                } else {
                    System.out.println("  ✗ Spurious hit");
                }
            } else {
                System.out.println("  ✗ Hash mismatch");
            }
            
            // Roll hash
            if (i < n - m) {
                char oldChar = (char)(text.charAt(i) - 'A');
                char newChar = (char)(text.charAt(i + m) - 'A');
                
                textHash = (BASE * (textHash - oldChar * h) + newChar) % MOD;
                if (textHash < 0) textHash += MOD;
                
                System.out.println("  Rolled: removed '" + text.charAt(i) + 
                                   "', added '" + text.charAt(i + m) + "'");
            }
        }
    }
}
```

**Output**:
```
h = 70
Pattern hash: 1
Initial window hash: 1

Position 0: AAB
  Text hash: 1
  Pattern hash: 1
  ✓ MATCH!
  Rolled: removed 'A', added 'A'

Position 1: ABA
  Text hash: 27
  Pattern hash: 1
  ✗ Hash mismatch
  Rolled: removed 'A', added 'A'

Position 2: BAA
  Text hash: 26
  Pattern hash: 1
  ✗ Hash mismatch
  Rolled: removed 'B', added 'B'

Position 3: AAB
  Text hash: 1
  Pattern hash: 1
  ✓ MATCH!
```

---

## Rolling Hash in Detail

### Understanding the Rolling Hash Formula

**Initial Hash**: 
```
For window s[0..m-1]:
hash = (s[0]×d^(m-1) + s[1]×d^(m-2) + ... + s[m-1]×d^0) % q
```

**Rolling Update**:
```
For window s[i..i+m-1], next window is s[i+1..i+m]:

Step 1: Remove s[i]
   hash' = hash - s[i] × d^(m-1)

Step 2: Shift left (multiply by d)
   hash'' = hash' × d

Step 3: Add s[i+m]
   hash''' = hash'' + s[i+m]

Step 4: Apply modulo
   newHash = hash''' % q

Combined:
   newHash = (d × (hash - s[i] × d^(m-1)) + s[i+m]) % q
```

### Visual Representation

```
Window 1: [A][B][C]
          ↓  ↓  ↓
         d² d¹ d⁰
hash = A×d² + B×d¹ + C×d⁰

Roll to Window 2: [B][C][D]

Remove A:     hash - A×d²
Shift left:   (hash - A×d²) × d  = B×d² + C×d¹
Add D:        B×d² + C×d¹ + D×d⁰

New hash = B×d² + C×d¹ + D×d⁰ ✓
```

### Implementation Variants

**Variant 1: Left to Right Hash**
```java
// Build hash from left to right
public long hashLTR(String s, int base, int mod) {
    long hash = 0;
    for (int i = 0; i < s.length(); i++) {
        hash = (hash * base + s.charAt(i)) % mod;
    }
    return hash;
}

// Roll: remove leftmost, add rightmost
public long rollLTR(long hash, char remove, char add, long h, int base, int mod) {
    hash = (base * (hash - remove * h) + add) % mod;
    if (hash < 0) hash += mod;
    return hash;
}
```

**Variant 2: Right to Left Hash**
```java
// Build hash from right to left
public long hashRTL(String s, int base, int mod) {
    long hash = 0;
    long pow = 1;
    
    for (int i = s.length() - 1; i >= 0; i--) {
        hash = (hash + s.charAt(i) * pow) % mod;
        pow = (pow * base) % mod;
    }
    
    return hash;
}

// Roll: remove rightmost, add leftmost
public long rollRTL(long hash, char remove, char add, long pow, int base, int mod) {
    hash = (hash - remove + add * pow + mod) % mod;
    return hash;
}
```

**Variant 3: Bidirectional Rolling Hash**
```java
public class BidirectionalHash {
    private long hashLTR, hashRTL;
    private String text;
    private int start, length;
    private long powerLTR, powerRTL;
    
    public BidirectionalHash(String text, int start, int length, int base, int mod) {
        this.text = text;
        this.start = start;
        this.length = length;
        
        // Compute both hashes
        hashLTR = 0;
        hashRTL = 0;
        powerLTR = 1;
        powerRTL = 1;
        
        for (int i = 0; i < length; i++) {
            char c = text.charAt(start + i);
            hashLTR = (hashLTR * base + c) % mod;
            
            hashRTL = (hashRTL + c * powerRTL) % mod;
            powerRTL = (powerRTL * base) % mod;
            
            if (i < length - 1) {
                powerLTR = (powerLTR * base) % mod;
            }
        }
    }
    
    // Check if substring is palindrome using hash comparison
    public boolean isPalindrome() {
        return hashLTR == hashRTL;
    }
}
```

### Handling Negative Modulo

**Problem**: In Java, `-776 % 101 = -70`, not `31` as expected

**Solution 1: Post-adjustment**
```java
hash = (base * (hash - char * h) + newChar) % mod;
if (hash < 0) {
    hash += mod;
}
```

**Solution 2: Pre-adjustment**
```java
hash = (base * ((hash - char * h) % mod + mod) % mod + newChar) % mod;
```

**Solution 3: Add mod before modulo**
```java
hash = (base * (hash - char * h + mod) + newChar) % mod;
```

**Comparison**:
```java
// Example: hash = 5, char = 10, h = 100, mod = 101, base = 31

// Solution 1
hash = (31 * (5 - 10 * 100) + 65) % 101;
     = (31 * (-995) + 65) % 101;
     = -30780 % 101
     = -70
if (hash < 0) hash += 101;
     = 31

// Solution 2
hash = (31 * ((5 - 1000) % 101 + 101) % 101 + 65) % 101;
     = (31 * ((-995) % 101 + 101) % 101 + 65) % 101;
     = (31 * (-91 + 101) % 101 + 65) % 101;
     = (31 * 10 + 65) % 101;
     = 375 % 101
     = 71  (WRONG!)

// Solution 3
hash = (31 * (5 - 1000 + 101) + 65) % 101;
     = (31 * (-894) + 65) % 101;
     = -27649 % 101
     = -72
// Still negative!

BEST: Use Solution 1 (post-adjustment)
```

---

## Handling Hash Collisions

### What is a Spurious Hit?

**Definition**: When hashes match but strings don't (false positive)

```
hash("ABC") = 123
hash("XYZ") = 123  ← Collision!

When searching for "ABC":
- Find "XYZ" at some position
- Hashes match → need to verify
- Character comparison → not a match
- Continue searching
```

### Collision Probability

For random strings of length m:
```
Collision probability ≈ 1 / MOD

Example:
MOD = 10^9 + 7
P(collision) ≈ 10^-9 (very small)

But with n comparisons:
P(at least one collision) ≈ n / MOD

For n = 10^6:
P(collision) ≈ 10^6 / 10^9 = 0.001 = 0.1%
```

### Verification Strategy

**Always verify when hashes match**:
```java
if (patternHash == textHash) {
    // DON'T just return true!
    
    // Verify character by character
    boolean match = true;
    for (int j = 0; j < m; j++) {
        if (text.charAt(i + j) != pattern.charAt(j)) {
            match = false;
            break;
        }
    }
    
    if (match) {
        return i; // Confirmed match
    }
    // Otherwise, spurious hit - continue searching
}
```

### Reducing Collisions

**Method 1: Use Larger MOD**
```java
// Small MOD (more collisions)
int MOD = 101;
P(collision) ≈ 1/101 ≈ 1%

// Large MOD (fewer collisions)
int MOD = 1_000_000_007;
P(collision) ≈ 10^-9 ≈ 0.0000001%
```

**Method 2: Double Hashing**
```java
public class DoubleHashing {
    private static final int BASE1 = 31;
    private static final int MOD1 = 1_000_000_007;
    private static final int BASE2 = 37;
    private static final int MOD2 = 1_000_000_009;
    
    public static boolean matches(String text, int start, String pattern) {
        // Compute both hashes for pattern
        long hash1_pattern = hash(pattern, BASE1, MOD1);
        long hash2_pattern = hash(pattern, BASE2, MOD2);
        
        // Compute both hashes for text window
        String window = text.substring(start, start + pattern.length());
        long hash1_text = hash(window, BASE1, MOD1);
        long hash2_text = hash(window, BASE2, MOD2);
        
        // Both must match
        if (hash1_pattern == hash1_text && hash2_pattern == hash2_text) {
            // Still verify (paranoid)
            return window.equals(pattern);
        }
        
        return false;
    }
    
    private static long hash(String s, int base, int mod) {
        long h = 0;
        for (char c : s.toCharArray()) {
            h = (h * base + c) % mod;
        }
        return h;
    }
}

// P(collision) ≈ 1 / (MOD1 × MOD2) ≈ 10^-18
```

**Method 3: Choose Good Parameters**
```java
// GOOD parameters
int BASE = 31;  // Prime, not too small
int MOD = 1_000_000_007;  // Large prime

// BAD parameters
int BASE = 2;   // Too small, many patterns collapse
int MOD = 100;  // Not prime, more collisions
```

### Collision Example

```java
public class CollisionDemo {
    public static void main(String[] args) {
        int BASE = 10;
        int MOD = 13;
        
        // Find strings with same hash
        Map<Integer, List<String>> hashMap = new HashMap<>();
        
        for (char c1 = 'A'; c1 <= 'Z'; c1++) {
            for (char c2 = 'A'; c2 <= 'Z'; c2++) {
                String s = "" + c1 + c2;
                int hash = computeHash(s, BASE, MOD);
                
                hashMap.computeIfAbsent(hash, k -> new ArrayList<>()).add(s);
            }
        }
        
        // Print collisions
        System.out.println("Collisions found:");
        for (Map.Entry<Integer, List<String>> entry : hashMap.entrySet()) {
            if (entry.getValue().size() > 1) {
                System.out.println("Hash " + entry.getKey() + ": " + entry.getValue());
            }
        }
    }
    
    private static int computeHash(String s, int base, int mod) {
        int hash = 0;
        for (char c : s.toCharArray()) {
            hash = (hash * base + c) % mod;
        }
        return hash;
    }
}
```

**Sample Output**:
```
Collisions found:
Hash 0: [AA, AN, BA, ...]
Hash 1: [AB, AO, BB, ...]
Hash 2: [AC, AP, BC, ...]
...
```

---

## Common Patterns

### Pattern 1: Find First Occurrence

```java
public int findFirst(String text, String pattern) {
    int n = text.length();
    int m = pattern.length();
    if (m > n) return -1;
    
    int BASE = 31, MOD = 1_000_000_007;
    
    // Compute h = BASE^(m-1)
    long h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * BASE) % MOD;
    }
    
    // Compute hashes
    long patHash = 0, txtHash = 0;
    for (int i = 0; i < m; i++) {
        patHash = (patHash * BASE + pattern.charAt(i)) % MOD;
        txtHash = (txtHash * BASE + text.charAt(i)) % MOD;
    }
    
    // Search
    for (int i = 0; i <= n - m; i++) {
        if (patHash == txtHash && text.substring(i, i + m).equals(pattern)) {
            return i;
        }
        
        if (i < n - m) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
    
    return -1;
}
```

### Pattern 2: Count Occurrences

```java
public int countOccurrences(String text, String pattern) {
    int count = 0;
    int n = text.length();
    int m = pattern.length();
    if (m > n) return 0;
    
    int BASE = 31, MOD = 1_000_000_007;
    
    long h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * BASE) % MOD;
    }
    
    long patHash = 0, txtHash = 0;
    for (int i = 0; i < m; i++) {
        patHash = (patHash * BASE + pattern.charAt(i)) % MOD;
        txtHash = (txtHash * BASE + text.charAt(i)) % MOD;
    }
    
    for (int i = 0; i <= n - m; i++) {
        if (patHash == txtHash) {
            boolean match = true;
            for (int j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    match = false;
                    break;
                }
            }
            if (match) count++;
        }
        
        if (i < n - m) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
    
    return count;
}
```

### Pattern 3: Check if Substring Exists

```java
public boolean contains(String text, String pattern) {
    return findFirst(text, pattern) != -1;
}

// Example
public static void main(String[] args) {
    String text = "The quick brown fox";
    String pattern = "quick";
    
    System.out.println(contains(text, pattern)); // true
    System.out.println(contains(text, "slow"));  // false
}
```

### Pattern 4: Search Multiple Patterns

```java
public Map<String, List<Integer>> searchMultiple(String text, String[] patterns) {
    Map<String, List<Integer>> result = new HashMap<>();
    
    if (patterns.length == 0) return result;
    
    int m = patterns[0].length(); // Assume all same length
    int n = text.length();
    
    int BASE = 31, MOD = 1_000_000_007;
    
    // Compute pattern hashes
    Map<Long, List<String>> hashToPatterns = new HashMap<>();
    for (String pattern : patterns) {
        long hash = computeHash(pattern, BASE, MOD);
        hashToPatterns.computeIfAbsent(hash, k -> new ArrayList<>()).add(pattern);
        result.put(pattern, new ArrayList<>());
    }
    
    // Slide window
    long h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * BASE) % MOD;
    }
    
    long txtHash = computeHash(text.substring(0, m), BASE, MOD);
    
    for (int i = 0; i <= n - m; i++) {
        if (hashToPatterns.containsKey(txtHash)) {
            String window = text.substring(i, i + m);
            for (String pattern : hashToPatterns.get(txtHash)) {
                if (window.equals(pattern)) {
                    result.get(pattern).add(i);
                }
            }
        }
        
        if (i < n - m) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
    
    return result;
}

private long computeHash(String s, int base, int mod) {
    long hash = 0;
    for (char c : s.toCharArray()) {
        hash = (hash * base + c) % mod;
    }
    return hash;
}

// Example
public static void main(String[] args) {
    String text = "ababcabcab";
    String[] patterns = {"abc", "cab", "bca"};
    
    Map<String, List<Integer>> result = searchMultiple(text, patterns);
    
    for (Map.Entry<String, List<Integer>> entry : result.entrySet()) {
        System.out.println(entry.getKey() + ": " + entry.getValue());
    }
}
```

**Output**:
```
abc: [2, 5]
cab: [4, 7]
bca: [3]
```

### Pattern 5: Case-Insensitive Search

```java
public int searchIgnoreCase(String text, String pattern) {
    return findFirst(text.toLowerCase(), pattern.toLowerCase());
}

// Example
public static void main(String[] args) {
    String text = "Hello World";
    String pattern = "WORLD";
    
    int index = searchIgnoreCase(text, pattern);
    System.out.println("Found at: " + index); // 6
}
```

### Pattern 6: Overlapping Matches

```java
public List<Integer> findOverlapping(String text, String pattern) {
    List<Integer> result = new ArrayList<>();
    int n = text.length();
    int m = pattern.length();
    
    if (m > n) return result;
    
    int BASE = 31, MOD = 1_000_000_007;
    
    long h = 1;
    for (int i = 0; i < m - 1; i++) {
        h = (h * BASE) % MOD;
    }
    
    long patHash = 0, txtHash = 0;
    for (int i = 0; i < m; i++) {
        patHash = (patHash * BASE + pattern.charAt(i)) % MOD;
        txtHash = (txtHash * BASE + text.charAt(i)) % MOD;
    }
    
    for (int i = 0; i <= n - m; i++) {
        if (patHash == txtHash && text.substring(i, i + m).equals(pattern)) {
            result.add(i); // Add match, continue searching
        }
        
        if (i < n - m) {
            txtHash = (BASE * (txtHash - text.charAt(i) * h) + text.charAt(i + m)) % MOD;
            if (txtHash < 0) txtHash += MOD;
        }
    }
    
    return result;
}

// Example
public static void main(String[] args) {
    String text = "AAAAAA";
    String pattern = "AAA";
    
    List<Integer> indices = findOverlapping(text, pattern);
    System.out.println(indices); // [0, 1, 2, 3]
}
```

---

## Summary

### Part 1 Covered:
✅ Why Rabin-Karp algorithm  
✅ Core concept: Rolling hash  
✅ Hash function design  
✅ Basic implementation  
✅ Step-by-step examples  
✅ Rolling hash mechanics  
✅ Collision handling  
✅ Common patterns  

### Key Takeaways:

1. **Rolling Hash**: Core optimization enabling O(1) window updates
2. **Hash Parameters**: Choose BASE (31, 256) and MOD (10^9+7) carefully
3. **Verification**: Always verify character-by-character when hashes match
4. **Collisions**: Use large prime MOD, consider double hashing
5. **Time Complexity**: O(n + m) average, O(n × m) worst case

### Coming in Part 2:
- Advanced applications (longest duplicate substring, repeated DNA)
- Optimization techniques (multiple bases, early termination)
- 2D pattern matching
- Interview questions and answers
- Practice problems with complete solutions

---

**Next**: [4.7-Rabin-Karp-Algorithm-Part2.md](4.7-Rabin-Karp-Algorithm-Part2.md)
