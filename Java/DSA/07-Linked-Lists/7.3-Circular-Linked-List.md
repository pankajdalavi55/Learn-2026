# 7.3 Circular Linked List

## Table of Contents
1. [Introduction](#introduction)
2. [Node Structure](#node-structure)
3. [Basic Implementation](#basic-implementation)
4. [Core Operations](#core-operations)
5. [Common Patterns](#common-patterns)
6. [Advanced Operations](#advanced-operations)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is a Circular Linked List?

A **circular linked list** is a variation of linked list where:
- The **last node points back to the first node** (instead of null)
- Forms a **circle** - no null at the end
- Can be singly or doubly linked
- Can be traversed infinitely

### Types of Circular Linked Lists

#### 1. Circular Singly Linked List
```
     ┌─────────────────────────────┐
     │                             │
     ↓                             │
HEAD → [10|●] → [20|●] → [30|●] → [40|●]
       
Last node points back to head (no null)
```

#### 2. Circular Doubly Linked List
```
     ┌──────────────────────────────────────┐
     │                                      │
     ↓                                      │
HEAD → [●|10|●] ↔ [●|20|●] ↔ [●|30|●] ↔ [●|40|●]
       ↑                                      │
       │                                      │
       └──────────────────────────────────────┘
       
Last.next → head
Head.prev → last
```

### Comparison Table

| Feature | Singly LL | Circular Singly LL |
|---------|-----------|-------------------|
| **Last node points to** | null | head |
| **End detection** | node == null | node == head |
| **Traversal** | Linear, one-way | Circular, infinite |
| **Access from any node** | Need head | Any node works |
| **Use cases** | Simple lists | Round-robin, buffers |

### Key Characteristics

- **No null pointers**: Last node connects to first
- **Infinite traversal**: Can loop continuously
- **Any node as starting point**: Don't necessarily need head
- **Efficient for circular operations**: Round-robin scheduling, Josephus problem
- **Easier to traverse**: From any node to any other node

### Complexity Analysis

| Operation | Linear LL | Circular LL |
|-----------|-----------|-------------|
| **Access** | O(n) | O(n) |
| **Search** | O(n) | O(n) |
| **Insert at beginning** | O(1) | O(n)* or O(1)** |
| **Insert at end** | O(n) or O(1) | O(1)** |
| **Delete at beginning** | O(1) | O(n)* or O(1)** |
| **Delete at end** | O(n) | O(n) |

\* Without tail pointer  
\*\* With tail pointer

### When to Use Circular Linked List?

✅ **Use Circular Linked List when**:
- Round-robin scheduling needed
- Circular buffer implementation
- Josephus problem variations
- Game turn management
- Continuous looping required
- Playlist with repeat functionality

❌ **Avoid when**:
- Need clear start/end
- Linear traversal only
- Risk of infinite loops confusing
- Standard list operations sufficient

---

## Node Structure

### Node for Circular Singly Linked List

```java
public class Node {
    int data;
    Node next;
    
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
    
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}
```

### Node for Circular Doubly Linked List

```java
public class Node {
    int data;
    Node next;
    Node prev;
    
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
    
    public Node(int data, Node prev, Node next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}
```

### Generic Node

```java
public class Node<T> {
    T data;
    Node<T> next;
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}
```

---

## Basic Implementation

### Circular Singly Linked List (with Tail pointer)

**Using tail pointer is recommended for efficient operations**

```java
public class CircularLinkedList {
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node tail;  // Points to last node (recommended over head)
    private int size;
    
    public CircularLinkedList() {
        this.tail = null;
        this.size = 0;
    }
    
    // Check if list is empty
    public boolean isEmpty() {
        return tail == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Get head (first node)
    private Node getHead() {
        return (tail == null) ? null : tail.next;
    }
    
    // Display list
    public void display() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        Node current = tail.next;  // Start from head
        do {
            System.out.print(current.data);
            if (current != tail) {
                System.out.print(" → ");
            }
            current = current.next;
        } while (current != tail.next);
        
        System.out.println(" → (circular)");
    }
    
    // Test
    public static void main(String[] args) {
        CircularLinkedList list = new CircularLinkedList();
        System.out.println("Empty? " + list.isEmpty()); // true
        System.out.println("Size: " + list.size());     // 0
        list.display();                                  // List is empty
    }
}
```

**Why use tail instead of head?**
- `tail.next` gives head in O(1)
- Insert at end is O(1)
- Insert at beginning is also O(1)
- More efficient overall

---

### Circular Doubly Linked List

```java
public class CircularDoublyLinkedList {
    private class Node {
        int data;
        Node next;
        Node prev;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node head;
    private int size;
    
    public CircularDoublyLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public boolean isEmpty() {
        return head == null;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        Node current = head;
        do {
            System.out.print(current.data + " ↔ ");
            current = current.next;
        } while (current != head);
        
        System.out.println("(circular)");
    }
}
```

---

## Core Operations

### 1. Insert at Beginning

**Using tail pointer for O(1) insertion**

```java
/**
 * Insert at beginning - O(1) with tail pointer
 */
public void addFirst(int data) {
    Node newNode = new Node(data);
    
    if (isEmpty()) {
        tail = newNode;
        tail.next = tail;  // Point to itself
    } else {
        newNode.next = tail.next;  // New node points to head
        tail.next = newNode;        // Tail points to new head
    }
    
    size++;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    
    list.addFirst(30);  // 30 → (circular)
    list.addFirst(20);  // 20 → 30 → (circular)
    list.addFirst(10);  // 10 → 20 → 30 → (circular)
    
    list.display();
}
```

**Visual Process**:
```
Initial: tail = null

After addFirst(30):
TAIL → [30|●] ─┐
       ↑       │
       └───────┘

After addFirst(20):
        ┌──────────┐
        ↓          │
TAIL → [30|●] → [20|●]
                ↑
                HEAD

After addFirst(10):
        ┌─────────────────┐
        ↓                 │
TAIL → [30|●] → [10|●] → [20|●]
                ↑
                HEAD
```

**Complexity**: O(1) time, O(1) space

---

### 2. Insert at End

**Most efficient with tail pointer**

```java
/**
 * Insert at end - O(1) with tail pointer
 */
public void addLast(int data) {
    Node newNode = new Node(data);
    
    if (isEmpty()) {
        tail = newNode;
        tail.next = tail;
    } else {
        newNode.next = tail.next;  // New node points to head
        tail.next = newNode;        // Old tail points to new node
        tail = newNode;             // Update tail
    }
    
    size++;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    
    list.addLast(10);  // 10 → (circular)
    list.addLast(20);  // 10 → 20 → (circular)
    list.addLast(30);  // 10 → 20 → 30 → (circular)
    
    list.display();
}
```

**Visual Process**:
```
Before: tail → [20|●] → [10|●] ─┐
               ↑                │
               └────────────────┘

Step 1: Create newNode [30|null]

Step 2: newNode.next = tail.next
        [30|●] → [10|●]

Step 3: tail.next = newNode
        [20|●] → [30|●] → [10|●]

Step 4: tail = newNode
        tail → [30|●] → [10|●] ─┐
               ↑                │
               └────────────────┘
```

**Complexity**: O(1) time, O(1) space

---

### 3. Insert at Position

```java
/**
 * Insert at specific position (0-based)
 */
public void insertAt(int index, int data) {
    if (index < 0 || index > size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    if (index == 0) {
        addFirst(data);
        return;
    }
    
    if (index == size) {
        addLast(data);
        return;
    }
    
    Node newNode = new Node(data);
    Node current = tail.next;  // Start from head
    
    // Traverse to position (index - 1)
    for (int i = 0; i < index - 1; i++) {
        current = current.next;
    }
    
    newNode.next = current.next;
    current.next = newNode;
    size++;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(30);
    list.insertAt(1, 20);  // Insert 20 at index 1
    
    list.display();  // 10 → 20 → 30 → (circular)
}
```

**Complexity**: O(n) time, O(1) space

---

### 4. Delete from Beginning

```java
/**
 * Delete first node - O(1)
 */
public int removeFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    Node head = tail.next;
    int data = head.data;
    
    if (tail == tail.next) {  // Single node
        tail = null;
    } else {
        tail.next = head.next;  // Skip first node
    }
    
    size--;
    return data;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println("Removed: " + list.removeFirst()); // 10
    list.display();  // 20 → 30 → (circular)
}
```

**Visual Process**:
```
Before: tail → [30|●] → [10|●] → [20|●] ─┐
                        ↑                │
                        └────────────────┘

After:  tail → [30|●] → [20|●] ─┐
               ↑                │
               └────────────────┘
               
[10] is garbage collected
```

**Complexity**: O(1) time, O(1) space

---

### 5. Delete from End

**Requires traversal to second-last node**

```java
/**
 * Delete last node - O(n)
 */
public int removeLast() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    Node head = tail.next;
    int data = tail.data;
    
    if (tail == head) {  // Single node
        tail = null;
    } else {
        // Find second-last node
        Node current = head;
        while (current.next != tail) {
            current = current.next;
        }
        
        current.next = head;  // Point to head
        tail = current;       // Update tail
    }
    
    size--;
    return data;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println("Removed: " + list.removeLast()); // 30
    list.display();  // 10 → 20 → (circular)
}
```

**Complexity**: O(n) time, O(1) space

---

### 6. Delete at Position

```java
/**
 * Delete node at specific position
 */
public int removeAt(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    if (index == 0) {
        return removeFirst();
    }
    
    if (index == size - 1) {
        return removeLast();
    }
    
    Node current = tail.next;  // Start from head
    
    // Traverse to (index - 1)
    for (int i = 0; i < index - 1; i++) {
        current = current.next;
    }
    
    int data = current.next.data;
    current.next = current.next.next;
    size--;
    
    return data;
}
```

**Complexity**: O(n) time, O(1) space

---

### 7. Search Operation

```java
/**
 * Search for a value
 */
public int search(int target) {
    if (isEmpty()) return -1;
    
    Node current = tail.next;
    int index = 0;
    
    do {
        if (current.data == target) {
            return index;
        }
        current = current.next;
        index++;
    } while (current != tail.next);
    
    return -1;
}

/**
 * Check if value exists
 */
public boolean contains(int target) {
    return search(target) != -1;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println(list.search(20));    // 1
    System.out.println(list.search(100));   // -1
    System.out.println(list.contains(30));  // true
}
```

**Complexity**: O(n) time, O(1) space

---

### 8. Get Element at Index

```java
/**
 * Get value at specific index
 */
public int get(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    Node current = tail.next;
    for (int i = 0; i < index; i++) {
        current = current.next;
    }
    
    return current.data;
}

/**
 * Get first element
 */
public int getFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    return tail.next.data;
}

/**
 * Get last element
 */
public int getLast() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    return tail.data;
}
```

**Complexity**: O(n) time, O(1) space

---

## Common Patterns

### Pattern 1: Josephus Problem

**Classic circular linked list problem**

```java
/**
 * Josephus Problem: n people in circle, eliminate every kth person
 * Find the survivor
 */
public int josephus(int n, int k) {
    // Create circular list with n people
    CircularLinkedList list = new CircularLinkedList();
    for (int i = 1; i <= n; i++) {
        list.addLast(i);
    }
    
    Node current = list.tail.next;  // Start from position 1
    
    while (list.size() > 1) {
        // Count k-1 people
        for (int i = 0; i < k - 1; i++) {
            current = current.next;
        }
        
        // Eliminate kth person
        Node toEliminate = current.next;
        System.out.println("Eliminated: " + toEliminate.data);
        
        // Remove node
        if (toEliminate == list.tail) {
            list.tail = current;
        }
        current.next = toEliminate.next;
        list.size--;
        
        current = current.next;  // Move to next person
    }
    
    return list.tail.data;  // Survivor
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    
    // 7 people, every 3rd eliminated
    int survivor = list.josephus(7, 3);
    System.out.println("Survivor: " + survivor);
    
    /*
     * Circle: 1 → 2 → 3 → 4 → 5 → 6 → 7 → (back to 1)
     * Eliminations: 3, 6, 2, 7, 5, 1
     * Survivor: 4
     */
}
```

**Visual Process** (n=7, k=3):
```
Start: 1 → 2 → 3 → 4 → 5 → 6 → 7 → (circular)
       ↑
      
Count 3: 1, 2, 3 → Eliminate 3
        1 → 2 → 4 → 5 → 6 → 7 → (circular)
                ↑

Count 3: 4, 5, 6 → Eliminate 6
        1 → 2 → 4 → 5 → 7 → (circular)
                        ↑

Continue until one remains: 4
```

**Complexity**: O(n × k) time, O(1) space

**Mathematical Solution**: O(n) time
```java
public int josephusMath(int n, int k) {
    int survivor = 0;
    for (int i = 2; i <= n; i++) {
        survivor = (survivor + k) % i;
    }
    return survivor + 1;  // Convert to 1-based
}
```

---

### Pattern 2: Split Circular List into Two

```java
/**
 * Split circular list into two halves
 */
public CircularLinkedList[] split() {
    if (isEmpty() || size == 1) {
        return new CircularLinkedList[]{this, new CircularLinkedList()};
    }
    
    // Find middle using slow-fast pointers
    Node slow = tail.next;
    Node fast = tail.next;
    
    while (fast.next != tail.next && fast.next.next != tail.next) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Create two lists
    CircularLinkedList list1 = new CircularLinkedList();
    CircularLinkedList list2 = new CircularLinkedList();
    
    // First half: head to slow
    list1.tail = slow;
    list1.tail.next = tail.next;
    
    // Second half: slow.next to tail
    list2.tail = tail;
    list2.tail.next = slow.next;
    slow.next = tail.next;
    
    // Update sizes
    list1.size = (size + 1) / 2;
    list2.size = size / 2;
    
    return new CircularLinkedList[]{list1, list2};
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    for (int i = 1; i <= 7; i++) {
        list.addLast(i);
    }
    
    System.out.print("Original: ");
    list.display();  // 1 → 2 → 3 → 4 → 5 → 6 → 7 → (circular)
    
    CircularLinkedList[] halves = list.split();
    
    System.out.print("First half: ");
    halves[0].display();  // 1 → 2 → 3 → 4 → (circular)
    
    System.out.print("Second half: ");
    halves[1].display();  // 5 → 6 → 7 → (circular)
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 3: Check if List is Circular

```java
/**
 * Check if a linked list is circular
 * Works with any linked list (may or may not be circular)
 */
public static boolean isCircular(Node head) {
    if (head == null) return false;
    
    Node current = head.next;
    
    while (current != null && current != head) {
        current = current.next;
    }
    
    return current == head;
}

/**
 * Alternative: Using Floyd's cycle detection
 */
public static boolean isCircularFloyd(Node head) {
    if (head == null) return false;
    
    Node slow = head;
    Node fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // Has cycle, now check if it's circular (ends at head)
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow == head;
        }
    }
    
    return false;  // No cycle
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 4: Convert to Regular Linked List

```java
/**
 * Convert circular linked list to regular (linear) linked list
 */
public Node convertToLinear() {
    if (isEmpty()) return null;
    
    Node head = tail.next;
    tail.next = null;  // Break the circle
    
    return head;
}

/**
 * Convert regular linked list to circular
 */
public static Node convertToCircular(Node head) {
    if (head == null) return null;
    
    Node tail = head;
    while (tail.next != null) {
        tail = tail.next;
    }
    
    tail.next = head;  // Make circular
    return tail;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    Node linearHead = list.convertToLinear();
    // Now it's: 10 → 20 → 30 → null
    
    Node circularTail = convertToCircular(linearHead);
    // Now it's: 10 → 20 → 30 → (back to 10)
}
```

**Complexity**: O(n) time for linear to circular, O(1) for circular to linear

---

### Pattern 5: Rotate List by K

```java
/**
 * Rotate circular list by k positions
 */
public void rotate(int k) {
    if (isEmpty() || k == 0) return;
    
    k = k % size;  // Normalize k
    if (k == 0) return;
    
    // Move tail k positions forward
    for (int i = 0; i < k; i++) {
        tail = tail.next;
    }
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    for (int i = 1; i <= 5; i++) {
        list.addLast(i);
    }
    
    System.out.print("Before: ");
    list.display();  // 1 → 2 → 3 → 4 → 5 → (circular)
    
    list.rotate(2);
    
    System.out.print("After: ");
    list.display();  // 3 → 4 → 5 → 1 → 2 → (circular)
}
```

**Complexity**: O(k) time, O(1) space

---

### Pattern 6: Sorted Insert in Circular List

```java
/**
 * Insert in sorted circular linked list
 */
public void sortedInsert(int data) {
    Node newNode = new Node(data);
    
    // Case 1: Empty list
    if (isEmpty()) {
        tail = newNode;
        tail.next = tail;
        size++;
        return;
    }
    
    Node head = tail.next;
    
    // Case 2: Insert at beginning (before head)
    if (data <= head.data) {
        newNode.next = head;
        tail.next = newNode;
        size++;
        return;
    }
    
    // Case 3: Insert at end (after tail)
    if (data >= tail.data) {
        newNode.next = head;
        tail.next = newNode;
        tail = newNode;
        size++;
        return;
    }
    
    // Case 4: Insert in middle
    Node current = head;
    while (current.next != head && current.next.data < data) {
        current = current.next;
    }
    
    newNode.next = current.next;
    current.next = newNode;
    size++;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    
    list.sortedInsert(10);
    list.sortedInsert(30);
    list.sortedInsert(20);
    list.sortedInsert(5);
    list.sortedInsert(25);
    
    list.display();  // 5 → 10 → 20 → 25 → 30 → (circular)
}
```

**Complexity**: O(n) time, O(1) space

---

## Advanced Operations

### 1. Exchange First and Last Nodes

```java
/**
 * Exchange first and last nodes (data swap)
 */
public void exchangeFirstLast() {
    if (isEmpty() || size == 1) return;
    
    int temp = tail.next.data;
    tail.next.data = tail.data;
    tail.data = temp;
}

/**
 * Exchange by changing links (more complex but proper)
 */
public void exchangeFirstLastByLinks() {
    if (isEmpty() || size == 1) return;
    
    Node head = tail.next;
    
    if (size == 2) {
        tail = head;
        return;
    }
    
    // Find second-last node
    Node secondLast = head;
    while (secondLast.next != tail) {
        secondLast = secondLast.next;
    }
    
    // Rearrange links
    tail.next = head.next;
    secondLast.next = head;
    head.next = tail;
    
    Node temp = head;
    head = tail;
    tail = temp;
    
    tail.next = head;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    for (int i = 1; i <= 5; i++) {
        list.addLast(i);
    }
    
    System.out.print("Before: ");
    list.display();  // 1 → 2 → 3 → 4 → 5 → (circular)
    
    list.exchangeFirstLast();
    
    System.out.print("After: ");
    list.display();  // 5 → 2 → 3 → 4 → 1 → (circular)
}
```

**Complexity**: O(n) time for link exchange, O(1) for data swap

---

### 2. Reverse Circular List

```java
/**
 * Reverse circular linked list
 */
public void reverse() {
    if (isEmpty() || size == 1) return;
    
    Node prev = tail;
    Node current = tail.next;
    Node head = current;
    
    do {
        Node next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    } while (current != head);
    
    tail = head;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    for (int i = 1; i <= 5; i++) {
        list.addLast(i);
    }
    
    System.out.print("Before: ");
    list.display();  // 1 → 2 → 3 → 4 → 5 → (circular)
    
    list.reverse();
    
    System.out.print("After: ");
    list.display();  // 5 → 4 → 3 → 2 → 1 → (circular)
}
```

**Complexity**: O(n) time, O(1) space

---

### 3. Merge Two Sorted Circular Lists

```java
/**
 * Merge two sorted circular linked lists
 */
public static CircularLinkedList mergeSorted(CircularLinkedList list1, 
                                              CircularLinkedList list2) {
    if (list1.isEmpty()) return list2;
    if (list2.isEmpty()) return list1;
    
    CircularLinkedList result = new CircularLinkedList();
    
    Node p1 = list1.tail.next;
    Node p2 = list2.tail.next;
    
    int count1 = 0, count2 = 0;
    
    while (count1 < list1.size || count2 < list2.size) {
        if (count1 == list1.size) {
            result.addLast(p2.data);
            p2 = p2.next;
            count2++;
        } else if (count2 == list2.size) {
            result.addLast(p1.data);
            p1 = p1.next;
            count1++;
        } else if (p1.data <= p2.data) {
            result.addLast(p1.data);
            p1 = p1.next;
            count1++;
        } else {
            result.addLast(p2.data);
            p2 = p2.next;
            count2++;
        }
    }
    
    return result;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list1 = new CircularLinkedList();
    list1.addLast(1);
    list1.addLast(3);
    list1.addLast(5);
    
    CircularLinkedList list2 = new CircularLinkedList();
    list2.addLast(2);
    list2.addLast(4);
    list2.addLast(6);
    
    CircularLinkedList merged = mergeSorted(list1, list2);
    merged.display();  // 1 → 2 → 3 → 4 → 5 → 6 → (circular)
}
```

**Complexity**: O(m + n) time, O(m + n) space

---

### 4. Count Nodes in Circular List

```java
/**
 * Count nodes when you don't know if it's circular
 */
public static int countNodes(Node head) {
    if (head == null) return 0;
    
    int count = 1;
    Node current = head.next;
    
    while (current != null && current != head) {
        count++;
        current = current.next;
    }
    
    return count;
}

/**
 * Count with cycle detection
 */
public static int countNodesSafe(Node node) {
    if (node == null) return 0;
    
    Set<Node> visited = new HashSet<>();
    int count = 0;
    
    while (node != null && !visited.contains(node)) {
        visited.add(node);
        count++;
        node = node.next;
    }
    
    return count;
}
```

**Complexity**: O(n) time, O(1) or O(n) space

---

## Interview Questions

### Question 1: Detect Loop Start (Advanced)

**Problem**: Find the node where the loop begins in a linked list with a cycle.

```java
/**
 * Find the start of the loop in circular list
 * In pure circular list, it's always the head
 */
public Node detectLoopStart(Node head) {
    if (head == null) return null;
    
    Node slow = head;
    Node fast = head;
    
    // Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // Found cycle, now find start
            slow = head;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;  // Loop start
        }
    }
    
    return null;  // No cycle
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 2: Clone Circular List

**Problem**: Create a deep copy of circular linked list.

```java
/**
 * Clone circular linked list
 */
public CircularLinkedList clone() {
    if (isEmpty()) {
        return new CircularLinkedList();
    }
    
    CircularLinkedList cloned = new CircularLinkedList();
    Node current = tail.next;
    
    do {
        cloned.addLast(current.data);
        current = current.next;
    } while (current != tail.next);
    
    return cloned;
}

// Test
public static void main(String[] args) {
    CircularLinkedList original = new CircularLinkedList();
    original.addLast(10);
    original.addLast(20);
    original.addLast(30);
    
    CircularLinkedList cloned = original.clone();
    
    System.out.print("Original: ");
    original.display();
    
    System.out.print("Cloned: ");
    cloned.display();
    
    // Modify original
    original.addLast(40);
    
    System.out.print("After modify original: ");
    original.display();
    
    System.out.print("Cloned remains: ");
    cloned.display();
}
```

**Complexity**: O(n) time, O(n) space

---

### Question 3: Find Length of Loop

**Problem**: Find the length of the loop in a linked list.

```java
/**
 * Find length of loop in circular list
 * For pure circular list, length = size of list
 */
public int loopLength() {
    return size;
}

/**
 * General case: Find loop length in any list with cycle
 */
public static int findLoopLength(Node head) {
    if (head == null) return 0;
    
    Node slow = head;
    Node fast = head;
    
    // Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // Count loop length
            int length = 1;
            Node temp = slow.next;
            while (temp != slow) {
                length++;
                temp = temp.next;
            }
            return length;
        }
    }
    
    return 0;  // No loop
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 4: Check if Two Lists are Identical Circular

**Problem**: Check if two circular lists have same data in same order.

```java
/**
 * Check if two circular lists are identical
 */
public boolean isIdentical(CircularLinkedList other) {
    if (this.size != other.size) {
        return false;
    }
    
    if (this.isEmpty() && other.isEmpty()) {
        return true;
    }
    
    Node current1 = this.tail.next;
    Node current2 = other.tail.next;
    
    do {
        if (current1.data != current2.data) {
            return false;
        }
        current1 = current1.next;
        current2 = current2.next;
    } while (current1 != this.tail.next);
    
    return true;
}

// Test
public static void main(String[] args) {
    CircularLinkedList list1 = new CircularLinkedList();
    list1.addLast(10);
    list1.addLast(20);
    list1.addLast(30);
    
    CircularLinkedList list2 = new CircularLinkedList();
    list2.addLast(10);
    list2.addLast(20);
    list2.addLast(30);
    
    System.out.println(list1.isIdentical(list2));  // true
    
    list2.addLast(40);
    System.out.println(list1.isIdentical(list2));  // false
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 5: Remove Duplicates from Unsorted Circular List

**Problem**: Remove duplicate values from circular list.

```java
/**
 * Remove duplicates using HashSet
 */
public void removeDuplicates() {
    if (isEmpty() || size == 1) return;
    
    Set<Integer> seen = new HashSet<>();
    Node current = tail.next;
    Node prev = tail;
    
    int processed = 0;
    
    while (processed < size) {
        if (seen.contains(current.data)) {
            // Remove duplicate
            prev.next = current.next;
            if (current == tail) {
                tail = prev;
            }
            size--;
        } else {
            seen.add(current.data);
            prev = current;
        }
        
        current = current.next;
        processed++;
    }
}

// Test
public static void main(String[] args) {
    CircularLinkedList list = new CircularLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(10);
    list.addLast(30);
    list.addLast(20);
    
    System.out.print("Before: ");
    list.display();  // 10 → 20 → 10 → 30 → 20 → (circular)
    
    list.removeDuplicates();
    
    System.out.print("After: ");
    list.display();  // 10 → 20 → 30 → (circular)
}
```

**Complexity**: O(n) time, O(n) space

---

## Practice Problems

### Easy Level

1. **Insert in Empty Circular List**
   - Handle single node circular list
   - Solution: Node points to itself

2. **Display Circular List**
   - Print without infinite loop
   - Solution: Use do-while with head check

3. **Count Nodes**
   - Count without size variable
   - Solution: Traverse until back to start

4. **Search in Circular List**
   - Find if element exists
   - Solution: Traverse with loop detection

5. **Convert Linear to Circular**
   - Make last point to first
   - Solution: Find tail, connect to head

### Medium Level

6. **Josephus Problem** (Classic!)
   - Eliminate every kth person
   - Solution: Simulate with circular list

7. **Split into Two Halves**
   - Divide into two circular lists
   - Solution: Find middle, split

8. **Sorted Insert**
   - Insert maintaining sorted order
   - Solution: Find position, handle edge cases

9. **Check if Circular**
   - Detect if list is circular
   - Solution: Traverse and check for cycle

10. **Exchange First and Last**
    - Swap first and last nodes
    - Solution: Data swap or link manipulation

### Hard Level

11. **Clone with Random Pointer**
    - Deep copy with additional pointer
    - Solution: Interleaving method

12. **Merge K Sorted Circular Lists**
    - Merge multiple sorted lists
    - Solution: Min heap approach

13. **Reverse in Groups**
    - Reverse k nodes at a time
    - Solution: Group reversal maintaining circular

14. **Find Pattern**
    - Check if pattern exists
    - Solution: KMP on circular structure

15. **Palindrome Partitioning**
    - Split into palindromic sublists
    - Solution: Dynamic programming

---

## Summary

### Key Takeaways

1. **No null at end**: Last node points back to first
2. **Use tail pointer**: More efficient than head for circular lists
3. **Josephus problem**: Classic application of circular lists
4. **Infinite traversal**: Be careful to avoid infinite loops
5. **Rotation is simple**: Just move tail pointer

### Operations Complexity Summary

| Operation | Without Tail | With Tail |
|-----------|--------------|-----------|
| addFirst | O(n) | O(1) ⭐ |
| addLast | O(n) | O(1) ⭐ |
| removeFirst | O(n) | O(1) ⭐ |
| removeLast | O(n) | O(n) |
| search | O(n) | O(n) |
| rotate | O(n) | O(k) ⭐ |

### When to Use Circular vs Linear

```
Use Circular Linked List:
✓ Round-robin scheduling
✓ Circular buffer/queue
✓ Josephus problem
✓ Game turn rotation
✓ Music playlist (repeat mode)
✓ Network token ring

Use Linear Linked List:
✓ Clear start/end needed
✓ Simple sequential processing
✓ Stack/Queue without rotation
✓ Standard list operations
```

### Common Patterns Checklist

- [ ] Josephus problem
- [ ] Split into two halves
- [ ] Sorted insert
- [ ] Check if circular
- [ ] Rotate by k positions
- [ ] Exchange first and last
- [ ] Merge sorted circular lists
- [ ] Remove duplicates

### Real-World Applications

1. **Operating Systems**: Round-robin CPU scheduling
2. **Games**: Turn-based gameplay rotation
3. **Media Players**: Repeat/loop playlist
4. **Network**: Token ring topology
5. **Multiplayer Games**: Player turn management
6. **Resource Allocation**: Fair distribution algorithms

### Common Mistakes to Avoid

1. **Infinite Loops**: Always use do-while or counter
2. **Losing Tail Reference**: Track tail properly
3. **Single Node Case**: Handle node pointing to itself
4. **Breaking the Circle**: Ensure last always points to first
5. **Traversal Logic**: Use `do-while` not `while` for circular

### Interview Tips

1. **Clarify Circular Type**: Singly or doubly circular?
2. **Ask About Tail**: Is tail pointer maintained?
3. **Edge Cases**: Empty, single node, breaking circle
4. **Josephus Variant**: Know both simulation and math formula
5. **Draw It**: Visualize the circular structure
6. **Loop Detection**: Use do-while for traversal

### Complexity Comparison

| Structure | Access | Insert Begin | Insert End | Delete Begin | Delete End |
|-----------|--------|--------------|------------|--------------|------------|
| Array | O(1) | O(n) | O(1) | O(n) | O(1) |
| Singly LL | O(n) | O(1) | O(n) | O(1) | O(n) |
| Doubly LL | O(n) | O(1) | O(1) | O(1) | O(1) |
| Circular (tail) | O(n) | O(1) | O(1) | O(1) | O(n) |

---

**Previous**: [7.2 Doubly Linked List](7.2-Doubly-Linked-List.md)

**Next**: [7.4 Linked List Problems](7.4-Linked-List-Problems.md) - Practice comprehensive problems

**Master**: Josephus problem is the most important pattern for circular lists!
