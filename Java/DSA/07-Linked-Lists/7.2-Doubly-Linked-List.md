# 7.2 Doubly Linked List

## Table of Contents
1. [Introduction](#introduction)
2. [Node Structure](#node-structure)
3. [Basic Implementation](#basic-implementation)
4. [Core Operations](#core-operations)
5. [Common Patterns](#common-patterns)
6. [Advanced Operations](#advanced-operations)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is a Doubly Linked List?

A **doubly linked list** is a linear data structure where each node contains:
- **Data**: The actual value
- **Next pointer**: Reference to the next node
- **Previous pointer**: Reference to the previous node

This bidirectional linkage allows traversal in both forward and backward directions.

### Visual Representation

```
        ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
null ← [●|10|●] ↔ [●|20|●] ↔ [●|30|●] ↔ [●|40|●] → null
        └─────────┘     └─────────────┘     └─────────┘     └─────────┘
        prev data next   prev data next   prev data next   prev data next
        
HEAD points to first node
TAIL points to last node (optional but recommended)
```

### Singly vs Doubly Linked List

| Feature | Singly Linked | Doubly Linked |
|---------|---------------|---------------|
| **Pointers per node** | 1 (next) | 2 (next, prev) |
| **Memory** | Less | More (extra prev pointer) |
| **Traversal** | Forward only | Both directions |
| **Delete given node** | O(n) - need previous | O(1) - have prev pointer |
| **Insert before node** | O(n) - need previous | O(1) - have prev pointer |
| **Reverse traversal** | Not possible | O(n) |

### Key Characteristics

- **Bidirectional Traversal**: Can move forward and backward
- **Easy Deletion**: Delete a node in O(1) if you have its reference
- **More Memory**: Requires extra pointer per node
- **Easier Operations**: Some operations simpler than singly linked list

### Complexity Analysis

| Operation | Singly LL | Doubly LL |
|-----------|-----------|-----------|
| **Access** | O(n) | O(n) |
| **Search** | O(n) | O(n) |
| **Insert at beginning** | O(1) | O(1) |
| **Insert at end** | O(n) or O(1)* | O(1)** |
| **Insert before node** | O(n) | O(1) |
| **Delete at beginning** | O(1) | O(1) |
| **Delete at end** | O(n) | O(1)** |
| **Delete given node** | O(n) | O(1) |

\* O(1) with tail pointer  
\*\* With tail pointer (standard in doubly LL)

### When to Use Doubly Linked List?

✅ **Use Doubly Linked List when**:
- Need bidirectional traversal
- Frequent deletions at both ends
- Need to delete nodes in O(1) given reference
- Implementing LRU cache, browser history
- Need previous node access frequently

❌ **Avoid when**:
- Memory is critical constraint
- Only forward traversal needed (use singly)
- Working with very small nodes (overhead too high)

---

## Node Structure

### Basic Node Class

```java
public class Node {
    int data;
    Node next;
    Node prev;
    
    // Constructor
    public Node(int data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
    
    // Constructor with both pointers
    public Node(int data, Node prev, Node next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}
```

### Generic Node Class

```java
public class Node<T> {
    T data;
    Node<T> next;
    Node<T> prev;
    
    public Node(T data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
    
    public Node(T data, Node<T> prev, Node<T> next) {
        this.data = data;
        this.prev = prev;
        this.next = next;
    }
}
```

**Advantage**: Allows any data type - `Node<Integer>`, `Node<String>`, etc.

---

## Basic Implementation

### Complete Doubly Linked List Class

```java
public class DoublyLinkedList {
    // Inner Node class
    private class Node {
        int data;
        Node next;
        Node prev;
        
        Node(int data) {
            this.data = data;
            this.next = null;
            this.prev = null;
        }
    }
    
    private Node head;  // First node
    private Node tail;  // Last node
    private int size;   // Number of nodes
    
    // Constructor
    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    // Check if list is empty
    public boolean isEmpty() {
        return head == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Display list forward
    public void displayForward() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        System.out.print("null ← ");
        Node current = head;
        while (current != null) {
            System.out.print(current.data);
            if (current.next != null) {
                System.out.print(" ↔ ");
            }
            current = current.next;
        }
        System.out.println(" → null");
    }
    
    // Display list backward
    public void displayBackward() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        System.out.print("null ← ");
        Node current = tail;
        while (current != null) {
            System.out.print(current.data);
            if (current.prev != null) {
                System.out.print(" ↔ ");
            }
            current = current.prev;
        }
        System.out.println(" → null");
    }
    
    // Test
    public static void main(String[] args) {
        DoublyLinkedList list = new DoublyLinkedList();
        System.out.println("Empty? " + list.isEmpty()); // true
        System.out.println("Size: " + list.size());     // 0
        list.displayForward();                           // List is empty
    }
}
```

---

## Core Operations

### 1. Insert at Beginning (addFirst)

**O(1) operation - very efficient**

```java
/**
 * Insert at beginning - O(1)
 */
public void addFirst(int data) {
    Node newNode = new Node(data);
    
    if (isEmpty()) {
        head = tail = newNode;
    } else {
        newNode.next = head;
        head.prev = newNode;
        head = newNode;
    }
    
    size++;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    
    list.addFirst(30);  // 30
    list.addFirst(20);  // 20 ↔ 30
    list.addFirst(10);  // 10 ↔ 20 ↔ 30
    
    list.displayForward();
    // Output: null ← 10 ↔ 20 ↔ 30 → null
}
```

**Visual Process**:
```
Initial: head=null, tail=null

After addFirst(30):
HEAD/TAIL → [null|30|null]

After addFirst(20):
HEAD → [null|20|●] ↔ [●|30|null] ← TAIL

After addFirst(10):
HEAD → [null|10|●] ↔ [●|20|●] ↔ [●|30|null] ← TAIL
```

**Complexity**: O(1) time, O(1) space

---

### 2. Insert at End (addLast)

**O(1) with tail pointer**

```java
/**
 * Insert at end - O(1) with tail pointer
 */
public void addLast(int data) {
    Node newNode = new Node(data);
    
    if (isEmpty()) {
        head = tail = newNode;
    } else {
        tail.next = newNode;
        newNode.prev = tail;
        tail = newNode;
    }
    
    size++;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    
    list.addLast(10);  // 10
    list.addLast(20);  // 10 ↔ 20
    list.addLast(30);  // 10 ↔ 20 ↔ 30
    
    list.displayForward();
    // Output: null ← 10 ↔ 20 ↔ 30 → null
}
```

**Visual Process**:
```
Before: HEAD → [●|10|●] ↔ [●|20|null] ← TAIL

Step 1: Create newNode
        newNode = [null|30|null]

Step 2: Link tail to newNode
        tail.next = newNode
        [●|20|●] → [null|30|null]

Step 3: Link newNode to tail
        newNode.prev = tail
        [●|20|●] ↔ [●|30|null]

Step 4: Update tail
        TAIL → [●|30|null]
```

**Complexity**: O(1) time, O(1) space

---

### 3. Insert at Position

**Insert at specific index**

```java
/**
 * Insert at specific position (0-based index)
 */
public void insertAt(int index, int data) {
    if (index < 0 || index > size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    // Insert at beginning
    if (index == 0) {
        addFirst(data);
        return;
    }
    
    // Insert at end
    if (index == size) {
        addLast(data);
        return;
    }
    
    // Insert in middle
    Node newNode = new Node(data);
    Node current = head;
    
    // Traverse to position
    for (int i = 0; i < index; i++) {
        current = current.next;
    }
    
    // Insert before current
    newNode.next = current;
    newNode.prev = current.prev;
    current.prev.next = newNode;
    current.prev = newNode;
    
    size++;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    
    list.addLast(10);
    list.addLast(30);
    list.insertAt(1, 20);  // Insert 20 at index 1
    
    list.displayForward();
    // Output: null ← 10 ↔ 20 ↔ 30 → null
}
```

**Visual Process** (Insert 25 at index 2):
```
Before: [●|10|●] ↔ [●|20|●] ↔ [●|30|●] ↔ [●|40|null]
                            current

Step 1: Create newNode = [null|25|null]

Step 2: Set newNode pointers
        newNode.next = current (30)
        newNode.prev = current.prev (20)
        [●|20|●] ← [●|25|●] → [●|30|●]

Step 3: Update surrounding nodes
        current.prev.next = newNode (20.next = 25)
        current.prev = newNode (30.prev = 25)

Result: [●|10|●] ↔ [●|20|●] ↔ [●|25|●] ↔ [●|30|●] ↔ [●|40|null]
```

**Complexity**: O(n) time, O(1) space

---

### 4. Delete from Beginning (removeFirst)

**O(1) operation**

```java
/**
 * Delete first node - O(1)
 */
public int removeFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    int data = head.data;
    
    if (head == tail) {  // Single node
        head = tail = null;
    } else {
        head = head.next;
        head.prev = null;
    }
    
    size--;
    return data;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println("Removed: " + list.removeFirst()); // 10
    list.displayForward();
    // Output: null ← 20 ↔ 30 → null
}
```

**Visual Process**:
```
Before: HEAD → [null|10|●] ↔ [●|20|●] ↔ [●|30|null] ← TAIL

Step 1: Move head forward
        HEAD → [●|20|●] ↔ [●|30|null]

Step 2: Remove backward link
        HEAD → [null|20|●] ↔ [●|30|null]

Note: [10] becomes garbage collected
```

**Complexity**: O(1) time, O(1) space

---

### 5. Delete from End (removeLast)

**O(1) with tail pointer - major advantage over singly linked list!**

```java
/**
 * Delete last node - O(1) with tail pointer
 */
public int removeLast() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    int data = tail.data;
    
    if (head == tail) {  // Single node
        head = tail = null;
    } else {
        tail = tail.prev;
        tail.next = null;
    }
    
    size--;
    return data;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println("Removed: " + list.removeLast()); // 30
    list.displayForward();
    // Output: null ← 10 ↔ 20 → null
}
```

**Visual Process**:
```
Before: HEAD → [null|10|●] ↔ [●|20|●] ↔ [●|30|null] ← TAIL

Step 1: Move tail backward
        [null|10|●] ↔ [●|20|null] ← TAIL

Step 2: Remove forward link
        Already done by tail = tail.prev

Note: [30] becomes garbage collected
```

**Complexity**: O(1) time, O(1) space ✨

---

### 6. Delete at Position

```java
/**
 * Delete node at specific position
 */
public int removeAt(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    if (index == 0) {
        return removeFirst();
    }
    
    if (index == size - 1) {
        return removeLast();
    }
    
    // Navigate to node
    Node current = head;
    for (int i = 0; i < index; i++) {
        current = current.next;
    }
    
    int data = current.data;
    
    // Update links
    current.prev.next = current.next;
    current.next.prev = current.prev;
    
    size--;
    return data;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    list.addLast(40);
    
    System.out.println("Removed: " + list.removeAt(2)); // 30
    list.displayForward();
    // Output: null ← 10 ↔ 20 ↔ 40 → null
}
```

**Visual Process** (Delete node at index 2):
```
Before: [●|10|●] ↔ [●|20|●] ↔ [●|30|●] ↔ [●|40|null]
                            current

Step 1: Update previous node's next
        current.prev.next = current.next
        [●|20|●] → [●|40|●]

Step 2: Update next node's prev
        current.next.prev = current.prev
        [●|20|●] ← [●|40|●]

Result: [●|10|●] ↔ [●|20|●] ↔ [●|40|null]
        [30] is now orphaned and garbage collected
```

**Complexity**: O(n) time, O(1) space

---

### 7. Delete Given Node (O(1)!)

**Major advantage of doubly linked list**

```java
/**
 * Delete a specific node in O(1)
 * Assumption: node is in the list and not null
 */
public void deleteNode(Node node) {
    if (node == null) {
        throw new IllegalArgumentException("Node cannot be null");
    }
    
    // Node is head
    if (node == head) {
        removeFirst();
        return;
    }
    
    // Node is tail
    if (node == tail) {
        removeLast();
        return;
    }
    
    // Node is in middle
    node.prev.next = node.next;
    node.next.prev = node.prev;
    size--;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    Node node20 = list.head.next;  // Reference to node with value 20
    list.addLast(20);
    list.addLast(30);
    
    // Direct deletion without traversal!
    list.deleteNode(node20);
    list.displayForward();
}
```

**Complexity**: O(1) time, O(1) space ⚡

---

### 8. Search Operation

```java
/**
 * Search for a value from beginning
 */
public int search(int target) {
    Node current = head;
    int index = 0;
    
    while (current != null) {
        if (current.data == target) {
            return index;
        }
        current = current.next;
        index++;
    }
    
    return -1;
}

/**
 * Search from end (backward)
 */
public int searchFromEnd(int target) {
    Node current = tail;
    int index = size - 1;
    
    while (current != null) {
        if (current.data == target) {
            return index;
        }
        current = current.prev;
        index--;
    }
    
    return -1;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println(list.search(20));          // 1
    System.out.println(list.searchFromEnd(20));   // 1
}
```

**Optimization**: Search from both ends simultaneously for faster results!

**Complexity**: O(n) time, O(1) space

---

### 9. Get Element at Index

```java
/**
 * Get value at specific index
 * Optimized: Search from nearest end
 */
public int get(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    Node current;
    
    // Optimize: choose direction
    if (index < size / 2) {
        // Search from head
        current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
    } else {
        // Search from tail
        current = tail;
        for (int i = size - 1; i > index; i--) {
            current = current.prev;
        }
    }
    
    return current.data;
}

/**
 * Get first element
 */
public int getFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    return head.data;
}

/**
 * Get last element
 */
public int getLast() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    return tail.data;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    for (int i = 0; i < 100; i++) {
        list.addLast(i);
    }
    
    System.out.println(list.get(10));      // Searches from head (faster)
    System.out.println(list.get(90));      // Searches from tail (faster)
    System.out.println(list.getFirst());   // 0
    System.out.println(list.getLast());    // 99
}
```

**Complexity**: O(n/2) average = O(n) time, O(1) space

---

## Common Patterns

### Pattern 1: Reverse Doubly Linked List

**Swap next and prev pointers**

```java
/**
 * Reverse doubly linked list
 * Time: O(n), Space: O(1)
 */
public void reverse() {
    if (head == null || head.next == null) {
        return;
    }
    
    Node current = head;
    Node temp = null;
    
    // Swap next and prev for each node
    while (current != null) {
        temp = current.prev;
        current.prev = current.next;
        current.next = temp;
        current = current.prev;  // Move to next (which was prev)
    }
    
    // Swap head and tail
    temp = head;
    head = tail;
    tail = temp;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.print("Original: ");
    list.displayForward();  // 10 ↔ 20 ↔ 30
    
    list.reverse();
    
    System.out.print("Reversed: ");
    list.displayForward();  // 30 ↔ 20 ↔ 10
}
```

**Visual Process**:
```
Before: [null|10|●] ↔ [●|20|●] ↔ [●|30|null]

Step 1: Swap 10's pointers
        [●|10|null] ← (swapped)

Step 2: Swap 20's pointers
        [null|20|●] ← (swapped)

Step 3: Swap 30's pointers
        [null|30|●] ← (swapped)

Step 4: Swap head and tail
        [null|30|●] ↔ [●|20|●] ↔ [●|10|null]
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 2: Find Pairs with Sum

**Using two pointers from both ends**

```java
/**
 * Find all pairs with given sum in sorted doubly linked list
 */
public void findPairsWithSum(int target) {
    if (head == null) return;
    
    Node left = head;
    Node right = tail;
    boolean found = false;
    
    while (left != right && left.prev != right) {
        int sum = left.data + right.data;
        
        if (sum == target) {
            System.out.println("(" + left.data + ", " + right.data + ")");
            left = left.next;
            right = right.prev;
            found = true;
        } else if (sum < target) {
            left = left.next;
        } else {
            right = right.prev;
        }
    }
    
    if (!found) {
        System.out.println("No pairs found");
    }
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(1);
    list.addLast(2);
    list.addLast(4);
    list.addLast(5);
    list.addLast(6);
    list.addLast(8);
    list.addLast(9);
    
    System.out.println("Pairs with sum 10:");
    list.findPairsWithSum(10);
    // Output: (1, 9) (2, 8) (4, 6)
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 3: Remove Duplicates

**For unsorted list using HashSet**

```java
/**
 * Remove duplicates from unsorted doubly linked list
 */
public void removeDuplicates() {
    if (head == null) return;
    
    Set<Integer> seen = new HashSet<>();
    Node current = head;
    
    while (current != null) {
        if (seen.contains(current.data)) {
            // Remove duplicate
            Node toRemove = current;
            current = current.next;
            deleteNode(toRemove);
        } else {
            seen.add(current.data);
            current = current.next;
        }
    }
}

/**
 * Remove duplicates from sorted list
 */
public void removeDuplicatesSorted() {
    if (head == null) return;
    
    Node current = head;
    
    while (current != null && current.next != null) {
        if (current.data == current.next.data) {
            Node duplicate = current.next;
            current.next = duplicate.next;
            if (duplicate.next != null) {
                duplicate.next.prev = current;
            } else {
                tail = current;
            }
            size--;
        } else {
            current = current.next;
        }
    }
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(10);
    list.addLast(30);
    list.addLast(20);
    
    System.out.print("Before: ");
    list.displayForward();  // 10 ↔ 20 ↔ 10 ↔ 30 ↔ 20
    
    list.removeDuplicates();
    
    System.out.print("After: ");
    list.displayForward();  // 10 ↔ 20 ↔ 30
}
```

**Complexity**: 
- Unsorted: O(n) time, O(n) space
- Sorted: O(n) time, O(1) space

---

### Pattern 4: Rotate List

**Rotate right by k positions**

```java
/**
 * Rotate list right by k positions
 */
public void rotate(int k) {
    if (head == null || k == 0) return;
    
    k = k % size;
    if (k == 0) return;
    
    // Find new tail (size - k - 1)
    Node newTail = head;
    for (int i = 0; i < size - k - 1; i++) {
        newTail = newTail.next;
    }
    
    Node newHead = newTail.next;
    
    // Break and reconnect
    newTail.next = null;
    newHead.prev = null;
    tail.next = head;
    head.prev = tail;
    
    head = newHead;
    tail = newTail;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    for (int i = 1; i <= 5; i++) {
        list.addLast(i);
    }
    
    System.out.print("Before: ");
    list.displayForward();  // 1 ↔ 2 ↔ 3 ↔ 4 ↔ 5
    
    list.rotate(2);
    
    System.out.print("After: ");
    list.displayForward();  // 4 ↔ 5 ↔ 1 ↔ 2 ↔ 3
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 5: Palindrome Check

**Using two pointers from both ends**

```java
/**
 * Check if doubly linked list is palindrome
 * More efficient than singly linked list!
 */
public boolean isPalindrome() {
    if (head == null || head == tail) {
        return true;
    }
    
    Node left = head;
    Node right = tail;
    
    while (left != right && left.prev != right) {
        if (left.data != right.data) {
            return false;
        }
        left = left.next;
        right = right.prev;
    }
    
    return true;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list1 = new DoublyLinkedList();
    list1.addLast(1);
    list1.addLast(2);
    list1.addLast(3);
    list1.addLast(2);
    list1.addLast(1);
    System.out.println(list1.isPalindrome()); // true
    
    DoublyLinkedList list2 = new DoublyLinkedList();
    list2.addLast(1);
    list2.addLast(2);
    list2.addLast(3);
    System.out.println(list2.isPalindrome()); // false
}
```

**Complexity**: O(n/2) = O(n) time, O(1) space
**Better than singly LL**: No need to reverse half of the list!

---

## Advanced Operations

### 1. LRU Cache Implementation

**Using Doubly Linked List + HashMap**

```java
/**
 * LRU Cache using Doubly Linked List
 */
class LRUCache {
    private class Node {
        int key, value;
        Node prev, next;
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Map<Integer, Node> cache;
    private int capacity;
    private Node head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        
        // Dummy head and tail
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        
        Node node = cache.get(key);
        remove(node);
        addToHead(node);
        
        return node.value;
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            remove(node);
            addToHead(node);
        } else {
            if (cache.size() == capacity) {
                Node lru = tail.prev;
                remove(lru);
                cache.remove(lru.key);
            }
            
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
        }
    }
    
    private void addToHead(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
    
    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

// Test
public static void main(String[] args) {
    LRUCache cache = new LRUCache(2);
    
    cache.put(1, 1);
    cache.put(2, 2);
    System.out.println(cache.get(1));    // 1
    cache.put(3, 3);                     // Evicts key 2
    System.out.println(cache.get(2));    // -1 (not found)
    cache.put(4, 4);                     // Evicts key 1
    System.out.println(cache.get(1));    // -1 (not found)
    System.out.println(cache.get(3));    // 3
    System.out.println(cache.get(4));    // 4
}
```

**Complexity**: O(1) for both get and put operations

---

### 2. Flatten Multi-level Doubly Linked List

```java
/**
 * Flatten a multi-level doubly linked list
 * Each node may have a child pointer to another list
 */
class MultiNode {
    int val;
    MultiNode prev, next, child;
    
    MultiNode(int val) {
        this.val = val;
    }
}

public MultiNode flatten(MultiNode head) {
    if (head == null) return null;
    
    MultiNode current = head;
    
    while (current != null) {
        if (current.child != null) {
            // Find tail of child list
            MultiNode childTail = current.child;
            while (childTail.next != null) {
                childTail = childTail.next;
            }
            
            // Insert child list
            childTail.next = current.next;
            if (current.next != null) {
                current.next.prev = childTail;
            }
            
            current.next = current.child;
            current.child.prev = current;
            current.child = null;
        }
        
        current = current.next;
    }
    
    return head;
}
```

**Complexity**: O(n) time, O(1) space

---

### 3. Sort Doubly Linked List

**Using Merge Sort**

```java
/**
 * Sort doubly linked list using merge sort
 */
public void mergeSort() {
    head = mergeSortHelper(head);
    
    // Update tail
    if (head != null) {
        tail = head;
        while (tail.next != null) {
            tail = tail.next;
        }
    }
}

private Node mergeSortHelper(Node node) {
    if (node == null || node.next == null) {
        return node;
    }
    
    // Split list
    Node middle = getMiddle(node);
    Node nextToMiddle = middle.next;
    
    middle.next = null;
    nextToMiddle.prev = null;
    
    // Sort both halves
    Node left = mergeSortHelper(node);
    Node right = mergeSortHelper(nextToMiddle);
    
    // Merge
    return merge(left, right);
}

private Node getMiddle(Node node) {
    if (node == null) return null;
    
    Node slow = node, fast = node;
    
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}

private Node merge(Node left, Node right) {
    if (left == null) return right;
    if (right == null) return left;
    
    if (left.data <= right.data) {
        left.next = merge(left.next, right);
        left.next.prev = left;
        left.prev = null;
        return left;
    } else {
        right.next = merge(left, right.next);
        right.next.prev = right;
        right.prev = null;
        return right;
    }
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(40);
    list.addLast(10);
    list.addLast(30);
    list.addLast(20);
    
    System.out.print("Before: ");
    list.displayForward();
    
    list.mergeSort();
    
    System.out.print("After: ");
    list.displayForward();
}
```

**Complexity**: O(n log n) time, O(log n) space

---

### 4. Clone List with Random Pointer

```java
class RandomNode {
    int data;
    RandomNode next, prev, random;
    
    RandomNode(int data) {
        this.data = data;
    }
}

/**
 * Clone doubly linked list with random pointer
 */
public RandomNode clone(RandomNode head) {
    if (head == null) return null;
    
    // Step 1: Create copy nodes interleaved
    RandomNode current = head;
    while (current != null) {
        RandomNode copy = new RandomNode(current.data);
        copy.next = current.next;
        current.next = copy;
        if (copy.next != null) {
            copy.next.prev = copy;
        }
        copy.prev = current;
        current = copy.next;
    }
    
    // Step 2: Copy random pointers
    current = head;
    while (current != null) {
        if (current.random != null) {
            current.next.random = current.random.next;
        }
        current = current.next.next;
    }
    
    // Step 3: Separate lists
    current = head;
    RandomNode copyHead = head.next;
    RandomNode copyCurrent = copyHead;
    
    while (current != null) {
        current.next = current.next.next;
        if (copyCurrent.next != null) {
            copyCurrent.next = copyCurrent.next.next;
            copyCurrent.next.prev = copyCurrent;
        }
        current = current.next;
        copyCurrent = copyCurrent.next;
    }
    
    copyHead.prev = null;
    return copyHead;
}
```

**Complexity**: O(n) time, O(1) space (excluding output)

---

## Interview Questions

### Question 1: Delete All Occurrences

**Problem**: Delete all nodes with given value.

```java
/**
 * Delete all occurrences of a value
 */
public void deleteAllOccurrences(int target) {
    Node current = head;
    
    while (current != null) {
        if (current.data == target) {
            Node toDelete = current;
            current = current.next;
            
            if (toDelete == head) {
                removeFirst();
            } else if (toDelete == tail) {
                removeLast();
            } else {
                toDelete.prev.next = toDelete.next;
                toDelete.next.prev = toDelete.prev;
                size--;
            }
        } else {
            current = current.next;
        }
    }
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(1);
    list.addLast(2);
    list.addLast(3);
    list.addLast(2);
    list.addLast(4);
    list.addLast(2);
    
    list.deleteAllOccurrences(2);
    list.displayForward();  // 1 ↔ 3 ↔ 4
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 2: Sort K-Sorted Doubly Linked List

**Problem**: Sort a list where each element is at most k positions away from sorted position.

```java
/**
 * Sort k-sorted doubly linked list using min heap
 */
public void sortKSorted(int k) {
    if (head == null) return;
    
    PriorityQueue<Node> minHeap = new PriorityQueue<>((a, b) -> a.data - b.data);
    
    // Add first k+1 elements to heap
    Node current = head;
    for (int i = 0; i <= k && current != null; i++) {
        minHeap.offer(current);
        current = current.next;
    }
    
    Node newHead = null, last = null;
    
    while (!minHeap.isEmpty()) {
        // Get minimum
        Node min = minHeap.poll();
        
        // Build sorted list
        if (newHead == null) {
            newHead = min;
            last = min;
            last.prev = null;
        } else {
            last.next = min;
            min.prev = last;
            last = min;
        }
        
        // Add next element
        if (current != null) {
            minHeap.offer(current);
            current = current.next;
        }
    }
    
    last.next = null;
    head = newHead;
    tail = last;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    list.addLast(3);
    list.addLast(2);
    list.addLast(1);
    list.addLast(5);
    list.addLast(6);
    list.addLast(4);
    
    list.sortKSorted(2);
    list.displayForward();  // 1 ↔ 2 ↔ 3 ↔ 4 ↔ 5 ↔ 6
}
```

**Complexity**: O(n log k) time, O(k) space

---

### Question 3: Reverse in Groups

**Problem**: Reverse list in groups of k.

```java
/**
 * Reverse doubly linked list in groups of k
 */
public void reverseInGroups(int k) {
    if (head == null || k <= 1) return;
    
    Node current = head;
    Node newHead = null;
    Node prevGroupTail = null;
    
    while (current != null) {
        Node groupStart = current;
        Node prev = null;
        int count = 0;
        
        // Reverse k nodes
        while (current != null && count < k) {
            Node next = current.next;
            current.next = prev;
            current.prev = next;
            prev = current;
            current = next;
            count++;
        }
        
        // Update head for first group
        if (newHead == null) {
            newHead = prev;
        }
        
        // Connect with previous group
        if (prevGroupTail != null) {
            prevGroupTail.next = prev;
            prev.prev = prevGroupTail;
        }
        
        prevGroupTail = groupStart;
    }
    
    head = newHead;
    tail = prevGroupTail;
}

// Test
public static void main(String[] args) {
    DoublyLinkedList list = new DoublyLinkedList();
    for (int i = 1; i <= 8; i++) {
        list.addLast(i);
    }
    
    System.out.print("Before: ");
    list.displayForward();  // 1 ↔ 2 ↔ 3 ↔ 4 ↔ 5 ↔ 6 ↔ 7 ↔ 8
    
    list.reverseInGroups(3);
    
    System.out.print("After: ");
    list.displayForward();  // 3 ↔ 2 ↔ 1 ↔ 6 ↔ 5 ↔ 4 ↔ 8 ↔ 7
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 4: Convert BST to Sorted Doubly Linked List

**Problem**: Convert binary search tree to sorted circular doubly linked list.

```java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

/**
 * Convert BST to sorted doubly linked list
 */
public Node bstToDLL(TreeNode root) {
    if (root == null) return null;
    
    Node[] headTail = new Node[2];
    convertHelper(root, headTail);
    
    return headTail[0];
}

private void convertHelper(TreeNode node, Node[] headTail) {
    if (node == null) return;
    
    // Convert left subtree
    convertHelper(node.left, headTail);
    
    // Create node for current
    Node current = new Node(node.val);
    
    if (headTail[1] != null) {
        headTail[1].next = current;
        current.prev = headTail[1];
    } else {
        headTail[0] = current;  // First node
    }
    
    headTail[1] = current;  // Update tail
    
    // Convert right subtree
    convertHelper(node.right, headTail);
}

// Test
public static void main(String[] args) {
    /*
            4
           / \
          2   5
         / \
        1   3
    */
    TreeNode root = new TreeNode(4);
    root.left = new TreeNode(2);
    root.right = new TreeNode(5);
    root.left.left = new TreeNode(1);
    root.left.right = new TreeNode(3);
    
    Node head = bstToDLL(root);
    // Result: 1 ↔ 2 ↔ 3 ↔ 4 ↔ 5
}
```

**Complexity**: O(n) time, O(h) space (recursion stack)

---

### Question 5: Quadruple Sum in Doubly Linked List

**Problem**: Find all quadruples with given sum.

```java
/**
 * Find quadruples with given sum in sorted DLL
 */
public void findQuadruplets(int target) {
    if (head == null) return;
    
    Node first = head;
    
    while (first != null) {
        Node second = first.next;
        
        while (second != null) {
            Node left = second.next;
            Node right = tail;
            
            while (left != right && left.prev != right) {
                int sum = first.data + second.data + left.data + right.data;
                
                if (sum == target) {
                    System.out.println("(" + first.data + ", " + second.data + 
                                     ", " + left.data + ", " + right.data + ")");
                    left = left.next;
                    right = right.prev;
                } else if (sum < target) {
                    left = left.next;
                } else {
                    right = right.prev;
                }
            }
            
            second = second.next;
        }
        
        first = first.next;
    }
}
```

**Complexity**: O(n³) time, O(1) space

---

## Practice Problems

### Easy Level

1. **Design Doubly Linked List** (LC 707)
   - Implement basic operations
   - Solution: Maintain head and tail

2. **Delete Node in DLL**
   - Delete given node reference
   - Solution: O(1) using prev pointer

3. **Reverse Doubly Linked List**
   - Reverse the list
   - Solution: Swap next and prev

4. **Find Middle Element**
   - Find middle node
   - Solution: Slow-fast pointers

5. **Palindrome Check**
   - Check if palindrome
   - Solution: Two pointers from ends

### Medium Level

6. **LRU Cache** (LC 146)
   - Implement LRU cache
   - Solution: DLL + HashMap

7. **Flatten Multi-level List** (LC 430)
   - Flatten nested list
   - Solution: DFS traversal

8. **Rotate Doubly Linked List**
   - Rotate by k positions
   - Solution: Find new head/tail

9. **Remove Duplicates**
   - Remove all duplicates
   - Solution: HashSet or two pointers

10. **Sort K-Sorted List**
    - Sort nearly sorted list
    - Solution: Min heap

### Hard Level

11. **Convert BST to DLL** (LC 426)
    - In-place conversion
    - Solution: Inorder traversal

12. **Reverse in K-Groups**
    - Reverse groups of k
    - Solution: Iterative reversal

13. **Clone with Random Pointer** (LC 138)
    - Deep copy with random
    - Solution: Interleaving

14. **All O(1) Data Structure** (LC 432)
    - Inc/dec/getMax/getMin in O(1)
    - Solution: DLL + HashMap

15. **Design Browser History** (LC 1472)
    - Back/forward navigation
    - Solution: Doubly linked list

---

## Summary

### Key Takeaways

1. **Bidirectional Traversal**: Major advantage over singly linked list
2. **O(1) Delete at End**: With tail pointer (vs O(n) for singly)
3. **O(1) Delete Given Node**: No need to find previous node
4. **More Memory**: Extra prev pointer per node
5. **Perfect for LRU Cache**: Fast add/remove from both ends

### Operations Complexity Summary

| Operation | Singly LL | Doubly LL |
|-----------|-----------|-----------|
| addFirst | O(1) | O(1) |
| addLast | O(n) or O(1)* | O(1) |
| removeFirst | O(1) | O(1) |
| removeLast | O(n) | O(1) ⭐ |
| deleteNode(node) | O(n) | O(1) ⭐ |
| reverse | O(n) | O(n) |
| palindrome | O(n) + reverse | O(n/2) ⭐ |

### Common Patterns Checklist

- [ ] Reverse list (swap next/prev)
- [ ] Two pointers from both ends
- [ ] Delete node in O(1)
- [ ] LRU cache implementation
- [ ] Flatten multi-level list
- [ ] Convert BST to DLL
- [ ] Rotate list
- [ ] Remove duplicates

### When to Choose Doubly Linked List

```
Choose Doubly LL over Singly LL:
✓ Need backward traversal
✓ Frequent deletions at end
✓ Delete nodes in O(1) given reference
✓ LRU cache, browser history
✓ Undo/Redo functionality
✓ Two-pointer problems

Choose Singly LL:
✓ Memory is critical
✓ Only forward traversal
✓ Simple stack implementation
✓ Smaller overhead acceptable
```

### Real-World Applications

1. **LRU Cache**: Most recently used items tracking
2. **Browser History**: Back/forward navigation
3. **Undo/Redo**: Text editors, graphics software
4. **Music Player**: Previous/next song
5. **Task Scheduler**: Priority-based scheduling
6. **Memory Management**: Free block list

### Common Mistakes to Avoid

1. **Forgetting to Update Prev**: Always update both next and prev
2. **Not Handling Head/Tail**: Check edge cases
3. **Losing References**: Keep track before modifying
4. **Not Updating Size**: Maintain size counter
5. **Null Pointer Errors**: Check null before accessing prev/next

### Interview Tips

1. **Clarify Circular or Not**: Circular DLL is different
2. **Ask About Tail Pointer**: Usually present in DLL
3. **Draw the Links**: Visualize all 4 link changes
4. **Leverage Prev Pointer**: Use it for O(1) operations
5. **Consider Both Directions**: Can traverse from both ends

### Comparison with Other Structures

| Feature | Array | Singly LL | Doubly LL |
|---------|-------|-----------|-----------|
| Random Access | O(1) | O(n) | O(n) |
| Insert Begin | O(n) | O(1) | O(1) |
| Insert End | O(1)* | O(n)/O(1) | O(1) |
| Delete End | O(1)* | O(n) | O(1) |
| Memory | Compact | Medium | High |
| Cache Friendly | Yes | No | No |

---

**Previous**: [7.1 Singly Linked List](7.1-Singly-Linked-List.md)

**Next**: [7.3 Circular Linked List](7.3-Circular-Linked-List.md) - Learn about circular variants

**Practice**: Focus on LRU Cache and two-pointer problems!
