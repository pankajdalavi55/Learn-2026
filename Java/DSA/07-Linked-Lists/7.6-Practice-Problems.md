# 7.6 Linked List Practice Problems

## Table of Contents
1. [Introduction](#introduction)
2. [Easy Problems](#easy-problems)
3. [Medium Problems](#medium-problems)
4. [Hard Problems](#hard-problems)
5. [Problems by Pattern](#problems-by-pattern)
6. [Company-Specific Problems](#company-specific-problems)
7. [Problem-Solving Strategies](#problem-solving-strategies)
8. [Summary](#summary)

---

## Introduction

### How to Use This Guide

This comprehensive problem set covers all linked list patterns:
- **Basic Operations**: Insert, delete, search
- **Fast-Slow Pointer**: Middle, cycle detection
- **Reversal**: Complete, partial, groups
- **Two Pointers**: Merge, intersection
- **Advanced**: LRU cache, flatten, clone

### Problem Categories

| Category | Count | Key Patterns |
|----------|-------|--------------|
| **Easy** | 15 | Basic traversal, simple operations |
| **Medium** | 25 | Fast-slow, reversal, two pointers |
| **Hard** | 10 | K-group reversal, merge K lists |
| **Total** | 50 | All patterns covered |

### Difficulty Distribution

```
Easy (30%):    ███████░░░░░░░░░░░░░░
Medium (50%):  ██████████████████░░
Hard (20%):    ████████░░░░░░░░░░░░
```

### Study Plan

**Week 1: Fundamentals**
- Day 1-2: Basic operations (Easy)
- Day 3-4: Fast-slow pointer (Easy-Medium)
- Day 5-7: Reversal techniques (Medium)

**Week 2: Advanced**
- Day 1-3: Two pointers & merge (Medium)
- Day 4-5: Complex patterns (Medium-Hard)
- Day 6-7: Hard problems & review

---

## Easy Problems

### Problem 1: Reverse Linked List ⭐⭐⭐

**LeetCode 206** | **Frequency: Very High** | **Pattern: Reversal**

**Problem**: Reverse a singly linked list.

```
Input: 1 → 2 → 3 → 4 → 5 → null
Output: 5 → 4 → 3 → 2 → 1 → null
```

**Solution 1: Iterative (Recommended)**
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        
        return prev;
    }
}
```

**Solution 2: Recursive**
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        
        return newHead;
    }
}
```

**Complexity**: 
- Iterative: O(n) time, O(1) space ✅
- Recursive: O(n) time, O(n) space

**Key Points**:
- Master this pattern - used in 30%+ of problems
- Three pointers: prev, current, next
- Remember to return `prev` not `current`

---

### Problem 2: Middle of Linked List

**LeetCode 876** | **Frequency: High** | **Pattern: Fast-Slow Pointer**

**Problem**: Find the middle node. If even length, return second middle.

```
Input: 1 → 2 → 3 → 4 → 5 → null
Output: 3

Input: 1 → 2 → 3 → 4 → null
Output: 3
```

**Solution**:
```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return slow;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Fast moves 2x speed of slow
- When fast reaches end, slow is at middle
- Loop condition: `fast != null && fast.next != null`

---

### Problem 3: Merge Two Sorted Lists

**LeetCode 21** | **Frequency: Very High** | **Pattern: Two Pointers**

**Problem**: Merge two sorted linked lists.

```
Input: l1 = 1 → 2 → 4, l2 = 1 → 3 → 4
Output: 1 → 1 → 2 → 3 → 4 → 4
```

**Solution**:
```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }
        
        // Attach remaining nodes
        current.next = (l1 != null) ? l1 : l2;
        
        return dummy.next;
    }
}
```

**Complexity**: O(m + n) time, O(1) space

**Key Points**:
- Use dummy node to simplify edge cases
- Compare and attach smaller node
- Don't forget remaining nodes

---

### Problem 4: Linked List Cycle

**LeetCode 141** | **Frequency: Very High** | **Pattern: Fast-Slow (Floyd's)**

**Problem**: Detect if linked list has a cycle.

```
Input: 3 → 2 → 0 → -4 → (back to 2)
Output: true
```

**Solution**:
```java
class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Floyd's cycle detection algorithm
- If cycle exists, fast will catch slow
- O(1) space vs O(n) with HashSet

---

### Problem 5: Delete Node in Linked List

**LeetCode 237** | **Frequency: Medium** | **Pattern: Pointer Manipulation**

**Problem**: Delete a node given only access to that node (not head).

```
Input: 4 → 5 → 1 → 9, node = 5
Output: 4 → 1 → 9
```

**Solution**:
```java
class Solution {
    public void deleteNode(ListNode node) {
        // Copy next node's value
        node.val = node.next.val;
        // Delete next node
        node.next = node.next.next;
    }
}
```

**Complexity**: O(1) time, O(1) space

**Key Points**:
- Can't delete last node this way
- Copy next node's data, delete next
- Clever trick but not standard deletion

---

### Problem 6: Remove Duplicates from Sorted List

**LeetCode 83** | **Frequency: Medium** | **Pattern: Two Pointers**

**Problem**: Remove duplicates from sorted linked list.

```
Input: 1 → 1 → 2 → 3 → 3 → null
Output: 1 → 2 → 3 → null
```

**Solution**:
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode current = head;
        
        while (current != null && current.next != null) {
            if (current.val == current.next.val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        
        return head;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Sorted list: duplicates are adjacent
- Skip duplicate nodes by updating next
- Don't move current when deleting

---

### Problem 7: Intersection of Two Linked Lists

**LeetCode 160** | **Frequency: High** | **Pattern: Two Pointers**

**Problem**: Find the node where two lists intersect.

```
Input: 
A:     4 → 1 ↘
              8 → 4 → 5 → null
B: 5 → 6 → 1 ↗

Output: 8
```

**Solution**:
```java
class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        
        ListNode a = headA;
        ListNode b = headB;
        
        // When a reaches end, redirect to headB
        // When b reaches end, redirect to headA
        while (a != b) {
            a = (a == null) ? headB : a.next;
            b = (b == null) ? headA : b.next;
        }
        
        return a;
    }
}
```

**Complexity**: O(m + n) time, O(1) space

**Key Points**:
- Clever two-pointer technique
- Both travel same total distance
- Meet at intersection or null

---

### Problem 8: Remove Linked List Elements

**LeetCode 203** | **Frequency: Medium** | **Pattern: Dummy Node**

**Problem**: Remove all nodes with value `val`.

```
Input: 1 → 2 → 6 → 3 → 4 → 5 → 6 → null, val = 6
Output: 1 → 2 → 3 → 4 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode current = dummy;
        
        while (current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Dummy node handles head deletion
- Check current.next, not current
- Skip or move based on value

---

### Problem 9: Palindrome Linked List

**LeetCode 234** | **Frequency: High** | **Pattern: Fast-Slow + Reversal**

**Problem**: Check if linked list is palindrome.

```
Input: 1 → 2 → 2 → 1 → null
Output: true
```

**Solution**:
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }
        
        // Find middle
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Reverse second half
        ListNode secondHalf = reverse(slow.next);
        
        // Compare
        ListNode p1 = head;
        ListNode p2 = secondHalf;
        
        while (p2 != null) {
            if (p1.val != p2.val) {
                return false;
            }
            p1 = p1.next;
            p2 = p2.next;
        }
        
        return true;
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Find middle using fast-slow
- Reverse second half
- Compare both halves

---

### Problem 10: Convert Binary Number in Linked List

**LeetCode 1290** | **Frequency: Low** | **Pattern: Traversal**

**Problem**: Convert binary linked list to decimal.

```
Input: 1 → 0 → 1 → null
Output: 5 (binary 101 = decimal 5)
```

**Solution**:
```java
class Solution {
    public int getDecimalValue(ListNode head) {
        int result = 0;
        
        while (head != null) {
            result = result * 2 + head.val;
            head = head.next;
        }
        
        return result;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

## Medium Problems

### Problem 11: Add Two Numbers ⭐⭐⭐

**LeetCode 2** | **Frequency: Very High** | **Pattern: Two Pointers**

**Problem**: Add two numbers represented as linked lists (reversed).

```
Input: l1 = 2 → 4 → 3, l2 = 5 → 6 → 4
Output: 7 → 0 → 8
(342 + 465 = 807)
```

**Solution**:
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {
            int sum = carry;
            
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }
            
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }
            
            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(max(m, n)) time, O(max(m, n)) space

**Key Points**:
- Process digit by digit with carry
- Continue until both lists and carry are done
- Create new list for result

---

### Problem 12: Remove Nth Node From End ⭐⭐⭐

**LeetCode 19** | **Frequency: Very High** | **Pattern: Two Pointers**

**Problem**: Remove nth node from end in one pass.

```
Input: 1 → 2 → 3 → 4 → 5 → null, n = 2
Output: 1 → 2 → 3 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;
        
        // Move fast n+1 steps ahead
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }
        
        // Move both until fast reaches end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        
        // Remove nth node
        slow.next = slow.next.next;
        
        return dummy.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Gap of n between fast and slow
- When fast reaches end, slow is before target
- Dummy node handles edge case

---

### Problem 13: Linked List Cycle II ⭐⭐⭐

**LeetCode 142** | **Frequency: High** | **Pattern: Floyd's Extended**

**Problem**: Find the node where cycle begins.

```
Input: 3 → 2 → 0 → -4 → (back to 2)
Output: 2
```

**Solution**:
```java
class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        
        ListNode slow = head;
        ListNode fast = head;
        
        // Phase 1: Detect cycle
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                // Phase 2: Find cycle start
                slow = head;
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                return slow;
            }
        }
        
        return null;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Two phases: detect, then find start
- Mathematical proof: distance from head = distance from meeting point
- Move both one step at a time in phase 2

---

### Problem 14: Reorder List ⭐⭐⭐

**LeetCode 143** | **Frequency: High** | **Pattern: Fast-Slow + Reversal**

**Problem**: Reorder L0→L1→...→Ln to L0→Ln→L1→Ln-1→...

```
Input: 1 → 2 → 3 → 4 → null
Output: 1 → 4 → 2 → 3 → null
```

**Solution**:
```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null || head.next == null) {
            return;
        }
        
        // Find middle
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Reverse second half
        ListNode secondHalf = reverse(slow.next);
        slow.next = null;
        
        // Merge alternately
        ListNode first = head;
        ListNode second = secondHalf;
        
        while (second != null) {
            ListNode temp1 = first.next;
            ListNode temp2 = second.next;
            
            first.next = second;
            second.next = temp1;
            
            first = temp1;
            second = temp2;
        }
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Three steps: find middle, reverse, merge
- Combine multiple patterns
- In-place modification

---

### Problem 15: Swap Nodes in Pairs ⭐⭐

**LeetCode 24** | **Frequency: Medium** | **Pattern: Reversal**

**Problem**: Swap every two adjacent nodes.

```
Input: 1 → 2 → 3 → 4 → null
Output: 2 → 1 → 4 → 3 → null
```

**Solution**:
```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        while (prev.next != null && prev.next.next != null) {
            ListNode first = prev.next;
            ListNode second = prev.next.next;
            
            // Swap
            first.next = second.next;
            second.next = first;
            prev.next = second;
            
            prev = first;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 16: Odd Even Linked List

**LeetCode 328** | **Frequency: Medium** | **Pattern: Two Pointers**

**Problem**: Group odd index nodes then even index nodes.

```
Input: 1 → 2 → 3 → 4 → 5 → null
Output: 1 → 3 → 5 → 2 → 4 → null
```

**Solution**:
```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        ListNode odd = head;
        ListNode even = head.next;
        ListNode evenHead = even;
        
        while (even != null && even.next != null) {
            odd.next = even.next;
            odd = odd.next;
            even.next = odd.next;
            even = even.next;
        }
        
        odd.next = evenHead;
        return head;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 17: Reverse Linked List II ⭐⭐⭐

**LeetCode 92** | **Frequency: High** | **Pattern: Partial Reversal**

**Problem**: Reverse nodes from position left to right.

```
Input: 1 → 2 → 3 → 4 → 5 → null, left = 2, right = 4
Output: 1 → 4 → 3 → 2 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (head == null || left == right) {
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        // Move to node before left
        for (int i = 1; i < left; i++) {
            prev = prev.next;
        }
        
        // Reverse
        ListNode current = prev.next;
        for (int i = 0; i < right - left; i++) {
            ListNode next = current.next;
            current.next = next.next;
            next.next = prev.next;
            prev.next = next;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 18: Partition List

**LeetCode 86** | **Frequency: Medium** | **Pattern: Two Lists**

**Problem**: Partition around value x (less than x, then >= x).

```
Input: 1 → 4 → 3 → 2 → 5 → 2 → null, x = 3
Output: 1 → 2 → 2 → 4 → 3 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode beforeHead = new ListNode(0);
        ListNode afterHead = new ListNode(0);
        ListNode before = beforeHead;
        ListNode after = afterHead;
        
        while (head != null) {
            if (head.val < x) {
                before.next = head;
                before = before.next;
            } else {
                after.next = head;
                after = after.next;
            }
            head = head.next;
        }
        
        after.next = null;
        before.next = afterHead.next;
        
        return beforeHead.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 19: Rotate List

**LeetCode 61** | **Frequency: Medium** | **Pattern: Two Pointers**

**Problem**: Rotate list to the right by k places.

```
Input: 1 → 2 → 3 → 4 → 5 → null, k = 2
Output: 4 → 5 → 1 → 2 → 3 → null
```

**Solution**:
```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k == 0) {
            return head;
        }
        
        // Find length and last node
        int length = 1;
        ListNode last = head;
        while (last.next != null) {
            last = last.next;
            length++;
        }
        
        // Normalize k
        k = k % length;
        if (k == 0) return head;
        
        // Find new tail
        ListNode newTail = head;
        for (int i = 0; i < length - k - 1; i++) {
            newTail = newTail.next;
        }
        
        // Rotate
        ListNode newHead = newTail.next;
        newTail.next = null;
        last.next = head;
        
        return newHead;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 20: Sort List ⭐⭐⭐

**LeetCode 148** | **Frequency: High** | **Pattern: Merge Sort**

**Problem**: Sort linked list in O(n log n) time.

```
Input: 4 → 2 → 1 → 3 → null
Output: 1 → 2 → 3 → 4 → null
```

**Solution**:
```java
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        // Find middle
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;
        
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Split
        prev.next = null;
        
        // Sort both halves
        ListNode left = sortList(head);
        ListNode right = sortList(slow);
        
        // Merge
        return merge(left, right);
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }
        
        current.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}
```

**Complexity**: O(n log n) time, O(log n) space

---

### Problem 21: Copy List with Random Pointer ⭐⭐⭐

**LeetCode 138** | **Frequency: High** | **Pattern: Interleaving**

**Problem**: Deep copy list where each node has random pointer.

**Solution**:
```java
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        
        // Step 1: Create copy nodes interleaved
        Node current = head;
        while (current != null) {
            Node copy = new Node(current.val);
            copy.next = current.next;
            current.next = copy;
            current = copy.next;
        }
        
        // Step 2: Copy random pointers
        current = head;
        while (current != null) {
            if (current.random != null) {
                current.next.random = current.random.next;
            }
            current = current.next.next;
        }
        
        // Step 3: Separate lists
        current = head;
        Node copyHead = head.next;
        Node copyCurrent = copyHead;
        
        while (current != null) {
            current.next = current.next.next;
            if (copyCurrent.next != null) {
                copyCurrent.next = copyCurrent.next.next;
            }
            current = current.next;
            copyCurrent = copyCurrent.next;
        }
        
        return copyHead;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 22: Flatten Multilevel Doubly Linked List

**LeetCode 430** | **Frequency: Medium** | **Pattern: DFS**

**Problem**: Flatten a multilevel doubly linked list.

**Solution**:
```java
class Solution {
    public Node flatten(Node head) {
        if (head == null) return null;
        
        Node current = head;
        
        while (current != null) {
            if (current.child != null) {
                // Find tail of child
                Node childTail = current.child;
                while (childTail.next != null) {
                    childTail = childTail.next;
                }
                
                // Insert child list
                childTail.next = current.next;
                if (current.next != null) {
                    current.next.prev = childTail;
                }
                
                current.next = current.child;
                current.child.prev = current;
                current.child = null;
            }
            
            current = current.next;
        }
        
        return head;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 23: Delete Middle Node

**LeetCode 2095** | **Frequency: Medium** | **Pattern: Fast-Slow**

**Problem**: Delete the middle node of the list.

```
Input: 1 → 3 → 4 → 7 → 1 → 2 → 6 → null
Output: 1 → 3 → 4 → 1 → 2 → 6 → null
```

**Solution**:
```java
class Solution {
    public ListNode deleteMiddle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        
        ListNode slow = head;
        ListNode fast = head;
        ListNode prev = null;
        
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        
        prev.next = slow.next;
        return head;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 24: Maximum Twin Sum

**LeetCode 2130** | **Frequency: Low** | **Pattern: Fast-Slow + Reversal**

**Problem**: Find maximum twin sum (ith and (n-1-i)th nodes).

```
Input: 5 → 4 → 2 → 1 → null
Output: 6 (max of 5+1=6, 4+2=6)
```

**Solution**:
```java
class Solution {
    public int pairSum(ListNode head) {
        // Find middle
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Reverse second half
        ListNode secondHalf = reverse(slow);
        
        // Find max sum
        int maxSum = 0;
        ListNode first = head;
        ListNode second = secondHalf;
        
        while (second != null) {
            maxSum = Math.max(maxSum, first.val + second.val);
            first = first.next;
            second = second.next;
        }
        
        return maxSum;
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 25: Add Two Numbers II

**LeetCode 445** | **Frequency: Medium** | **Pattern: Reversal**

**Problem**: Add two numbers (most significant digit first).

```
Input: l1 = 7 → 2 → 4 → 3, l2 = 5 → 6 → 4
Output: 7 → 8 → 0 → 7
```

**Solution**:
```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // Reverse both
        l1 = reverse(l1);
        l2 = reverse(l2);
        
        // Add
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        int carry = 0;
        
        while (l1 != null || l2 != null || carry != 0) {
            int sum = carry;
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }
            
            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }
        
        // Reverse result
        return reverse(dummy.next);
    }
    
    private ListNode reverse(ListNode head) {
        ListNode prev = null;
        while (head != null) {
            ListNode next = head.next;
            head.next = prev;
            prev = head;
            head = next;
        }
        return prev;
    }
}
```

**Complexity**: O(max(m, n)) time, O(1) space

---

## Hard Problems

### Problem 26: Reverse Nodes in k-Group ⭐⭐⭐⭐

**LeetCode 25** | **Frequency: High** | **Pattern: Group Reversal**

**Problem**: Reverse k nodes at a time. If remaining < k, keep as is.

```
Input: 1 → 2 → 3 → 4 → 5 → null, k = 2
Output: 2 → 1 → 4 → 3 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null || k == 1) {
            return head;
        }
        
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prevGroupEnd = dummy;
        
        while (true) {
            // Check if k nodes available
            ListNode kth = getKth(prevGroupEnd, k);
            if (kth == null) break;
            
            ListNode nextGroupStart = kth.next;
            
            // Reverse k nodes
            ListNode prev = nextGroupStart;
            ListNode current = prevGroupEnd.next;
            
            while (current != nextGroupStart) {
                ListNode next = current.next;
                current.next = prev;
                prev = current;
                current = next;
            }
            
            // Connect with previous group
            ListNode temp = prevGroupEnd.next;
            prevGroupEnd.next = kth;
            prevGroupEnd = temp;
        }
        
        return dummy.next;
    }
    
    private ListNode getKth(ListNode current, int k) {
        while (current != null && k > 0) {
            current = current.next;
            k--;
        }
        return current;
    }
}
```

**Complexity**: O(n) time, O(1) space

**Key Points**:
- Most important hard linked list problem
- Check if k nodes available before reversing
- Carefully manage connections between groups

---

### Problem 27: Merge k Sorted Lists ⭐⭐⭐⭐

**LeetCode 23** | **Frequency: Very High** | **Pattern: Priority Queue**

**Problem**: Merge k sorted linked lists.

**Solution 1: Priority Queue**
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        
        // Add first node of each list
        for (ListNode node : lists) {
            if (node != null) {
                pq.offer(node);
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!pq.isEmpty()) {
            ListNode node = pq.poll();
            current.next = node;
            current = current.next;
            
            if (node.next != null) {
                pq.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}
```

**Solution 2: Divide and Conquer**
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        return mergeHelper(lists, 0, lists.length - 1);
    }
    
    private ListNode mergeHelper(ListNode[] lists, int left, int right) {
        if (left == right) {
            return lists[left];
        }
        
        int mid = left + (right - left) / 2;
        ListNode l1 = mergeHelper(lists, left, mid);
        ListNode l2 = mergeHelper(lists, mid + 1, right);
        
        return merge(l1, l2);
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                current.next = l1;
                l1 = l1.next;
            } else {
                current.next = l2;
                l2 = l2.next;
            }
            current = current.next;
        }
        
        current.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}
```

**Complexity**: 
- Priority Queue: O(n log k) time, O(k) space
- Divide & Conquer: O(n log k) time, O(log k) space

---

### Problem 28: LRU Cache ⭐⭐⭐⭐

**LeetCode 146** | **Frequency: Very High** | **Pattern: Doubly LL + HashMap**

**Problem**: Implement LRU cache with O(1) get and put.

**Solution**:
```java
class LRUCache {
    class Node {
        int key, value;
        Node prev, next;
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Map<Integer, Node> cache;
    private int capacity;
    private Node head, tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        
        // Dummy head and tail
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        
        Node node = cache.get(key);
        remove(node);
        addToHead(node);
        
        return node.value;
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            remove(node);
            addToHead(node);
        } else {
            if (cache.size() == capacity) {
                Node lru = tail.prev;
                remove(lru);
                cache.remove(lru.key);
            }
            
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            addToHead(newNode);
        }
    }
    
    private void addToHead(Node node) {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }
    
    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}
```

**Complexity**: O(1) for both operations

---

### Problem 29: Find Duplicate Number

**LeetCode 287** | **Frequency: High** | **Pattern: Floyd's (Array as LL)**

**Problem**: Find duplicate in array [1..n] without modifying.

```
Input: [1,3,4,2,2]
Output: 2
```

**Solution**:
```java
class Solution {
    public int findDuplicate(int[] nums) {
        // Treat array as linked list
        int slow = nums[0];
        int fast = nums[0];
        
        // Find intersection
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        
        // Find cycle start (duplicate)
        slow = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        
        return slow;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 30: Remove Duplicates from Sorted List II

**LeetCode 82** | **Frequency: Medium** | **Pattern: Dummy Node**

**Problem**: Remove all nodes with duplicate values.

```
Input: 1 → 2 → 3 → 3 → 4 → 4 → 5 → null
Output: 1 → 2 → 5 → null
```

**Solution**:
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        while (head != null) {
            // If duplicate values exist
            if (head.next != null && head.val == head.next.val) {
                // Skip all duplicates
                while (head.next != null && head.val == head.next.val) {
                    head = head.next;
                }
                prev.next = head.next;
            } else {
                prev = prev.next;
            }
            head = head.next;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 31: All O(1) Data Structure

**LeetCode 432** | **Frequency: Hard** | **Pattern: Doubly LL + HashMap**

**Problem**: Implement data structure with O(1) inc, dec, getMax, getMin.

**Solution**: Complex implementation using doubly linked list of buckets.

---

### Problem 32: Design Browser History

**LeetCode 1472** | **Frequency: Medium** | **Pattern: Doubly Linked List**

**Problem**: Implement browser history with back/forward.

**Solution**:
```java
class BrowserHistory {
    class Node {
        String url;
        Node prev, next;
        Node(String url) {
            this.url = url;
        }
    }
    
    private Node current;
    
    public BrowserHistory(String homepage) {
        current = new Node(homepage);
    }
    
    public void visit(String url) {
        Node newNode = new Node(url);
        current.next = newNode;
        newNode.prev = current;
        current = newNode;
    }
    
    public String back(int steps) {
        while (steps > 0 && current.prev != null) {
            current = current.prev;
            steps--;
        }
        return current.url;
    }
    
    public String forward(int steps) {
        while (steps > 0 && current.next != null) {
            current = current.next;
            steps--;
        }
        return current.url;
    }
}
```

**Complexity**: O(1) for visit, O(steps) for back/forward

---

### Problem 33: Sort List with Insertion Sort

**LeetCode 147** | **Frequency: Low** | **Pattern: Insertion Sort**

**Problem**: Sort using insertion sort algorithm.

**Solution**:
```java
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(0);
        ListNode current = head;
        
        while (current != null) {
            ListNode next = current.next;
            
            // Find insertion position
            ListNode prev = dummy;
            while (prev.next != null && prev.next.val < current.val) {
                prev = prev.next;
            }
            
            // Insert
            current.next = prev.next;
            prev.next = current;
            
            current = next;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n²) time, O(1) space

---

## Problems by Pattern

### Fast-Slow Pointer Problems

| # | Problem | Difficulty | Key Concept |
|---|---------|------------|-------------|
| 876 | Middle of Linked List | Easy | Basic fast-slow |
| 141 | Linked List Cycle | Easy | Floyd's detection |
| 142 | Linked List Cycle II | Medium | Find cycle start |
| 234 | Palindrome Linked List | Easy | Middle + reverse |
| 143 | Reorder List | Medium | Middle + reverse + merge |
| 2095 | Delete Middle | Medium | Middle with prev |
| 2130 | Maximum Twin Sum | Medium | Middle + reverse |
| 148 | Sort List | Medium | Middle for merge sort |

### Reversal Problems

| # | Problem | Difficulty | Type |
|---|---------|------------|------|
| 206 | Reverse Linked List | Easy | Complete |
| 92 | Reverse Linked List II | Medium | Partial |
| 25 | Reverse Nodes in k-Group | Hard | Groups |
| 24 | Swap Nodes in Pairs | Medium | Pairs |
| 143 | Reorder List | Medium | Half reverse |
| 445 | Add Two Numbers II | Medium | Reverse + add |

### Two Pointer Problems

| # | Problem | Difficulty | Concept |
|---|---------|------------|---------|
| 21 | Merge Two Sorted Lists | Easy | Merge |
| 19 | Remove Nth From End | Medium | Gap technique |
| 160 | Intersection | Easy | Equal distance |
| 86 | Partition List | Medium | Two lists |
| 328 | Odd Even List | Medium | Odd/even split |

### HashMap + Linked List

| # | Problem | Difficulty | Structure |
|---|---------|------------|-----------|
| 146 | LRU Cache | Medium | DLL + Map |
| 432 | All O(1) DS | Hard | DLL + Map |
| 138 | Copy Random Pointer | Medium | Map or interleave |
| 1472 | Browser History | Medium | DLL |

---

## Company-Specific Problems

### Google (Top 10)

1. **Reverse Linked List** (LC 206) - Most asked
2. **Merge Two Sorted Lists** (LC 21)
3. **LRU Cache** (LC 146) - Very common
4. **Copy List with Random** (LC 138)
5. **Palindrome Linked List** (LC 234)
6. **Reverse Nodes in k-Group** (LC 25)
7. **Add Two Numbers** (LC 2)
8. **Remove Nth From End** (LC 19)
9. **Linked List Cycle II** (LC 142)
10. **Reorder List** (LC 143)

### Amazon (Top 10)

1. **Reverse Linked List** (LC 206)
2. **Merge Two Sorted Lists** (LC 21)
3. **Add Two Numbers** (LC 2)
4. **LRU Cache** (LC 146)
5. **Copy List with Random** (LC 138)
6. **Remove Nth From End** (LC 19)
7. **Linked List Cycle** (LC 141)
8. **Reverse Linked List II** (LC 92)
9. **Merge k Sorted Lists** (LC 23)
10. **Intersection** (LC 160)

### Microsoft (Top 10)

1. **Reverse Linked List** (LC 206)
2. **Add Two Numbers** (LC 2)
3. **Merge Two Sorted Lists** (LC 21)
4. **Palindrome Linked List** (LC 234)
5. **LRU Cache** (LC 146)
6. **Copy List with Random** (LC 138)
7. **Linked List Cycle** (LC 141)
8. **Reorder List** (LC 143)
9. **Sort List** (LC 148)
10. **Flatten Multilevel DLL** (LC 430)

### Facebook/Meta (Top 10)

1. **Reverse Linked List** (LC 206)
2. **Add Two Numbers** (LC 2)
3. **Merge Two Sorted Lists** (LC 21)
4. **Copy List with Random** (LC 138)
5. **Linked List Cycle II** (LC 142)
6. **Remove Nth From End** (LC 19)
7. **Palindrome Linked List** (LC 234)
8. **Reverse Nodes in k-Group** (LC 25)
9. **LRU Cache** (LC 146)
10. **Merge k Sorted Lists** (LC 23)

---

## Problem-Solving Strategies

### Pattern Recognition

**1. When to Use Fast-Slow Pointer**:
- Find middle element
- Detect cycles
- Find nth from end (with gap)
- Palindrome check

**2. When to Use Reversal**:
- "Reverse" in problem name
- Palindrome check
- Reorder list
- Add numbers in reverse

**3. When to Use Dummy Node**:
- Head might be deleted
- Merging lists
- Partial operations
- Simplifies edge cases

**4. When to Use HashMap**:
- Clone with random pointer
- LRU cache
- Detect duplicates (unsorted)
- Frequency counting

### Common Patterns Template

**Template 1: Fast-Slow Pointer**
```java
ListNode slow = head, fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
    // Check condition (cycle, etc.)
}
// slow is at middle or meeting point
```

**Template 2: Reversal**
```java
ListNode prev = null, current = head;
while (current != null) {
    ListNode next = current.next;
    current.next = prev;
    prev = current;
    current = next;
}
return prev; // new head
```

**Template 3: Merge Two Lists**
```java
ListNode dummy = new ListNode(0);
ListNode current = dummy;
while (l1 != null && l2 != null) {
    if (l1.val <= l2.val) {
        current.next = l1;
        l1 = l1.next;
    } else {
        current.next = l2;
        l2 = l2.next;
    }
    current = current.next;
}
current.next = (l1 != null) ? l1 : l2;
return dummy.next;
```

### Debugging Checklist

- [ ] Handle null/empty list
- [ ] Handle single node
- [ ] Handle two nodes
- [ ] Check loop condition
- [ ] Update all pointers
- [ ] Return correct node
- [ ] No memory leaks (in non-GC languages)

### Time/Space Optimization

**Space Optimization**:
- Prefer iterative over recursive (O(1) vs O(n))
- Use fast-slow instead of HashSet for cycles
- In-place operations when possible

**Time Optimization**:
- Single pass when possible
- Use dummy node to avoid special cases
- Cache frequently used values (length, tail)

---

## Summary

### Must-Know Problems (Top 15)

**Essential (Must solve)**:
1. ✅ Reverse Linked List (206)
2. ✅ Merge Two Sorted Lists (21)
3. ✅ Linked List Cycle (141)
4. ✅ Linked List Cycle II (142)
5. ✅ Middle of Linked List (876)

**Very Important**:
6. ✅ Remove Nth From End (19)
7. ✅ Palindrome Linked List (234)
8. ✅ Add Two Numbers (2)
9. ✅ Reverse Linked List II (92)
10. ✅ Reorder List (143)

**Important Hard Problems**:
11. ✅ Reverse Nodes in k-Group (25)
12. ✅ Merge k Sorted Lists (23)
13. ✅ LRU Cache (146)
14. ✅ Copy List with Random (138)
15. ✅ Sort List (148)

### Pattern Frequency

```
Fast-Slow Pointer:     ████████████░░░░░░░░ 40%
Reversal:              ██████████░░░░░░░░░░ 30%
Two Pointers/Merge:    ████████░░░░░░░░░░░░ 20%
HashMap + LL:          ████░░░░░░░░░░░░░░░░ 10%
```

### Complexity Quick Reference

| Operation | Average | Worst |
|-----------|---------|-------|
| Traverse | O(n) | O(n) |
| Find Middle | O(n) | O(n) |
| Reverse | O(n) | O(n) |
| Merge 2 Lists | O(m+n) | O(m+n) |
| Merge k Lists | O(n log k) | O(n log k) |
| Detect Cycle | O(n) | O(n) |
| Sort | O(n log n) | O(n²)* |

\* Insertion sort

### Interview Success Tips

1. **Start with brute force**: Show you understand the problem
2. **Optimize space first**: O(n) to O(1) often easier than time optimization
3. **Draw it out**: Always visualize pointer movements
4. **Verify with examples**: Walk through edge cases
5. **Know time/space**: State complexity for each solution
6. **Master patterns**: Fast-slow, reversal, merge
7. **Practice top 15**: Covers 80% of interview questions

### Study Recommendation

**For beginners**: Focus on first 10 problems (Easy)
**For intermediate**: All Easy + Medium (up to problem 25)
**For advanced**: All problems + variations

### Next Steps

1. Complete all Easy problems
2. Master fast-slow and reversal patterns
3. Practice Medium problems 2-3 times each
4. Attempt Hard problems with hints first
5. Time yourself (aim for 20-30 min per Medium problem)

---

**Previous**: [7.5 Reversal Techniques](7.5-Reversal-Techniques.md)

**Practice More**: Revisit problems after 1 week for retention!

**Master These**: Problems marked with ⭐⭐⭐ or higher are interview essentials!
