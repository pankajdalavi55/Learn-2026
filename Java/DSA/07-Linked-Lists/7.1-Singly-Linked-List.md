# 7.1 Singly Linked List

## Table of Contents
1. [Introduction](#introduction)
2. [Node Structure](#node-structure)
3. [Basic Implementation](#basic-implementation)
4. [Core Operations](#core-operations)
5. [Common Patterns](#common-patterns)
6. [Advanced Operations](#advanced-operations)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is a Singly Linked List?

A **singly linked list** is a linear data structure where each element (node) contains:
- **Data**: The actual value
- **Next pointer**: Reference to the next node in the sequence

Unlike arrays, linked lists don't store elements in contiguous memory locations. Each node points to the next, forming a chain.

### Visual Representation

```
HEAD → [10|●] → [20|●] → [30|●] → [40|null]
       data next  data next  data next  data next
       
NULL indicates the end of the list
```

### Key Characteristics

- **Dynamic Size**: Grows/shrinks at runtime (no fixed size)
- **Non-contiguous Memory**: Nodes scattered in memory
- **Sequential Access**: Must traverse from head to reach any element
- **Efficient Insertions/Deletions**: No shifting required (unlike arrays)

### Complexity Analysis

| Operation | Array | Singly Linked List |
|-----------|-------|--------------------|
| **Access** | O(1) | O(n) |
| **Search** | O(n) | O(n) |
| **Insert at beginning** | O(n) | O(1) |
| **Insert at end** | O(1)* | O(n) or O(1)** |
| **Insert at position** | O(n) | O(n) |
| **Delete at beginning** | O(n) | O(1) |
| **Delete at end** | O(1)* | O(n) |
| **Delete at position** | O(n) | O(n) |

\* Assuming ArrayList with amortized time  
\*\* O(1) if tail pointer is maintained

### When to Use Singly Linked List?

✅ **Use Singly Linked List when**:
- Frequent insertions/deletions at beginning
- Size is unknown/dynamic
- Don't need random access
- Implementing stack/queue
- Memory fragmentation is acceptable

❌ **Avoid when**:
- Need random access (use ArrayList)
- Frequent access by index
- Memory overhead is critical
- Need reverse traversal (use Doubly Linked List)

---

## Node Structure

### Basic Node Class

```java
public class Node {
    int data;       // Value stored in node
    Node next;      // Reference to next node
    
    // Constructor
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
    
    // Constructor with next
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}
```

### Generic Node Class

```java
public class Node<T> {
    T data;
    Node<T> next;
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
    
    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }
}
```

**Why Generic?**: Allows any data type - `Node<Integer>`, `Node<String>`, etc.

---

## Basic Implementation

### Complete Singly Linked List Class

```java
public class SinglyLinkedList {
    // Inner Node class
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node head;  // Reference to first node
    private int size;   // Track number of nodes
    
    // Constructor
    public SinglyLinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    // Check if list is empty
    public boolean isEmpty() {
        return head == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Display list
    public void display() {
        if (isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        Node current = head;
        while (current != null) {
            System.out.print(current.data);
            if (current.next != null) {
                System.out.print(" → ");
            }
            current = current.next;
        }
        System.out.println(" → null");
    }
    
    // Test
    public static void main(String[] args) {
        SinglyLinkedList list = new SinglyLinkedList();
        System.out.println("Empty? " + list.isEmpty()); // true
        System.out.println("Size: " + list.size());     // 0
        list.display();                                  // List is empty
    }
}
```

---

## Core Operations

### 1. Insert at Beginning (addFirst)

**Most efficient operation - O(1)**

```java
public class SinglyLinkedList {
    private class Node {
        int data;
        Node next;
        Node(int data) { this.data = data; }
    }
    
    private Node head;
    private int size;
    
    /**
     * Insert at beginning - O(1)
     */
    public void addFirst(int data) {
        Node newNode = new Node(data);
        newNode.next = head;  // Point new node to current head
        head = newNode;       // Update head to new node
        size++;
    }
    
    // Test
    public static void main(String[] args) {
        SinglyLinkedList list = new SinglyLinkedList();
        
        list.addFirst(30);  // 30 → null
        list.addFirst(20);  // 20 → 30 → null
        list.addFirst(10);  // 10 → 20 → 30 → null
        
        list.display();
        System.out.println("Size: " + list.size()); // 3
    }
}
```

**Visual Process**:
```
Initial: HEAD → null

After addFirst(30):
HEAD → [30|null]

After addFirst(20):
HEAD → [20|●] → [30|null]

After addFirst(10):
HEAD → [10|●] → [20|●] → [30|null]
```

**Complexity**: O(1) time, O(1) space

---

### 2. Insert at End (addLast)

**Requires traversal - O(n)**

```java
/**
 * Insert at end - O(n)
 */
public void addLast(int data) {
    Node newNode = new Node(data);
    
    // Case 1: Empty list
    if (head == null) {
        head = newNode;
        size++;
        return;
    }
    
    // Case 2: Traverse to last node
    Node current = head;
    while (current.next != null) {
        current = current.next;
    }
    
    current.next = newNode;  // Link last node to new node
    size++;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    list.addLast(10);  // 10 → null
    list.addLast(20);  // 10 → 20 → null
    list.addLast(30);  // 10 → 20 → 30 → null
    
    list.display();
}
```

**Optimization with Tail Pointer**:
```java
public class SinglyLinkedList {
    private Node head;
    private Node tail;  // Maintain tail reference
    private int size;
    
    public void addLast(int data) {
        Node newNode = new Node(data);
        
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
        size++;
    }
}
```

**Complexity**: 
- Without tail: O(n) time
- With tail: O(1) time

---

### 3. Insert at Position

**Insert at specific index**

```java
/**
 * Insert at specific position (0-based index)
 * @param index 0 to size (inclusive)
 * @param data value to insert
 */
public void insertAt(int index, int data) {
    // Validate index
    if (index < 0 || index > size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    // Case 1: Insert at beginning
    if (index == 0) {
        addFirst(data);
        return;
    }
    
    // Case 2: Insert at middle/end
    Node newNode = new Node(data);
    Node current = head;
    
    // Traverse to position (index - 1)
    for (int i = 0; i < index - 1; i++) {
        current = current.next;
    }
    
    newNode.next = current.next;  // Link new node to next
    current.next = newNode;        // Link previous to new node
    size++;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    list.addLast(10);   // 10
    list.addLast(30);   // 10 → 30
    list.insertAt(1, 20); // 10 → 20 → 30
    
    list.display();
}
```

**Visual Process** (Insert 25 at index 2):
```
Before: 10 → 20 → 30 → 40

Step 1: Traverse to index 1 (20)
        current
          ↓
10 → [20|●] → [30|●] → [40|null]

Step 2: Create new node
newNode = [25|null]

Step 3: Link new node to next
newNode.next = current.next
[25|●] → [30|●]

Step 4: Link current to new node
current.next = newNode
10 → 20 → 25 → 30 → 40
```

**Complexity**: O(n) time, O(1) space

---

### 4. Delete from Beginning (removeFirst)

**Most efficient deletion - O(1)**

```java
/**
 * Delete first node - O(1)
 * @return deleted value
 */
public int removeFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    int data = head.data;
    head = head.next;  // Move head to next node
    size--;
    
    return data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    // 10 → 20 → 30
    
    System.out.println("Removed: " + list.removeFirst()); // 10
    list.display(); // 20 → 30
}
```

**Visual Process**:
```
Before: HEAD → [10|●] → [20|●] → [30|null]

After removeFirst():
        HEAD → [20|●] → [30|null]
        
Note: [10] becomes garbage collected
```

**Complexity**: O(1) time, O(1) space

---

### 5. Delete from End (removeLast)

**Requires traversal to second-last node**

```java
/**
 * Delete last node - O(n)
 * @return deleted value
 */
public int removeLast() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    // Case 1: Single node
    if (head.next == null) {
        int data = head.data;
        head = null;
        size--;
        return data;
    }
    
    // Case 2: Multiple nodes - traverse to second last
    Node current = head;
    while (current.next.next != null) {
        current = current.next;
    }
    
    int data = current.next.data;
    current.next = null;  // Remove link to last node
    size--;
    
    return data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    // 10 → 20 → 30
    
    System.out.println("Removed: " + list.removeLast()); // 30
    list.display(); // 10 → 20
}
```

**Visual Process**:
```
Before: [10|●] → [20|●] → [30|null]

Step 1: Traverse to second-last
                current
                  ↓
        [10|●] → [20|●] → [30|null]
                          current.next

Step 2: Remove link
        [10|●] → [20|null]  [30] → garbage
```

**Complexity**: O(n) time, O(1) space

---

### 6. Delete at Position

```java
/**
 * Delete node at specific position
 * @param index 0-based position
 * @return deleted value
 */
public int removeAt(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    // Case 1: Delete first
    if (index == 0) {
        return removeFirst();
    }
    
    // Case 2: Traverse to (index - 1)
    Node current = head;
    for (int i = 0; i < index - 1; i++) {
        current = current.next;
    }
    
    int data = current.next.data;
    current.next = current.next.next;  // Skip the node to delete
    size--;
    
    return data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    list.addLast(40);
    // 10 → 20 → 30 → 40
    
    System.out.println("Removed: " + list.removeAt(2)); // 30
    list.display(); // 10 → 20 → 40
}
```

**Complexity**: O(n) time, O(1) space

---

### 7. Search Operation

```java
/**
 * Search for a value
 * @return index if found, -1 otherwise
 */
public int search(int target) {
    Node current = head;
    int index = 0;
    
    while (current != null) {
        if (current.data == target) {
            return index;
        }
        current = current.next;
        index++;
    }
    
    return -1;  // Not found
}

/**
 * Check if value exists
 */
public boolean contains(int target) {
    return search(target) != -1;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println(list.search(20));    // 1
    System.out.println(list.search(100));   // -1
    System.out.println(list.contains(30));  // true
}
```

**Complexity**: O(n) time, O(1) space

---

### 8. Get Element at Index

```java
/**
 * Get value at specific index
 */
public int get(int index) {
    if (index < 0 || index >= size) {
        throw new IndexOutOfBoundsException("Invalid index: " + index);
    }
    
    Node current = head;
    for (int i = 0; i < index; i++) {
        current = current.next;
    }
    
    return current.data;
}

/**
 * Get first element
 */
public int getFirst() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    return head.data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.println(list.get(0));      // 10
    System.out.println(list.get(2));      // 30
    System.out.println(list.getFirst());  // 10
}
```

**Complexity**: O(n) time, O(1) space

---

## Common Patterns

### Pattern 1: Reverse a Linked List (Iterative)

**One of the most important interview patterns!**

```java
/**
 * Reverse linked list iteratively
 * Time: O(n), Space: O(1)
 */
public void reverse() {
    Node prev = null;
    Node current = head;
    Node next = null;
    
    while (current != null) {
        next = current.next;    // Save next
        current.next = prev;    // Reverse link
        prev = current;         // Move prev forward
        current = next;         // Move current forward
    }
    
    head = prev;  // Update head
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    
    System.out.print("Original: ");
    list.display();  // 10 → 20 → 30
    
    list.reverse();
    
    System.out.print("Reversed: ");
    list.display();  // 30 → 20 → 10
}
```

**Visual Process**:
```
Initial: 10 → 20 → 30 → null

Step 1: prev=null, current=10
        null ← 10   20 → 30 → null

Step 2: prev=10, current=20
        null ← 10 ← 20   30 → null

Step 3: prev=20, current=30
        null ← 10 ← 20 ← 30

Final: head=30
       30 → 20 → 10 → null
```

---

### Pattern 2: Reverse Recursively

```java
/**
 * Reverse linked list recursively
 * Time: O(n), Space: O(n) for recursion stack
 */
public void reverseRecursive() {
    head = reverseRecursiveHelper(head);
}

private Node reverseRecursiveHelper(Node node) {
    // Base case: empty or single node
    if (node == null || node.next == null) {
        return node;
    }
    
    // Reverse rest of the list
    Node newHead = reverseRecursiveHelper(node.next);
    
    // Reverse current link
    node.next.next = node;
    node.next = null;
    
    return newHead;
}
```

**Recursion Flow**:
```
reverseRecursive(10 → 20 → 30 → null)
  → reverseRecursive(20 → 30 → null)
    → reverseRecursive(30 → null)
      → return 30
    ← 30 ← 20, return 30
  ← 30 ← 20 ← 10, return 30
Result: 30 → 20 → 10 → null
```

---

### Pattern 3: Find Middle Element (Slow-Fast Pointer)

**Floyd's Tortoise and Hare Algorithm**

```java
/**
 * Find middle node using slow-fast pointers
 * If even length, returns second middle
 */
public int findMiddle() {
    if (isEmpty()) {
        throw new NoSuchElementException("List is empty");
    }
    
    Node slow = head;
    Node fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;       // Move 1 step
        fast = fast.next.next;  // Move 2 steps
    }
    
    return slow.data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    // Odd length
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    list.addLast(40);
    list.addLast(50);
    System.out.println(list.findMiddle()); // 30
    
    // Even length
    SinglyLinkedList list2 = new SinglyLinkedList();
    list2.addLast(10);
    list2.addLast(20);
    list2.addLast(30);
    list2.addLast(40);
    System.out.println(list2.findMiddle()); // 30 (second middle)
}
```

**Visual Process** (Odd length):
```
10 → 20 → 30 → 40 → 50 → null
slow      
fast

10 → 20 → 30 → 40 → 50 → null
     slow      
               fast

10 → 20 → 30 → 40 → 50 → null
          slow      
                         fast=null

Middle = 30
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 4: Detect Cycle (Floyd's Algorithm)

```java
/**
 * Detect if linked list has a cycle
 */
public boolean hasCycle() {
    if (head == null) return false;
    
    Node slow = head;
    Node fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true;  // Cycle detected
        }
    }
    
    return false;  // No cycle
}

// Test with cycle
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    
    // Create nodes
    Node n1 = new Node(10);
    Node n2 = new Node(20);
    Node n3 = new Node(30);
    Node n4 = new Node(40);
    
    // Link nodes
    n1.next = n2;
    n2.next = n3;
    n3.next = n4;
    n4.next = n2;  // Cycle: 40 → 20
    
    list.head = n1;
    
    System.out.println(list.hasCycle()); // true
}
```

**Visual with Cycle**:
```
10 → 20 → 30 → 40
     ↑_________↓
     
Slow and fast will eventually meet at some node
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 5: Find Nth Node from End

```java
/**
 * Find nth node from end (1-based)
 * Example: n=1 returns last node
 */
public int getNthFromEnd(int n) {
    if (n <= 0) {
        throw new IllegalArgumentException("n must be positive");
    }
    
    Node first = head;
    Node second = head;
    
    // Move first pointer n steps ahead
    for (int i = 0; i < n; i++) {
        if (first == null) {
            throw new IllegalArgumentException("n is larger than list size");
        }
        first = first.next;
    }
    
    // Move both pointers until first reaches end
    while (first != null) {
        first = first.next;
        second = second.next;
    }
    
    return second.data;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(10);
    list.addLast(20);
    list.addLast(30);
    list.addLast(40);
    list.addLast(50);
    
    System.out.println(list.getNthFromEnd(1)); // 50 (last)
    System.out.println(list.getNthFromEnd(2)); // 40 (second last)
    System.out.println(list.getNthFromEnd(5)); // 10 (first)
}
```

**Visual Process** (n=2):
```
10 → 20 → 30 → 40 → 50 → null

Step 1: Move first n(2) steps
first     second
  ↓         ↓
10 → 20 → 30 → 40 → 50 → null

Step 2: Move both until first=null
               first   second
                 ↓       ↓
10 → 20 → 30 → 40 → 50 → null

Result: second = 40 (2nd from end)
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 6: Remove Duplicates (Sorted List)

```java
/**
 * Remove duplicates from sorted linked list
 */
public void removeDuplicates() {
    if (head == null) return;
    
    Node current = head;
    
    while (current != null && current.next != null) {
        if (current.data == current.next.data) {
            // Skip duplicate
            current.next = current.next.next;
            size--;
        } else {
            current = current.next;
        }
    }
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(10);
    list.addLast(10);
    list.addLast(20);
    list.addLast(20);
    list.addLast(30);
    
    System.out.print("Before: ");
    list.display(); // 10 → 10 → 20 → 20 → 30
    
    list.removeDuplicates();
    
    System.out.print("After: ");
    list.display(); // 10 → 20 → 30
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 7: Palindrome Check

```java
/**
 * Check if linked list is palindrome
 */
public boolean isPalindrome() {
    if (head == null || head.next == null) {
        return true;
    }
    
    // Step 1: Find middle
    Node slow = head, fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Reverse second half
    Node secondHalf = reverseList(slow.next);
    
    // Step 3: Compare both halves
    Node firstHalf = head;
    while (secondHalf != null) {
        if (firstHalf.data != secondHalf.data) {
            return false;
        }
        firstHalf = firstHalf.next;
        secondHalf = secondHalf.next;
    }
    
    return true;
}

private Node reverseList(Node head) {
    Node prev = null;
    while (head != null) {
        Node next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list1 = new SinglyLinkedList();
    list1.addLast(1);
    list1.addLast(2);
    list1.addLast(3);
    list1.addLast(2);
    list1.addLast(1);
    System.out.println(list1.isPalindrome()); // true
    
    SinglyLinkedList list2 = new SinglyLinkedList();
    list2.addLast(1);
    list2.addLast(2);
    list2.addLast(3);
    System.out.println(list2.isPalindrome()); // false
}
```

**Complexity**: O(n) time, O(1) space

---

## Advanced Operations

### 1. Merge Two Sorted Lists

```java
/**
 * Merge two sorted linked lists
 */
public static Node mergeSorted(Node l1, Node l2) {
    // Dummy node for easier handling
    Node dummy = new Node(0);
    Node current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.data <= l2.data) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    // Attach remaining nodes
    if (l1 != null) current.next = l1;
    if (l2 != null) current.next = l2;
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // List 1: 1 → 3 → 5
    Node l1 = new Node(1);
    l1.next = new Node(3);
    l1.next.next = new Node(5);
    
    // List 2: 2 → 4 → 6
    Node l2 = new Node(2);
    l2.next = new Node(4);
    l2.next.next = new Node(6);
    
    Node merged = mergeSorted(l1, l2);
    // Result: 1 → 2 → 3 → 4 → 5 → 6
    
    while (merged != null) {
        System.out.print(merged.data + " ");
        merged = merged.next;
    }
}
```

**Complexity**: O(m + n) time, O(1) space

---

### 2. Sort Linked List (Merge Sort)

```java
/**
 * Sort linked list using merge sort
 */
public void mergeSort() {
    head = mergeSortHelper(head);
}

private Node mergeSortHelper(Node node) {
    // Base case
    if (node == null || node.next == null) {
        return node;
    }
    
    // Find middle
    Node middle = getMiddle(node);
    Node nextToMiddle = middle.next;
    middle.next = null;
    
    // Sort both halves
    Node left = mergeSortHelper(node);
    Node right = mergeSortHelper(nextToMiddle);
    
    // Merge sorted halves
    return merge(left, right);
}

private Node getMiddle(Node node) {
    if (node == null) return node;
    
    Node slow = node, fast = node;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    return slow;
}

private Node merge(Node l1, Node l2) {
    Node dummy = new Node(0);
    Node current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.data <= l2.data) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    current.next = (l1 != null) ? l1 : l2;
    return dummy.next;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(40);
    list.addLast(10);
    list.addLast(30);
    list.addLast(20);
    
    System.out.print("Before: ");
    list.display(); // 40 → 10 → 30 → 20
    
    list.mergeSort();
    
    System.out.print("After: ");
    list.display(); // 10 → 20 → 30 → 40
}
```

**Complexity**: O(n log n) time, O(log n) space (recursion stack)

---

### 3. Partition List Around Value

```java
/**
 * Partition list around value x
 * All nodes < x come before nodes >= x
 */
public void partition(int x) {
    // Create two dummy nodes
    Node beforeHead = new Node(0);
    Node before = beforeHead;
    Node afterHead = new Node(0);
    Node after = afterHead;
    
    Node current = head;
    
    while (current != null) {
        if (current.data < x) {
            before.next = current;
            before = before.next;
        } else {
            after.next = current;
            after = after.next;
        }
        current = current.next;
    }
    
    after.next = null;
    before.next = afterHead.next;
    head = beforeHead.next;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(3);
    list.addLast(5);
    list.addLast(8);
    list.addLast(5);
    list.addLast(10);
    list.addLast(2);
    list.addLast(1);
    
    System.out.print("Before: ");
    list.display(); // 3 → 5 → 8 → 5 → 10 → 2 → 1
    
    list.partition(5);
    
    System.out.print("After: ");
    list.display(); // 3 → 2 → 1 → 5 → 8 → 5 → 10
}
```

**Complexity**: O(n) time, O(1) space

---

### 4. Add Two Numbers (as Linked Lists)

```java
/**
 * Add two numbers represented as linked lists
 * Example: 342 (2→4→3) + 465 (5→6→4) = 807 (7→0→8)
 */
public static Node addTwoNumbers(Node l1, Node l2) {
    Node dummy = new Node(0);
    Node current = dummy;
    int carry = 0;
    
    while (l1 != null || l2 != null || carry != 0) {
        int sum = carry;
        
        if (l1 != null) {
            sum += l1.data;
            l1 = l1.next;
        }
        
        if (l2 != null) {
            sum += l2.data;
            l2 = l2.next;
        }
        
        carry = sum / 10;
        current.next = new Node(sum % 10);
        current = current.next;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // 342: 2 → 4 → 3
    Node l1 = new Node(2);
    l1.next = new Node(4);
    l1.next.next = new Node(3);
    
    // 465: 5 → 6 → 4
    Node l2 = new Node(5);
    l2.next = new Node(6);
    l2.next.next = new Node(4);
    
    Node result = addTwoNumbers(l1, l2);
    // 807: 7 → 0 → 8
    
    while (result != null) {
        System.out.print(result.data + " → ");
        result = result.next;
    }
    System.out.println("null");
}
```

**Complexity**: O(max(m, n)) time, O(max(m, n)) space

---

## Interview Questions

### Question 1: Delete Node Without Head Pointer

**Problem**: Delete a node when you only have access to that node (not head).

**Constraint**: Node is not the last node.

```java
/**
 * Delete node without head reference
 * Copy next node's data and delete next node
 */
public void deleteNode(Node node) {
    if (node == null || node.next == null) {
        throw new IllegalArgumentException("Cannot delete last node or null");
    }
    
    // Copy next node's data
    node.data = node.next.data;
    
    // Delete next node
    node.next = node.next.next;
}

// Test
public static void main(String[] args) {
    // Create: 1 → 2 → 3 → 4 → 5
    Node head = new Node(1);
    Node node2 = new Node(2);
    Node node3 = new Node(3);
    Node node4 = new Node(4);
    Node node5 = new Node(5);
    
    head.next = node2;
    node2.next = node3;
    node3.next = node4;
    node4.next = node5;
    
    // Delete node3 (value 3)
    deleteNode(node3);
    
    // Result: 1 → 2 → 4 → 5
}
```

**Complexity**: O(1) time, O(1) space

---

### Question 2: Intersection of Two Linked Lists

**Problem**: Find the node where two linked lists intersect.

```java
/**
 * Find intersection node of two lists
 */
public static Node getIntersectionNode(Node headA, Node headB) {
    if (headA == null || headB == null) return null;
    
    // Get lengths
    int lenA = getLength(headA);
    int lenB = getLength(headB);
    
    // Align both lists
    while (lenA > lenB) {
        headA = headA.next;
        lenA--;
    }
    
    while (lenB > lenA) {
        headB = headB.next;
        lenB--;
    }
    
    // Find intersection
    while (headA != headB) {
        headA = headA.next;
        headB = headB.next;
    }
    
    return headA;
}

private static int getLength(Node head) {
    int length = 0;
    while (head != null) {
        length++;
        head = head.next;
    }
    return length;
}
```

**Alternative Solution (Two Pointers)**:
```java
public static Node getIntersectionNode(Node headA, Node headB) {
    if (headA == null || headB == null) return null;
    
    Node a = headA;
    Node b = headB;
    
    // When a reaches end, restart at headB
    // When b reaches end, restart at headA
    // They will meet at intersection
    while (a != b) {
        a = (a == null) ? headB : a.next;
        b = (b == null) ? headA : b.next;
    }
    
    return a;
}
```

**Complexity**: O(m + n) time, O(1) space

---

### Question 3: Rotate List by K

**Problem**: Rotate list to the right by k places.

```java
/**
 * Rotate list right by k positions
 * Example: 1→2→3→4→5, k=2 → 4→5→1→2→3
 */
public void rotate(int k) {
    if (head == null || head.next == null || k == 0) return;
    
    // Get length and last node
    int length = 1;
    Node last = head;
    while (last.next != null) {
        last = last.next;
        length++;
    }
    
    // Normalize k
    k = k % length;
    if (k == 0) return;
    
    // Find new tail (length - k - 1)
    Node newTail = head;
    for (int i = 0; i < length - k - 1; i++) {
        newTail = newTail.next;
    }
    
    // Rotate
    Node newHead = newTail.next;
    newTail.next = null;
    last.next = head;
    head = newHead;
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(1);
    list.addLast(2);
    list.addLast(3);
    list.addLast(4);
    list.addLast(5);
    
    System.out.print("Before: ");
    list.display(); // 1 → 2 → 3 → 4 → 5
    
    list.rotate(2);
    
    System.out.print("After: ");
    list.display(); // 4 → 5 → 1 → 2 → 3
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 4: Reorder List

**Problem**: Reorder L0→L1→...→Ln-1→Ln to L0→Ln→L1→Ln-1→L2→Ln-2→...

```java
/**
 * Reorder list: L0→L1→L2→...→Ln-1→Ln
 * To: L0→Ln→L1→Ln-1→L2→Ln-2→...
 */
public void reorderList() {
    if (head == null || head.next == null) return;
    
    // Step 1: Find middle
    Node slow = head, fast = head;
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Reverse second half
    Node secondHalf = reverseList(slow.next);
    slow.next = null;
    
    // Step 3: Merge two halves
    Node first = head;
    Node second = secondHalf;
    
    while (second != null) {
        Node temp1 = first.next;
        Node temp2 = second.next;
        
        first.next = second;
        second.next = temp1;
        
        first = temp1;
        second = temp2;
    }
}

// Test
public static void main(String[] args) {
    SinglyLinkedList list = new SinglyLinkedList();
    list.addLast(1);
    list.addLast(2);
    list.addLast(3);
    list.addLast(4);
    list.addLast(5);
    
    System.out.print("Before: ");
    list.display(); // 1 → 2 → 3 → 4 → 5
    
    list.reorderList();
    
    System.out.print("After: ");
    list.display(); // 1 → 5 → 2 → 4 → 3
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 5: Clone List with Random Pointer

**Problem**: Clone a linked list where each node has a random pointer.

```java
class RandomNode {
    int data;
    RandomNode next;
    RandomNode random;
    
    RandomNode(int data) {
        this.data = data;
    }
}

/**
 * Clone list with random pointers
 */
public RandomNode copyRandomList(RandomNode head) {
    if (head == null) return null;
    
    // Step 1: Create copy nodes interleaved
    RandomNode current = head;
    while (current != null) {
        RandomNode copy = new RandomNode(current.data);
        copy.next = current.next;
        current.next = copy;
        current = copy.next;
    }
    
    // Step 2: Copy random pointers
    current = head;
    while (current != null) {
        if (current.random != null) {
            current.next.random = current.random.next;
        }
        current = current.next.next;
    }
    
    // Step 3: Separate lists
    current = head;
    RandomNode copyHead = head.next;
    RandomNode copyCurrent = copyHead;
    
    while (current != null) {
        current.next = current.next.next;
        if (copyCurrent.next != null) {
            copyCurrent.next = copyCurrent.next.next;
        }
        current = current.next;
        copyCurrent = copyCurrent.next;
    }
    
    return copyHead;
}
```

**Complexity**: O(n) time, O(1) space (excluding output)

---

## Practice Problems

### Easy Level

1. **Remove Elements** (LC 203)
   - Remove all nodes with value x
   - Solution: Traverse and skip matching nodes

2. **Middle of Linked List** (LC 876)
   - Find middle node
   - Solution: Slow-fast pointer

3. **Merge Two Sorted Lists** (LC 21)
   - Merge two sorted lists
   - Solution: Two-pointer merge

4. **Remove Duplicates** (LC 83)
   - Remove duplicates from sorted list
   - Solution: Compare adjacent nodes

5. **Reverse Linked List** (LC 206)
   - Reverse the list
   - Solution: Iterative or recursive

### Medium Level

6. **Add Two Numbers** (LC 2)
   - Add numbers stored in lists
   - Solution: Digit-by-digit addition with carry

7. **Remove Nth Node from End** (LC 19)
   - Remove nth node from end
   - Solution: Two-pointer technique

8. **Reorder List** (LC 143)
   - Reorder as described above
   - Solution: Find middle, reverse, merge

9. **Partition List** (LC 86)
   - Partition around value
   - Solution: Two separate lists

10. **Swap Nodes in Pairs** (LC 24)
    - Swap every two adjacent nodes
    - Solution: Iterative pointer manipulation

### Hard Level

11. **Merge K Sorted Lists** (LC 23)
    - Merge k sorted lists
    - Solution: Min heap or divide-and-conquer

12. **Reverse Nodes in K-Group** (LC 25)
    - Reverse every k nodes
    - Solution: Group reversal with recursion

13. **Copy List with Random Pointer** (LC 138)
    - Clone complex list
    - Solution: Interleaving method

---

## Summary

### Key Takeaways

1. **Dynamic Structure**: Linked lists grow/shrink efficiently without reallocation
2. **O(1) Insert/Delete at Head**: Most efficient operation
3. **O(n) Access**: Sequential traversal required (vs O(1) for arrays)
4. **Two-Pointer Patterns**: Essential for many problems (slow-fast, two-start)
5. **Recursion Works Well**: Natural fit for recursive solutions

### Operations Complexity Table

| Operation | Without Tail | With Tail |
|-----------|-------------|-----------|
| addFirst | O(1) | O(1) |
| addLast | O(n) | O(1) |
| removeFirst | O(1) | O(1) |
| removeLast | O(n) | O(n) |
| get(index) | O(n) | O(n) |
| search | O(n) | O(n) |
| reverse | O(n) | O(n) |

### Common Patterns Checklist

- [ ] Reverse list (iterative/recursive)
- [ ] Find middle (slow-fast pointers)
- [ ] Detect cycle (Floyd's algorithm)
- [ ] Nth from end (two pointers)
- [ ] Merge sorted lists
- [ ] Remove duplicates
- [ ] Partition list
- [ ] Palindrome check

### Interview Tips

1. **Clarify Requirements**: Single vs doubly linked? Sorted? Duplicates?
2. **Draw It Out**: Visualize pointer movements on paper
3. **Handle Edge Cases**: Empty list, single node, two nodes
4. **Use Dummy Nodes**: Simplifies edge cases in many problems
5. **Two Pointers**: Master slow-fast and two-start patterns
6. **Practice Reversal**: Core skill for many variations
7. **Mind the Nulls**: Check for null before accessing `.next`

### Linked List vs Array

```
Choose Linked List when:
✓ Frequent insertions/deletions at beginning
✓ Dynamic size unknown
✓ No random access needed
✓ Implementing stack/queue

Choose Array/ArrayList when:
✓ Need random access
✓ Size relatively stable
✓ Frequent index-based operations
✓ Memory locality important
```

### Common Mistakes to Avoid

1. **Losing Head Reference**: Always keep track of head
2. **Not Checking Null**: Verify `node != null` before `node.next`
3. **Forgetting to Update Size**: Maintain size counter
4. **Infinite Loops**: Be careful with cycle creation
5. **Memory Leaks**: Break links when deleting (esp. in non-GC languages)

---

**Next**: [7.2 Doubly Linked List](7.2-Doubly-Linked-List.md) - Learn bidirectional traversal

**Practice More**: [7.3 Circular Linked List](7.3-Circular-Linked-List.md)
