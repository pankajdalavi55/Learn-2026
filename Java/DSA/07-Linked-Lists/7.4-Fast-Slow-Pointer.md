# 7.4 Fast & Slow Pointer (Two Pointer Technique)

## Table of Contents
1. [Introduction](#introduction)
2. [Core Concept](#core-concept)
3. [Basic Patterns](#basic-patterns)
4. [Finding Middle Element](#finding-middle)
5. [Cycle Detection](#cycle-detection)
6. [Advanced Patterns](#advanced-patterns)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is Fast & Slow Pointer?

**Fast & Slow Pointer** (also called **Floyd's Tortoise and Hare Algorithm**) is a two-pointer technique where:
- **Slow pointer** moves one step at a time
- **Fast pointer** moves two steps at a time
- Both start from the same position (usually head)

This elegant technique solves several linked list problems in **O(n) time** and **O(1) space**.

### Visual Representation

```
Initial:
SLOW/FAST
    ↓
[10] → [20] → [30] → [40] → [50] → null

After 1 iteration:
    SLOW    FAST
      ↓       ↓
[10] → [20] → [30] → [40] → [50] → null

After 2 iterations:
           SLOW         FAST
             ↓            ↓
[10] → [20] → [30] → [40] → [50] → null

After 3 iterations:
                  SLOW              FAST
                    ↓                 ↓
[10] → [20] → [30] → [40] → [50] → null
```

### Why Does It Work?

**Key Insight**: Fast pointer covers **twice the distance** of slow pointer
- When slow moves `n` steps, fast moves `2n` steps
- If there's a cycle, fast will eventually catch slow
- If fast reaches null, there's no cycle
- When fast reaches end, slow is at middle

### Common Applications

1. **Find Middle Element** - O(n) time, O(1) space
2. **Detect Cycle** - Floyd's cycle detection
3. **Find Cycle Start** - Extended Floyd's algorithm
4. **Remove Nth from End** - Two-pointer variation
5. **Check Palindrome** - Find middle, then reverse
6. **Reorder List** - Split at middle, reverse, merge

### Complexity Benefits

| Problem | Naive Approach | Fast-Slow Pointer |
|---------|----------------|-------------------|
| Find Middle | Count, then traverse | O(n), O(1) ✅ |
| Detect Cycle | HashSet | O(n), O(n) → O(n), O(1) ✅ |
| Palindrome | Convert to array | O(n), O(n) → O(n), O(1) ✅ |

---

## Core Concept

### Basic Template

```java
class ListNode {
    int val;
    ListNode next;
    
    ListNode(int val) {
        this.val = val;
    }
}

public class FastSlowPointer {
    /**
     * Basic fast-slow pointer template
     */
    public void fastSlowTemplate(ListNode head) {
        if (head == null || head.next == null) {
            return;
        }
        
        ListNode slow = head;
        ListNode fast = head;
        
        // Standard loop condition
        while (fast != null && fast.next != null) {
            slow = slow.next;           // Move 1 step
            fast = fast.next.next;      // Move 2 steps
            
            // Do something based on problem
            // Example: check if slow == fast (cycle detection)
        }
        
        // At this point:
        // - fast reached end OR
        // - slow and fast met (cycle) OR
        // - slow is at middle
    }
}
```

### Important Loop Conditions

```java
// Standard condition (most common)
while (fast != null && fast.next != null)

// Why this order?
// 1. Check fast != null first (prevent NPE on fast.next)
// 2. Check fast.next != null (prevent NPE on fast.next.next)

// Alternative conditions for specific cases:
while (fast.next != null && fast.next.next != null)  // When slow starts at head-1
while (slow != fast)                                   // For cycle detection loop
```

### Movement Speed Analysis

```java
/**
 * Demonstrate movement speeds
 */
public void demonstrateSpeed(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    
    int iteration = 0;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        iteration++;
        
        System.out.println("Iteration " + iteration + ":");
        System.out.println("  Slow moved " + iteration + " steps");
        System.out.println("  Fast moved " + (iteration * 2) + " steps");
    }
}
```

---

## Basic Patterns

### Pattern 1: Find Middle Element

**Most fundamental application**

```java
/**
 * Find middle node of linked list
 * If even length, returns second middle
 */
public ListNode findMiddle(ListNode head) {
    if (head == null) {
        return null;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;  // Slow is at middle
}

// Test
public static void main(String[] args) {
    // Create list: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    FastSlowPointer fsp = new FastSlowPointer();
    ListNode middle = fsp.findMiddle(head);
    System.out.println("Middle: " + middle.val);  // 3
    
    // Even length: 1 → 2 → 3 → 4
    ListNode head2 = new ListNode(1);
    head2.next = new ListNode(2);
    head2.next.next = new ListNode(3);
    head2.next.next.next = new ListNode(4);
    
    middle = fsp.findMiddle(head2);
    System.out.println("Middle: " + middle.val);  // 3 (second middle)
}
```

**Visual Process** (Odd length):
```
List: 1 → 2 → 3 → 4 → 5 → null

Step 0: slow=1, fast=1
[1] → 2 → 3 → 4 → 5 → null

Step 1: slow=2, fast=3
1 → [2] → [3] → 4 → 5 → null

Step 2: slow=3, fast=5
1 → 2 → [3] → 4 → [5] → null

Step 3: fast.next == null, STOP
Middle = 3 ✓
```

**Visual Process** (Even length):
```
List: 1 → 2 → 3 → 4 → null

Step 0: slow=1, fast=1
[1] → 2 → 3 → 4 → null

Step 1: slow=2, fast=3
1 → [2] → [3] → 4 → null

Step 2: slow=3, fast=null, STOP
Middle = 3 (second middle) ✓
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 2: Find First Middle (Even Length)

**For even length, return first middle instead of second**

```java
/**
 * Find first middle for even length
 */
public ListNode findFirstMiddle(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    ListNode slow = head;
    ListNode fast = head.next;  // Start fast one ahead
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return slow;
}

// Test
public static void main(String[] args) {
    // Even length: 1 → 2 → 3 → 4
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    
    FastSlowPointer fsp = new FastSlowPointer();
    ListNode middle = fsp.findFirstMiddle(head);
    System.out.println("First Middle: " + middle.val);  // 2
}
```

**Difference**:
```
Standard (fast = head):
1 → 2 → 3 → 4 → null
        ↑ (returns 3)

Modified (fast = head.next):
1 → 2 → 3 → 4 → null
    ↑ (returns 2)
```

---

## Finding Middle

### Variation 1: Split List into Two Halves

```java
/**
 * Split linked list into two halves
 * For odd length, first half has extra node
 */
public ListNode[] splitInHalf(ListNode head) {
    if (head == null) {
        return new ListNode[]{null, null};
    }
    
    // Find middle
    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;
    
    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Split
    if (prev != null) {
        prev.next = null;
    }
    
    return new ListNode[]{head, slow};
}

// Test
public static void main(String[] args) {
    // List: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    FastSlowPointer fsp = new FastSlowPointer();
    ListNode[] halves = fsp.splitInHalf(head);
    
    // First half: 1 → 2 → 3
    // Second half: 4 → 5
}
```

**Complexity**: O(n) time, O(1) space

---

### Variation 2: Delete Middle Node

**LeetCode 2095: Delete the Middle Node of a Linked List**

```java
/**
 * Delete middle node from linked list
 */
public ListNode deleteMiddle(ListNode head) {
    // Edge case: single node
    if (head == null || head.next == null) {
        return null;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;
    
    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Delete middle (slow)
    if (prev != null) {
        prev.next = slow.next;
    }
    
    return head;
}

// Test
public static void main(String[] args) {
    // List: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    FastSlowPointer fsp = new FastSlowPointer();
    head = fsp.deleteMiddle(head);
    
    // Result: 1 → 2 → 4 → 5 (deleted 3)
}
```

**Complexity**: O(n) time, O(1) space

---

## Cycle Detection

### Pattern 3: Detect Cycle (Floyd's Algorithm)

**LeetCode 141: Linked List Cycle**

```java
/**
 * Detect if linked list has a cycle
 * Returns true if cycle exists
 */
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true;  // Cycle detected!
        }
    }
    
    return false;  // No cycle
}

// Test
public static void main(String[] args) {
    // Create cycle: 1 → 2 → 3 → 4 → 2 (cycle)
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = head.next;  // Create cycle
    
    FastSlowPointer fsp = new FastSlowPointer();
    System.out.println(fsp.hasCycle(head));  // true
}
```

**Visual Process**:
```
List with cycle: 1 → 2 → 3 → 4 ─┐
                     ↑___________┘

Iteration 1:
slow = 2, fast = 3

Iteration 2:
slow = 3, fast = 2 (wrapped around)

Iteration 3:
slow = 4, fast = 4 ✓ CYCLE DETECTED!
```

**Why It Works**:
- In a cycle, fast eventually catches slow
- Like two runners on a circular track
- Fast gains 1 position per iteration
- Will meet within one cycle length

**Complexity**: O(n) time, O(1) space

---

### Pattern 4: Find Cycle Start (Floyd's Extended Algorithm)

**LeetCode 142: Linked List Cycle II**

```java
/**
 * Find the node where cycle begins
 * Returns null if no cycle
 */
public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    
    // Phase 1: Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // Phase 2: Find cycle start
            ListNode ptr = head;
            
            while (ptr != slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            
            return ptr;  // Cycle start
        }
    }
    
    return null;  // No cycle
}

// Test
public static void main(String[] args) {
    // Create cycle: 1 → 2 → 3 → 4 → 2 (cycle starts at 2)
    ListNode head = new ListNode(1);
    ListNode cycleStart = new ListNode(2);
    head.next = cycleStart;
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = cycleStart;  // Cycle to 2
    
    FastSlowPointer fsp = new FastSlowPointer();
    ListNode start = fsp.detectCycle(head);
    System.out.println("Cycle starts at: " + start.val);  // 2
}
```

**Mathematical Proof**:
```
Let:
- L = distance from head to cycle start
- C = cycle length
- k = distance from cycle start to meeting point

When they meet:
- Slow traveled: L + k
- Fast traveled: L + k + nC (n = number of complete cycles)

Since fast = 2 × slow:
L + k + nC = 2(L + k)
L + k + nC = 2L + 2k
nC = L + k
L = nC - k

So: Distance from head to cycle start (L) = 
    Distance from meeting point to cycle start (nC - k)

Moving one pointer from head and one from meeting point
at same speed will make them meet at cycle start!
```

**Visual Example**:
```
List: 1 → 2 → 3 → 4 → 5 ─┐
          ↑_______________┘

L = 1 (head to 2)
C = 4 (cycle: 2→3→4→5→2)

Meeting point: Let's say at node 4
k = 2 (from 2 to 4)

L = nC - k
1 = 4 - 2 - 1 = 1 ✓

Moving from head (1 step) and from meeting point (1 step)
both reach node 2 (cycle start)
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 5: Find Cycle Length

```java
/**
 * Find length of cycle in linked list
 * Returns 0 if no cycle
 */
public int cycleLength(ListNode head) {
    if (head == null || head.next == null) {
        return 0;
    }
    
    ListNode slow = head;
    ListNode fast = head;
    
    // Detect cycle
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            // Count cycle length
            int length = 1;
            ListNode temp = slow.next;
            
            while (temp != slow) {
                length++;
                temp = temp.next;
            }
            
            return length;
        }
    }
    
    return 0;  // No cycle
}

// Test
public static void main(String[] args) {
    // Create cycle: 1 → 2 → 3 → 4 → 2 (cycle length = 3)
    ListNode head = new ListNode(1);
    ListNode cycleStart = new ListNode(2);
    head.next = cycleStart;
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = cycleStart;
    
    FastSlowPointer fsp = new FastSlowPointer();
    System.out.println("Cycle length: " + fsp.cycleLength(head));  // 3
}
```

**Complexity**: O(n) time, O(1) space

---

## Advanced Patterns

### Pattern 6: Palindrome Check

**LeetCode 234: Palindrome Linked List**

```java
/**
 * Check if linked list is palindrome
 * Using fast-slow to find middle, then reverse second half
 */
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    
    // Step 1: Find middle using fast-slow
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Reverse second half
    ListNode secondHalf = reverseList(slow.next);
    
    // Step 3: Compare both halves
    ListNode firstHalf = head;
    
    while (secondHalf != null) {
        if (firstHalf.val != secondHalf.val) {
            return false;
        }
        firstHalf = firstHalf.next;
        secondHalf = secondHalf.next;
    }
    
    return true;
}

private ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    
    while (current != null) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}

// Test
public static void main(String[] args) {
    // Palindrome: 1 → 2 → 3 → 2 → 1
    ListNode head1 = new ListNode(1);
    head1.next = new ListNode(2);
    head1.next.next = new ListNode(3);
    head1.next.next.next = new ListNode(2);
    head1.next.next.next.next = new ListNode(1);
    
    FastSlowPointer fsp = new FastSlowPointer();
    System.out.println(fsp.isPalindrome(head1));  // true
    
    // Not palindrome: 1 → 2 → 3
    ListNode head2 = new ListNode(1);
    head2.next = new ListNode(2);
    head2.next.next = new ListNode(3);
    
    System.out.println(fsp.isPalindrome(head2));  // false
}
```

**Visual Process**:
```
List: 1 → 2 → 3 → 2 → 1

Step 1: Find middle (3)
1 → 2 → 3 → 2 → 1
        ↑

Step 2: Reverse second half (2 → 1 becomes 1 → 2)
1 → 2 → 3 ← 2 ← 1

Step 3: Compare
1 == 1 ✓
2 == 2 ✓
Palindrome!
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 7: Remove Nth Node from End

**LeetCode 19: Remove Nth Node From End of List**

```java
/**
 * Remove nth node from end using two pointers
 * Variation: Use gap of n between pointers
 */
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    
    ListNode slow = dummy;
    ListNode fast = dummy;
    
    // Move fast n+1 steps ahead
    for (int i = 0; i <= n; i++) {
        fast = fast.next;
    }
    
    // Move both until fast reaches end
    while (fast != null) {
        slow = slow.next;
        fast = fast.next;
    }
    
    // Remove nth node
    slow.next = slow.next.next;
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // List: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    FastSlowPointer fsp = new FastSlowPointer();
    head = fsp.removeNthFromEnd(head, 2);
    
    // Result: 1 → 2 → 3 → 5 (removed 4)
}
```

**Visual Process** (n=2):
```
List: 1 → 2 → 3 → 4 → 5 → null

Step 1: Move fast 3 steps (n+1)
dummy → 1 → 2 → 3 → 4 → 5 → null
slow          fast

Step 2: Move both until fast=null
dummy → 1 → 2 → 3 → 4 → 5 → null
              slow         fast

Step 3: Remove slow.next (4)
1 → 2 → 3 → 5
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 8: Reorder List

**LeetCode 143: Reorder List**

```java
/**
 * Reorder list: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...
 * Using fast-slow to find middle, reverse, then merge
 */
public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }
    
    // Step 1: Find middle
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast.next != null && fast.next.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Reverse second half
    ListNode secondHalf = reverseList(slow.next);
    slow.next = null;
    
    // Step 3: Merge two halves
    ListNode first = head;
    ListNode second = secondHalf;
    
    while (second != null) {
        ListNode temp1 = first.next;
        ListNode temp2 = second.next;
        
        first.next = second;
        second.next = temp1;
        
        first = temp1;
        second = temp2;
    }
}

// Test
public static void main(String[] args) {
    // List: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    FastSlowPointer fsp = new FastSlowPointer();
    fsp.reorderList(head);
    
    // Result: 1 → 5 → 2 → 4 → 3
}
```

**Visual Process**:
```
Original: 1 → 2 → 3 → 4 → 5

Step 1: Find middle
First: 1 → 2 → 3
Second: 4 → 5

Step 2: Reverse second
First: 1 → 2 → 3
Second: 5 → 4

Step 3: Merge alternately
1 → 5 → 2 → 4 → 3
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 9: Sort List (Merge Sort)

**LeetCode 148: Sort List**

```java
/**
 * Sort linked list using merge sort
 * Fast-slow pointer to find middle for splitting
 */
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    // Find middle using fast-slow
    ListNode slow = head;
    ListNode fast = head;
    ListNode prev = null;
    
    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Split at middle
    prev.next = null;
    
    // Sort both halves
    ListNode left = sortList(head);
    ListNode right = sortList(slow);
    
    // Merge sorted halves
    return merge(left, right);
}

private ListNode merge(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }
    
    if (l1 != null) current.next = l1;
    if (l2 != null) current.next = l2;
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // List: 4 → 2 → 1 → 3
    ListNode head = new ListNode(4);
    head.next = new ListNode(2);
    head.next.next = new ListNode(1);
    head.next.next.next = new ListNode(3);
    
    FastSlowPointer fsp = new FastSlowPointer();
    head = fsp.sortList(head);
    
    // Result: 1 → 2 → 3 → 4
}
```

**Complexity**: O(n log n) time, O(log n) space (recursion)

---

## Interview Questions

### Question 1: Happy Number

**LeetCode 202: Happy Number**

```java
/**
 * Determine if a number is happy
 * Use fast-slow to detect cycle in number transformations
 */
public boolean isHappy(int n) {
    int slow = n;
    int fast = n;
    
    do {
        slow = getNext(slow);           // Move 1 step
        fast = getNext(getNext(fast));  // Move 2 steps
        
    } while (slow != fast);
    
    return slow == 1;  // If cycle at 1, it's happy
}

private int getNext(int n) {
    int sum = 0;
    while (n > 0) {
        int digit = n % 10;
        sum += digit * digit;
        n /= 10;
    }
    return sum;
}

// Test
public static void main(String[] args) {
    FastSlowPointer fsp = new FastSlowPointer();
    
    System.out.println(fsp.isHappy(19));  // true
    // 19 → 82 → 68 → 100 → 1
    
    System.out.println(fsp.isHappy(2));   // false
    // 2 → 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 (cycle)
}
```

**Why Fast-Slow Works**: If not happy, will cycle; fast-slow detects cycle

**Complexity**: O(log n) time, O(1) space

---

### Question 2: Intersection of Two Linked Lists

**LeetCode 160: Intersection of Two Linked Lists**

```java
/**
 * Find intersection node of two lists
 * Using two-pointer technique (variation of fast-slow)
 */
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }
    
    ListNode a = headA;
    ListNode b = headB;
    
    // When a reaches end, restart at headB
    // When b reaches end, restart at headA
    // They will meet at intersection or null
    while (a != b) {
        a = (a == null) ? headB : a.next;
        b = (b == null) ? headA : b.next;
    }
    
    return a;
}

// Test
public static void main(String[] args) {
    // Create intersection
    ListNode intersection = new ListNode(8);
    intersection.next = new ListNode(4);
    intersection.next.next = new ListNode(5);
    
    // List A: 4 → 1 → 8 → 4 → 5
    ListNode headA = new ListNode(4);
    headA.next = new ListNode(1);
    headA.next.next = intersection;
    
    // List B: 5 → 6 → 1 → 8 → 4 → 5
    ListNode headB = new ListNode(5);
    headB.next = new ListNode(6);
    headB.next.next = new ListNode(1);
    headB.next.next.next = intersection;
    
    FastSlowPointer fsp = new FastSlowPointer();
    ListNode result = fsp.getIntersectionNode(headA, headB);
    System.out.println("Intersection at: " + result.val);  // 8
}
```

**Complexity**: O(m + n) time, O(1) space

---

### Question 3: Find Duplicate Number

**LeetCode 287: Find the Duplicate Number**

```java
/**
 * Find duplicate in array [1..n] using Floyd's algorithm
 * Treat array as linked list: nums[i] points to nums[nums[i]]
 */
public int findDuplicate(int[] nums) {
    // Phase 1: Find intersection point
    int slow = nums[0];
    int fast = nums[0];
    
    do {
        slow = nums[slow];
        fast = nums[nums[fast]];
    } while (slow != fast);
    
    // Phase 2: Find cycle start (duplicate)
    slow = nums[0];
    
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    
    return slow;
}

// Test
public static void main(String[] args) {
    FastSlowPointer fsp = new FastSlowPointer();
    
    int[] nums = {1, 3, 4, 2, 2};
    System.out.println(fsp.findDuplicate(nums));  // 2
    
    int[] nums2 = {3, 1, 3, 4, 2};
    System.out.println(fsp.findDuplicate(nums2));  // 3
}
```

**Why It Works**: Duplicate creates a cycle in the "linked list"

**Complexity**: O(n) time, O(1) space

---

### Question 4: Circular Array Loop

**LeetCode 457: Circular Array Loop**

```java
/**
 * Check if circular array has a loop
 * Using fast-slow pointer in circular array
 */
public boolean circularArrayLoop(int[] nums) {
    int n = nums.length;
    
    for (int i = 0; i < n; i++) {
        if (nums[i] == 0) continue;
        
        int slow = i, fast = i;
        boolean forward = nums[i] > 0;
        
        while (true) {
            slow = getNext(nums, slow, forward);
            if (slow == -1) break;
            
            fast = getNext(nums, fast, forward);
            if (fast == -1) break;
            fast = getNext(nums, fast, forward);
            if (fast == -1) break;
            
            if (slow == fast) return true;
        }
        
        // Mark visited
        int index = i;
        int val = nums[i];
        while (nums[index] * val > 0) {
            int next = getNext(nums, index, val > 0);
            nums[index] = 0;
            index = next;
        }
    }
    
    return false;
}

private int getNext(int[] nums, int index, boolean forward) {
    boolean direction = nums[index] > 0;
    if (direction != forward) return -1;
    
    int next = (index + nums[index]) % nums.length;
    if (next < 0) next += nums.length;
    
    if (next == index) return -1;  // Single element loop
    
    return next;
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 5: Maximum Twin Sum

**LeetCode 2130: Maximum Twin Sum of a Linked List**

```java
/**
 * Find maximum twin sum in linked list
 * Twin: ith and (n-1-i)th nodes
 */
public int pairSum(ListNode head) {
    // Find middle
    ListNode slow = head;
    ListNode fast = head;
    
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Reverse second half
    ListNode secondHalf = reverseList(slow);
    
    // Calculate max twin sum
    int maxSum = 0;
    ListNode first = head;
    ListNode second = secondHalf;
    
    while (second != null) {
        maxSum = Math.max(maxSum, first.val + second.val);
        first = first.next;
        second = second.next;
    }
    
    return maxSum;
}

// Test
public static void main(String[] args) {
    // List: 5 → 4 → 2 → 1
    // Twins: (5,1)=6, (4,2)=6
    ListNode head = new ListNode(5);
    head.next = new ListNode(4);
    head.next.next = new ListNode(2);
    head.next.next.next = new ListNode(1);
    
    FastSlowPointer fsp = new FastSlowPointer();
    System.out.println(fsp.pairSum(head));  // 6
}
```

**Complexity**: O(n) time, O(1) space

---

## Practice Problems

### Easy Level

1. **Middle of Linked List** (LC 876)
   - Find middle node
   - Solution: Standard fast-slow

2. **Linked List Cycle** (LC 141)
   - Detect cycle existence
   - Solution: Floyd's cycle detection

3. **Remove Duplicates from Sorted List** (LC 83)
   - Remove consecutive duplicates
   - Solution: Single pointer (no need fast-slow)

4. **Merge Two Sorted Lists** (LC 21)
   - Merge two lists
   - Solution: Two pointers (not fast-slow)

5. **Reverse Linked List** (LC 206)
   - Reverse entire list
   - Solution: Iterative/recursive

### Medium Level

6. **Linked List Cycle II** (LC 142) ⭐
   - Find cycle start
   - Solution: Floyd's extended algorithm

7. **Remove Nth Node From End** (LC 19) ⭐
   - Remove from end
   - Solution: Two pointers with gap

8. **Palindrome Linked List** (LC 234) ⭐
   - Check palindrome
   - Solution: Fast-slow + reverse

9. **Reorder List** (LC 143) ⭐
   - Reorder alternately
   - Solution: Fast-slow + reverse + merge

10. **Sort List** (LC 148) ⭐
    - Sort in O(n log n)
    - Solution: Merge sort with fast-slow

11. **Odd Even Linked List** (LC 328)
    - Group odd/even indices
    - Solution: Two pointers

12. **Rotate List** (LC 61)
    - Rotate right by k
    - Solution: Find length, move pointers

13. **Swap Nodes in Pairs** (LC 24)
    - Swap adjacent pairs
    - Solution: Iterative pointer swap

14. **Delete Middle Node** (LC 2095)
    - Delete middle element
    - Solution: Fast-slow with prev

15. **Maximum Twin Sum** (LC 2130)
    - Find max twin sum
    - Solution: Fast-slow + reverse

### Hard Level

16. **Merge K Sorted Lists** (LC 23)
    - Merge multiple lists
    - Solution: Priority queue / divide-conquer

17. **Reverse Nodes in K-Group** (LC 25)
    - Reverse every k nodes
    - Solution: Group reversal

18. **Copy List with Random Pointer** (LC 138)
    - Deep copy with random
    - Solution: Interleaving

19. **Find Duplicate Number** (LC 287) ⭐
    - Find duplicate in array
    - Solution: Floyd's on array

20. **Circular Array Loop** (LC 457)
    - Detect loop in circular array
    - Solution: Fast-slow on array

---

## Summary

### Key Takeaways

1. **Fast moves 2x speed**: Core concept of the technique
2. **O(1) space**: Major advantage over HashSet approaches
3. **Multiple applications**: Middle, cycle, palindrome, reorder
4. **Floyd's algorithm**: Cycle detection and finding start
5. **Always check null**: `fast != null && fast.next != null`

### Common Patterns Summary

| Pattern | Use Case | Complexity |
|---------|----------|------------|
| Find Middle | Split list, palindrome | O(n), O(1) |
| Detect Cycle | Check if cycle exists | O(n), O(1) |
| Find Cycle Start | Find where cycle begins | O(n), O(1) |
| Nth from End | Remove/find from end | O(n), O(1) |
| Palindrome | Check symmetry | O(n), O(1) |
| Reorder | Rearrange alternately | O(n), O(1) |

### Loop Conditions Reference

```java
// Standard (most common)
while (fast != null && fast.next != null)

// For first middle in even length
while (fast.next != null && fast.next.next != null)

// For cycle detection loop
while (slow != fast)

// For specific iterations
for (int i = 0; i < n; i++)
```

### Fast-Slow vs Other Techniques

```
Fast-Slow Pointer:
✓ O(1) space (vs O(n) for HashSet)
✓ Elegant mathematical properties
✓ Works on implicit linked lists (arrays)
✓ In-place operations

HashSet Approach:
✓ Simpler to understand
✓ Can store additional info
✗ O(n) extra space
✗ Not allowed in space-optimized problems
```

### Problem Recognition Guide

**Use Fast-Slow when**:
- "Find middle of linked list"
- "Detect cycle in linked list"
- "Check if palindrome" (linked list)
- "Remove nth from end"
- "Reorder list alternately"
- "Find duplicate in array [1..n]"
- Space complexity must be O(1)

**Don't use when**:
- Need to access arbitrary positions
- Array allows random access
- HashSet/HashMap is allowed and simpler

### Common Mistakes to Avoid

1. **Wrong loop condition**: Always `fast != null && fast.next != null`
2. **Null pointer**: Check before `fast.next.next`
3. **Off-by-one**: Carefully handle even/odd length differences
4. **Forgetting dummy node**: Use for deletion problems
5. **Not considering empty/single**: Handle edge cases

### Interview Tips

1. **Clarify constraints**: Ask about space complexity
2. **Draw it out**: Visualize pointer movements
3. **Start simple**: Begin with finding middle
4. **Know Floyd's**: Both cycle detection and finding start
5. **Practice variations**: Middle, cycle, palindrome, reorder
6. **Explain why**: Mathematical reasoning for cycle detection
7. **Consider edge cases**: Empty, single, two nodes

### Time Complexity Analysis

```
n = list length

Find Middle: O(n/2) = O(n)
Detect Cycle: O(n) worst case
Find Cycle Start: O(n) + O(n) = O(n)
Palindrome: O(n) + O(n/2) + O(n/2) = O(n)
Remove Nth: O(n)

All are single-pass or minimal passes!
```

### Master These Problems

**Must Know**:
1. ✅ Find Middle (LC 876)
2. ✅ Detect Cycle (LC 141)
3. ✅ Find Cycle Start (LC 142)
4. ✅ Palindrome (LC 234)
5. ✅ Remove Nth from End (LC 19)

**Advanced**:
6. ✅ Reorder List (LC 143)
7. ✅ Sort List (LC 148)
8. ✅ Find Duplicate (LC 287)
9. ✅ Happy Number (LC 202)
10. ✅ Maximum Twin Sum (LC 2130)

---

**Previous**: [7.3 Circular Linked List](7.3-Circular-Linked-List.md)

**Next**: [7.5 Linked List Practice Problems](7.5-Linked-List-Practice-Problems.md)

**Master**: Floyd's Cycle Detection is the cornerstone of this technique!
