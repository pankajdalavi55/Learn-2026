# 7.5 Reversal Techniques for Linked Lists

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Reversal](#basic-reversal)
3. [Recursive Reversal](#recursive-reversal)
4. [Partial Reversal](#partial-reversal)
5. [Group Reversal](#group-reversal)
6. [Advanced Patterns](#advanced-patterns)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is List Reversal?

**List reversal** is the process of reversing the direction of links in a linked list, making the last node become the first and vice versa.

### Why Learn Reversal Techniques?

- **Most common operation**: Appears in 30%+ of linked list problems
- **Foundation for complex problems**: Reorder, palindrome, rotate
- **Multiple approaches**: Iterative, recursive, partial, groups
- **Interview favorite**: Tests pointer manipulation skills
- **Space-time tradeoff**: Choose between O(1) and O(n) space

### Visual Example

```
Original:
HEAD → [1|●] → [2|●] → [3|●] → [4|●] → [5|null]

Reversed:
HEAD → [5|●] → [4|●] → [3|●] → [2|●] → [1|null]

Direction of all arrows is flipped!
```

### Types of Reversal

| Type | Description | Complexity |
|------|-------------|------------|
| **Complete** | Reverse entire list | O(n), O(1) |
| **Partial** | Reverse between positions | O(n), O(1) |
| **Group** | Reverse k nodes at a time | O(n), O(1) |
| **Alternate** | Reverse alternate k nodes | O(n), O(1) |
| **Recursive** | Using recursion | O(n), O(n) |

### Common Applications

1. **Palindrome Check**: Reverse second half, compare
2. **Reorder List**: Reverse second half, merge
3. **Add Two Numbers**: Process in reverse order
4. **Print Reverse**: Without modifying list
5. **Reverse K-Group**: Advanced reversal pattern

---

## Basic Reversal

### Pattern 1: Iterative Reversal (Standard)

**Most important and fundamental pattern!**

```java
class ListNode {
    int val;
    ListNode next;
    
    ListNode(int val) {
        this.val = val;
    }
}

public class ReverseList {
    /**
     * Reverse entire linked list iteratively
     * LeetCode 206: Reverse Linked List
     */
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        
        while (current != null) {
            ListNode next = current.next;  // Save next
            current.next = prev;           // Reverse link
            prev = current;                // Move prev forward
            current = next;                // Move current forward
        }
        
        return prev;  // New head
    }
    
    // Test
    public static void main(String[] args) {
        // Create: 1 → 2 → 3 → 4 → 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        
        ReverseList rl = new ReverseList();
        head = rl.reverseList(head);
        
        // Result: 5 → 4 → 3 → 2 → 1
        printList(head);
    }
    
    private static void printList(ListNode head) {
        while (head != null) {
            System.out.print(head.val + " → ");
            head = head.next;
        }
        System.out.println("null");
    }
}
```

**Visual Step-by-Step**:
```
Initial: 1 → 2 → 3 → 4 → 5 → null
         ↑
      current
      prev=null

Step 1: Save next (2), reverse link
null ← 1   2 → 3 → 4 → 5 → null
       ↑   ↑
      prev current

Step 2: Save next (3), reverse link
null ← 1 ← 2   3 → 4 → 5 → null
            ↑   ↑
           prev current

Step 3: Save next (4), reverse link
null ← 1 ← 2 ← 3   4 → 5 → null
                ↑   ↑
               prev current

Step 4: Save next (5), reverse link
null ← 1 ← 2 ← 3 ← 4   5 → null
                    ↑   ↑
                   prev current

Step 5: Save next (null), reverse link
null ← 1 ← 2 ← 3 ← 4 ← 5   null
                        ↑   ↑
                       prev current

Final: prev is new head
HEAD → 5 → 4 → 3 → 2 → 1 → null
```

**Key Points**:
- Three pointers: `prev`, `current`, `next`
- Save `next` before breaking link
- Move all pointers forward each iteration
- Return `prev` at the end (new head)

**Complexity**: O(n) time, O(1) space

---

### Pattern 2: Using Dummy Node

**Useful when integrating with other operations**

```java
/**
 * Reverse using dummy node (less common but useful)
 */
public ListNode reverseWithDummy(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    ListNode current = head;
    
    while (current != null) {
        ListNode next = current.next;
        current.next = dummy.next;
        dummy.next = current;
        current = next;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseWithDummy(head);
    
    printList(head);  // 3 → 2 → 1 → null
}
```

**Visual Process**:
```
Initial:
dummy → null
1 → 2 → 3 → null

Step 1: Insert 1 at beginning
dummy → 1 → null
2 → 3 → null

Step 2: Insert 2 at beginning
dummy → 2 → 1 → null
3 → null

Step 3: Insert 3 at beginning
dummy → 3 → 2 → 1 → null
```

**Complexity**: O(n) time, O(1) space

---

## Recursive Reversal

### Pattern 3: Recursive Approach

**Elegant but uses stack space**

```java
/**
 * Reverse linked list recursively
 * Uses O(n) space on call stack
 */
public ListNode reverseRecursive(ListNode head) {
    // Base case: empty or single node
    if (head == null || head.next == null) {
        return head;
    }
    
    // Recursive case
    ListNode newHead = reverseRecursive(head.next);
    
    // Reverse the link
    head.next.next = head;
    head.next = null;
    
    return newHead;
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseRecursive(head);
    
    printList(head);  // 4 → 3 → 2 → 1 → null
}
```

**Recursion Flow**:
```
reverseRecursive(1 → 2 → 3 → 4)
  → reverseRecursive(2 → 3 → 4)
    → reverseRecursive(3 → 4)
      → reverseRecursive(4)
        → return 4 (base case)
      
      ← 4, now reverse: 4 ← 3
    ← 4, now reverse: 4 ← 3 ← 2
  ← 4, now reverse: 4 ← 3 ← 2 ← 1

Result: 4 → 3 → 2 → 1
```

**Key Steps**:
1. Recurse to the last node (base case)
2. On return, reverse current link
3. Set current.next = null
4. Return the new head (propagates up)

**Complexity**: O(n) time, O(n) space (call stack)

---

### Pattern 4: Tail Recursive

**More efficient recursive version**

```java
/**
 * Tail recursive reversal with accumulator
 */
public ListNode reverseTailRecursive(ListNode head) {
    return reverseTailHelper(head, null);
}

private ListNode reverseTailHelper(ListNode current, ListNode prev) {
    if (current == null) {
        return prev;
    }
    
    ListNode next = current.next;
    current.next = prev;
    
    return reverseTailHelper(next, current);
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseTailRecursive(head);
    
    printList(head);  // 3 → 2 → 1 → null
}
```

**Advantages**:
- Can be optimized by compiler (tail call optimization)
- Similar structure to iterative version
- Cleaner than standard recursion

**Complexity**: O(n) time, O(n) space (but optimizable)

---

## Partial Reversal

### Pattern 5: Reverse Between Positions

**LeetCode 92: Reverse Linked List II**

```java
/**
 * Reverse list between positions left and right (1-indexed)
 * Example: 1→2→3→4→5, left=2, right=4 → 1→4→3→2→5
 */
public ListNode reverseBetween(ListNode head, int left, int right) {
    if (head == null || left == right) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    
    // Move to node before left
    for (int i = 1; i < left; i++) {
        prev = prev.next;
    }
    
    // Reverse the sublist
    ListNode current = prev.next;
    ListNode next;
    
    for (int i = 0; i < right - left; i++) {
        next = current.next;
        current.next = next.next;
        next.next = prev.next;
        prev.next = next;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // Create: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseBetween(head, 2, 4);
    
    printList(head);  // 1 → 4 → 3 → 2 → 5 → null
}
```

**Visual Process** (left=2, right=4):
```
Original: 1 → 2 → 3 → 4 → 5
             left    right

Step 1: Position prev before left
dummy → 1 → 2 → 3 → 4 → 5
        ↑
       prev

Step 2: Reverse 2→3 (move 3 to front)
dummy → 1 → 3 → 2 → 4 → 5
        ↑       ↑
       prev  current

Step 3: Reverse 2→4 (move 4 to front)
dummy → 1 → 4 → 3 → 2 → 5
        ↑           ↑
       prev      current

Result: 1 → 4 → 3 → 2 → 5
```

**Alternative: Three-Part Approach**
```java
public ListNode reverseBetweenThreePart(ListNode head, int left, int right) {
    if (head == null || left == right) return head;
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode beforeLeft = dummy;
    
    // Move to node before left
    for (int i = 1; i < left; i++) {
        beforeLeft = beforeLeft.next;
    }
    
    // Identify the three parts
    ListNode leftNode = beforeLeft.next;
    ListNode prev = null;
    ListNode current = leftNode;
    
    // Reverse the middle part
    for (int i = 0; i <= right - left; i++) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    // Connect three parts
    beforeLeft.next = prev;     // Connect to reversed part
    leftNode.next = current;    // Connect to remaining part
    
    return dummy.next;
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 6: Reverse First N Nodes

```java
/**
 * Reverse first n nodes of linked list
 */
public ListNode reverseFirstN(ListNode head, int n) {
    if (head == null || n <= 1) {
        return head;
    }
    
    ListNode prev = null;
    ListNode current = head;
    ListNode remaining = null;
    int count = 0;
    
    // Reverse first n nodes
    while (current != null && count < n) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
        count++;
    }
    
    // Connect reversed part with remaining
    head.next = current;
    
    return prev;
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseFirstN(head, 3);
    
    printList(head);  // 3 → 2 → 1 → 4 → 5 → null
}
```

**Complexity**: O(n) time, O(1) space

---

## Group Reversal

### Pattern 7: Reverse K-Group

**LeetCode 25: Reverse Nodes in k-Group**

```java
/**
 * Reverse nodes in groups of k
 * If remaining < k, keep as is
 */
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || k == 1) {
        return head;
    }
    
    // Count total nodes
    int count = 0;
    ListNode temp = head;
    while (temp != null) {
        count++;
        temp = temp.next;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prevGroupEnd = dummy;
    
    while (count >= k) {
        ListNode groupStart = prevGroupEnd.next;
        ListNode prev = null;
        ListNode current = groupStart;
        
        // Reverse k nodes
        for (int i = 0; i < k; i++) {
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        
        // Connect with previous and next groups
        prevGroupEnd.next = prev;
        groupStart.next = current;
        prevGroupEnd = groupStart;
        
        count -= k;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // Create: 1 → 2 → 3 → 4 → 5
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    ReverseList rl = new ReverseList();
    head = rl.reverseKGroup(head, 2);
    
    printList(head);  // 2 → 1 → 4 → 3 → 5 → null
}
```

**Visual Process** (k=3):
```
Original: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

Group 1 (reverse 1,2,3):
3 → 2 → 1 → 4 → 5 → 6 → 7 → 8

Group 2 (reverse 4,5,6):
3 → 2 → 1 → 6 → 5 → 4 → 7 → 8

Remaining < k (keep as is):
3 → 2 → 1 → 6 → 5 → 4 → 7 → 8
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 8: Reverse Alternate K Nodes

```java
/**
 * Reverse alternate k nodes
 * Reverse k, skip k, reverse k, skip k...
 */
public ListNode reverseAlternateKGroup(ListNode head, int k) {
    if (head == null || k <= 1) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prevGroupEnd = dummy;
    ListNode current = head;
    
    boolean reverse = true;
    
    while (current != null) {
        // Check if k nodes available
        ListNode temp = current;
        int count = 0;
        while (temp != null && count < k) {
            temp = temp.next;
            count++;
        }
        
        if (count < k) break;
        
        if (reverse) {
            // Reverse k nodes
            ListNode groupStart = current;
            ListNode prev = null;
            
            for (int i = 0; i < k; i++) {
                ListNode next = current.next;
                current.next = prev;
                prev = current;
                current = next;
            }
            
            prevGroupEnd.next = prev;
            groupStart.next = current;
            prevGroupEnd = groupStart;
        } else {
            // Skip k nodes
            for (int i = 0; i < k; i++) {
                prevGroupEnd = current;
                current = current.next;
            }
        }
        
        reverse = !reverse;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    // Create: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8
    ListNode head = new ListNode(1);
    for (int i = 2; i <= 8; i++) {
        ListNode curr = head;
        while (curr.next != null) curr = curr.next;
        curr.next = new ListNode(i);
    }
    
    ReverseList rl = new ReverseList();
    head = rl.reverseAlternateKGroup(head, 3);
    
    printList(head);  // 3 → 2 → 1 → 4 → 5 → 6 → 8 → 7 → (last 2 < k)
}
```

**Visual Process** (k=2):
```
Original: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8

Reverse 1,2:
2 → 1 → 3 → 4 → 5 → 6 → 7 → 8

Skip 3,4:
2 → 1 → 3 → 4 → 5 → 6 → 7 → 8

Reverse 5,6:
2 → 1 → 3 → 4 → 6 → 5 → 7 → 8

Skip 7,8:
2 → 1 → 3 → 4 → 6 → 5 → 7 → 8
```

**Complexity**: O(n) time, O(1) space

---

## Advanced Patterns

### Pattern 9: Reverse in Pairs (Swap Adjacent)

**LeetCode 24: Swap Nodes in Pairs**

```java
/**
 * Swap every two adjacent nodes
 * Example: 1→2→3→4 becomes 2→1→4→3
 */
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    
    while (prev.next != null && prev.next.next != null) {
        ListNode first = prev.next;
        ListNode second = prev.next.next;
        
        // Swap
        first.next = second.next;
        second.next = first;
        prev.next = second;
        
        prev = first;
    }
    
    return dummy.next;
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    
    ReverseList rl = new ReverseList();
    head = rl.swapPairs(head);
    
    printList(head);  // 2 → 1 → 4 → 3 → null
}
```

**Visual Process**:
```
Original: dummy → 1 → 2 → 3 → 4 → null
          prev

Step 1: Swap 1 and 2
dummy → 2 → 1 → 3 → 4 → null
            ↑
           prev

Step 2: Swap 3 and 4
dummy → 2 → 1 → 4 → 3 → null
                    ↑
                   prev
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 10: Pairwise Reverse (Recursive)

```java
/**
 * Swap pairs recursively
 */
public ListNode swapPairsRecursive(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    
    ListNode newHead = head.next;
    head.next = swapPairsRecursive(newHead.next);
    newHead.next = head;
    
    return newHead;
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    head.next.next.next.next = new ListNode(5);
    
    ReverseList rl = new ReverseList();
    head = rl.swapPairsRecursive(head);
    
    printList(head);  // 2 → 1 → 4 → 3 → 5 → null
}
```

**Recursion Flow**:
```
swapPairs(1 → 2 → 3 → 4)
  newHead = 2
  1.next = swapPairs(3 → 4)
    newHead = 4
    3.next = swapPairs(null)
      return null
    4.next = 3
    return 4
  2.next = 1
  return 2

Result: 2 → 1 → 4 → 3
```

**Complexity**: O(n) time, O(n) space

---

### Pattern 11: Reverse and Add

**LeetCode 445: Add Two Numbers II**

```java
/**
 * Add two numbers represented as linked lists (most significant first)
 * Use reversal to add from least significant
 */
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    // Reverse both lists
    l1 = reverseList(l1);
    l2 = reverseList(l2);
    
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    int carry = 0;
    
    while (l1 != null || l2 != null || carry != 0) {
        int sum = carry;
        
        if (l1 != null) {
            sum += l1.val;
            l1 = l1.next;
        }
        
        if (l2 != null) {
            sum += l2.val;
            l2 = l2.next;
        }
        
        carry = sum / 10;
        current.next = new ListNode(sum % 10);
        current = current.next;
    }
    
    // Reverse result
    return reverseList(dummy.next);
}

// Test
public static void main(String[] args) {
    // 7 → 2 → 4 → 3 (7243)
    ListNode l1 = new ListNode(7);
    l1.next = new ListNode(2);
    l1.next.next = new ListNode(4);
    l1.next.next.next = new ListNode(3);
    
    // 5 → 6 → 4 (564)
    ListNode l2 = new ListNode(5);
    l2.next = new ListNode(6);
    l2.next.next = new ListNode(4);
    
    ReverseList rl = new ReverseList();
    ListNode result = rl.addTwoNumbers(l1, l2);
    
    printList(result);  // 7 → 8 → 0 → 7 (7807)
}
```

**Complexity**: O(max(m, n)) time, O(1) space

---

### Pattern 12: Print Reverse (Without Modifying)

```java
/**
 * Print linked list in reverse without modifying
 * Using recursion
 */
public void printReverse(ListNode head) {
    if (head == null) {
        return;
    }
    
    printReverse(head.next);
    System.out.print(head.val + " ");
}

/**
 * Print reverse using stack
 */
public void printReverseStack(ListNode head) {
    Stack<Integer> stack = new Stack<>();
    
    while (head != null) {
        stack.push(head.val);
        head = head.next;
    }
    
    while (!stack.isEmpty()) {
        System.out.print(stack.pop() + " ");
    }
}

// Test
public static void main(String[] args) {
    ListNode head = new ListNode(1);
    head.next = new ListNode(2);
    head.next.next = new ListNode(3);
    head.next.next.next = new ListNode(4);
    
    ReverseList rl = new ReverseList();
    
    System.out.print("Recursive: ");
    rl.printReverse(head);     // 4 3 2 1
    System.out.println();
    
    System.out.print("Stack: ");
    rl.printReverseStack(head); // 4 3 2 1
}
```

**Complexity**: 
- Recursive: O(n) time, O(n) space
- Stack: O(n) time, O(n) space

---

## Interview Questions

### Question 1: Reverse Sublist

**Problem**: Reverse nodes from position m to n.

```java
/**
 * More intuitive version of reverseBetween
 */
public ListNode reverseSublist(ListNode head, int m, int n) {
    if (head == null || m >= n) {
        return head;
    }
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode beforeM = dummy;
    
    // Move to node before m
    for (int i = 1; i < m; i++) {
        beforeM = beforeM.next;
    }
    
    ListNode mNode = beforeM.next;
    ListNode prev = null;
    ListNode current = mNode;
    
    // Reverse m to n
    for (int i = 0; i <= n - m; i++) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    // Reconnect
    beforeM.next = prev;
    mNode.next = current;
    
    return dummy.next;
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 2: Reverse Even Length Groups

**LeetCode 2074: Reverse Nodes in Even Length Groups**

```java
/**
 * Reverse nodes in even length groups
 * Groups: 1, 2, 3, 4, 5...
 */
public ListNode reverseEvenLengthGroups(ListNode head) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy;
    int groupSize = 1;
    
    while (prev.next != null) {
        // Count actual group size
        ListNode temp = prev.next;
        int actualSize = 0;
        
        for (int i = 0; i < groupSize && temp != null; i++) {
            actualSize++;
            temp = temp.next;
        }
        
        // Reverse if even
        if (actualSize % 2 == 0) {
            prev = reverseGroup(prev, actualSize);
        } else {
            // Skip group
            for (int i = 0; i < actualSize; i++) {
                prev = prev.next;
            }
        }
        
        groupSize++;
    }
    
    return dummy.next;
}

private ListNode reverseGroup(ListNode beforeGroup, int k) {
    ListNode groupStart = beforeGroup.next;
    ListNode prev = null;
    ListNode current = groupStart;
    
    for (int i = 0; i < k; i++) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    beforeGroup.next = prev;
    groupStart.next = current;
    
    return groupStart;
}
```

**Complexity**: O(n) time, O(1) space

---

### Question 3: Reverse Binary Tree Level Order

**Convert level order to reverse level order using list reversal**

```java
/**
 * Demonstrate reversal in tree context
 */
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();
        
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(0, level);  // Add at beginning (reverse)
    }
    
    return result;
}
```

---

### Question 4: Reverse String Using Linked List

**Apply reversal concept to strings**

```java
/**
 * Reverse string using linked list approach
 */
public String reverseString(String s) {
    char[] chars = s.toCharArray();
    int left = 0;
    int right = chars.length - 1;
    
    while (left < right) {
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        left++;
        right--;
    }
    
    return new String(chars);
}
```

---

### Question 5: Reverse Words in String

**LeetCode 151: Reverse Words in a String**

```java
/**
 * Reverse words using reversal technique
 * "the sky is blue" → "blue is sky the"
 */
public String reverseWords(String s) {
    // Trim and split
    String[] words = s.trim().split("\\s+");
    
    // Reverse array
    int left = 0;
    int right = words.length - 1;
    
    while (left < right) {
        String temp = words[left];
        words[left] = words[right];
        words[right] = temp;
        left++;
        right--;
    }
    
    return String.join(" ", words);
}
```

---

## Practice Problems

### Easy Level

1. **Reverse Linked List** (LC 206) ⭐
   - Complete reversal
   - Solution: Standard iterative

2. **Palindrome Linked List** (LC 234)
   - Reverse second half
   - Solution: Find middle + reverse

3. **Reverse String** (LC 344)
   - Apply reversal to array
   - Solution: Two pointers

4. **Reverse Vowels of String** (LC 345)
   - Selective reversal
   - Solution: Two pointers

5. **Reverse String II** (LC 541)
   - Reverse first k in 2k groups
   - Solution: Group reversal

### Medium Level

6. **Reverse Linked List II** (LC 92) ⭐
   - Partial reversal
   - Solution: Three-part approach

7. **Swap Nodes in Pairs** (LC 24) ⭐
   - Reverse in pairs
   - Solution: Iterative swap

8. **Reverse Words in String** (LC 151)
   - Word-level reversal
   - Solution: Split + reverse

9. **Reverse Words III** (LC 557)
   - Reverse each word
   - Solution: Split + reverse each

10. **Add Two Numbers II** (LC 445)
    - Use reversal for addition
    - Solution: Reverse + add + reverse

11. **Odd Even Linked List** (LC 328)
    - Rearrange (similar to reversal)
    - Solution: Two pointers

12. **Reorder List** (LC 143)
    - Reverse + merge
    - Solution: Find middle + reverse + merge

13. **Rotate List** (LC 61)
    - Rotation (related to reversal)
    - Solution: Connect + break

14. **Reverse String in Parentheses** (LC 1190)
    - Nested reversal
    - Solution: Stack-based

15. **Reverse Substrings** (LC 1410)
    - Multiple reversals
    - Solution: Stack or recursion

### Hard Level

16. **Reverse Nodes in k-Group** (LC 25) ⭐⭐
    - Group reversal
    - Solution: Iterative k-reversal

17. **Reverse Even Length Groups** (LC 2074)
    - Conditional reversal
    - Solution: Group counting + reverse

18. **Maximum Score After Splitting** (LC 1422)
    - Uses reversal concept
    - Solution: Prefix sum

19. **Basic Calculator III** (LC 772)
    - Reverse Polish notation
    - Solution: Stack with reversal

20. **Reverse Pairs** (LC 493)
    - Count inversions
    - Solution: Merge sort

---

## Summary

### Key Takeaways

1. **Master iterative first**: Foundation for all variations
2. **Three pointers**: prev, current, next (standard pattern)
3. **Dummy node helpful**: For partial reversals
4. **Recursive elegant**: But uses O(n) space
5. **Group reversal common**: Practice k-group pattern

### Reversal Patterns Summary

| Pattern | Use Case | Complexity |
|---------|----------|------------|
| Complete Iterative | Full reversal | O(n), O(1) ✅ |
| Recursive | Elegant solution | O(n), O(n) |
| Partial (m to n) | Sublist reversal | O(n), O(1) |
| K-Group | Groups of k | O(n), O(1) |
| Swap Pairs | Adjacent swap | O(n), O(1) |
| Alternate K | Skip alternate | O(n), O(1) |

### Iterative vs Recursive

```
Iterative Reversal:
✓ O(1) space
✓ Better performance
✓ No stack overflow risk
✓ Preferred in interviews

Recursive Reversal:
✓ Elegant and concise
✓ Easier to understand
✗ O(n) space (call stack)
✗ Stack overflow for large lists
```

### Common Reversal Templates

**Template 1: Complete Reversal**
```java
ListNode prev = null, current = head;
while (current != null) {
    ListNode next = current.next;
    current.next = prev;
    prev = current;
    current = next;
}
return prev;
```

**Template 2: Partial Reversal**
```java
// 1. Move to start position
// 2. Reverse k nodes
// 3. Reconnect three parts
```

**Template 3: Group Reversal**
```java
while (hasKNodes) {
    // 1. Reverse k nodes
    // 2. Connect groups
    // 3. Move to next group
}
```

### Problem Recognition Guide

**Use Complete Reversal when**:
- "Reverse linked list"
- "Check palindrome" (reverse half)
- "Reorder list" (reverse half)

**Use Partial Reversal when**:
- "Reverse from position m to n"
- "Reverse sublist"
- "Swap specific nodes"

**Use Group Reversal when**:
- "Reverse k nodes at a time"
- "Swap pairs"
- "Reverse even/odd groups"

### Common Mistakes to Avoid

1. **Losing head reference**: Save in dummy node
2. **Not saving next**: Will lose rest of list
3. **Wrong return**: Return `prev` not `current`
4. **Off-by-one**: Careful with indices
5. **Not handling edges**: Empty, single node
6. **Forgetting reconnection**: Link reversed part back

### Interview Tips

1. **Start with basic**: Show you know standard reversal
2. **Explain approach**: Three pointers - prev, current, next
3. **Draw it**: Visualize pointer movements
4. **Handle edges**: Empty, single, two nodes
5. **Optimize space**: Prefer iterative over recursive
6. **Test on paper**: Walk through small example
7. **Know variations**: Partial, groups, alternate

### Complexity Cheat Sheet

```
Complete Reversal:
- Iterative: O(n) time, O(1) space ⭐
- Recursive: O(n) time, O(n) space

Partial Reversal:
- O(n) time, O(1) space

K-Group Reversal:
- O(n) time, O(1) space
- Process each node once

Swap Pairs:
- O(n) time, O(1) space
- Special case of k=2
```

### Master These Problems

**Must Know** (Interview Essentials):
1. ✅ Reverse Linked List (LC 206)
2. ✅ Reverse Linked List II (LC 92)
3. ✅ Swap Nodes in Pairs (LC 24)
4. ✅ Reverse Nodes in k-Group (LC 25)
5. ✅ Palindrome Linked List (LC 234)

**Advanced**:
6. ✅ Reorder List (LC 143)
7. ✅ Add Two Numbers II (LC 445)
8. ✅ Reverse Even Length Groups (LC 2074)

---

**Previous**: [7.4 Fast & Slow Pointer](7.4-Fast-Slow-Pointer.md)

**Next**: [7.6 Linked List Practice Problems](7.6-Linked-List-Practice-Problems.md)

**Master Pattern**: Three pointers (prev, current, next) - The foundation of all reversal techniques!
