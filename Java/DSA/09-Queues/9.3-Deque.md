# 9.3 Deque (Double-Ended Queue)

## Table of Contents
1. [Introduction](#introduction)
2. [Deque Fundamentals](#deque-fundamentals)
3. [Java Deque Interface](#java-deque-interface)
4. [Array-Based Deque](#array-based-deque)
5. [Circular Deque](#circular-deque)
6. [Linked List Deque](#linked-list-deque)
7. [Common Deque Patterns](#common-deque-patterns)
8. [Classic Problems](#classic-problems)
9. [Interview Questions](#interview-questions)
10. [Practice Problems](#practice-problems)
11. [Summary](#summary)

---

## Introduction

### What is a Deque?

A **Deque** (Double-Ended Queue, pronounced "deck") is a linear data structure that allows insertion and deletion at **both ends** (front and rear).

**Key Features**:
- Insert/delete from **front**
- Insert/delete from **rear**
- Combines stack and queue operations
- Can be used as both FIFO and LIFO

### Real-World Analogies

1. **Browser History**: Navigate forward and backward
2. **Undo/Redo**: Add to both ends, remove from both ends
3. **Sliding Window**: Add new elements, remove old elements
4. **Card Deck**: Draw from top or bottom
5. **Work Stealing Queue**: Workers take from front, steal from rear

### Deque Visualization

```
Operations at BOTH ends:

    addFirst          addLast
        ↓                ↓
Front → [A] [B] [C] [D] ← Rear
        ↑                ↑
    removeFirst      removeLast

Examples:
- addFirst(E)  → [E, A, B, C, D]
- addLast(E)   → [A, B, C, D, E]
- removeFirst() → [B, C, D] (A removed)
- removeLast()  → [A, B, C] (D removed)
```

---

## Deque Fundamentals

### Deque vs Queue vs Stack

| Feature | Queue | Stack | Deque |
|---------|-------|-------|-------|
| Insert | Rear only | Top only | Both ends |
| Delete | Front only | Top only | Both ends |
| Principle | FIFO | LIFO | Both FIFO/LIFO |
| Use Case | BFS | DFS, Recursion | Sliding window |
| Flexibility | Low | Low | High |

**Visual Comparison**:
```
Queue:
  enqueue → [1, 2, 3] → dequeue
  (rear)              (front)

Stack:
           [1, 2, 3] ← pop
  push →            (top)

Deque:
  addFirst → [1, 2, 3] ← addLast
  removeFirst       removeLast
```

### Core Operations

**Insertion Operations**:
| Operation | Description | Time |
|-----------|-------------|------|
| `addFirst(e)` | Add element at front | O(1) |
| `addLast(e)` | Add element at rear | O(1) |
| `offerFirst(e)` | Add at front (returns false if full) | O(1) |
| `offerLast(e)` | Add at rear (returns false if full) | O(1) |

**Deletion Operations**:
| Operation | Description | Time |
|-----------|-------------|------|
| `removeFirst()` | Remove from front | O(1) |
| `removeLast()` | Remove from rear | O(1) |
| `pollFirst()` | Remove from front (returns null if empty) | O(1) |
| `pollLast()` | Remove from rear (returns null if empty) | O(1) |

**Examination Operations**:
| Operation | Description | Time |
|-----------|-------------|------|
| `getFirst()` | View front element | O(1) |
| `getLast()` | View rear element | O(1) |
| `peekFirst()` | View front (returns null if empty) | O(1) |
| `peekLast()` | View rear (returns null if empty) | O(1) |

---

## Java Deque Interface

### Deque Hierarchy

```
Collection<E>
    ↓
Queue<E>
    ↓
Deque<E>
    ↓
  ┌─────┴─────┐
  ↓           ↓
ArrayDeque  LinkedList
```

### Common Implementations

**1. ArrayDeque** (Recommended):
```java
Deque<Integer> deque = new ArrayDeque<>();
```
- **Fastest** implementation
- **Resizable array**
- **No capacity restrictions**
- **Not thread-safe**
- **Null elements not allowed**

**2. LinkedList**:
```java
Deque<Integer> deque = new LinkedList<>();
```
- **Doubly-linked list**
- **Allows null elements**
- **Slower than ArrayDeque**
- **More memory overhead**

### Method Summary

**Two Variants** (like Queue):
- **Throws exception**: `addFirst()`, `removeFirst()`, `getFirst()`
- **Returns special value**: `offerFirst()`, `pollFirst()`, `peekFirst()`

| Operation | First Element (Head) | Last Element (Tail) |
|-----------|---------------------|---------------------|
| **Insert** | `addFirst(e)` | `addLast(e)` |
| | `offerFirst(e)` | `offerLast(e)` |
| **Remove** | `removeFirst()` | `removeLast()` |
| | `pollFirst()` | `pollLast()` |
| **Examine** | `getFirst()` | `getLast()` |
| | `peekFirst()` | `peekLast()` |

### Basic Usage

```java
import java.util.*;

public class DequeBasics {
    public static void main(String[] args) {
        Deque<Integer> deque = new ArrayDeque<>();
        
        // Add elements
        deque.addFirst(10);   // [10]
        deque.addLast(20);    // [10, 20]
        deque.addFirst(5);    // [5, 10, 20]
        deque.addLast(25);    // [5, 10, 20, 25]
        
        System.out.println("Deque: " + deque);  // [5, 10, 20, 25]
        
        // View elements
        System.out.println("First: " + deque.peekFirst());  // 5
        System.out.println("Last: " + deque.peekLast());    // 25
        
        // Remove elements
        System.out.println("Removed first: " + deque.removeFirst());  // 5
        System.out.println("Removed last: " + deque.removeLast());    // 25
        
        System.out.println("Deque: " + deque);  // [10, 20]
        
        // Size and empty check
        System.out.println("Size: " + deque.size());      // 2
        System.out.println("Empty? " + deque.isEmpty());  // false
    }
}
```

**Output**:
```
Deque: [5, 10, 20, 25]
First: 5
Last: 25
Removed first: 5
Removed last: 25
Deque: [10, 20]
Size: 2
Empty? false
```

### Deque as Stack

```java
Deque<Integer> stack = new ArrayDeque<>();

// Stack operations
stack.push(10);      // addFirst(10)
stack.push(20);      // addFirst(20)
stack.push(30);      // addFirst(30)

System.out.println(stack.peek());  // 30 (top)
System.out.println(stack.pop());   // 30 (removeFirst)
System.out.println(stack.pop());   // 20
```

### Deque as Queue

```java
Deque<Integer> queue = new ArrayDeque<>();

// Queue operations
queue.offer(10);     // addLast(10)
queue.offer(20);     // addLast(20)
queue.offer(30);     // addLast(30)

System.out.println(queue.peek());  // 10 (front)
System.out.println(queue.poll());  // 10 (removeFirst)
System.out.println(queue.poll());  // 20
```

---

## Array-Based Deque

### Simple Array Deque

```java
public class ArrayDeque {
    private int[] arr;
    private int front;
    private int rear;
    private int size;
    private int capacity;
    
    public ArrayDeque(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = -1;
        this.rear = 0;
        this.size = 0;
    }
    
    // Add element at front
    public void addFirst(int value) {
        if (isFull()) {
            throw new IllegalStateException("Deque is full");
        }
        
        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (front == 0) {
            front = capacity - 1;  // Wrap around
        } else {
            front--;
        }
        
        arr[front] = value;
        size++;
    }
    
    // Add element at rear
    public void addLast(int value) {
        if (isFull()) {
            throw new IllegalStateException("Deque is full");
        }
        
        if (front == -1) {
            front = 0;
            rear = 0;
        } else if (rear == capacity - 1) {
            rear = 0;  // Wrap around
        } else {
            rear++;
        }
        
        arr[rear] = value;
        size++;
    }
    
    // Remove element from front
    public int removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        
        int value = arr[front];
        
        if (front == rear) {
            // Only one element
            front = -1;
            rear = -1;
        } else if (front == capacity - 1) {
            front = 0;  // Wrap around
        } else {
            front++;
        }
        
        size--;
        return value;
    }
    
    // Remove element from rear
    public int removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        
        int value = arr[rear];
        
        if (front == rear) {
            // Only one element
            front = -1;
            rear = -1;
        } else if (rear == 0) {
            rear = capacity - 1;  // Wrap around
        } else {
            rear--;
        }
        
        size--;
        return value;
    }
    
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return arr[front];
    }
    
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return arr[rear];
    }
    
    public boolean isEmpty() {
        return front == -1;
    }
    
    public boolean isFull() {
        return (front == 0 && rear == capacity - 1) || (front == rear + 1);
    }
    
    public int size() {
        return size;
    }
}
```

**Time**: All operations O(1)
**Space**: O(n)

---

## Circular Deque

### Circular Deque Implementation

**Using modulo arithmetic for circular behavior**.

```java
public class CircularDeque {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public CircularDeque(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = capacity - 1;
        this.size = 0;
    }
    
    // Add at front
    public boolean addFirst(int value) {
        if (isFull()) {
            return false;
        }
        
        front = (front - 1 + capacity) % capacity;
        arr[front] = value;
        size++;
        
        return true;
    }
    
    // Add at rear
    public boolean addLast(int value) {
        if (isFull()) {
            return false;
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
        
        return true;
    }
    
    // Remove from front
    public int removeFirst() {
        if (isEmpty()) {
            return -1;
        }
        
        int value = arr[front];
        front = (front + 1) % capacity;
        size--;
        
        return value;
    }
    
    // Remove from rear
    public int removeLast() {
        if (isEmpty()) {
            return -1;
        }
        
        int value = arr[rear];
        rear = (rear - 1 + capacity) % capacity;
        size--;
        
        return value;
    }
    
    public int peekFirst() {
        return isEmpty() ? -1 : arr[front];
    }
    
    public int peekLast() {
        return isEmpty() ? -1 : arr[rear];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
    
    public int size() {
        return size;
    }
}
```

**LeetCode 641** - Design Circular Deque

### Dry Run Example

```
Circular Deque with capacity = 3

Operation        | front | rear | Array      | Size
-----------------|-------|------|------------|-----
Initial          |   0   |  2   | [_, _, _]  | 0
addLast(10)      |   0   |  0   | [10,_, _]  | 1
addLast(20)      |   0   |  1   | [10,20,_]  | 2
addFirst(5)      |   2   |  1   | [10,20,5]  | 3
                 |       |      |     ↑  ↑   |
                 |       |      | front rear |
removeLast()→20  |   2   |  0   | [10,_,5]   | 2
addFirst(3)      |   1   |  0   | [10,3,5]   | 3
                 |       |      |  ↑  ↑      |
                 |       |      | rear front |
removeFirst()→3  |   2   |  0   | [10,_,5]   | 2
```

**Key Points**:
- `addFirst`: `front = (front - 1 + capacity) % capacity`
- `addLast`: `rear = (rear + 1) % capacity`
- `removeFirst`: `front = (front + 1) % capacity`
- `removeLast`: `rear = (rear - 1 + capacity) % capacity`

---

## Linked List Deque

### Doubly Linked List Implementation

```java
public class LinkedListDeque {
    private Node front;
    private Node rear;
    private int size;
    
    private static class Node {
        int data;
        Node prev;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.prev = null;
            this.next = null;
        }
    }
    
    public LinkedListDeque() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
    
    // Add at front
    public void addFirst(int value) {
        Node newNode = new Node(value);
        
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            newNode.next = front;
            front.prev = newNode;
            front = newNode;
        }
        
        size++;
    }
    
    // Add at rear
    public void addLast(int value) {
        Node newNode = new Node(value);
        
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear.next = newNode;
            newNode.prev = rear;
            rear = newNode;
        }
        
        size++;
    }
    
    // Remove from front
    public int removeFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        
        int value = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;
        } else {
            front.prev = null;
        }
        
        size--;
        return value;
    }
    
    // Remove from rear
    public int removeLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        
        int value = rear.data;
        rear = rear.prev;
        
        if (rear == null) {
            front = null;
        } else {
            rear.next = null;
        }
        
        size--;
        return value;
    }
    
    public int peekFirst() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return front.data;
    }
    
    public int peekLast() {
        if (isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return rear.data;
    }
    
    public boolean isEmpty() {
        return front == null;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Deque is empty");
            return;
        }
        
        System.out.print("Deque: ");
        Node current = front;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```

### Visual Representation

**addFirst(10)**:
```
        front/rear
            ↓
   null ← [10] → null
```

**addLast(20)**:
```
        front          rear
            ↓            ↓
   null ← [10] ↔ [20] → null
```

**addFirst(5)**:
```
       front              rear
           ↓                ↓
   null ← [5] ↔ [10] ↔ [20] → null
```

**removeFirst()** → 5:
```
                front      rear
                   ↓         ↓
          null ← [10] ↔ [20] → null
```

**removeLast()** → 20:
```
                front/rear
                    ↓
           null ← [10] → null
```

**Time**: All operations O(1)
**Space**: O(n)

---

## Common Deque Patterns

### Pattern 1: Sliding Window Maximum ⭐⭐⭐⭐⭐

**LeetCode 239** | **Difficulty: Hard** | **Most Important**

**Problem**: Find maximum in each sliding window of size k.

**Input**: `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
**Output**: `[3,3,5,5,6,7]`

**Solution using Deque**:
```java
public class SlidingWindowMaximum {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new ArrayDeque<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            // Remove elements outside window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // Remove smaller elements (they won't be useful)
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            
            deque.offerLast(i);
            
            // Add to result when window is complete
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
}
```

**Dry Run**:
```
nums = [1,3,-1,-3,5,3,6,7], k = 3

i=0: deque=[0], window=[1]
i=1: deque=[1], window=[1,3], nums[1]=3 > nums[0]=1, remove 0
i=2: deque=[1,2], result[0]=nums[1]=3
i=3: deque=[1,2,3], result[1]=nums[1]=3
i=4: deque=[4], result[2]=nums[4]=5, nums[4]=5 > all previous
i=5: deque=[4,5], result[3]=nums[4]=5
i=6: deque=[6], result[4]=nums[6]=6, nums[6]=6 > all previous
i=7: deque=[7], result[5]=nums[7]=7

Result: [3,3,5,5,6,7]
```

**Why Deque?**
- Remove from **front**: Elements outside window
- Remove from **rear**: Smaller elements that won't be max
- Maintains **decreasing order** of potential maximums

**Time**: O(n) - each element added/removed once
**Space**: O(k)

---

### Pattern 2: Longest Subarray with Limit ⭐⭐⭐

**LeetCode 1438** | **Difficulty: Medium**

**Problem**: Find longest subarray where |max - min| ≤ limit.

**Input**: `nums = [8,2,4,7]`, `limit = 4`
**Output**: `2` (subarray [2,4])

**Solution**:
```java
public class LongestSubarrayWithLimit {
    public int longestSubarray(int[] nums, int limit) {
        Deque<Integer> maxDeque = new ArrayDeque<>();  // Decreasing
        Deque<Integer> minDeque = new ArrayDeque<>();  // Increasing
        
        int left = 0;
        int maxLen = 0;
        
        for (int right = 0; right < nums.length; right++) {
            // Maintain decreasing maxDeque
            while (!maxDeque.isEmpty() && nums[maxDeque.peekLast()] < nums[right]) {
                maxDeque.pollLast();
            }
            maxDeque.offerLast(right);
            
            // Maintain increasing minDeque
            while (!minDeque.isEmpty() && nums[minDeque.peekLast()] > nums[right]) {
                minDeque.pollLast();
            }
            minDeque.offerLast(right);
            
            // Shrink window if limit exceeded
            while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > limit) {
                left++;
                
                if (maxDeque.peekFirst() < left) {
                    maxDeque.pollFirst();
                }
                if (minDeque.peekFirst() < left) {
                    minDeque.pollFirst();
                }
            }
            
            maxLen = Math.max(maxLen, right - left + 1);
        }
        
        return maxLen;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Pattern 3: Jump Game VI ⭐⭐⭐

**LeetCode 1696** | **Difficulty: Medium**

**Problem**: Maximum score jumping at most k steps.

**Input**: `nums = [1,-1,-2,4,-7,3]`, `k = 2`
**Output**: `7` (1→-1→4→3)

**Solution**:
```java
public class JumpGameVI {
    public int maxResult(int[] nums, int k) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        
        Deque<Integer> deque = new ArrayDeque<>();
        deque.offer(0);
        
        for (int i = 1; i < n; i++) {
            // Remove indices outside k range
            while (!deque.isEmpty() && deque.peekFirst() < i - k) {
                deque.pollFirst();
            }
            
            // Current dp value
            dp[i] = nums[i] + dp[deque.peekFirst()];
            
            // Maintain decreasing order
            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {
                deque.pollLast();
            }
            
            deque.offerLast(i);
        }
        
        return dp[n - 1];
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Pattern 4: Max Value of Equation ⭐⭐⭐

**LeetCode 1499** | **Difficulty: Hard**

**Problem**: Maximize `yi + yj + |xi - xj|` where `|xi - xj| ≤ k`.

**Solution**:
```java
public class MaxValueOfEquation {
    public int findMaxValueOfEquation(int[][] points, int k) {
        Deque<Integer> deque = new ArrayDeque<>();
        int maxVal = Integer.MIN_VALUE;
        
        for (int i = 0; i < points.length; i++) {
            int x = points[i][0];
            int y = points[i][1];
            
            // Remove points outside k range
            while (!deque.isEmpty() && x - points[deque.peekFirst()][0] > k) {
                deque.pollFirst();
            }
            
            // Calculate max value
            if (!deque.isEmpty()) {
                int j = deque.peekFirst();
                maxVal = Math.max(maxVal, y + x + points[j][1] - points[j][0]);
            }
            
            // Maintain decreasing order of (yi - xi)
            while (!deque.isEmpty()) {
                int last = deque.peekLast();
                if (y - x >= points[last][1] - points[last][0]) {
                    deque.pollLast();
                } else {
                    break;
                }
            }
            
            deque.offerLast(i);
        }
        
        return maxVal;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Classic Problems

### Problem 1: Design Circular Deque ⭐⭐⭐⭐⭐

**LeetCode 641** | **Difficulty: Medium** | **Must Solve**

Complete implementation provided in [Circular Deque](#circular-deque) section.

---

### Problem 2: Shortest Subarray with Sum at Least K ⭐⭐⭐⭐

**LeetCode 862** | **Difficulty: Hard**

**Problem**: Find shortest subarray with sum ≥ k.

**Input**: `nums = [2,-1,2]`, `k = 3`
**Output**: `3`

**Solution**:
```java
public class ShortestSubarrayWithSum {
    public int shortestSubarray(int[] nums, int k) {
        int n = nums.length;
        long[] prefixSum = new long[n + 1];
        
        // Calculate prefix sum
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        Deque<Integer> deque = new ArrayDeque<>();
        int minLen = Integer.MAX_VALUE;
        
        for (int i = 0; i <= n; i++) {
            // Check if we can form a valid subarray
            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= k) {
                minLen = Math.min(minLen, i - deque.pollFirst());
            }
            
            // Maintain increasing order of prefix sums
            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {
                deque.pollLast();
            }
            
            deque.offerLast(i);
        }
        
        return minLen == Integer.MAX_VALUE ? -1 : minLen;
    }
}
```

**Why Deque?**
- Maintain increasing order of prefix sums
- Remove from front when valid subarray found
- Remove from rear when smaller prefix sum appears

**Time**: O(n) | **Space**: O(n)

---

### Problem 3: Constrained Subsequence Sum ⭐⭐⭐

**LeetCode 1425** | **Difficulty: Hard**

**Problem**: Maximum sum subsequence with adjacent elements at most k apart.

**Solution**:
```java
public class ConstrainedSubsequenceSum {
    public int constrainedSubsetSum(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();
        int[] dp = new int[nums.length];
        
        for (int i = 0; i < nums.length; i++) {
            // Remove indices outside k range
            while (!deque.isEmpty() && deque.peekFirst() < i - k) {
                deque.pollFirst();
            }
            
            // Calculate dp[i]
            dp[i] = nums[i];
            if (!deque.isEmpty()) {
                dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);
            }
            
            // Maintain decreasing order
            while (!deque.isEmpty() && dp[deque.peekLast()] < dp[i]) {
                deque.pollLast();
            }
            
            if (dp[i] > 0) {
                deque.offerLast(i);
            }
        }
        
        int maxSum = Integer.MIN_VALUE;
        for (int val : dp) {
            maxSum = Math.max(maxSum, val);
        }
        
        return maxSum;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Interview Questions

### Question 1: LRU Cache using Deque

**Problem**: Implement LRU cache with O(1) operations.

**Solution**:
```java
public class LRUCache {
    private Map<Integer, Integer> cache;
    private Deque<Integer> deque;
    private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.deque = new LinkedList<>();
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        
        // Move to front (most recently used)
        deque.remove(key);
        deque.addFirst(key);
        
        return cache.get(key);
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            deque.remove(key);
        } else if (cache.size() == capacity) {
            // Remove least recently used
            int lru = deque.removeLast();
            cache.remove(lru);
        }
        
        cache.put(key, value);
        deque.addFirst(key);
    }
}
```

**Note**: This is O(n) due to `remove(key)`. True O(1) LRU needs doubly-linked list + HashMap.

---

### Question 2: Max of Min for Every Window Size

**Problem**: Find maximum of minimums for all window sizes.

**Input**: `arr = [10, 20, 30, 50, 10, 70, 30]`
**Output**: `[70, 30, 20, 10, 10, 10, 10]`

**Solution**:
```java
public class MaxOfMinForWindowSize {
    public int[] maxOfMin(int[] arr) {
        int n = arr.length;
        int[] result = new int[n + 1];
        Arrays.fill(result, Integer.MIN_VALUE);
        
        // Find previous smaller and next smaller
        int[] left = new int[n];
        int[] right = new int[n];
        Arrays.fill(left, -1);
        Arrays.fill(right, n);
        
        Deque<Integer> deque = new ArrayDeque<>();
        
        // Previous smaller
        for (int i = 0; i < n; i++) {
            while (!deque.isEmpty() && arr[deque.peekLast()] >= arr[i]) {
                deque.pollLast();
            }
            if (!deque.isEmpty()) {
                left[i] = deque.peekLast();
            }
            deque.offerLast(i);
        }
        
        deque.clear();
        
        // Next smaller
        for (int i = n - 1; i >= 0; i--) {
            while (!deque.isEmpty() && arr[deque.peekLast()] >= arr[i]) {
                deque.pollLast();
            }
            if (!deque.isEmpty()) {
                right[i] = deque.peekLast();
            }
            deque.offerLast(i);
        }
        
        // Calculate result
        for (int i = 0; i < n; i++) {
            int len = right[i] - left[i] - 1;
            result[len] = Math.max(result[len], arr[i]);
        }
        
        // Fill gaps
        for (int i = n - 1; i >= 1; i--) {
            result[i] = Math.max(result[i], result[i + 1]);
        }
        
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            ans[i] = result[i + 1];
        }
        
        return ans;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Question 3: Deque with Min/Max

**Problem**: Design deque with O(1) getMin() and getMax().

**Solution**:
```java
public class MinMaxDeque {
    private Deque<Integer> deque;
    private Deque<Integer> minDeque;
    private Deque<Integer> maxDeque;
    
    public MinMaxDeque() {
        deque = new ArrayDeque<>();
        minDeque = new ArrayDeque<>();
        maxDeque = new ArrayDeque<>();
    }
    
    public void addLast(int value) {
        deque.addLast(value);
        
        // Maintain min deque (increasing)
        while (!minDeque.isEmpty() && minDeque.peekLast() > value) {
            minDeque.pollLast();
        }
        minDeque.addLast(value);
        
        // Maintain max deque (decreasing)
        while (!maxDeque.isEmpty() && maxDeque.peekLast() < value) {
            maxDeque.pollLast();
        }
        maxDeque.addLast(value);
    }
    
    public int removeFirst() {
        if (deque.isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        
        int value = deque.removeFirst();
        
        if (minDeque.peekFirst() == value) {
            minDeque.pollFirst();
        }
        if (maxDeque.peekFirst() == value) {
            maxDeque.pollFirst();
        }
        
        return value;
    }
    
    public int getMin() {
        if (minDeque.isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return minDeque.peekFirst();
    }
    
    public int getMax() {
        if (maxDeque.isEmpty()) {
            throw new NoSuchElementException("Deque is empty");
        }
        return maxDeque.peekFirst();
    }
}
```

**Time**: All operations O(1) amortized
**Space**: O(n)

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Key Concept |
|---|---------|----------|-------------|
| 1 | Design Circular Deque | 641 | Circular array |
| 2 | Reverse Subarray To Maximize Array Value | 1330 | Deque manipulation |

### Medium Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Sliding Window Maximum | 239 | Monotonic deque | ⭐⭐⭐⭐⭐ |
| 2 | Longest Continuous Subarray With Limit | 1438 | Min/Max deques | ⭐⭐⭐⭐ |
| 3 | Jump Game VI | 1696 | DP + deque | ⭐⭐⭐⭐ |
| 4 | Constrained Subsequence Sum | 1425 | DP + deque | ⭐⭐⭐ |
| 5 | Max Value of Equation | 1499 | Monotonic deque | ⭐⭐⭐ |
| 6 | Maximum Number of Robots | 2398 | Sliding window | ⭐⭐⭐ |

### Hard Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Shortest Subarray with Sum at Least K | 862 | Prefix sum + deque | ⭐⭐⭐⭐⭐ |
| 2 | Minimum Cost to Make Array Equal | 2448 | Deque optimization | ⭐⭐⭐ |
| 3 | Continuous Subarrays | 2762 | Monotonic deque | ⭐⭐⭐ |

---

## Summary

### Key Concepts

**Deque Definition**:
- **Double-ended queue**: Insert/delete at both ends
- **Most flexible**: Can be stack, queue, or both
- **O(1) operations**: All insertions and deletions

**When to Use Deque?**
✅ Sliding window problems
✅ Monotonic queue optimization
✅ Maintaining min/max in window
✅ Need both FIFO and LIFO
✅ Need to remove from both ends

### Implementation Comparison

| Feature | ArrayDeque | LinkedList |
|---------|------------|------------|
| **Implementation** | Resizable array | Doubly-linked list |
| **addFirst/Last** | O(1) amortized | O(1) |
| **removeFirst/Last** | O(1) | O(1) |
| **get(index)** | O(1) | O(n) |
| **Null elements** | ❌ No | ✅ Yes |
| **Memory** | More efficient | Overhead per node |
| **Cache** | Better locality | Poor locality |
| **Recommended** | ✅ Yes | For null support only |

### Deque vs Other Structures

| Structure | Insert Front | Insert Rear | Remove Front | Remove Rear |
|-----------|--------------|-------------|--------------|-------------|
| **Deque** | O(1) | O(1) | O(1) | O(1) |
| **Queue** | ❌ | O(1) | O(1) | ❌ |
| **Stack** | O(1) | ❌ | O(1) | ❌ |
| **ArrayList** | O(n) | O(1) | O(n) | O(1) |

### Common Deque Patterns

**Pattern 1: Monotonic Deque (Sliding Window Maximum)**
```java
Deque<Integer> deque = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    // Remove outside window
    while (!deque.isEmpty() && deque.peekFirst() < i - k + 1)
        deque.pollFirst();
    
    // Maintain monotonic property
    while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i])
        deque.pollLast();
    
    deque.offerLast(i);
}
```

**Pattern 2: Min/Max in Window**
```java
Deque<Integer> minDeque = new ArrayDeque<>();  // Increasing
Deque<Integer> maxDeque = new ArrayDeque<>();  // Decreasing

// Maintain both for O(1) min/max queries
```

**Pattern 3: DP Optimization**
```java
Deque<Integer> deque = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    // Remove outside range
    while (!deque.isEmpty() && deque.peekFirst() < i - k)
        deque.pollFirst();
    
    dp[i] = calculate(dp[deque.peekFirst()]);
    
    // Maintain optimal values
    while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i])
        deque.pollLast();
    
    deque.offerLast(i);
}
```

### Java Deque Quick Reference

```java
// Creation
Deque<Integer> deque = new ArrayDeque<>();  // Preferred
Deque<Integer> deque = new LinkedList<>();  // If need nulls

// Insertion
deque.addFirst(x);      // Throws exception if fails
deque.addLast(x);
deque.offerFirst(x);    // Returns false if fails
deque.offerLast(x);

// Deletion
deque.removeFirst();    // Throws exception if empty
deque.removeLast();
deque.pollFirst();      // Returns null if empty
deque.pollLast();

// Examination
deque.getFirst();       // Throws exception if empty
deque.getLast();
deque.peekFirst();      // Returns null if empty
deque.peekLast();

// As Stack
deque.push(x);          // addFirst(x)
deque.pop();            // removeFirst()
deque.peek();           // peekFirst()

// As Queue
deque.offer(x);         // addLast(x)
deque.poll();           // pollFirst()
deque.peek();           // peekFirst()
```

### Common Mistakes

1. ❌ Using `LinkedList` instead of `ArrayDeque` (slower)
2. ❌ Not removing elements outside window range
3. ❌ Wrong monotonic property (increasing vs decreasing)
4. ❌ Storing values instead of indices (lose position info)
5. ❌ Not handling empty deque before peek/poll
6. ❌ Using `remove(Object)` for O(1) - it's O(n)!

### Interview Tips

1. ✅ **Identify pattern**: Need min/max in window? → Deque
2. ✅ **Choose monotonic type**: Max → decreasing, Min → increasing
3. ✅ **Store indices**: Usually better than storing values
4. ✅ **Remove from both ends**: Front for window, rear for optimization
5. ✅ **ArrayDeque preferred**: Faster than LinkedList
6. ✅ **Check edge cases**: Empty deque, single element

### Must Master Problems

**Top 5 Essential**:
1. ✅ **Sliding Window Maximum** (LC 239) - Foundation ⭐⭐⭐⭐⭐
2. ✅ **Design Circular Deque** (LC 641) - Implementation ⭐⭐⭐⭐⭐
3. ✅ **Shortest Subarray with Sum ≥ K** (LC 862) - Hard pattern ⭐⭐⭐⭐⭐
4. ✅ **Jump Game VI** (LC 1696) - DP optimization ⭐⭐⭐⭐
5. ✅ **Longest Subarray with Limit** (LC 1438) - Min/Max tracking ⭐⭐⭐⭐

### Performance Characteristics

**ArrayDeque**:
- **Amortized O(1)**: All deque operations
- **Resizing**: Doubles when full (like ArrayList)
- **Initial capacity**: 16 elements
- **Memory**: ~50% less than LinkedList

**LinkedList**:
- **Strict O(1)**: All deque operations
- **No resizing**: Always O(1) insertion
- **Memory**: 24 bytes per node overhead

### Next Steps

- **Next**: [9.4 Priority Queue](9.4-Priority-Queue.md)
- **Practice**: Solve all medium deque problems
- **Master**: Monotonic deque pattern
- **Advanced**: Combine with DP for optimization

---

**Previous**: [9.2 Circular Queue](9.2-Circular-Queue.md)

**Remember**: Deque is the secret weapon for sliding window optimization problems!
