# 9.4 Priority Queue

## Table of Contents
1. [Introduction](#introduction)
2. [Priority Queue Fundamentals](#priority-queue-fundamentals)
3. [Heap Data Structure](#heap-data-structure)
4. [Java PriorityQueue Class](#java-priorityqueue-class)
5. [Min Heap Implementation](#min-heap-implementation)
6. [Max Heap Implementation](#max-heap-implementation)
7. [Custom Comparators](#custom-comparators)
8. [Essential Priority Queue Patterns](#essential-priority-queue-patterns)
9. [Top K Problems](#top-k-problems)
10. [Merge K Problems](#merge-k-problems)
11. [Interview Questions](#interview-questions)
12. [Practice Problems](#practice-problems)
13. [Summary](#summary)

---

## Introduction

### What is a Priority Queue?

A **Priority Queue** is an abstract data type where each element has a **priority**, and elements are served based on their priority rather than their insertion order.

**Key Characteristics**:
- **Not FIFO**: Elements served by priority, not insertion order
- **Highest priority first**: In max heap
- **Lowest priority first**: In min heap
- **Implemented using Heap**: Binary heap is most common

### Real-World Analogies

1. **Emergency Room**: Critical patients treated first, not first-come-first-served
2. **CPU Scheduling**: High-priority tasks executed before low-priority
3. **Flight Boarding**: First class boards before economy
4. **Print Queue**: Urgent documents printed first
5. **Network Packets**: QoS (Quality of Service) routing

### Priority Queue Visualization

```
Min Heap Priority Queue (smaller value = higher priority):

Insert: 5, 3, 7, 1, 9
        
        1          ← Root (minimum, highest priority)
       / \
      3   7
     / \
    5   9

poll() → 1 (removes minimum)
poll() → 3
poll() → 5
```

```
Max Heap Priority Queue (larger value = higher priority):

Insert: 5, 3, 7, 1, 9
        
        9          ← Root (maximum, highest priority)
       / \
      7   5
     / \
    1   3

poll() → 9 (removes maximum)
poll() → 7
poll() → 5
```

---

## Priority Queue Fundamentals

### Priority Queue vs Regular Queue

| Feature | Regular Queue | Priority Queue |
|---------|--------------|----------------|
| Order | FIFO | By priority |
| Insertion | O(1) | O(log n) |
| Deletion | O(1) | O(log n) |
| Peek | O(1) | O(1) |
| Use Case | Process in order | Process by importance |
| Implementation | Array/LinkedList | Heap |

**Example**:
```
Regular Queue:
enqueue(5), enqueue(3), enqueue(7)
Queue: [5, 3, 7]
poll() → 5 (first in)

Priority Queue (Min Heap):
offer(5), offer(3), offer(7)
PQ: [3, 5, 7] (internally as heap)
poll() → 3 (minimum, highest priority)
```

### Core Operations

| Operation | Description | Time Complexity |
|-----------|-------------|-----------------|
| `offer(e)` / `add(e)` | Insert element | O(log n) |
| `poll()` / `remove()` | Remove highest priority | O(log n) |
| `peek()` / `element()` | View highest priority | O(1) |
| `size()` | Get number of elements | O(1) |
| `isEmpty()` | Check if empty | O(1) |
| `contains(e)` | Check if element exists | O(n) |
| `remove(e)` | Remove specific element | O(n) |

### Applications

**1. Dijkstra's Algorithm**: Shortest path
**2. A\* Search**: Pathfinding with heuristics
**3. Huffman Coding**: Data compression
**4. Median Finding**: Running median in stream
**5. Task Scheduling**: CPU scheduling, event simulation
**6. K-way Merge**: Merge sorted arrays/files
**7. Top K Problems**: Find largest/smallest K elements

---

## Heap Data Structure

### What is a Heap?

A **Heap** is a **complete binary tree** that satisfies the **heap property**:
- **Min Heap**: Parent ≤ Children (root is minimum)
- **Max Heap**: Parent ≥ Children (root is maximum)

### Complete Binary Tree

**Properties**:
- All levels filled except possibly last
- Last level filled from left to right
- Height: O(log n)

**Example**:
```
Valid Complete Binary Tree:
        1
       / \
      2   3
     / \
    4   5

Invalid (not complete):
        1
       / \
      2   3
       \
        4  (gap at position 3)
```

### Min Heap Property

**Rule**: `parent ≤ children`

```
        1           ← Minimum at root
       / \
      3   2
     / \ / \
    7  5 4  6

Array: [1, 3, 2, 7, 5, 4, 6]
Index:  0  1  2  3  4  5  6
```

### Max Heap Property

**Rule**: `parent ≥ children`

```
        9           ← Maximum at root
       / \
      7   6
     / \ / \
    3  5 4  2

Array: [9, 7, 6, 3, 5, 4, 2]
Index:  0  1  2  3  4  5  6
```

### Array Representation

**Index Relationships** (0-based indexing):
- **Parent**: `(i - 1) / 2`
- **Left Child**: `2 * i + 1`
- **Right Child**: `2 * i + 2`

**Example**:
```
Tree:
        10
       /  \
      15   20
     / \   /
    30 40 50

Array: [10, 15, 20, 30, 40, 50]
Index:   0   1   2   3   4   5

For index 1 (value 15):
- Parent: (1-1)/2 = 0 → 10
- Left child: 2*1+1 = 3 → 30
- Right child: 2*1+2 = 4 → 40
```

### Heap Operations

**1. Heapify Up (Bubble Up)**:
```
After inserting 5:
        10              10              5
       /  \            /  \            / \
      15   20   →     5   20    →    10  20
     / \   /         / \   /         / \  /
    30 40 5         30 40 15        30 40 15

Steps:
1. Insert at end
2. Compare with parent
3. Swap if violates heap property
4. Repeat until heap property satisfied
```

**2. Heapify Down (Bubble Down)**:
```
After removing root (10):
        50              15              15
       /  \            /  \            /  \
      15   20   →     30  20    →    30   20
     / \             /               /
    30 40           40              40

Steps:
1. Replace root with last element
2. Compare with children
3. Swap with smaller child (min heap)
4. Repeat until heap property satisfied
```

---

## Java PriorityQueue Class

### Creating Priority Queue

```java
import java.util.*;

// Min Heap (default - natural ordering)
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

// Max Heap (reverse ordering)
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

// With initial capacity
PriorityQueue<Integer> pq = new PriorityQueue<>(20);

// With comparator
PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

// From collection
List<Integer> list = Arrays.asList(5, 3, 7, 1);
PriorityQueue<Integer> pq = new PriorityQueue<>(list);
```

### Basic Operations

```java
public class PriorityQueueBasics {
    public static void main(String[] args) {
        // Create min heap
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        
        // Add elements (offer is preferred)
        pq.offer(5);
        pq.offer(3);
        pq.offer(7);
        pq.offer(1);
        pq.offer(9);
        
        System.out.println("PQ: " + pq);  // [1, 3, 7, 5, 9] (heap order, not sorted)
        
        // Peek (view min without removing)
        System.out.println("Min: " + pq.peek());  // 1
        
        // Poll (remove and return min)
        System.out.println("Removed: " + pq.poll());  // 1
        System.out.println("Removed: " + pq.poll());  // 3
        
        System.out.println("PQ: " + pq);  // [5, 9, 7]
        
        // Size and empty check
        System.out.println("Size: " + pq.size());      // 3
        System.out.println("Empty? " + pq.isEmpty());  // false
        
        // Contains (O(n) operation)
        System.out.println("Contains 7? " + pq.contains(7));  // true
        
        // Remove all
        while (!pq.isEmpty()) {
            System.out.print(pq.poll() + " ");  // 5 7 9
        }
    }
}
```

**Output**:
```
PQ: [1, 3, 7, 5, 9]
Min: 1
Removed: 1
Removed: 3
PQ: [5, 9, 7]
Size: 3
Empty? false
Contains 7? true
5 7 9
```

### Important Notes

⚠️ **PriorityQueue is NOT sorted**:
```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(5);
pq.offer(3);
pq.offer(7);
pq.offer(1);

System.out.println(pq);  // [1, 3, 7, 5] (heap order, NOT [1, 3, 5, 7])

// Iterating doesn't guarantee order
for (int x : pq) {
    System.out.print(x + " ");  // 1 3 7 5 (not sorted!)
}

// To get sorted order, poll all elements
while (!pq.isEmpty()) {
    System.out.print(pq.poll() + " ");  // 1 3 5 7 (sorted!)
}
```

⚠️ **Null elements not allowed**:
```java
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(null);  // NullPointerException!
```

⚠️ **Not thread-safe**:
```java
// For thread-safe, use:
PriorityBlockingQueue<Integer> pq = new PriorityBlockingQueue<>();
```

---

## Min Heap Implementation

### Array-Based Min Heap

```java
public class MinHeap {
    private int[] heap;
    private int size;
    private int capacity;
    
    public MinHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity];
        this.size = 0;
    }
    
    // Helper methods for indices
    private int parent(int i) {
        return (i - 1) / 2;
    }
    
    private int leftChild(int i) {
        return 2 * i + 1;
    }
    
    private int rightChild(int i) {
        return 2 * i + 2;
    }
    
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
    // Insert element (heapify up)
    public void insert(int value) {
        if (size == capacity) {
            throw new IllegalStateException("Heap is full");
        }
        
        heap[size] = value;
        int current = size;
        size++;
        
        // Heapify up
        while (current > 0 && heap[current] < heap[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
    }
    
    // Extract minimum (heapify down)
    public int extractMin() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        
        int min = heap[0];
        heap[0] = heap[size - 1];
        size--;
        
        heapifyDown(0);
        
        return min;
    }
    
    // Heapify down from index i
    private void heapifyDown(int i) {
        int smallest = i;
        int left = leftChild(i);
        int right = rightChild(i);
        
        if (left < size && heap[left] < heap[smallest]) {
            smallest = left;
        }
        
        if (right < size && heap[right] < heap[smallest]) {
            smallest = right;
        }
        
        if (smallest != i) {
            swap(i, smallest);
            heapifyDown(smallest);
        }
    }
    
    // Peek minimum
    public int peek() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        return heap[0];
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return size == 0;
    }
    
    // Display heap
    public void display() {
        System.out.print("Heap: ");
        for (int i = 0; i < size; i++) {
            System.out.print(heap[i] + " ");
        }
        System.out.println();
    }
}
```

### Dry Run Example

```
Insert operations: 10, 15, 20, 7, 6

Step 1: Insert 10
Index:  0
Heap: [10]

Step 2: Insert 15
Index:  0   1
Heap: [10, 15]

Step 3: Insert 20
Index:  0   1   2
Heap: [10, 15, 20]

Step 4: Insert 7
Index:  0   1   2   3
Heap: [10, 15, 20, 7]

Heapify up from index 3:
- Compare 7 with parent(3) = index 1 (15)
- 7 < 15, swap
Heap: [10, 7, 20, 15]

- Compare 7 with parent(1) = index 0 (10)
- 7 < 10, swap
Heap: [7, 10, 20, 15]

Step 5: Insert 6
Index:  0   1   2   3   4
Heap: [7, 10, 20, 15, 6]

Heapify up from index 4:
- Compare 6 with parent(4) = index 1 (10)
- 6 < 10, swap
Heap: [7, 6, 20, 15, 10]

- Compare 6 with parent(1) = index 0 (7)
- 6 < 7, swap
Heap: [6, 7, 20, 15, 10]

Final Min Heap:
        6
       / \
      7   20
     / \
    15  10
```

**Extract Min**:
```
Initial: [6, 7, 20, 15, 10]

Step 1: Remove root (6), replace with last (10)
Heap: [10, 7, 20, 15]

Step 2: Heapify down from 0
- Compare 10 with children 7 and 20
- Smallest is 7 (index 1), swap
Heap: [7, 10, 20, 15]

- Compare 10 with children 15 and null
- 10 < 15, stop

Final: [7, 10, 20, 15]

        7
       / \
      10  20
     /
    15

Extracted: 6
```

---

## Max Heap Implementation

### Array-Based Max Heap

```java
public class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity];
        this.size = 0;
    }
    
    private int parent(int i) {
        return (i - 1) / 2;
    }
    
    private int leftChild(int i) {
        return 2 * i + 1;
    }
    
    private int rightChild(int i) {
        return 2 * i + 2;
    }
    
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
    // Insert element (heapify up)
    public void insert(int value) {
        if (size == capacity) {
            throw new IllegalStateException("Heap is full");
        }
        
        heap[size] = value;
        int current = size;
        size++;
        
        // Heapify up (parent < current for max heap)
        while (current > 0 && heap[current] > heap[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
    }
    
    // Extract maximum (heapify down)
    public int extractMax() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        
        int max = heap[0];
        heap[0] = heap[size - 1];
        size--;
        
        heapifyDown(0);
        
        return max;
    }
    
    // Heapify down from index i
    private void heapifyDown(int i) {
        int largest = i;
        int left = leftChild(i);
        int right = rightChild(i);
        
        if (left < size && heap[left] > heap[largest]) {
            largest = left;
        }
        
        if (right < size && heap[right] > heap[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(i, largest);
            heapifyDown(largest);
        }
    }
    
    public int peek() {
        if (size == 0) {
            throw new NoSuchElementException("Heap is empty");
        }
        return heap[0];
    }
    
    public int size() {
        return size;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
}
```

### Usage Example

```java
public class MaxHeapDemo {
    public static void main(String[] args) {
        MaxHeap maxHeap = new MaxHeap(10);
        
        maxHeap.insert(10);
        maxHeap.insert(15);
        maxHeap.insert(20);
        maxHeap.insert(7);
        maxHeap.insert(25);
        
        System.out.println("Max: " + maxHeap.peek());  // 25
        
        System.out.println("Extract: " + maxHeap.extractMax());  // 25
        System.out.println("Extract: " + maxHeap.extractMax());  // 20
        System.out.println("Extract: " + maxHeap.extractMax());  // 15
    }
}
```

---

## Custom Comparators

### Custom Objects with Priority

```java
class Task {
    String name;
    int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public String toString() {
        return name + "(" + priority + ")";
    }
}

public class CustomComparatorExample {
    public static void main(String[] args) {
        // Method 1: Comparator using lambda
        PriorityQueue<Task> pq = new PriorityQueue<>(
            (a, b) -> Integer.compare(a.priority, b.priority)
        );
        
        // Method 2: Comparator.comparingInt
        PriorityQueue<Task> pq2 = new PriorityQueue<>(
            Comparator.comparingInt(t -> t.priority)
        );
        
        // Method 3: Task implements Comparable
        // (See below)
        
        pq.offer(new Task("Email", 2));
        pq.offer(new Task("Meeting", 1));
        pq.offer(new Task("Code Review", 3));
        
        while (!pq.isEmpty()) {
            System.out.println(pq.poll());
        }
        // Output:
        // Meeting(1)
        // Email(2)
        // Code Review(3)
    }
}
```

### Implementing Comparable

```java
class Task implements Comparable<Task> {
    String name;
    int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
    
    @Override
    public String toString() {
        return name + "(" + priority + ")";
    }
}

// Usage:
PriorityQueue<Task> pq = new PriorityQueue<>();
pq.offer(new Task("Task A", 3));
pq.offer(new Task("Task B", 1));
pq.offer(new Task("Task C", 2));

while (!pq.isEmpty()) {
    System.out.println(pq.poll());
}
// Output: Task B(1), Task C(2), Task A(3)
```

### Multiple Criteria Sorting

```java
class Student {
    String name;
    int grade;
    int age;
    
    public Student(String name, int grade, int age) {
        this.name = name;
        this.grade = grade;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + "(grade:" + grade + ", age:" + age + ")";
    }
}

public class MultiCriteriaSort {
    public static void main(String[] args) {
        // Sort by grade (descending), then by age (ascending)
        PriorityQueue<Student> pq = new PriorityQueue<>(
            Comparator.comparing((Student s) -> s.grade).reversed()
                      .thenComparing(s -> s.age)
        );
        
        pq.offer(new Student("Alice", 85, 20));
        pq.offer(new Student("Bob", 90, 22));
        pq.offer(new Student("Charlie", 90, 21));
        pq.offer(new Student("David", 85, 19));
        
        while (!pq.isEmpty()) {
            System.out.println(pq.poll());
        }
        // Output:
        // Charlie(grade:90, age:21)
        // Bob(grade:90, age:22)
        // David(grade:85, age:19)
        // Alice(grade:85, age:20)
    }
}
```

---

## Essential Priority Queue Patterns

### Pattern 1: Kth Largest/Smallest Element ⭐⭐⭐⭐⭐

**LeetCode 215** - Kth Largest Element in Array

**Problem**: Find kth largest element in unsorted array.

**Input**: `nums = [3,2,1,5,6,4]`, `k = 2`
**Output**: `5`

**Solution 1: Min Heap (Optimal)**
```java
public class KthLargest {
    public int findKthLargest(int[] nums, int k) {
        // Min heap of size k
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        for (int num : nums) {
            minHeap.offer(num);
            
            // Keep only k largest elements
            if (minHeap.size() > k) {
                minHeap.poll();  // Remove smallest
            }
        }
        
        return minHeap.peek();  // Kth largest
    }
}
```

**Explanation**:
```
nums = [3,2,1,5,6,4], k = 2

After 3: minHeap = [3]
After 2: minHeap = [2, 3]
After 1: minHeap = [1, 2, 3] → poll() → [2, 3]
After 5: minHeap = [2, 3, 5] → poll() → [3, 5]
After 6: minHeap = [3, 5, 6] → poll() → [5, 6]
After 4: minHeap = [4, 5, 6] → poll() → [5, 6]

Result: 5 (top of min heap)
```

**Why Min Heap?**
- Keep k largest elements
- Smallest of these k is the kth largest
- Remove elements smaller than kth largest

**Time**: O(n log k) | **Space**: O(k)

**Solution 2: Max Heap**
```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
    
    for (int num : nums) {
        maxHeap.offer(num);
    }
    
    // Poll k-1 times
    for (int i = 0; i < k - 1; i++) {
        maxHeap.poll();
    }
    
    return maxHeap.peek();
}
```

**Time**: O(n log n) | **Space**: O(n)

---

### Pattern 2: Top K Frequent Elements ⭐⭐⭐⭐

**LeetCode 347** - Top K Frequent Elements

**Problem**: Find k most frequent elements.

**Input**: `nums = [1,1,1,2,2,3]`, `k = 2`
**Output**: `[1, 2]`

**Solution**:
```java
public class TopKFrequent {
    public int[] topKFrequent(int[] nums, int k) {
        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : nums) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        
        // Min heap of size k (sort by frequency)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(
            (a, b) -> freqMap.get(a) - freqMap.get(b)
        );
        
        for (int num : freqMap.keySet()) {
            minHeap.offer(num);
            
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        
        // Extract result
        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = minHeap.poll();
        }
        
        return result;
    }
}
```

**Time**: O(n log k) | **Space**: O(n)

---

### Pattern 3: Merge K Sorted Lists ⭐⭐⭐⭐⭐

**LeetCode 23** - Merge K Sorted Lists

**Problem**: Merge k sorted linked lists.

**Solution**:
```java
public class MergeKSortedLists {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) {
            return null;
        }
        
        // Min heap (sort by node value)
        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(
            (a, b) -> a.val - b.val
        );
        
        // Add first node of each list
        for (ListNode head : lists) {
            if (head != null) {
                minHeap.offer(head);
            }
        }
        
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (!minHeap.isEmpty()) {
            ListNode node = minHeap.poll();
            current.next = node;
            current = current.next;
            
            // Add next node from same list
            if (node.next != null) {
                minHeap.offer(node.next);
            }
        }
        
        return dummy.next;
    }
}
```

**Time**: O(n log k) where n = total nodes, k = lists
**Space**: O(k)

---

### Pattern 4: Find Median from Data Stream ⭐⭐⭐⭐⭐

**LeetCode 295** - Find Median from Data Stream

**Problem**: Implement data structure supporting:
- `addNum(int num)`: Add number to stream
- `findMedian()`: Return median of all numbers

**Solution using Two Heaps**:
```java
public class MedianFinder {
    private PriorityQueue<Integer> maxHeap;  // Lower half (max at top)
    private PriorityQueue<Integer> minHeap;  // Upper half (min at top)
    
    public MedianFinder() {
        maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        minHeap = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        // Add to max heap first
        maxHeap.offer(num);
        
        // Balance: move largest from maxHeap to minHeap
        minHeap.offer(maxHeap.poll());
        
        // Maintain size: maxHeap size >= minHeap size
        if (maxHeap.size() < minHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    public double findMedian() {
        if (maxHeap.size() > minHeap.size()) {
            return maxHeap.peek();
        } else {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        }
    }
}
```

**Visualization**:
```
Add numbers: 1, 2, 3, 4, 5

After 1:
maxHeap: [1]    minHeap: []
Median: 1

After 2:
maxHeap: [1]    minHeap: [2]
Median: (1+2)/2 = 1.5

After 3:
maxHeap: [2, 1]    minHeap: [3]
Median: 2

After 4:
maxHeap: [2, 1]    minHeap: [3, 4]
Median: (2+3)/2 = 2.5

After 5:
maxHeap: [3, 2, 1]    minHeap: [4, 5]
Median: 3
```

**Invariants**:
1. `maxHeap.size() >= minHeap.size()`
2. `maxHeap.size() - minHeap.size() <= 1`
3. All elements in maxHeap ≤ all elements in minHeap

**Time**: addNum O(log n), findMedian O(1)
**Space**: O(n)

---

## Top K Problems

### Problem 1: Kth Smallest Element in Sorted Matrix ⭐⭐⭐

**LeetCode 378** - Kth Smallest Element in Sorted Matrix

**Problem**: Find kth smallest in n×n matrix where each row/column sorted.

**Input**:
```
matrix = [[1,5,9],
          [10,11,13],
          [12,13,15]]
k = 8
```
**Output**: `13`

**Solution**:
```java
public class KthSmallestInMatrix {
    public int kthSmallest(int[][] matrix, int k) {
        int n = matrix.length;
        
        // Min heap: [value, row, col]
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (a, b) -> a[0] - b[0]
        );
        
        // Add first element of each row
        for (int i = 0; i < Math.min(n, k); i++) {
            minHeap.offer(new int[]{matrix[i][0], i, 0});
        }
        
        int result = 0;
        for (int i = 0; i < k; i++) {
            int[] current = minHeap.poll();
            result = current[0];
            int row = current[1];
            int col = current[2];
            
            // Add next element from same row
            if (col + 1 < n) {
                minHeap.offer(new int[]{matrix[row][col + 1], row, col + 1});
            }
        }
        
        return result;
    }
}
```

**Time**: O(k log n) | **Space**: O(n)

---

### Problem 2: K Closest Points to Origin ⭐⭐⭐⭐

**LeetCode 973** - K Closest Points to Origin

**Problem**: Find k closest points to origin (0, 0).

**Input**: `points = [[1,3],[-2,2]]`, `k = 1`
**Output**: `[[-2,2]]`

**Solution**:
```java
public class KClosestPoints {
    public int[][] kClosest(int[][] points, int k) {
        // Max heap (by distance) of size k
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(
            (a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1])
        );
        
        for (int[] point : points) {
            maxHeap.offer(point);
            
            if (maxHeap.size() > k) {
                maxHeap.poll();
            }
        }
        
        int[][] result = new int[k][2];
        for (int i = 0; i < k; i++) {
            result[i] = maxHeap.poll();
        }
        
        return result;
    }
}
```

**Why Max Heap?**
- Keep k closest points
- Farthest of these k is removed when size > k
- No need for sqrt (compare squared distances)

**Time**: O(n log k) | **Space**: O(k)

---

### Problem 3: Reorganize String ⭐⭐⭐

**LeetCode 767** - Reorganize String

**Problem**: Rearrange string so no adjacent characters are same.

**Input**: `s = "aab"`
**Output**: `"aba"`

**Solution**:
```java
public class ReorganizeString {
    public String reorganizeString(String s) {
        // Count frequencies
        Map<Character, Integer> freqMap = new HashMap<>();
        for (char c : s.toCharArray()) {
            freqMap.put(c, freqMap.getOrDefault(c, 0) + 1);
        }
        
        // Max heap (by frequency)
        PriorityQueue<Character> maxHeap = new PriorityQueue<>(
            (a, b) -> freqMap.get(b) - freqMap.get(a)
        );
        maxHeap.addAll(freqMap.keySet());
        
        StringBuilder result = new StringBuilder();
        
        while (maxHeap.size() >= 2) {
            // Take two most frequent
            char first = maxHeap.poll();
            char second = maxHeap.poll();
            
            result.append(first);
            result.append(second);
            
            // Decrease frequencies and add back
            freqMap.put(first, freqMap.get(first) - 1);
            freqMap.put(second, freqMap.get(second) - 1);
            
            if (freqMap.get(first) > 0) maxHeap.offer(first);
            if (freqMap.get(second) > 0) maxHeap.offer(second);
        }
        
        // Handle remaining character
        if (!maxHeap.isEmpty()) {
            char last = maxHeap.poll();
            if (freqMap.get(last) > 1) {
                return "";  // Impossible
            }
            result.append(last);
        }
        
        return result.toString();
    }
}
```

**Time**: O(n log k) where k = unique chars
**Space**: O(k)

---

## Merge K Problems

### Problem 1: Merge K Sorted Arrays ⭐⭐⭐⭐

**Problem**: Merge k sorted arrays into one sorted array.

**Input**: `arrays = [[1,4,5], [1,3,4], [2,6]]`
**Output**: `[1,1,2,3,4,4,5,6]`

**Solution**:
```java
public class MergeKSortedArrays {
    public List<Integer> mergeKArrays(int[][] arrays) {
        List<Integer> result = new ArrayList<>();
        
        // Min heap: [value, arrayIndex, elementIndex]
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (a, b) -> a[0] - b[0]
        );
        
        // Add first element of each array
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i].length > 0) {
                minHeap.offer(new int[]{arrays[i][0], i, 0});
            }
        }
        
        while (!minHeap.isEmpty()) {
            int[] current = minHeap.poll();
            int value = current[0];
            int arrayIdx = current[1];
            int elementIdx = current[2];
            
            result.add(value);
            
            // Add next element from same array
            if (elementIdx + 1 < arrays[arrayIdx].length) {
                minHeap.offer(new int[]{
                    arrays[arrayIdx][elementIdx + 1],
                    arrayIdx,
                    elementIdx + 1
                });
            }
        }
        
        return result;
    }
}
```

**Time**: O(n log k) where n = total elements
**Space**: O(k)

---

### Problem 2: Smallest Range Covering K Lists ⭐⭐⭐⭐

**LeetCode 632** - Smallest Range Covering Elements from K Lists

**Problem**: Find smallest range containing at least one number from each list.

**Input**: `nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]`
**Output**: `[20, 24]`

**Solution**:
```java
public class SmallestRange {
    public int[] smallestRange(List<List<Integer>> nums) {
        // Min heap: [value, listIndex, elementIndex]
        PriorityQueue<int[]> minHeap = new PriorityQueue<>(
            (a, b) -> a[0] - b[0]
        );
        
        int currentMax = Integer.MIN_VALUE;
        
        // Add first element of each list
        for (int i = 0; i < nums.size(); i++) {
            int value = nums.get(i).get(0);
            minHeap.offer(new int[]{value, i, 0});
            currentMax = Math.max(currentMax, value);
        }
        
        int rangeStart = 0;
        int rangeEnd = Integer.MAX_VALUE;
        
        while (minHeap.size() == nums.size()) {
            int[] current = minHeap.poll();
            int currentMin = current[0];
            int listIdx = current[1];
            int elementIdx = current[2];
            
            // Update range if smaller
            if (currentMax - currentMin < rangeEnd - rangeStart) {
                rangeStart = currentMin;
                rangeEnd = currentMax;
            }
            
            // Add next element from same list
            if (elementIdx + 1 < nums.get(listIdx).size()) {
                int nextValue = nums.get(listIdx).get(elementIdx + 1);
                minHeap.offer(new int[]{nextValue, listIdx, elementIdx + 1});
                currentMax = Math.max(currentMax, nextValue);
            }
        }
        
        return new int[]{rangeStart, rangeEnd};
    }
}
```

**Time**: O(n log k) | **Space**: O(k)

---

## Interview Questions

### Question 1: Task Scheduler ⭐⭐⭐⭐

**LeetCode 621** - Task Scheduler

**Problem**: Schedule tasks with n intervals between same tasks.

**Input**: `tasks = ['A','A','A','B','B','B']`, `n = 2`
**Output**: `8` (A → B → idle → A → B → idle → A → B)

**Solution**:
```java
public class TaskScheduler {
    public int leastInterval(char[] tasks, int n) {
        // Count frequencies
        int[] freq = new int[26];
        for (char task : tasks) {
            freq[task - 'A']++;
        }
        
        // Max heap
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        for (int f : freq) {
            if (f > 0) {
                maxHeap.offer(f);
            }
        }
        
        int time = 0;
        
        while (!maxHeap.isEmpty()) {
            List<Integer> temp = new ArrayList<>();
            
            // Execute tasks for n+1 interval
            for (int i = 0; i <= n; i++) {
                if (!maxHeap.isEmpty()) {
                    int count = maxHeap.poll();
                    if (count > 1) {
                        temp.add(count - 1);
                    }
                }
                time++;
                
                if (maxHeap.isEmpty() && temp.isEmpty()) {
                    break;
                }
            }
            
            // Add back remaining tasks
            for (int count : temp) {
                maxHeap.offer(count);
            }
        }
        
        return time;
    }
}
```

**Time**: O(n) | **Space**: O(1)

---

### Question 2: Sliding Window Median ⭐⭐⭐⭐

**LeetCode 480** - Sliding Window Median

**Problem**: Find median in each sliding window.

**Solution**:
```java
public class SlidingWindowMedian {
    public double[] medianSlidingWindow(int[] nums, int k) {
        double[] result = new double[nums.length - k + 1];
        
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        for (int i = 0; i < nums.length; i++) {
            // Add new element
            if (maxHeap.isEmpty() || nums[i] <= maxHeap.peek()) {
                maxHeap.offer(nums[i]);
            } else {
                minHeap.offer(nums[i]);
            }
            
            // Balance heaps
            if (maxHeap.size() > minHeap.size() + 1) {
                minHeap.offer(maxHeap.poll());
            } else if (minHeap.size() > maxHeap.size()) {
                maxHeap.offer(minHeap.poll());
            }
            
            // Remove old element
            if (i >= k) {
                int toRemove = nums[i - k];
                if (toRemove <= maxHeap.peek()) {
                    maxHeap.remove(toRemove);
                } else {
                    minHeap.remove(toRemove);
                }
                
                // Rebalance
                if (maxHeap.size() > minHeap.size() + 1) {
                    minHeap.offer(maxHeap.poll());
                } else if (minHeap.size() > maxHeap.size()) {
                    maxHeap.offer(minHeap.poll());
                }
            }
            
            // Calculate median
            if (i >= k - 1) {
                if (k % 2 == 0) {
                    result[i - k + 1] = ((long)maxHeap.peek() + (long)minHeap.peek()) / 2.0;
                } else {
                    result[i - k + 1] = maxHeap.peek();
                }
            }
        }
        
        return result;
    }
}
```

**Time**: O(n k) due to remove() | **Space**: O(k)

---

### Question 3: IPO ⭐⭐⭐

**LeetCode 502** - IPO

**Problem**: Maximize capital by selecting at most k projects.

**Solution**:
```java
public class IPO {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        // Min heap for projects by capital
        PriorityQueue<int[]> minCapital = new PriorityQueue<>(
            (a, b) -> a[0] - b[0]
        );
        
        // Max heap for available projects by profit
        PriorityQueue<Integer> maxProfit = new PriorityQueue<>(Collections.reverseOrder());
        
        // Add all projects to minCapital
        for (int i = 0; i < profits.length; i++) {
            minCapital.offer(new int[]{capital[i], profits[i]});
        }
        
        // Select k projects
        for (int i = 0; i < k; i++) {
            // Move affordable projects to maxProfit
            while (!minCapital.isEmpty() && minCapital.peek()[0] <= w) {
                maxProfit.offer(minCapital.poll()[1]);
            }
            
            // No affordable projects
            if (maxProfit.isEmpty()) {
                break;
            }
            
            // Select most profitable
            w += maxProfit.poll();
        }
        
        return w;
    }
}
```

**Time**: O(n log n + k log n) | **Space**: O(n)

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Key Concept |
|---|---------|----------|-------------|
| 1 | Last Stone Weight | 1046 | Max heap |
| 2 | Kth Largest Element in Stream | 703 | Min heap of size k |
| 3 | Relative Ranks | 506 | Sorting with heap |
| 4 | Min Cost to Connect Sticks | 1167 | Greedy + min heap |

### Medium Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Kth Largest Element | 215 | Min heap | ⭐⭐⭐⭐⭐ |
| 2 | Top K Frequent Elements | 347 | Frequency + heap | ⭐⭐⭐⭐⭐ |
| 3 | K Closest Points | 973 | Distance + heap | ⭐⭐⭐⭐ |
| 4 | Reorganize String | 767 | Greedy + heap | ⭐⭐⭐⭐ |
| 5 | Task Scheduler | 621 | Greedy + heap | ⭐⭐⭐⭐ |
| 6 | Find K Pairs with Smallest Sums | 373 | Merge k | ⭐⭐⭐ |
| 7 | Kth Smallest in Sorted Matrix | 378 | Merge k | ⭐⭐⭐ |
| 8 | Ugly Number II | 264 | Three pointers + heap | ⭐⭐⭐ |
| 9 | Meeting Rooms II | 253 | Sweep line + heap | ⭐⭐⭐⭐ |
| 10 | Single-Threaded CPU | 1834 | Simulation + heap | ⭐⭐⭐ |

### Hard Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Find Median from Data Stream | 295 | Two heaps | ⭐⭐⭐⭐⭐ |
| 2 | Merge K Sorted Lists | 23 | Merge k | ⭐⭐⭐⭐⭐ |
| 3 | Sliding Window Median | 480 | Two heaps + window | ⭐⭐⭐⭐ |
| 4 | Smallest Range K Lists | 632 | Merge k + range | ⭐⭐⭐⭐ |
| 5 | IPO | 502 | Two heaps greedy | ⭐⭐⭐ |
| 6 | Trapping Rain Water II | 407 | Priority queue BFS | ⭐⭐⭐ |
| 7 | The Skyline Problem | 218 | Multiset/TreeMap | ⭐⭐⭐⭐ |

---

## Summary

### Key Concepts

**Priority Queue Definition**:
- **Priority-based**: Not FIFO, elements served by priority
- **Heap-based**: Binary heap implementation
- **Min/Max**: Min heap (smallest first) or max heap (largest first)
- **O(log n)**: Insert and delete operations

**When to Use Priority Queue?**
✅ Find kth largest/smallest
✅ Top k elements
✅ Merge k sorted structures
✅ Running median
✅ Task scheduling by priority
✅ Shortest path algorithms (Dijkstra)
✅ Greedy algorithms with priority

### Heap Properties

**Complete Binary Tree**:
- All levels filled except last
- Last level filled left to right
- Height: O(log n)

**Min Heap**: `parent ≤ children`
**Max Heap**: `parent ≥ children`

**Array Indices** (0-based):
- Parent: `(i - 1) / 2`
- Left: `2 * i + 1`
- Right: `2 * i + 2`

### Operation Complexity

| Operation | Time | Notes |
|-----------|------|-------|
| **insert/offer** | O(log n) | Heapify up |
| **poll/remove** | O(log n) | Heapify down |
| **peek** | O(1) | Return root |
| **size/isEmpty** | O(1) | Track size |
| **contains** | O(n) | Linear search |
| **remove(element)** | O(n) | Find + heapify |
| **Build heap** | O(n) | Bottom-up heapify |

### Java PriorityQueue Quick Reference

```java
// Min heap (default)
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

// Max heap
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

// Custom comparator (lambda)
PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);

// Custom comparator (method reference)
PriorityQueue<String> pq = new PriorityQueue<>(Comparator.comparingInt(String::length));

// Operations
pq.offer(x);      // Insert (preferred)
pq.add(x);        // Insert (throws exception if fails)
pq.poll();        // Remove and return min/max (null if empty)
pq.remove();      // Remove and return min/max (exception if empty)
pq.peek();        // View min/max (null if empty)
pq.element();     // View min/max (exception if empty)
pq.size();        // Get size
pq.isEmpty();     // Check empty
pq.contains(x);   // Check if contains (O(n))
```

### Common Patterns

**Pattern 1: Kth Largest/Smallest**
```java
// Kth largest → use min heap of size k
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
for (int num : nums) {
    minHeap.offer(num);
    if (minHeap.size() > k) {
        minHeap.poll();
    }
}
return minHeap.peek();
```

**Pattern 2: Top K Frequent**
```java
// Count frequencies, then min heap of size k
Map<Integer, Integer> freq = new HashMap<>();
// ... count frequencies

PriorityQueue<Integer> minHeap = new PriorityQueue<>(
    (a, b) -> freq.get(a) - freq.get(b)
);
```

**Pattern 3: Two Heaps (Median)**
```java
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
PriorityQueue<Integer> minHeap = new PriorityQueue<>();

// Maintain: maxHeap.size() >= minHeap.size()
// All elements in maxHeap <= all in minHeap
```

**Pattern 4: Merge K**
```java
// Min heap with [value, source_index, element_index]
PriorityQueue<int[]> minHeap = new PriorityQueue<>(
    (a, b) -> a[0] - b[0]
);

// Add first element from each source
// Poll and add next from same source
```

### Common Mistakes

1. ❌ Using max heap when min heap needed (or vice versa)
2. ❌ Comparing objects without comparator
3. ❌ Thinking PriorityQueue is sorted (it's a heap!)
4. ❌ Iterating PriorityQueue expecting sorted order
5. ❌ Using `contains()` or `remove(element)` frequently (O(n))
6. ❌ Forgetting to check `isEmpty()` before `peek()`/`poll()`
7. ❌ Not using size k for top k problems (using size n)

### Interview Tips

1. ✅ **Identify pattern**: "Kth", "Top K", "Median" → Priority Queue
2. ✅ **Choose heap type**: Kth largest → min heap, Kth smallest → max heap
3. ✅ **Optimize space**: Keep only k elements for top k
4. ✅ **Use comparator**: For custom objects or complex sorting
5. ✅ **Two heaps**: For median or range queries
6. ✅ **Greedy + heap**: For scheduling, selection problems
7. ✅ **Merge k pattern**: For k sorted structures

### Must Master Problems

**Top 5 Essential**:
1. ✅ **Kth Largest Element** (LC 215) - Foundation ⭐⭐⭐⭐⭐
2. ✅ **Top K Frequent** (LC 347) - Frequency pattern ⭐⭐⭐⭐⭐
3. ✅ **Find Median from Stream** (LC 295) - Two heaps ⭐⭐⭐⭐⭐
4. ✅ **Merge K Sorted Lists** (LC 23) - Merge k pattern ⭐⭐⭐⭐⭐
5. ✅ **K Closest Points** (LC 973) - Distance + heap ⭐⭐⭐⭐

### Min Heap vs Max Heap Selection

**For Kth Largest**:
- Use **Min Heap** of size k
- Keep k largest elements
- Top of heap is kth largest

**For Kth Smallest**:
- Use **Max Heap** of size k
- Keep k smallest elements
- Top of heap is kth smallest

**Counterintuitive but correct!**

### Heap vs Sorting

| Approach | Time | Space | When to Use |
|----------|------|-------|-------------|
| **Heap** | O(n log k) | O(k) | k << n, streaming data |
| **Sort** | O(n log n) | O(1) | k ≈ n, all data available |

**Example**: Find top 10 from 1 million elements
- Heap: O(1M × log 10) ≈ 3.3M operations
- Sort: O(1M × log 1M) ≈ 20M operations

### Next Steps

- **Next**: [9.5 Monotonic Queue](9.5-Monotonic-Queue.md)
- **Practice**: Solve all Top K and Merge K problems
- **Master**: Two heaps pattern for median
- **Advanced**: Priority queue in graph algorithms

---

**Previous**: [9.3 Deque](9.3-Deque.md)

**Remember**: Priority Queue is essential for "kth", "top k", and "median" problems!
