# 9.2 Circular Queue

## Table of Contents
1. [Introduction](#introduction)
2. [Why Circular Queue?](#why-circular-queue)
3. [Basic Implementation](#basic-implementation)
4. [Advanced Implementations](#advanced-implementations)
5. [Common Problems](#common-problems)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is a Circular Queue?

A **Circular Queue** (or **Ring Buffer**) is a linear data structure that uses a **fixed-size array** in a circular manner. When the rear reaches the end of the array, it wraps around to the beginning if space is available.

### Why "Circular"?

**Linear Queue Problem**:
```
Initial: [_, _, _, _, _]  (capacity = 5)
         front=0, rear=-1

After enqueue(1,2,3,4,5):
         [1, 2, 3, 4, 5]
          ↑           ↑
        front       rear

After 3 dequeues:
         [X, X, X, 4, 5]
                   ↑  ↑
                 front rear

Problem: Can't add new elements!
         rear = 4 (end of array)
         But positions 0,1,2 are FREE! ❌
```

**Circular Queue Solution**:
```
After dequeues:
         [X, X, X, 4, 5]
                   ↑  ↑
                 front rear

After enqueue(6):
         [6, X, X, 4, 5]
          ↑        ↑
        rear     front

Wraps around! ✅
```

### Real-World Examples

1. **CPU Scheduling**: Round-robin algorithm
2. **Buffering**: Audio/video streaming
3. **Traffic Light**: Circular signal rotation
4. **Keyboard Buffer**: Key press storage
5. **Memory Management**: Circular buffers in OS

---

## Why Circular Queue?

### Advantages

✅ **Efficient Space Utilization**: No wasted space
✅ **O(1) Operations**: Constant time enqueue/dequeue
✅ **Fixed Memory**: Predictable memory usage
✅ **Cache Friendly**: Contiguous memory allocation
✅ **No Fragmentation**: Circular wrapping prevents gaps

### Disadvantages

❌ **Fixed Size**: Cannot grow dynamically
❌ **Complexity**: Slightly more complex than linear queue
❌ **Overflow Risk**: Must handle full condition

### Comparison

| Feature | Linear Queue | Circular Queue |
|---------|--------------|----------------|
| Space Usage | Wasteful | Efficient |
| Enqueue | O(1) until full | O(1) |
| Dequeue | O(1) | O(1) |
| Wrap Around | ❌ No | ✅ Yes |
| Implementation | Simple | Moderate |
| Use Case | Limited | Production systems |

---

## Basic Implementation

### Approach 1: Using Size Variable

```java
public class CircularQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    // Constructor
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    // Enqueue: Add element at rear
    public void enqueue(int value) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
    }
    
    // Dequeue: Remove element from front
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        int value = arr[front];
        front = (front + 1) % capacity;
        size--;
        
        return value;
    }
    
    // Peek: View front element
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    // Get rear element
    public int rear() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[rear];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        
        System.out.print("Queue: ");
        for (int i = 0; i < size; i++) {
            int index = (front + i) % capacity;
            System.out.print(arr[index] + " ");
        }
        System.out.println();
    }
    
    public static void main(String[] args) {
        CircularQueue queue = new CircularQueue(5);
        
        queue.enqueue(10);
        queue.enqueue(20);
        queue.enqueue(30);
        queue.display();  // Queue: 10 20 30
        
        System.out.println("Dequeue: " + queue.dequeue());  // 10
        System.out.println("Dequeue: " + queue.dequeue());  // 20
        
        queue.enqueue(40);
        queue.enqueue(50);
        queue.enqueue(60);
        queue.display();  // Queue: 30 40 50 60
        
        System.out.println("Front: " + queue.peek());  // 30
        System.out.println("Size: " + queue.size());   // 4
    }
}
```

**Time Complexity**: All operations O(1)
**Space Complexity**: O(n) where n is capacity

---

### Approach 2: Without Size Variable

**Key Idea**: Use empty slot to distinguish full from empty.

```java
public class CircularQueueNoSize {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    
    public CircularQueueNoSize(int capacity) {
        // Add 1 to capacity for the empty slot
        this.capacity = capacity + 1;
        this.arr = new int[this.capacity];
        this.front = 0;
        this.rear = 0;
    }
    
    public void enqueue(int value) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        
        arr[rear] = value;
        rear = (rear + 1) % capacity;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        int value = arr[front];
        front = (front + 1) % capacity;
        
        return value;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    public boolean isEmpty() {
        return front == rear;
    }
    
    public boolean isFull() {
        return (rear + 1) % capacity == front;
    }
    
    public int size() {
        return (rear - front + capacity) % capacity;
    }
}
```

**Key Points**:
- Sacrifice one slot to distinguish full vs empty
- `isEmpty()`: `front == rear`
- `isFull()`: `(rear + 1) % capacity == front`

---

### Detailed Dry Run

```
Circular Queue with capacity = 5

Initial State:
Array: [_, _, _, _, _]
       front=0, rear=0, size=0

Step 1: enqueue(10)
        rear = (0 + 1) % 5 = 1
        arr[0] = 10
        [10, _, _, _, _]
         ↑   ↑
       front rear
        size=1

Step 2: enqueue(20)
        rear = (1 + 1) % 5 = 2
        arr[1] = 20
        [10, 20, _, _, _]
         ↑       ↑
       front   rear
        size=2

Step 3: enqueue(30)
        [10, 20, 30, _, _]
         ↑           ↑
       front       rear
        size=3

Step 4: dequeue() → 10
        front = (0 + 1) % 5 = 1
        [X, 20, 30, _, _]
             ↑      ↑
           front  rear
        size=2

Step 5: dequeue() → 20
        front = (1 + 1) % 5 = 2
        [X, X, 30, _, _]
                ↑   ↑
              front rear
        size=1

Step 6: enqueue(40)
        [X, X, 30, 40, _]
                ↑      ↑
              front  rear
        size=2

Step 7: enqueue(50)
        [X, X, 30, 40, 50]
                ↑          ↑
              front      rear
        size=3

Step 8: enqueue(60) - WRAP AROUND!
        rear = (4 + 1) % 5 = 0
        [60, X, 30, 40, 50]
          ↑   ↑
        rear  front
        size=4

Step 9: enqueue(70)
        rear = (0 + 1) % 5 = 1
        [60, 70, 30, 40, 50]
               ↑ ↑
             rear front
        size=5 (FULL!)

Step 10: enqueue(80) → Exception: Queue is full
```

---

## Advanced Implementations

### Implementation 1: Generic Circular Queue

```java
public class GenericCircularQueue<T> {
    private T[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    @SuppressWarnings("unchecked")
    public GenericCircularQueue(int capacity) {
        this.capacity = capacity;
        this.arr = (T[]) new Object[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public void enqueue(T value) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        T value = arr[front];
        arr[front] = null;  // Help GC
        front = (front + 1) % capacity;
        size--;
        
        return value;
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
    
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        if (isEmpty()) {
            return "[]";
        }
        
        StringBuilder sb = new StringBuilder("[");
        for (int i = 0; i < size; i++) {
            int index = (front + i) % capacity;
            sb.append(arr[index]);
            if (i < size - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}
```

**Usage**:
```java
public static void main(String[] args) {
    GenericCircularQueue<String> queue = new GenericCircularQueue<>(3);
    
    queue.enqueue("Alice");
    queue.enqueue("Bob");
    queue.enqueue("Charlie");
    
    System.out.println(queue);  // [Alice, Bob, Charlie]
    
    queue.dequeue();
    queue.enqueue("David");
    
    System.out.println(queue);  // [Bob, Charlie, David]
}
```

---

### Implementation 2: Dynamic Circular Queue

**Auto-resize when full**.

```java
public class DynamicCircularQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public DynamicCircularQueue(int initialCapacity) {
        this.capacity = initialCapacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public void enqueue(int value) {
        if (isFull()) {
            resize(capacity * 2);
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
    }
    
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        int value = arr[front];
        front = (front + 1) % capacity;
        size--;
        
        // Shrink if utilization < 25%
        if (size > 0 && size == capacity / 4) {
            resize(capacity / 2);
        }
        
        return value;
    }
    
    private void resize(int newCapacity) {
        int[] newArr = new int[newCapacity];
        
        // Copy elements in order
        for (int i = 0; i < size; i++) {
            newArr[i] = arr[(front + i) % capacity];
        }
        
        arr = newArr;
        front = 0;
        rear = size - 1;
        capacity = newCapacity;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
    
    public int size() {
        return size;
    }
    
    public int capacity() {
        return capacity;
    }
}
```

**Complexity**:
- **Enqueue**: O(1) amortized (O(n) when resizing)
- **Dequeue**: O(1) amortized
- **Space**: O(n) for n elements

---

### Implementation 3: Thread-Safe Circular Queue

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.Condition;

public class ThreadSafeCircularQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();
    
    public ThreadSafeCircularQueue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public void enqueue(int value) throws InterruptedException {
        lock.lock();
        try {
            while (isFull()) {
                notFull.await();  // Wait until not full
            }
            
            rear = (rear + 1) % capacity;
            arr[rear] = value;
            size++;
            
            notEmpty.signal();  // Signal waiting dequeuers
        } finally {
            lock.unlock();
        }
    }
    
    public int dequeue() throws InterruptedException {
        lock.lock();
        try {
            while (isEmpty()) {
                notEmpty.await();  // Wait until not empty
            }
            
            int value = arr[front];
            front = (front + 1) % capacity;
            size--;
            
            notFull.signal();  // Signal waiting enqueuers
            
            return value;
        } finally {
            lock.unlock();
        }
    }
    
    public boolean isEmpty() {
        lock.lock();
        try {
            return size == 0;
        } finally {
            lock.unlock();
        }
    }
    
    public boolean isFull() {
        lock.lock();
        try {
            return size == capacity;
        } finally {
            lock.unlock();
        }
    }
}
```

**Use Case**: Producer-consumer pattern, multi-threaded applications.

---

## Common Problems

### Problem 1: Design Circular Queue ⭐⭐⭐⭐⭐

**LeetCode 622** | **Difficulty: Medium** | **Frequency: Very High**

**Problem**: Implement circular queue with fixed size.

**Operations**:
- `MyCircularQueue(k)`: Constructor
- `enQueue(value)`: Insert element
- `deQueue()`: Delete element
- `Front()`: Get front item
- `Rear()`: Get rear item
- `isEmpty()`: Check if empty
- `isFull()`: Check if full

**Solution**:
```java
class MyCircularQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public MyCircularQueue(int k) {
        this.capacity = k;
        this.arr = new int[k];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
        
        return true;
    }
    
    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        
        front = (front + 1) % capacity;
        size--;
        
        return true;
    }
    
    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }
    
    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return arr[rear];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}

/**
 * Usage:
 * MyCircularQueue obj = new MyCircularQueue(3);
 * obj.enQueue(1);  // true
 * obj.enQueue(2);  // true
 * obj.enQueue(3);  // true
 * obj.enQueue(4);  // false (full)
 * obj.Rear();      // 3
 * obj.isFull();    // true
 * obj.deQueue();   // true
 * obj.enQueue(4);  // true
 * obj.Rear();      // 4
 */
```

**Time**: All operations O(1)
**Space**: O(k)

---

### Problem 2: Design Circular Deque ⭐⭐⭐⭐

**LeetCode 641** | **Difficulty: Medium**

**Problem**: Implement circular double-ended queue.

**Operations**:
- `insertFront()`, `insertLast()`
- `deleteFront()`, `deleteLast()`
- `getFront()`, `getRear()`

**Solution**:
```java
class MyCircularDeque {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public MyCircularDeque(int k) {
        this.capacity = k;
        this.arr = new int[k];
        this.front = 0;
        this.rear = k - 1;
        this.size = 0;
    }
    
    public boolean insertFront(int value) {
        if (isFull()) {
            return false;
        }
        
        front = (front - 1 + capacity) % capacity;
        arr[front] = value;
        size++;
        
        return true;
    }
    
    public boolean insertLast(int value) {
        if (isFull()) {
            return false;
        }
        
        rear = (rear + 1) % capacity;
        arr[rear] = value;
        size++;
        
        return true;
    }
    
    public boolean deleteFront() {
        if (isEmpty()) {
            return false;
        }
        
        front = (front + 1) % capacity;
        size--;
        
        return true;
    }
    
    public boolean deleteLast() {
        if (isEmpty()) {
            return false;
        }
        
        rear = (rear - 1 + capacity) % capacity;
        size--;
        
        return true;
    }
    
    public int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return arr[front];
    }
    
    public int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return arr[rear];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}
```

**Key Points**:
- Insert front: `front = (front - 1 + capacity) % capacity`
- Delete rear: `rear = (rear - 1 + capacity) % capacity`
- Add `capacity` before modulo to handle negative values

**Time**: All operations O(1)

---

### Problem 3: Design Hit Counter ⭐⭐⭐

**LeetCode 362** | **Difficulty: Medium**

**Problem**: Count hits in last 5 minutes (300 seconds).

**Solution using Circular Queue**:
```java
public class HitCounter {
    private int[] times;
    private int[] hits;
    private int capacity = 300;
    
    public HitCounter() {
        times = new int[capacity];
        hits = new int[capacity];
    }
    
    public void hit(int timestamp) {
        int index = timestamp % capacity;
        
        if (times[index] != timestamp) {
            // New timestamp at this slot
            times[index] = timestamp;
            hits[index] = 1;
        } else {
            // Same timestamp
            hits[index]++;
        }
    }
    
    public int getHits(int timestamp) {
        int total = 0;
        
        for (int i = 0; i < capacity; i++) {
            if (timestamp - times[i] < 300) {
                total += hits[i];
            }
        }
        
        return total;
    }
}
```

**Optimized with Queue**:
```java
public class HitCounter {
    private Queue<Integer> queue;
    
    public HitCounter() {
        queue = new LinkedList<>();
    }
    
    public void hit(int timestamp) {
        queue.offer(timestamp);
    }
    
    public int getHits(int timestamp) {
        // Remove hits older than 300 seconds
        while (!queue.isEmpty() && timestamp - queue.peek() >= 300) {
            queue.poll();
        }
        
        return queue.size();
    }
}
```

**Time**: 
- `hit()`: O(1)
- `getHits()`: O(n) worst case, O(1) amortized

---

### Problem 4: Moving Average from Data Stream ⭐⭐

**LeetCode 346** | **Difficulty: Easy**

**Problem**: Calculate moving average of last n numbers.

**Solution using Circular Queue**:
```java
public class MovingAverage {
    private int[] arr;
    private int capacity;
    private int size;
    private int front;
    private int rear;
    private double sum;
    
    public MovingAverage(int size) {
        this.capacity = size;
        this.arr = new int[size];
        this.size = 0;
        this.front = 0;
        this.rear = -1;
        this.sum = 0;
    }
    
    public double next(int val) {
        if (size < capacity) {
            // Queue not full
            rear = (rear + 1) % capacity;
            arr[rear] = val;
            sum += val;
            size++;
        } else {
            // Queue full, remove oldest
            sum -= arr[front];
            front = (front + 1) % capacity;
            
            rear = (rear + 1) % capacity;
            arr[rear] = val;
            sum += val;
        }
        
        return sum / size;
    }
}

/**
 * Usage:
 * MovingAverage obj = new MovingAverage(3);
 * obj.next(1);  // 1.0
 * obj.next(10); // 5.5 = (1 + 10) / 2
 * obj.next(3);  // 4.67 = (1 + 10 + 3) / 3
 * obj.next(5);  // 6.0 = (10 + 3 + 5) / 3
 */
```

**Time**: O(1) per operation
**Space**: O(n)

---

## Interview Questions

### Question 1: Check if Circular Queue is Symmetric

**Problem**: Check if circular queue is symmetric (palindrome).

**Example**:
```
Input: [1, 2, 3, 2, 1]
Output: true

Input: [1, 2, 3, 4]
Output: false
```

**Solution**:
```java
public class SymmetricQueue {
    public static boolean isSymmetric(CircularQueue queue) {
        if (queue.isEmpty()) {
            return true;
        }
        
        int size = queue.size();
        int[] arr = new int[size];
        
        // Extract all elements
        for (int i = 0; i < size; i++) {
            arr[i] = queue.dequeue();
            queue.enqueue(arr[i]);  // Restore
        }
        
        // Check palindrome
        int left = 0, right = size - 1;
        while (left < right) {
            if (arr[left] != arr[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Question 2: Implement k Queues in Single Array

**Problem**: Implement k circular queues in one array.

**Solution**:
```java
public class KQueues {
    private int[] arr;
    private int[] front;
    private int[] rear;
    private int[] next;
    private int[] size;
    private int free;
    private int k;
    private int n;
    
    public KQueues(int k, int n) {
        this.k = k;
        this.n = n;
        this.arr = new int[n];
        this.front = new int[k];
        this.rear = new int[k];
        this.next = new int[n];
        this.size = new int[k];
        
        Arrays.fill(front, -1);
        Arrays.fill(rear, -1);
        
        // Initialize free list
        for (int i = 0; i < n - 1; i++) {
            next[i] = i + 1;
        }
        next[n - 1] = -1;
        free = 0;
    }
    
    public void enqueue(int queueNum, int value) {
        if (free == -1) {
            throw new IllegalStateException("All queues are full");
        }
        
        // Get free slot
        int i = free;
        free = next[i];
        
        if (front[queueNum] == -1) {
            front[queueNum] = i;
        } else {
            next[rear[queueNum]] = i;
        }
        
        next[i] = -1;
        rear[queueNum] = i;
        arr[i] = value;
        size[queueNum]++;
    }
    
    public int dequeue(int queueNum) {
        if (front[queueNum] == -1) {
            throw new NoSuchElementException("Queue " + queueNum + " is empty");
        }
        
        int i = front[queueNum];
        front[queueNum] = next[i];
        
        if (front[queueNum] == -1) {
            rear[queueNum] = -1;
        }
        
        // Add to free list
        next[i] = free;
        free = i;
        
        size[queueNum]--;
        return arr[i];
    }
    
    public boolean isEmpty(int queueNum) {
        return front[queueNum] == -1;
    }
    
    public int size(int queueNum) {
        return size[queueNum];
    }
}
```

**Time**: All operations O(1)
**Space**: O(n + k)

---

### Question 3: Gas Station ⭐⭐⭐

**LeetCode 134** | **Difficulty: Medium**

**Problem**: Find starting gas station to complete circular route.

**Input**: 
```
gas = [1,2,3,4,5]
cost = [3,4,5,1,2]
```
**Output**: `3`

**Solution**:
```java
public class GasStation {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int totalGas = 0;
        int totalCost = 0;
        int tank = 0;
        int start = 0;
        
        for (int i = 0; i < gas.length; i++) {
            totalGas += gas[i];
            totalCost += cost[i];
            tank += gas[i] - cost[i];
            
            // If tank becomes negative, start from next station
            if (tank < 0) {
                start = i + 1;
                tank = 0;
            }
        }
        
        // If total gas < total cost, impossible
        return totalGas < totalCost ? -1 : start;
    }
}
```

**Key Insight**: If we can't reach station i from start, we can't reach from any station between start and i.

**Time**: O(n) | **Space**: O(1)

---

### Question 4: Circular Array Loop ⭐⭐⭐

**LeetCode 457** | **Difficulty: Medium**

**Problem**: Check if circular array has a cycle.

**Input**: `nums = [2,-1,1,2,2]`
**Output**: `true`

**Explanation**: Index 0 → 2 → 4 → 1 → 0 (cycle)

**Solution**:
```java
public class CircularArrayLoop {
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;
        
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) continue;
            
            int slow = i, fast = i;
            boolean forward = nums[i] > 0;
            
            while (true) {
                // Move slow one step
                slow = getNext(nums, slow, forward);
                if (slow == -1) break;
                
                // Move fast two steps
                fast = getNext(nums, fast, forward);
                if (fast == -1) break;
                fast = getNext(nums, fast, forward);
                if (fast == -1) break;
                
                // Cycle detected
                if (slow == fast) {
                    // Check if cycle length > 1
                    if (slow == getNext(nums, slow, forward)) {
                        break;  // Self loop
                    }
                    return true;
                }
            }
            
            // Mark as visited
            slow = i;
            int val = nums[i];
            while (nums[slow] * val > 0) {
                int next = getNext(nums, slow, forward);
                nums[slow] = 0;
                slow = next;
            }
        }
        
        return false;
    }
    
    private int getNext(int[] nums, int index, boolean forward) {
        boolean direction = nums[index] > 0;
        
        if (direction != forward) return -1;  // Direction changed
        
        int next = (index + nums[index]) % nums.length;
        if (next < 0) next += nums.length;
        
        if (next == index) return -1;  // Self loop
        
        return next;
    }
}
```

**Time**: O(n) | **Space**: O(1)

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Key Concept |
|---|---------|----------|-------------|
| 1 | Design Circular Queue | 622 | Basic implementation |
| 2 | Moving Average from Data Stream | 346 | Sliding window |
| 3 | Design Hit Counter | 362 | Time-based queue |
| 4 | First Unique Character in Stream | - | Frequency + queue |

### Medium Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Design Circular Deque | 641 | Double-ended | ⭐⭐⭐⭐ |
| 2 | Gas Station | 134 | Greedy + circular | ⭐⭐⭐⭐⭐ |
| 3 | Circular Array Loop | 457 | Cycle detection | ⭐⭐⭐ |
| 4 | Design Bounded Blocking Queue | 1188 | Thread-safe | ⭐⭐⭐ |
| 5 | Time Based Key-Value Store | 981 | Binary search + map | ⭐⭐⭐ |

### Hard Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Design Memory Allocator | 2502 | Memory management | ⭐⭐⭐ |
| 2 | Minimum Window Subsequence | 727 | Two pointers | ⭐⭐ |

---

## Summary

### Key Concepts

**Circular Queue**:
- **FIFO** with circular wrapping
- **Fixed size** with efficient space usage
- **O(1)** operations for all methods
- **Modulo arithmetic** for index calculation

### Circular Index Calculation

```java
// Forward movement
rear = (rear + 1) % capacity
front = (front + 1) % capacity

// Backward movement
front = (front - 1 + capacity) % capacity
rear = (rear - 1 + capacity) % capacity

// Size calculation (without size variable)
size = (rear - front + capacity) % capacity
```

### Empty vs Full Detection

**Method 1: Use size variable**
```java
isEmpty() → size == 0
isFull()  → size == capacity
```

**Method 2: Sacrifice one slot**
```java
isEmpty() → front == rear
isFull()  → (rear + 1) % capacity == front
```

**Method 3: Use flag**
```java
isEmpty() → front == -1
isFull()  → (rear + 1) % capacity == front && size == capacity
```

### Implementation Comparison

| Feature | Array (size var) | Array (no size) | Dynamic |
|---------|------------------|-----------------|---------|
| **Space** | O(n) | O(n+1) | O(n) |
| **isFull** | O(1) | O(1) | Auto-resize |
| **size()** | O(1) | O(1) calculation | O(1) |
| **Complexity** | Simple | Moderate | Complex |
| **Use Case** | Most common | Space critical | Unknown size |

### Common Patterns

**Pattern 1: Basic Circular Operations**
```java
enqueue(x):
    rear = (rear + 1) % capacity
    arr[rear] = x

dequeue():
    value = arr[front]
    front = (front + 1) % capacity
    return value
```

**Pattern 2: Circular Traversal**
```java
for (int i = 0; i < size; i++) {
    int index = (front + i) % capacity;
    process(arr[index]);
}
```

**Pattern 3: Circular Distance**
```java
distance = (rear - front + capacity) % capacity
```

### Common Mistakes

1. ❌ Forgetting modulo: `rear++` instead of `rear = (rear + 1) % capacity`
2. ❌ Negative modulo: `(front - 1) % capacity` → use `(front - 1 + capacity) % capacity`
3. ❌ Full condition: `rear == capacity - 1` instead of proper circular check
4. ❌ Not resetting indices when queue becomes empty
5. ❌ Off-by-one errors in size calculation

### Interview Tips

1. ✅ **Clarify requirements**: Fixed vs dynamic size?
2. ✅ **Choose detection method**: Size variable vs sacrifice slot?
3. ✅ **Handle edge cases**: Empty, full, single element
4. ✅ **Modulo arithmetic**: Always add capacity before modulo for negative
5. ✅ **Circular properties**: Understand wrapping behavior

### LeetCode Must-Solve

**Top 5 Essential**:
1. ✅ **Design Circular Queue** (LC 622) - Foundation ⭐⭐⭐⭐⭐
2. ✅ **Design Circular Deque** (LC 641) - Double-ended ⭐⭐⭐⭐
3. ✅ **Gas Station** (LC 134) - Circular array logic ⭐⭐⭐⭐⭐
4. ✅ **Moving Average** (LC 346) - Sliding window ⭐⭐⭐
5. ✅ **Circular Array Loop** (LC 457) - Cycle detection ⭐⭐⭐

### Quick Reference

**Circular Queue Template**:
```java
public class CircularQueue {
    private int[] arr;
    private int front, rear, capacity, size;
    
    public CircularQueue(int k) {
        capacity = k;
        arr = new int[k];
        front = 0;
        rear = -1;
        size = 0;
    }
    
    public boolean enqueue(int x) {
        if (size == capacity) return false;
        rear = (rear + 1) % capacity;
        arr[rear] = x;
        size++;
        return true;
    }
    
    public boolean dequeue() {
        if (size == 0) return false;
        front = (front + 1) % capacity;
        size--;
        return true;
    }
}
```

### Real-World Applications

1. **CPU Scheduling**: Round-robin algorithm
2. **Buffer Management**: Audio/video streaming
3. **Memory Pool**: Fixed-size object pools
4. **Traffic Simulation**: Circular traffic light systems
5. **Producer-Consumer**: Bounded buffer problem

### Next Steps

- **Next**: [9.3 Queue Using Linked List](9.3-Queue-Using-Linked-List.md)
- **Related**: Priority Queue, Deque
- **Practice**: Solve LC 622, 641, 134

---

**Previous**: [9.1 Queue Basics](9.1-Queue-Basics.md)

**Remember**: Circular queues are essential for efficient fixed-size buffer implementations!
