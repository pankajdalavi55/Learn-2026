# 9.1 Queue Basics

## Table of Contents
1. [Introduction](#introduction)
2. [Queue Fundamentals](#queue-fundamentals)
3. [Queue vs Other Data Structures](#queue-vs-other-data-structures)
4. [Java Queue Implementations](#java-queue-implementations)
5. [Array-Based Queue](#array-based-queue)
6. [Circular Queue](#circular-queue)
7. [Linked List Queue](#linked-list-queue)
8. [Generic Queue](#generic-queue)
9. [Essential Queue Patterns](#essential-queue-patterns)
10. [Common Problems](#common-problems)
11. [Interview Questions](#interview-questions)
12. [Practice Problems](#practice-problems)
13. [Summary](#summary)

---

## Introduction

### What is a Queue?

A **Queue** is a linear data structure that follows the **FIFO (First In First Out)** principle:
- First element added is the first to be removed
- Elements are added at the **rear (back)**
- Elements are removed from the **front**

### Real-World Analogies

1. **Line at Ticket Counter**: First person in line gets served first
2. **Print Queue**: First document sent gets printed first
3. **Call Center**: First caller in queue gets answered first
4. **Traffic Light**: First car to arrive moves first
5. **Message Queue**: First message sent is processed first

### Queue Visualization

```
Front → [A] [B] [C] [D] ← Rear
        ↓               ↑
      Dequeue         Enqueue

Operations:
- enqueue(E) → [A] [B] [C] [D] [E]
- dequeue()  → [B] [C] [D] [E]  (A removed)
```

---

## Queue Fundamentals

### FIFO Principle

**First In First Out**:
```
Timeline:
t=1: enqueue(10) → [10]
t=2: enqueue(20) → [10, 20]
t=3: enqueue(30) → [10, 20, 30]
t=4: dequeue()   → [20, 30]      (10 removed first)
t=5: dequeue()   → [30]          (20 removed second)
```

### Core Operations

| Operation | Description | Time Complexity |
|-----------|-------------|-----------------|
| `enqueue(x)` | Add element to rear | O(1) |
| `dequeue()` | Remove element from front | O(1) |
| `peek()`/`front()` | View front element | O(1) |
| `isEmpty()` | Check if queue is empty | O(1) |
| `size()` | Get number of elements | O(1) |
| `isFull()` | Check if queue is full (array-based) | O(1) |

### Queue States

**Empty Queue**:
```
Front = -1, Rear = -1
[]
```

**Normal Queue**:
```
Front = 0, Rear = 2
[10, 20, 30]
 ↑       ↑
Front   Rear
```

**Full Queue** (array-based):
```
Front = 0, Rear = 4 (capacity = 5)
[10, 20, 30, 40, 50]
```

---

## Queue vs Other Data Structures

### Queue vs Stack

| Feature | Queue | Stack |
|---------|-------|-------|
| Principle | FIFO | LIFO |
| Insertion | Rear (enqueue) | Top (push) |
| Deletion | Front (dequeue) | Top (pop) |
| Use Case | Scheduling, BFS | Function calls, DFS |
| Example | Print queue | Undo/Redo |

**Visual Comparison**:
```
Queue (FIFO):
enqueue(1,2,3) → [1,2,3]
dequeue()      → 1 (first in, first out)

Stack (LIFO):
push(1,2,3)    → [1,2,3]
pop()          → 3 (last in, first out)
```

### Queue vs Array

| Feature | Queue | Array |
|---------|-------|-------|
| Access | Front/Rear only | Any index (O(1)) |
| Insertion | O(1) at rear | O(n) in middle |
| Deletion | O(1) at front | O(n) in middle |
| Search | O(n) | O(n) linear, O(log n) sorted |
| Use Case | Order processing | Random access |

### Queue vs Linked List

| Feature | Queue | Linked List |
|---------|-------|-------------|
| Structure | Abstract ADT | Physical structure |
| Operations | enqueue/dequeue | insert/delete anywhere |
| Implementation | Can use LL | Independent structure |
| Flexibility | Fixed operations | More flexible |

---

## Java Queue Implementations

### Queue Interface

Java provides `Queue<E>` interface in `java.util` package.

**Hierarchy**:
```
Collection<E>
    ↓
Queue<E>
    ↓
Deque<E> (Double-ended queue)
```

### Common Implementations

**1. LinkedList** (Most common):
```java
Queue<Integer> queue = new LinkedList<>();
```

**2. ArrayDeque** (Faster than LinkedList):
```java
Queue<Integer> queue = new ArrayDeque<>();
```

**3. PriorityQueue** (Heap-based, not FIFO):
```java
Queue<Integer> queue = new PriorityQueue<>();
```

### Queue Methods

**Two Variants**:
- **Throws exception**: `add()`, `remove()`, `element()`
- **Returns special value**: `offer()`, `poll()`, `peek()`

| Operation | Throws Exception | Returns Special Value |
|-----------|------------------|----------------------|
| Insert | `add(e)` | `offer(e)` (returns false if full) |
| Remove | `remove()` | `poll()` (returns null if empty) |
| Examine | `element()` | `peek()` (returns null if empty) |

### Basic Usage

```java
import java.util.*;

public class QueueBasics {
    public static void main(String[] args) {
        // Create queue using LinkedList
        Queue<Integer> queue = new LinkedList<>();
        
        // Enqueue (add elements)
        queue.offer(10);
        queue.offer(20);
        queue.offer(30);
        
        System.out.println("Queue: " + queue);  // [10, 20, 30]
        
        // Peek (view front)
        System.out.println("Front: " + queue.peek());  // 10
        
        // Dequeue (remove elements)
        System.out.println("Removed: " + queue.poll());  // 10
        System.out.println("Removed: " + queue.poll());  // 20
        
        System.out.println("Queue: " + queue);  // [30]
        
        // Check empty
        System.out.println("Empty? " + queue.isEmpty());  // false
        
        // Size
        System.out.println("Size: " + queue.size());  // 1
    }
}
```

**Output**:
```
Queue: [10, 20, 30]
Front: 10
Removed: 10
Removed: 20
Queue: [30]
Empty? false
Size: 1
```

---

## Array-Based Queue

### Simple Array Queue

**Problem**: Front pointer never moves back, causing "false full" condition.

```java
public class SimpleArrayQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public SimpleArrayQueue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    // Enqueue: Add element at rear
    public void enqueue(int value) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        rear++;
        arr[rear] = value;
        size++;
    }
    
    // Dequeue: Remove element from front
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        int value = arr[front];
        front++;
        size--;
        return value;
    }
    
    // Peek: View front element
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return rear == capacity - 1;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        System.out.print("Queue: ");
        for (int i = front; i <= rear; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

**Problem with Simple Queue**:
```
Initial: capacity = 5
         front=0, rear=-1

After enqueue(1,2,3,4,5):
[1, 2, 3, 4, 5]
 ↑           ↑
front       rear

After 3 dequeues:
[X, X, X, 4, 5]
          ↑  ↑
        front rear

Problem: Can't add new elements even though positions 0-2 are free!
Solution: Use Circular Queue
```

---

## Circular Queue

### Concept

**Circular Queue** uses modulo arithmetic to wrap around the array.

**Visualization**:
```
     0   1   2   3   4
   [10][20][30][40][50]
    ↑               ↑
  front           rear

After rear reaches end, wraps to beginning:
     0   1   2   3   4
   [60][20][30][40][50]
         ↑           ↑
       front        rear (wraps to 0)
```

### Implementation

```java
public class CircularQueue {
    private int[] arr;
    private int front;
    private int rear;
    private int capacity;
    private int size;
    
    public CircularQueue(int capacity) {
        this.capacity = capacity;
        this.arr = new int[capacity];
        this.front = -1;
        this.rear = -1;
        this.size = 0;
    }
    
    // Enqueue: Add element at rear
    public void enqueue(int value) {
        if (isFull()) {
            throw new IllegalStateException("Queue is full");
        }
        
        if (isEmpty()) {
            front = 0;
            rear = 0;
        } else {
            rear = (rear + 1) % capacity;  // Circular increment
        }
        
        arr[rear] = value;
        size++;
    }
    
    // Dequeue: Remove element from front
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        int value = arr[front];
        
        if (front == rear) {
            // Only one element, reset queue
            front = -1;
            rear = -1;
        } else {
            front = (front + 1) % capacity;  // Circular increment
        }
        
        size--;
        return value;
    }
    
    // Peek: View front element
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return arr[front];
    }
    
    public boolean isEmpty() {
        return front == -1;
    }
    
    public boolean isFull() {
        return (rear + 1) % capacity == front;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        
        System.out.print("Queue: ");
        int i = front;
        do {
            System.out.print(arr[i] + " ");
            i = (i + 1) % capacity;
        } while (i != (rear + 1) % capacity);
        System.out.println();
    }
}
```

**LeetCode 622** - Design Circular Queue

### Detailed Operations

**Enqueue Operation**:
```
Step 1: Check if full
        (rear + 1) % capacity == front

Step 2: If empty, set front = 0, rear = 0
        Else, rear = (rear + 1) % capacity

Step 3: arr[rear] = value

Step 4: size++
```

**Dequeue Operation**:
```
Step 1: Check if empty
        front == -1

Step 2: value = arr[front]

Step 3: If front == rear, reset (front = -1, rear = -1)
        Else, front = (front + 1) % capacity

Step 4: size--

Step 5: return value
```

### Dry Run Example

```
Circular Queue with capacity = 3

Operation      | front | rear | Array      | Size
---------------|-------|------|------------|-----
Initial        | -1    | -1   | [-, -, -]  | 0
enqueue(10)    |  0    |  0   | [10,-, -]  | 1
enqueue(20)    |  0    |  1   | [10,20,-]  | 2
enqueue(30)    |  0    |  2   | [10,20,30] | 3
dequeue()→10   |  1    |  2   | [-,20,30]  | 2
enqueue(40)    |  1    |  0   | [40,20,30] | 3  (wrapped!)
               |       |      |     ↑      |
               |       |      | rear=0     |
dequeue()→20   |  2    |  0   | [40,-,30]  | 2
dequeue()→30   |  0    |  0   | [40,-,-]   | 1
```

**Time**: All operations O(1)
**Space**: O(n) where n is capacity

---

## Linked List Queue

### Node Class

```java
class Node {
    int data;
    Node next;
    
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}
```

### LinkedList Queue Implementation

```java
public class LinkedListQueue {
    private Node front;
    private Node rear;
    private int size;
    
    public LinkedListQueue() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
    
    // Enqueue: Add element at rear
    public void enqueue(int value) {
        Node newNode = new Node(value);
        
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        
        size++;
    }
    
    // Dequeue: Remove element from front
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        int value = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;  // Queue became empty
        }
        
        size--;
        return value;
    }
    
    // Peek: View front element
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return front.data;
    }
    
    public boolean isEmpty() {
        return front == null;
    }
    
    public int size() {
        return size;
    }
    
    public void display() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        
        System.out.print("Queue: ");
        Node current = front;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```

### Visual Representation

**Enqueue Operation**:
```
Initial: front=null, rear=null
         null

After enqueue(10):
         front/rear
            ↓
         [10|null]

After enqueue(20):
         front      rear
            ↓         ↓
         [10|→] → [20|null]

After enqueue(30):
         front            rear
            ↓               ↓
         [10|→] → [20|→] → [30|null]
```

**Dequeue Operation**:
```
Before dequeue():
         front            rear
            ↓               ↓
         [10|→] → [20|→] → [30|null]

After dequeue() → 10:
                 front      rear
                    ↓         ↓
                 [20|→] → [30|null]
```

**Time**: All operations O(1)
**Space**: O(n) for n elements

---

## Generic Queue

### Generic Implementation

```java
public class GenericQueue<T> {
    private Node<T> front;
    private Node<T> rear;
    private int size;
    
    private static class Node<T> {
        T data;
        Node<T> next;
        
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
    
    public GenericQueue() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
    
    public void enqueue(T value) {
        Node<T> newNode = new Node<>(value);
        
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        
        size++;
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        T value = front.data;
        front = front.next;
        
        if (front == null) {
            rear = null;
        }
        
        size--;
        return value;
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return front.data;
    }
    
    public boolean isEmpty() {
        return front == null;
    }
    
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        if (isEmpty()) {
            return "[]";
        }
        
        StringBuilder sb = new StringBuilder("[");
        Node<T> current = front;
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(", ");
            }
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

### Usage Example

```java
public class GenericQueueDemo {
    public static void main(String[] args) {
        // Integer Queue
        GenericQueue<Integer> intQueue = new GenericQueue<>();
        intQueue.enqueue(10);
        intQueue.enqueue(20);
        intQueue.enqueue(30);
        System.out.println("Int Queue: " + intQueue);  // [10, 20, 30]
        
        // String Queue
        GenericQueue<String> strQueue = new GenericQueue<>();
        strQueue.enqueue("Hello");
        strQueue.enqueue("World");
        System.out.println("String Queue: " + strQueue);  // [Hello, World]
        
        // Custom Object Queue
        GenericQueue<Person> personQueue = new GenericQueue<>();
        personQueue.enqueue(new Person("Alice", 25));
        personQueue.enqueue(new Person("Bob", 30));
        System.out.println("Person Queue: " + personQueue);
    }
}

class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}
```

---

## Essential Queue Patterns

### Pattern 1: Level Order Traversal (BFS)

**Problem**: Traverse tree level by level.

**Solution**:
```java
public class BFSPattern {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if (root == null) return result;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();
            
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            
            result.add(currentLevel);
        }
        
        return result;
    }
}
```

**LeetCode 102** - Binary Tree Level Order Traversal

**Time**: O(n) | **Space**: O(w) where w is max width

---

### Pattern 2: First Non-Repeating Character

**Problem**: Find first non-repeating character in stream.

**Solution**:
```java
public class FirstNonRepeating {
    public static String firstNonRepeating(String stream) {
        Queue<Character> queue = new LinkedList<>();
        Map<Character, Integer> freq = new HashMap<>();
        StringBuilder result = new StringBuilder();
        
        for (char c : stream.toCharArray()) {
            // Update frequency
            freq.put(c, freq.getOrDefault(c, 0) + 1);
            queue.offer(c);
            
            // Remove repeating characters from front
            while (!queue.isEmpty() && freq.get(queue.peek()) > 1) {
                queue.poll();
            }
            
            // First non-repeating or -1
            if (queue.isEmpty()) {
                result.append('#');
            } else {
                result.append(queue.peek());
            }
        }
        
        return result.toString();
    }
    
    public static void main(String[] args) {
        System.out.println(firstNonRepeating("aabccd"));  // a#bbbb
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Pattern 3: Generate Binary Numbers

**Problem**: Generate binary numbers from 1 to n.

**Input**: `n = 5`
**Output**: `["1", "10", "11", "100", "101"]`

**Solution**:
```java
public class GenerateBinaryNumbers {
    public static List<String> generateBinary(int n) {
        List<String> result = new ArrayList<>();
        Queue<String> queue = new LinkedList<>();
        
        queue.offer("1");
        
        for (int i = 0; i < n; i++) {
            String current = queue.poll();
            result.add(current);
            
            // Generate next two binary numbers
            queue.offer(current + "0");
            queue.offer(current + "1");
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        System.out.println(generateBinary(10));
        // [1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010]
    }
}
```

**Key Idea**: 
- Start with "1"
- For each number, generate two more: number+"0" and number+"1"

**Time**: O(n) | **Space**: O(n)

---

### Pattern 4: Sliding Window Maximum

**Problem**: Find maximum in each sliding window of size k.

**Input**: `nums = [1,3,-1,-3,5,3,6,7]`, `k = 3`
**Output**: `[3,3,5,5,6,7]`

**Solution**:
```java
public class SlidingWindowMaximum {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new ArrayDeque<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            // Remove elements outside window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // Remove smaller elements (not useful)
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            
            deque.offerLast(i);
            
            // Add to result when window is complete
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
}
```

**LeetCode 239** - Sliding Window Maximum

**Time**: O(n) | **Space**: O(k)

---

### Pattern 5: Reverse First K Elements

**Problem**: Reverse first k elements of queue.

**Input**: `queue = [10, 20, 30, 40, 50]`, `k = 3`
**Output**: `[30, 20, 10, 40, 50]`

**Solution**:
```java
public class ReverseFirstK {
    public static void reverseFirstK(Queue<Integer> queue, int k) {
        if (queue.isEmpty() || k <= 0) {
            return;
        }
        
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Push first k elements to stack
        for (int i = 0; i < k; i++) {
            stack.push(queue.poll());
        }
        
        // Pop from stack and enqueue
        while (!stack.isEmpty()) {
            queue.offer(stack.pop());
        }
        
        // Move remaining elements to back
        for (int i = 0; i < queue.size() - k; i++) {
            queue.offer(queue.poll());
        }
    }
    
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>(Arrays.asList(10, 20, 30, 40, 50));
        reverseFirstK(queue, 3);
        System.out.println(queue);  // [30, 20, 10, 40, 50]
    }
}
```

**Time**: O(n) | **Space**: O(k)

---

### Pattern 6: Interleave Queue

**Problem**: Interleave first half with second half.

**Input**: `queue = [1, 2, 3, 4, 5, 6]`
**Output**: `[1, 4, 2, 5, 3, 6]`

**Solution**:
```java
public class InterleaveQueue {
    public static void interleave(Queue<Integer> queue) {
        int n = queue.size();
        Queue<Integer> firstHalf = new LinkedList<>();
        
        // Move first half to temp queue
        for (int i = 0; i < n / 2; i++) {
            firstHalf.offer(queue.poll());
        }
        
        // Interleave
        while (!firstHalf.isEmpty()) {
            queue.offer(firstHalf.poll());
            queue.offer(queue.poll());
        }
    }
    
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        interleave(queue);
        System.out.println(queue);  // [1, 4, 2, 5, 3, 6]
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Common Problems

### Problem 1: Implement Stack using Queues ⭐⭐⭐

**LeetCode 225** | **Difficulty: Easy**

**Solution 1: Two Queues**:
```java
public class StackUsingQueues {
    private Queue<Integer> q1;
    private Queue<Integer> q2;
    
    public StackUsingQueues() {
        q1 = new LinkedList<>();
        q2 = new LinkedList<>();
    }
    
    // Push: O(n)
    public void push(int x) {
        q2.offer(x);
        
        while (!q1.isEmpty()) {
            q2.offer(q1.poll());
        }
        
        // Swap queues
        Queue<Integer> temp = q1;
        q1 = q2;
        q2 = temp;
    }
    
    // Pop: O(1)
    public int pop() {
        return q1.poll();
    }
    
    // Top: O(1)
    public int top() {
        return q1.peek();
    }
    
    public boolean empty() {
        return q1.isEmpty();
    }
}
```

**Solution 2: One Queue**:
```java
public class StackUsingOneQueue {
    private Queue<Integer> queue;
    
    public StackUsingOneQueue() {
        queue = new LinkedList<>();
    }
    
    // Push: O(n)
    public void push(int x) {
        queue.offer(x);
        int size = queue.size();
        
        // Rotate queue
        for (int i = 0; i < size - 1; i++) {
            queue.offer(queue.poll());
        }
    }
    
    // Pop: O(1)
    public int pop() {
        return queue.poll();
    }
    
    // Top: O(1)
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```

---

### Problem 2: Number of Recent Calls ⭐⭐

**LeetCode 933** | **Difficulty: Easy**

**Problem**: Count requests in last 3000ms.

**Solution**:
```java
public class RecentCounter {
    private Queue<Integer> queue;
    
    public RecentCounter() {
        queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.offer(t);
        
        // Remove requests older than 3000ms
        while (queue.peek() < t - 3000) {
            queue.poll();
        }
        
        return queue.size();
    }
}

/**
 * Usage:
 * RecentCounter obj = new RecentCounter();
 * obj.ping(1);     // 1
 * obj.ping(100);   // 2
 * obj.ping(3001);  // 3
 * obj.ping(3002);  // 3
 */
```

**Time**: O(1) amortized | **Space**: O(n)

---

## Interview Questions

### Question 1: Reverse a Queue

**Problem**: Reverse all elements in a queue.

**Solution**:
```java
public class ReverseQueue {
    public static void reverse(Queue<Integer> queue) {
        if (queue.isEmpty()) {
            return;
        }
        
        int front = queue.poll();
        reverse(queue);
        queue.offer(front);
    }
    
    // Iterative using stack
    public static void reverseIterative(Queue<Integer> queue) {
        Deque<Integer> stack = new ArrayDeque<>();
        
        while (!queue.isEmpty()) {
            stack.push(queue.poll());
        }
        
        while (!stack.isEmpty()) {
            queue.offer(stack.pop());
        }
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Question 2: Queue using Stacks

**Problem**: Implement queue using two stacks.

**Solution**:
```java
public class QueueUsingStacks {
    private Deque<Integer> s1;  // For enqueue
    private Deque<Integer> s2;  // For dequeue
    
    public QueueUsingStacks() {
        s1 = new ArrayDeque<>();
        s2 = new ArrayDeque<>();
    }
    
    // Enqueue: O(1)
    public void enqueue(int x) {
        s1.push(x);
    }
    
    // Dequeue: O(1) amortized
    public int dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        if (s2.isEmpty()) {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
        }
        
        return s2.pop();
    }
    
    // Peek: O(1) amortized
    public int peek() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        
        if (s2.isEmpty()) {
            while (!s1.isEmpty()) {
                s2.push(s1.pop());
            }
        }
        
        return s2.peek();
    }
    
    public boolean isEmpty() {
        return s1.isEmpty() && s2.isEmpty();
    }
}
```

**LeetCode 232** - Implement Queue using Stacks

**Time**: O(1) amortized for all operations

---

### Question 3: Sort Queue

**Problem**: Sort a queue without using any other data structure.

**Solution**:
```java
public class SortQueue {
    public static void sort(Queue<Integer> queue) {
        if (queue.isEmpty()) {
            return;
        }
        
        // Remove front element
        int min = findMin(queue, queue.size());
        
        // Recursively sort remaining
        sort(queue);
        
        // Add min at end
        queue.offer(min);
    }
    
    private static int findMin(Queue<Integer> queue, int size) {
        int min = Integer.MAX_VALUE;
        
        for (int i = 0; i < size; i++) {
            int current = queue.poll();
            min = Math.min(min, current);
            
            if (current != min) {
                queue.offer(current);
            }
        }
        
        return min;
    }
    
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>(Arrays.asList(30, 10, 40, 20));
        sort(queue);
        System.out.println(queue);  // [10, 20, 30, 40]
    }
}
```

**Time**: O(n²) | **Space**: O(n) recursion

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Key Concept |
|---|---------|----------|-------------|
| 1 | Implement Queue using Stacks | 232 | Two stacks |
| 2 | Implement Stack using Queues | 225 | One/two queues |
| 3 | Number of Recent Calls | 933 | Time window |
| 4 | Design Circular Queue | 622 | Circular array |
| 5 | Moving Average from Data Stream | 346 | Sliding window |

### Medium Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Binary Tree Level Order Traversal | 102 | BFS | ⭐⭐⭐⭐⭐ |
| 2 | Sliding Window Maximum | 239 | Deque | ⭐⭐⭐⭐⭐ |
| 3 | Rotting Oranges | 994 | Multi-source BFS | ⭐⭐⭐⭐ |
| 4 | Open the Lock | 752 | BFS | ⭐⭐⭐ |
| 5 | Perfect Squares | 279 | BFS/DP | ⭐⭐⭐ |
| 6 | Shortest Path in Binary Matrix | 1091 | BFS | ⭐⭐⭐ |
| 7 | Snakes and Ladders | 909 | BFS | ⭐⭐ |

### Hard Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Sliding Window Median | 480 | Two heaps | ⭐⭐⭐⭐ |
| 2 | Jump Game VI | 1696 | Monotonic deque | ⭐⭐⭐ |
| 3 | Shortest Subarray with Sum at Least K | 862 | Monotonic deque | ⭐⭐⭐ |

---

## Summary

### Key Concepts

**FIFO Principle**:
- First In First Out
- Enqueue at rear, dequeue from front
- Opposite of stack (LIFO)

**Implementation Approaches**:
1. **Array-based**: Fixed size, circular for efficiency
2. **Linked List**: Dynamic size, no overflow
3. **Generic**: Type-safe, reusable

### Implementation Comparison

| Feature | Array (Circular) | Linked List |
|---------|------------------|-------------|
| **Enqueue** | O(1) | O(1) |
| **Dequeue** | O(1) | O(1) |
| **Peek** | O(1) | O(1) |
| **Space** | Fixed (may waste) | Dynamic |
| **Cache** | Better locality | Pointer overhead |
| **Resize** | Expensive | Not needed |
| **Use When** | Known max size | Unknown size |

### Queue Operations Complexity

| Operation | Array | Linked List | ArrayDeque |
|-----------|-------|-------------|------------|
| enqueue() | O(1) | O(1) | O(1) amortized |
| dequeue() | O(1) | O(1) | O(1) |
| peek() | O(1) | O(1) | O(1) |
| isEmpty() | O(1) | O(1) | O(1) |
| size() | O(1) | O(1) | O(1) |

### Common Queue Patterns

**1. BFS Traversal**:
```java
Queue<Node> queue = new LinkedList<>();
queue.offer(start);

while (!queue.isEmpty()) {
    Node current = queue.poll();
    // Process current
    // Add neighbors to queue
}
```

**2. Level Order Processing**:
```java
int levelSize = queue.size();
for (int i = 0; i < levelSize; i++) {
    Node node = queue.poll();
    // Process node at current level
}
```

**3. Sliding Window**:
```java
Deque<Integer> deque = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    // Remove outside window
    while (!deque.isEmpty() && deque.peekFirst() < i - k + 1)
        deque.pollFirst();
    // Process current element
}
```

### Common Mistakes

1. ❌ Not checking `isEmpty()` before `poll()/peek()`
2. ❌ Using `remove()`/`element()` instead of `poll()`/`peek()` (throws exception)
3. ❌ Circular queue: Wrong modulo calculation
4. ❌ LinkedList: Forgetting to update `rear` when last element removed
5. ❌ Not resetting `front` and `rear` to -1 when queue becomes empty

### Interview Tips

1. ✅ **Clarify requirements**: Fixed vs dynamic size?
2. ✅ **Choose right implementation**: Array vs LinkedList
3. ✅ **Handle edge cases**: Empty queue, full queue (array)
4. ✅ **Use built-in Queue**: LinkedList/ArrayDeque in Java
5. ✅ **BFS pattern**: Most common queue application
6. ✅ **Deque for optimization**: Sliding window problems

### Must Master Problems

**Top 5 Essential**:
1. ✅ **Implement Queue using Stacks** (LC 232) - Classic design
2. ✅ **Binary Tree Level Order** (LC 102) - BFS foundation
3. ✅ **Design Circular Queue** (LC 622) - Array implementation
4. ✅ **Sliding Window Maximum** (LC 239) - Deque optimization
5. ✅ **Rotting Oranges** (LC 994) - Multi-source BFS

### Java Queue Quick Reference

```java
// Create queue
Queue<Integer> queue = new LinkedList<>();
Queue<Integer> queue = new ArrayDeque<>();  // Faster

// Operations (prefer these - return null/false on failure)
queue.offer(x);      // Enqueue
queue.poll();        // Dequeue
queue.peek();        // Front element
queue.isEmpty();     // Check empty
queue.size();        // Get size

// Alternative (throw exceptions)
queue.add(x);        // Enqueue
queue.remove();      // Dequeue
queue.element();     // Front element
```

### Next Topics

- **Deque (Double-ended Queue)**: Add/remove from both ends
- **Priority Queue**: Heap-based, not FIFO
- **Circular Deque**: Combines circular + double-ended
- **Blocking Queue**: Thread-safe queue

---

**Next**: [9.2 Queue Using Array](9.2-Queue-Using-Array.md)

**Remember**: Queue is the foundation of BFS - master it for graph and tree problems!
