# Array Basics - Complete Guide for Competitive Programming

## Why Arrays Matter?

**Arrays are the foundation of 70% of coding problems!**

- Most basic and widely used data structure
- Foundation for ArrayList, Stack, Queue, Heap
- Critical for: Two Pointers, Sliding Window, Binary Search, DP
- Fastest access time: **O(1)** random access

**Master arrays = Solve most coding problems!**

---

## Table of Contents

1. [Array Declaration & Initialization](#declaration)
2. [Common Operations](#operations)
3. [Arrays Class Utilities](#arrays-class)
4. [Multi-dimensional Arrays](#multidimensional)
5. [Array vs ArrayList](#comparison)
6. [Common Patterns](#patterns)
7. [Common Pitfalls](#pitfalls)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="declaration"></a>
## 1. Array Declaration & Initialization

### Basic Declaration

```java
public class ArrayDeclaration {
    public static void main(String[] args) {
        
        // Method 1: Declare then initialize
        int[] arr1;              // Declaration
        arr1 = new int[5];       // Initialization with size 5
        
        // Method 2: Declare and initialize together
        int[] arr2 = new int[5]; // All elements = 0 by default
        
        // Method 3: Declare with values
        int[] arr3 = {1, 2, 3, 4, 5};
        
        // Method 4: Using new with values
        int[] arr4 = new int[]{1, 2, 3, 4, 5};
        
        // Alternative syntax (NOT recommended for new code)
        int arr5[] = new int[5];  // C-style, avoid in Java
        
        System.out.println(Arrays.toString(arr3));
        // Output: [1, 2, 3, 4, 5]
    }
}
```

---

### Default Values

```java
public class DefaultValues {
    public static void main(String[] args) {
        
        // Primitive types - default to zero/false
        int[] nums = new int[3];
        System.out.println(Arrays.toString(nums));
        // Output: [0, 0, 0]
        
        double[] decimals = new double[3];
        System.out.println(Arrays.toString(decimals));
        // Output: [0.0, 0.0, 0.0]
        
        boolean[] flags = new boolean[3];
        System.out.println(Arrays.toString(flags));
        // Output: [false, false, false]
        
        char[] chars = new char[3];
        System.out.println(Arrays.toString(chars));
        // Output: ['\u0000', '\u0000', '\u0000'] (null character)
        
        // Object types - default to null
        String[] strings = new String[3];
        System.out.println(Arrays.toString(strings));
        // Output: [null, null, null]
    }
}
```

---

### Array Length

```java
public class ArrayLength {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};
        
        // Length is a PROPERTY (not a method!)
        System.out.println(arr.length);  // 5
        // System.out.println(arr.length());  // ERROR! Not a method
        
        // Length is FINAL - cannot be changed
        // arr.length = 10;  // ERROR! Cannot assign
        
        // To change size, create new array
        int[] newArr = Arrays.copyOf(arr, 10);
        System.out.println(newArr.length);  // 10
    }
}
```

---

<a name="operations"></a>
## 2. Common Operations

### Accessing Elements

```java
public class ArrayAccess {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};
        
        // Access by index (0-based)
        System.out.println(arr[0]);  // 10 (first element)
        System.out.println(arr[4]);  // 50 (last element)
        System.out.println(arr[arr.length - 1]);  // 50 (last element)
        
        // Update element
        arr[2] = 100;
        System.out.println(Arrays.toString(arr));
        // [10, 20, 100, 40, 50]
        
        // ArrayIndexOutOfBoundsException
        // System.out.println(arr[5]);  // ERROR! Index 5 doesn't exist
        // System.out.println(arr[-1]);  // ERROR! Negative index
    }
}
```

**Time Complexity:** O(1) for access/update

---

### Traversing Arrays

```java
public class ArrayTraversal {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};
        
        // Method 1: Traditional for loop
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
        
        // Method 2: Enhanced for loop (for-each)
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        // Method 3: Using Arrays.toString()
        System.out.println(Arrays.toString(arr));
        
        // Method 4: Stream (Java 8+)
        Arrays.stream(arr).forEach(num -> System.out.print(num + " "));
        System.out.println();
        
        // Reverse traversal
        for (int i = arr.length - 1; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

**When to use which:**
- **Traditional for:** Need index, modify elements
- **Enhanced for:** Read-only, cleaner syntax
- **Stream:** Functional style, chaining operations

---

### Finding Min/Max

```java
public class MinMaxArray {
    public static void main(String[] args) {
        int[] arr = {45, 23, 67, 12, 89, 34};
        
        // Method 1: Manual iteration
        int min = arr[0];
        int max = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < min) min = arr[i];
            if (arr[i] > max) max = arr[i];
        }
        
        System.out.println("Min: " + min + ", Max: " + max);
        // Min: 12, Max: 89
        
        // Method 2: Using Stream (Java 8+)
        int minStream = Arrays.stream(arr).min().getAsInt();
        int maxStream = Arrays.stream(arr).max().getAsInt();
        
        System.out.println("Min: " + minStream + ", Max: " + maxStream);
    }
}
```

**Time Complexity:** O(n)

---

### Copying Arrays

```java
import java.util.*;

public class ArrayCopy {
    public static void main(String[] args) {
        int[] original = {1, 2, 3, 4, 5};
        
        // Method 1: Arrays.copyOf() - Full copy
        int[] copy1 = Arrays.copyOf(original, original.length);
        
        // Copy with different size
        int[] copy2 = Arrays.copyOf(original, 3);  // [1, 2, 3]
        int[] copy3 = Arrays.copyOf(original, 7);  // [1, 2, 3, 4, 5, 0, 0]
        
        // Method 2: Arrays.copyOfRange() - Partial copy
        int[] copy4 = Arrays.copyOfRange(original, 1, 4);  // [2, 3, 4]
        // From index 1 (inclusive) to 4 (exclusive)
        
        // Method 3: System.arraycopy()
        int[] copy5 = new int[5];
        System.arraycopy(original, 0, copy5, 0, original.length);
        
        // Method 4: clone()
        int[] copy6 = original.clone();
        
        // Method 5: Manual copy
        int[] copy7 = new int[original.length];
        for (int i = 0; i < original.length; i++) {
            copy7[i] = original[i];
        }
        
        // WARNING: Assignment does NOT copy!
        int[] notACopy = original;  // Same reference!
        notACopy[0] = 100;
        System.out.println(original[0]);  // 100 (modified original!)
        
        System.out.println(Arrays.toString(copy1));
        System.out.println(Arrays.toString(copy4));
    }
}
```

**Which to use:**
- **Arrays.copyOf():** Simple full copy or resize
- **Arrays.copyOfRange():** Copy specific range
- **System.arraycopy():** Performance-critical, large arrays
- **clone():** Quick syntax, shallow copy

---

### Filling Arrays

```java
import java.util.*;

public class ArrayFill {
    public static void main(String[] args) {
        
        // Fill entire array with same value
        int[] arr1 = new int[5];
        Arrays.fill(arr1, 10);
        System.out.println(Arrays.toString(arr1));
        // [10, 10, 10, 10, 10]
        
        // Fill specific range
        int[] arr2 = new int[10];
        Arrays.fill(arr2, 2, 7, 99);  // From index 2 to 7 (exclusive)
        System.out.println(Arrays.toString(arr2));
        // [0, 0, 99, 99, 99, 99, 99, 0, 0, 0]
        
        // Fill with different values
        int[] arr3 = new int[5];
        for (int i = 0; i < arr3.length; i++) {
            arr3[i] = i * 10;
        }
        System.out.println(Arrays.toString(arr3));
        // [0, 10, 20, 30, 40]
        
        // Fill with max/min values
        int[] arr4 = new int[5];
        Arrays.fill(arr4, Integer.MAX_VALUE);
        System.out.println(Arrays.toString(arr4));
        // [2147483647, 2147483647, ...]
    }
}
```

**Use Cases:**
- Initialize DP array with infinity: `Arrays.fill(dp, Integer.MAX_VALUE)`
- Initialize visited array: `Arrays.fill(visited, false)`
- Reset array: `Arrays.fill(arr, 0)`

---

<a name="arrays-class"></a>
## 3. Arrays Class Utilities

### Sorting

```java
import java.util.*;

public class ArraySorting {
    public static void main(String[] args) {
        
        // Sort entire array (ascending)
        int[] arr1 = {5, 2, 8, 1, 9};
        Arrays.sort(arr1);
        System.out.println(Arrays.toString(arr1));
        // [1, 2, 5, 8, 9]
        
        // Sort specific range
        int[] arr2 = {5, 2, 8, 1, 9};
        Arrays.sort(arr2, 1, 4);  // Sort from index 1 to 4 (exclusive)
        System.out.println(Arrays.toString(arr2));
        // [5, 1, 2, 8, 9]
        
        // Sort in descending order (wrapper class only!)
        Integer[] arr3 = {5, 2, 8, 1, 9};
        Arrays.sort(arr3, Collections.reverseOrder());
        System.out.println(Arrays.toString(arr3));
        // [9, 8, 5, 2, 1]
        
        // Sort strings
        String[] words = {"banana", "apple", "cherry"};
        Arrays.sort(words);
        System.out.println(Arrays.toString(words));
        // [apple, banana, cherry]
        
        // Custom comparator
        Integer[] arr4 = {-5, 2, -8, 1, 9};
        Arrays.sort(arr4, (a, b) -> Math.abs(a) - Math.abs(b));
        System.out.println(Arrays.toString(arr4));
        // [1, 2, -5, -8, 9] (sorted by absolute value)
    }
}
```

**Time Complexity:** O(n log n) - Dual-Pivot Quicksort

---

### Binary Search

```java
import java.util.*;

public class BinarySearchDemo {
    public static void main(String[] args) {
        
        // IMPORTANT: Array MUST be sorted!
        int[] arr = {1, 3, 5, 7, 9, 11, 13};
        
        // Search for existing element
        int index1 = Arrays.binarySearch(arr, 7);
        System.out.println(index1);  // 3
        
        // Search for non-existing element
        int index2 = Arrays.binarySearch(arr, 6);
        System.out.println(index2);  // -4 (-(insertion point) - 1)
        // Insertion point would be 3, so -(3) - 1 = -4
        
        // Search in range
        int index3 = Arrays.binarySearch(arr, 2, 5, 7);
        System.out.println(index3);  // 3
        
        // String search
        String[] words = {"apple", "banana", "cherry", "date"};
        int index4 = Arrays.binarySearch(words, "cherry");
        System.out.println(index4);  // 2
        
        // Convert negative result to insertion point
        if (index2 < 0) {
            int insertionPoint = -(index2 + 1);
            System.out.println("Insert at: " + insertionPoint);  // 3
        }
    }
}
```

**Time Complexity:** O(log n)

**Return Value:**
- **Positive:** Index of element if found
- **Negative:** `-(insertion_point) - 1` if not found

---

### Equality Check

```java
import java.util.*;

public class ArrayEquality {
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5};
        int[] arr2 = {1, 2, 3, 4, 5};
        int[] arr3 = {1, 2, 3, 4, 6};
        
        // WRONG: == compares references, not content!
        System.out.println(arr1 == arr2);  // false
        
        // CORRECT: Arrays.equals() compares content
        System.out.println(Arrays.equals(arr1, arr2));  // true
        System.out.println(Arrays.equals(arr1, arr3));  // false
        
        // Deep equals for multi-dimensional arrays
        int[][] matrix1 = {{1, 2}, {3, 4}};
        int[][] matrix2 = {{1, 2}, {3, 4}};
        
        System.out.println(Arrays.equals(matrix1, matrix2));      // false (shallow)
        System.out.println(Arrays.deepEquals(matrix1, matrix2));  // true (deep)
    }
}
```

---

### Converting Arrays

```java
import java.util.*;
import java.util.stream.*;

public class ArrayConversion {
    public static void main(String[] args) {
        
        // 1. Array to List
        Integer[] arr1 = {1, 2, 3, 4, 5};
        
        // Method 1: Arrays.asList() - Fixed size!
        List<Integer> list1 = Arrays.asList(arr1);
        // list1.add(6);  // ERROR! UnsupportedOperationException
        
        // Method 2: ArrayList constructor - Modifiable
        List<Integer> list2 = new ArrayList<>(Arrays.asList(arr1));
        list2.add(6);  // OK!
        
        // Method 3: Stream (Java 8+)
        List<Integer> list3 = Arrays.stream(arr1)
                                    .collect(Collectors.toList());
        
        // 2. List to Array
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Must specify array type
        Integer[] arr2 = numbers.toArray(new Integer[0]);
        
        // Stream for primitive array
        int[] arr3 = numbers.stream()
                           .mapToInt(i -> i)
                           .toArray();
        
        // 3. Primitive to Wrapper Array
        int[] primitives = {1, 2, 3, 4, 5};
        Integer[] wrappers = Arrays.stream(primitives)
                                   .boxed()
                                   .toArray(Integer[]::new);
        
        // 4. Wrapper to Primitive Array
        Integer[] wrapperArr = {1, 2, 3, 4, 5};
        int[] primitiveArr = Arrays.stream(wrapperArr)
                                   .mapToInt(i -> i)
                                   .toArray();
        
        System.out.println(list2);
        System.out.println(Arrays.toString(arr2));
    }
}
```

---

### Other Useful Methods

```java
import java.util.*;

public class OtherArrayMethods {
    public static void main(String[] args) {
        
        // 1. toString() - Print array
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(Arrays.toString(arr));
        // [1, 2, 3, 4, 5]
        
        // 2. deepToString() - Multi-dimensional arrays
        int[][] matrix = {{1, 2}, {3, 4}};
        System.out.println(Arrays.deepToString(matrix));
        // [[1, 2], [3, 4]]
        
        // 3. hashCode() - For hashing
        int hash = Arrays.hashCode(arr);
        System.out.println(hash);
        
        // 4. deepHashCode() - Multi-dimensional
        int deepHash = Arrays.deepHashCode(matrix);
        
        // 5. parallelSort() - Parallel sorting (faster for large arrays)
        int[] largeArr = new int[1000000];
        Arrays.parallelSort(largeArr);
        
        // 6. setAll() - Fill with function
        int[] arr2 = new int[5];
        Arrays.setAll(arr2, i -> i * 10);
        System.out.println(Arrays.toString(arr2));
        // [0, 10, 20, 30, 40]
        
        // 7. parallelPrefix() - Prefix sum
        int[] arr3 = {1, 2, 3, 4, 5};
        Arrays.parallelPrefix(arr3, (a, b) -> a + b);
        System.out.println(Arrays.toString(arr3));
        // [1, 3, 6, 10, 15] (cumulative sum)
    }
}
```

---

<a name="multidimensional"></a>
## 4. Multi-dimensional Arrays

### 2D Arrays (Matrix)

```java
import java.util.*;

public class TwoDArray {
    public static void main(String[] args) {
        
        // Declaration and initialization
        int[][] matrix1 = new int[3][4];  // 3 rows, 4 columns
        
        // Initialize with values
        int[][] matrix2 = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12}
        };
        
        // Access elements
        System.out.println(matrix2[0][0]);  // 1 (row 0, col 0)
        System.out.println(matrix2[2][3]);  // 12 (row 2, col 3)
        
        // Dimensions
        System.out.println(matrix2.length);       // 3 (rows)
        System.out.println(matrix2[0].length);    // 4 (columns)
        
        // Traverse 2D array
        for (int i = 0; i < matrix2.length; i++) {
            for (int j = 0; j < matrix2[i].length; j++) {
                System.out.print(matrix2[i][j] + " ");
            }
            System.out.println();
        }
        
        // Enhanced for loop
        for (int[] row : matrix2) {
            for (int val : row) {
                System.out.print(val + " ");
            }
            System.out.println();
        }
        
        // Print 2D array
        System.out.println(Arrays.deepToString(matrix2));
        // [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
    }
}
```

---

### Jagged Arrays (Non-rectangular)

```java
import java.util.*;

public class JaggedArray {
    public static void main(String[] args) {
        
        // Each row can have different lengths
        int[][] jagged = new int[3][];
        jagged[0] = new int[2];      // Row 0: 2 elements
        jagged[1] = new int[4];      // Row 1: 4 elements
        jagged[2] = new int[3];      // Row 2: 3 elements
        
        // Initialize with values
        int[][] jagged2 = {
            {1, 2},
            {3, 4, 5, 6},
            {7, 8, 9}
        };
        
        // Traverse jagged array
        for (int i = 0; i < jagged2.length; i++) {
            for (int j = 0; j < jagged2[i].length; j++) {
                System.out.print(jagged2[i][j] + " ");
            }
            System.out.println();
        }
        
        System.out.println(Arrays.deepToString(jagged2));
        // [[1, 2], [3, 4, 5, 6], [7, 8, 9]]
    }
}
```

---

### Common 2D Array Operations

```java
import java.util.*;

public class MatrixOperations {
    
    // 1. Fill 2D array
    public static void fill2D(int[][] matrix, int value) {
        for (int[] row : matrix) {
            Arrays.fill(row, value);
        }
    }
    
    // 2. Copy 2D array
    public static int[][] copy2D(int[][] original) {
        int[][] copy = new int[original.length][];
        for (int i = 0; i < original.length; i++) {
            copy[i] = Arrays.copyOf(original[i], original[i].length);
        }
        return copy;
    }
    
    // 3. Transpose matrix
    public static int[][] transpose(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] result = new int[cols][rows];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        return result;
    }
    
    // 4. Rotate 90 degrees clockwise
    public static void rotate90(int[][] matrix) {
        int n = matrix.length;
        
        // Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0, right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        System.out.println("Original:");
        System.out.println(Arrays.deepToString(matrix));
        
        int[][] transposed = transpose(matrix);
        System.out.println("\nTransposed:");
        System.out.println(Arrays.deepToString(transposed));
        
        int[][] copy = copy2D(matrix);
        rotate90(copy);
        System.out.println("\nRotated 90°:");
        System.out.println(Arrays.deepToString(copy));
    }
}
```

---

<a name="comparison"></a>
## 5. Array vs ArrayList - Complete Comparison

| Feature | Array | ArrayList |
|---------|-------|-----------|
| **Size** | Fixed (cannot change) | Dynamic (auto-resize) |
| **Declaration** | `int[] arr = new int[5]` | `ArrayList<Integer> list = new ArrayList<>()` |
| **Type** | Primitives & Objects | Objects only (no primitives) |
| **Syntax** | `arr[0] = 10` | `list.set(0, 10)` |
| **Access** | `arr[0]` | `list.get(0)` |
| **Length** | `arr.length` (property) | `list.size()` (method) |
| **Performance** | Faster (no overhead) | Slightly slower |
| **Memory** | Less (no wrapper overhead) | More (wrapper objects) |
| **Methods** | Limited (Arrays class) | Many (add, remove, contains, etc.) |
| **Multidimensional** | `int[][]` | `ArrayList<ArrayList<Integer>>` |
| **Type Safety** | Checked at runtime | Checked at compile time (generics) |

---

### When to Use What?

**Use Array when:**
✅ Size is known and fixed
✅ Need primitives (performance critical)
✅ Working with multi-dimensional data (matrix)
✅ Low-level operations, memory-sensitive
✅ Competitive programming (faster I/O)

**Use ArrayList when:**
✅ Size is unknown or changes frequently
✅ Need add/remove operations
✅ Need built-in methods (contains, indexOf, etc.)
✅ Code readability > performance
✅ Working with Collections API

---

### Conversion Examples

```java
import java.util.*;

public class ArrayListConversion {
    public static void main(String[] args) {
        
        // Array to ArrayList
        Integer[] arr = {1, 2, 3, 4, 5};
        ArrayList<Integer> list1 = new ArrayList<>(Arrays.asList(arr));
        
        // ArrayList to Array
        ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Integer[] arr2 = list2.toArray(new Integer[0]);
        
        // Primitive array to ArrayList (needs boxing)
        int[] primitives = {1, 2, 3, 4, 5};
        ArrayList<Integer> list3 = new ArrayList<>();
        for (int num : primitives) {
            list3.add(num);  // Auto-boxing
        }
        
        // ArrayList to primitive array
        int[] primitives2 = list3.stream()
                                 .mapToInt(i -> i)
                                 .toArray();
        
        System.out.println(list1);
        System.out.println(Arrays.toString(arr2));
    }
}
```

---

<a name="patterns"></a>
## 6. Common Array Patterns

### Pattern 1: Reverse an Array

```java
public class ReverseArray {
    
    // In-place reversal (two pointers)
    public static void reverse(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            // Swap
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        reverse(arr);
        System.out.println(Arrays.toString(arr));
        // [5, 4, 3, 2, 1]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 2: Left Rotate by K positions

```java
public class LeftRotate {
    
    // Helper: Reverse array from start to end
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    // Rotate left by k positions
    public static void rotateLeft(int[] arr, int k) {
        int n = arr.length;
        k = k % n;  // Handle k > n
        
        // Reverse first k elements
        reverse(arr, 0, k - 1);
        // Reverse remaining elements
        reverse(arr, k, n - 1);
        // Reverse entire array
        reverse(arr, 0, n - 1);
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateLeft(arr, 3);
        System.out.println(Arrays.toString(arr));
        // [4, 5, 6, 7, 1, 2, 3]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3: Remove Duplicates (In-place)

```java
public class RemoveDuplicates {
    
    // For SORTED array only
    public static int removeDuplicates(int[] arr) {
        if (arr.length == 0) return 0;
        
        int uniqueIndex = 0;
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] != arr[uniqueIndex]) {
                uniqueIndex++;
                arr[uniqueIndex] = arr[i];
            }
        }
        
        return uniqueIndex + 1;  // New length
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 1, 2, 2, 2, 3, 4, 4, 5};
        int newLength = removeDuplicates(arr);
        
        System.out.println("New length: " + newLength);
        System.out.println(Arrays.toString(Arrays.copyOf(arr, newLength)));
        // [1, 2, 3, 4, 5]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 4: Move Zeros to End

```java
public class MoveZeros {
    
    public static void moveZerosToEnd(int[] arr) {
        int nonZeroIndex = 0;
        
        // Move all non-zero elements to front
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                arr[nonZeroIndex] = arr[i];
                nonZeroIndex++;
            }
        }
        
        // Fill remaining with zeros
        while (nonZeroIndex < arr.length) {
            arr[nonZeroIndex] = 0;
            nonZeroIndex++;
        }
    }
    
    // Alternative: Swap-based approach
    public static void moveZerosSwap(int[] arr) {
        int nonZeroIndex = 0;
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                // Swap
                int temp = arr[nonZeroIndex];
                arr[nonZeroIndex] = arr[i];
                arr[i] = temp;
                nonZeroIndex++;
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {0, 1, 0, 3, 12, 0, 5};
        moveZerosToEnd(arr);
        System.out.println(Arrays.toString(arr));
        // [1, 3, 12, 5, 0, 0, 0]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 5: Find Second Largest

```java
public class SecondLargest {
    
    public static int findSecondLargest(int[] arr) {
        if (arr.length < 2) return -1;
        
        int largest = Integer.MIN_VALUE;
        int secondLargest = Integer.MIN_VALUE;
        
        for (int num : arr) {
            if (num > largest) {
                secondLargest = largest;
                largest = num;
            } else if (num > secondLargest && num != largest) {
                secondLargest = num;
            }
        }
        
        return secondLargest == Integer.MIN_VALUE ? -1 : secondLargest;
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 35, 1, 10, 34, 1};
        System.out.println(findSecondLargest(arr));  // 34
        
        int[] arr2 = {10, 10, 10};
        System.out.println(findSecondLargest(arr2));  // -1
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="pitfalls"></a>
## 7. Common Pitfalls & Solutions

### Pitfall 1: Comparing Arrays with ==

```java
// ❌ WRONG
int[] arr1 = {1, 2, 3};
int[] arr2 = {1, 2, 3};
System.out.println(arr1 == arr2);  // false (compares references!)

// ✅ CORRECT
System.out.println(Arrays.equals(arr1, arr2));  // true
```

---

### Pitfall 2: Length vs length()

```java
int[] arr = new int[5];
String str = "hello";

// ❌ WRONG
// System.out.println(arr.length());  // ERROR! length is property
// System.out.println(str.length);    // ERROR! length() is method

// ✅ CORRECT
System.out.println(arr.length);    // 5 (property, no parentheses)
System.out.println(str.length());  // 5 (method, with parentheses)
```

---

### Pitfall 3: ArrayIndexOutOfBoundsException

```java
int[] arr = {10, 20, 30};

// ❌ Common mistakes
// arr[3] = 40;  // ERROR! Index 3 doesn't exist (0-2)
// arr[-1] = 5;  // ERROR! Negative index

// ✅ CORRECT - Always check bounds
if (index >= 0 && index < arr.length) {
    arr[index] = value;
}

// Or use try-catch (not recommended for flow control)
try {
    arr[index] = value;
} catch (ArrayIndexOutOfBoundsException e) {
    // Handle error
}
```

---

### Pitfall 4: Modifying Array During Enhanced For Loop

```java
int[] arr = {1, 2, 3, 4, 5};

// ❌ WRONG - Changes don't reflect in array
for (int num : arr) {
    num = num * 2;  // Only changes local variable!
}
System.out.println(Arrays.toString(arr));  // [1, 2, 3, 4, 5] (unchanged)

// ✅ CORRECT - Use index-based loop
for (int i = 0; i < arr.length; i++) {
    arr[i] = arr[i] * 2;
}
System.out.println(Arrays.toString(arr));  // [2, 4, 6, 8, 10]
```

---

### Pitfall 5: Arrays.asList() Returns Fixed-Size List

```java
Integer[] arr = {1, 2, 3};
List<Integer> list = Arrays.asList(arr);

// ❌ WRONG - Cannot add/remove
// list.add(4);     // ERROR! UnsupportedOperationException
// list.remove(0);  // ERROR! UnsupportedOperationException

// ✅ CORRECT - Create new ArrayList
List<Integer> modifiableList = new ArrayList<>(Arrays.asList(arr));
modifiableList.add(4);     // OK!
modifiableList.remove(0);  // OK!
```

---

### Pitfall 6: Integer Overflow in Sum

```java
int[] arr = {Integer.MAX_VALUE, 1};

// ❌ WRONG - Overflow!
int sum = 0;
for (int num : arr) {
    sum += num;  // Overflow! Becomes negative
}
System.out.println(sum);  // Negative number

// ✅ CORRECT - Use long
long sumLong = 0;
for (int num : arr) {
    sumLong += num;
}
System.out.println(sumLong);  // Correct large positive number
```

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the difference between array and ArrayList?

**Answer:** See [comparison table above](#comparison). Key points:
- Array: Fixed size, primitives allowed, faster
- ArrayList: Dynamic size, objects only, more methods

---

### Q2: Can array size be changed after creation?

**Answer:** No! Array size is fixed. To resize:
```java
int[] newArr = Arrays.copyOf(oldArr, newSize);
```

---

### Q3: What's the default value of array elements?

**Answer:**
- **int/byte/short/long:** 0
- **float/double:** 0.0
- **boolean:** false
- **char:** '\u0000' (null character)
- **Object:** null

---

### Q4: How to copy an array?

**Answer:** Multiple ways:
```java
// Best: Arrays.copyOf()
int[] copy = Arrays.copyOf(original, original.length);

// Fast: System.arraycopy()
System.arraycopy(src, 0, dest, 0, length);

// Quick: clone()
int[] copy = original.clone();
```

---

### Q5: What's the time complexity of Arrays.sort()?

**Answer:** **O(n log n)**
- Primitives: Dual-Pivot Quicksort
- Objects: Timsort (stable)

---

### Q6: Can we use binary search on unsorted array?

**Answer:** **No!** Binary search requires sorted array. Otherwise, use linear search O(n).

---

### Q7: How to reverse an array in-place?

**Answer:** Two pointers from both ends:
```java
int left = 0, right = arr.length - 1;
while (left < right) {
    swap(arr, left++, right--);
}
```

---

### Q8: What's jagged array?

**Answer:** Array where each row can have different lengths:
```java
int[][] jagged = {
    {1, 2},
    {3, 4, 5, 6},
    {7, 8, 9}
};
```

---

### Q9: How to check if two arrays are equal?

**Answer:**
```java
// 1D array
Arrays.equals(arr1, arr2);

// Multi-dimensional array
Arrays.deepEquals(matrix1, matrix2);
```

---

### Q10: Can array hold different data types?

**Answer:** No for primitives. Yes for Objects using `Object[]`:
```java
Object[] mixed = {1, "hello", 3.14, true};  // Valid
```

---

### Q11: What happens if we access arr[-1]?

**Answer:** **ArrayIndexOutOfBoundsException** at runtime.

---

### Q12: How to find duplicates in array?

**Answer:**
```java
// Using HashSet
Set<Integer> seen = new HashSet<>();
Set<Integer> duplicates = new HashSet<>();

for (int num : arr) {
    if (!seen.add(num)) {
        duplicates.add(num);
    }
}
```

---

### Q13: Difference between arr.length and list.size()?

**Answer:**
- `arr.length`: **Property** (no parentheses)
- `list.size()`: **Method** (with parentheses)

---

### Q14: Can we sort primitive array in descending order directly?

**Answer:** **No!** Must use wrapper class:
```java
// ❌ Doesn't work
int[] arr = {5, 2, 8};
// Arrays.sort(arr, Collections.reverseOrder());  // ERROR

// ✅ Use Integer[]
Integer[] arr = {5, 2, 8};
Arrays.sort(arr, Collections.reverseOrder());
```

---

### Q15: How to initialize all elements to specific value?

**Answer:**
```java
Arrays.fill(arr, value);
```

---

### Q16: What's the difference between shallow and deep copy?

**Answer:**
- **Shallow copy:** Copies references (2D array rows point to same objects)
- **Deep copy:** Copies actual values (new objects created)

```java
// Shallow
int[][] shallow = matrix.clone();

// Deep
int[][] deep = new int[matrix.length][];
for (int i = 0; i < matrix.length; i++) {
    deep[i] = matrix[i].clone();
}
```

---

### Q17: Can we use foreach loop to modify array?

**Answer:** **No!** Use index-based loop:
```java
// ❌ Doesn't modify array
for (int num : arr) {
    num = num * 2;  // Only local variable
}

// ✅ Modifies array
for (int i = 0; i < arr.length; i++) {
    arr[i] = arr[i] * 2;
}
```

---

### Q18: What's the maximum size of array in Java?

**Answer:** **Integer.MAX_VALUE - 5** ≈ 2.1 billion elements (depends on JVM heap size)

---

### Q19: How to remove element from array?

**Answer:** Arrays are fixed size. Create new array:
```java
// Remove element at index k
int[] newArr = new int[arr.length - 1];
System.arraycopy(arr, 0, newArr, 0, k);
System.arraycopy(arr, k + 1, newArr, k, arr.length - k - 1);

// Or use ArrayList
```

---

### Q20: What's the difference between int[] and int arr[]?

**Answer:** Both are valid, but `int[]` is preferred (Java style):
```java
int[] arr1 = new int[5];  // ✅ Preferred
int arr2[] = new int[5];  // ⚠️ C-style, valid but avoid
```

---

<a name="practice-problems"></a>
## 9. Practice Problems with Solutions

### Problem 1: Two Sum

**Problem:** Find two numbers in array that add up to target.

**Example:** `[2, 7, 11, 15], target = 9` → `[0, 1]`

```java
import java.util.*;

public class TwoSum {
    
    // Using HashMap - O(n) time
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            
            map.put(nums[i], i);
        }
        
        return new int[]{-1, -1};  // Not found
    }
    
    public static void main(String[] args) {
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        
        int[] result = twoSum(nums, target);
        System.out.println(Arrays.toString(result));  // [0, 1]
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 2: Best Time to Buy and Sell Stock

**Problem:** Find maximum profit from one buy and one sell.

**Example:** `[7, 1, 5, 3, 6, 4]` → `5` (buy at 1, sell at 6)

```java
public class BestTimeToBuySell {
    
    public static int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            if (price < minPrice) {
                minPrice = price;
            } else {
                maxProfit = Math.max(maxProfit, price - minPrice);
            }
        }
        
        return maxProfit;
    }
    
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(maxProfit(prices));  // 5
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 3: Contains Duplicate

**Problem:** Check if array contains any duplicates.

**Example:** `[1, 2, 3, 1]` → `true`

```java
import java.util.*;

public class ContainsDuplicate {
    
    // Method 1: HashSet - O(n) time, O(n) space
    public static boolean containsDuplicate(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        
        for (int num : nums) {
            if (!seen.add(num)) {
                return true;
            }
        }
        
        return false;
    }
    
    // Method 2: Sorting - O(n log n) time, O(1) space
    public static boolean containsDuplicateSort(int[] nums) {
        Arrays.sort(nums);
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                return true;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 1};
        System.out.println(containsDuplicate(nums));  // true
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 4: Product of Array Except Self

**Problem:** Return array where each element is product of all others (without division).

**Example:** `[1, 2, 3, 4]` → `[24, 12, 8, 6]`

```java
import java.util.*;

public class ProductExceptSelf {
    
    public static int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        // Left products
        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }
        
        // Right products
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] = result[i] * rightProduct;
            rightProduct *= nums[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4};
        int[] result = productExceptSelf(nums);
        System.out.println(Arrays.toString(result));  // [24, 12, 8, 6]
    }
}
```

**Time:** O(n), **Space:** O(1) (excluding output)

---

### Problem 5: Maximum Subarray (Kadane's Algorithm)

**Problem:** Find contiguous subarray with maximum sum.

**Example:** `[-2, 1, -3, 4, -1, 2, 1, -5, 4]` → `6` ([4, -1, 2, 1])

```java
public class MaximumSubarray {
    
    public static int maxSubArray(int[] nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubArray(nums));  // 6
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 6: Rotate Array

**Problem:** Rotate array to the right by k steps.

**Example:** `[1, 2, 3, 4, 5, 6, 7], k=3` → `[5, 6, 7, 1, 2, 3, 4]`

```java
import java.util.*;

public class RotateArray {
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;  // Handle k > n
        
        // Reverse entire array
        reverse(nums, 0, n - 1);
        // Reverse first k elements
        reverse(nums, 0, k - 1);
        // Reverse remaining elements
        reverse(nums, k, n - 1);
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6, 7};
        rotate(nums, 3);
        System.out.println(Arrays.toString(nums));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 7: Find Missing Number

**Problem:** Given array containing n distinct numbers in range [0, n], find missing number.

**Example:** `[3, 0, 1]` → `2`

```java
public class MissingNumber {
    
    // Method 1: XOR (most elegant)
    public static int missingNumber(int[] nums) {
        int xor = nums.length;
        
        for (int i = 0; i < nums.length; i++) {
            xor ^= i ^ nums[i];
        }
        
        return xor;
    }
    
    // Method 2: Sum formula
    public static int missingNumberSum(int[] nums) {
        int n = nums.length;
        int expectedSum = n * (n + 1) / 2;
        int actualSum = 0;
        
        for (int num : nums) {
            actualSum += num;
        }
        
        return expectedSum - actualSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, 0, 1};
        System.out.println(missingNumber(nums));     // 2
        System.out.println(missingNumberSum(nums));  // 2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 8: Merge Sorted Arrays

**Problem:** Merge two sorted arrays into first array (has enough space).

**Example:** `nums1 = [1,2,3,0,0,0], m=3, nums2 = [2,5,6], n=3` → `[1,2,2,3,5,6]`

```java
import java.util.*;

public class MergeSortedArrays {
    
    public static void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;      // Last element in nums1
        int j = n - 1;      // Last element in nums2
        int k = m + n - 1;  // Last position in merged array
        
        // Merge from end to beginning
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
        
        // Copy remaining elements from nums2
        while (j >= 0) {
            nums1[k--] = nums2[j--];
        }
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 2, 3, 0, 0, 0};
        int[] nums2 = {2, 5, 6};
        
        merge(nums1, 3, nums2, 3);
        System.out.println(Arrays.toString(nums1));  // [1, 2, 2, 3, 5, 6]
    }
}
```

**Time:** O(m + n), **Space:** O(1)

---

### Problem 9: Majority Element

**Problem:** Find element that appears more than n/2 times.

**Example:** `[3, 2, 3]` → `3`

```java
public class MajorityElement {
    
    // Boyer-Moore Voting Algorithm
    public static int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count = 1;
        
        // Find candidate
        for (int i = 1; i < nums.length; i++) {
            if (count == 0) {
                candidate = nums[i];
                count = 1;
            } else if (nums[i] == candidate) {
                count++;
            } else {
                count--;
            }
        }
        
        return candidate;
    }
    
    public static void main(String[] args) {
        int[] nums = {2, 2, 1, 1, 1, 2, 2};
        System.out.println(majorityElement(nums));  // 2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 10: Move Zeroes

**Problem:** Move all zeros to end while maintaining order of non-zeros.

**Example:** `[0, 1, 0, 3, 12]` → `[1, 3, 12, 0, 0]`

```java
import java.util.*;

public class MoveZeroes {
    
    public static void moveZeroes(int[] nums) {
        int nonZeroIndex = 0;
        
        // Move non-zeros to front
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[nonZeroIndex++] = nums[i];
            }
        }
        
        // Fill rest with zeros
        while (nonZeroIndex < nums.length) {
            nums[nonZeroIndex++] = 0;
        }
    }
    
    public static void main(String[] args) {
        int[] nums = {0, 1, 0, 3, 12};
        moveZeroes(nums);
        System.out.println(Arrays.toString(nums));  // [1, 3, 12, 0, 0]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

## Key Takeaways

✅ **Arrays are fixed size** - Use ArrayList for dynamic sizing  
✅ **O(1) access time** - Random access by index  
✅ **arr.length is property** - No parentheses (unlike String.length())  
✅ **Use Arrays class** - sort(), fill(), copyOf(), equals(), etc.  
✅ **Two pointers pattern** - For reversal, rotation, in-place operations  
✅ **Enhanced for loop** - Read-only; use index loop to modify  
✅ **Watch for overflow** - Use long for sum operations  
✅ **Binary search requires sorted array** - O(log n) vs O(n)  
✅ **Deep methods for 2D arrays** - deepEquals(), deepToString()  
✅ **Prefer Array for performance** - ArrayList for flexibility  

---

[← Back: Comparators](../02-Java-Basics/Comparators.md) | [Next: Two Pointer Technique →](./3.2-Two-Pointer-Technique.md)
