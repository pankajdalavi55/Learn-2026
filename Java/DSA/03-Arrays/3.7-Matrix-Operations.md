# Matrix Operations - Complete Guide

## Why Matrix Operations?

**Essential for 2D array problems in interviews!**

- **Appears in:** Google, Amazon, Microsoft, Facebook (top interview topic)
- **Use cases:** Image processing, graphs, dynamic programming, game boards
- **Foundation for:** Graph algorithms, DP on grids, pathfinding
- **Common patterns:** Spiral traversal, boundary traversal, diagonal operations

**Master matrices = Solve 30+ LeetCode problems!**

---

## Table of Contents

1. [Matrix Basics](#basics)
2. [Traversal Patterns](#traversal)
3. [Matrix Transformations](#transformations)
4. [Search Operations](#search)
5. [Boundary & Diagonal Operations](#boundary-diagonal)
6. [Advanced Patterns](#advanced)
7. [Common Pitfalls](#pitfalls)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)

---

<a name="basics"></a>
## 1. Matrix Basics

### Declaration and Initialization

```java
public class MatrixBasics {
    
    public static void main(String[] args) {
        // Method 1: Declaration and initialization
        int[][] matrix1 = new int[3][4];  // 3 rows, 4 columns
        
        // Method 2: Direct initialization
        int[][] matrix2 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        // Method 3: Jagged array (different column sizes)
        int[][] jagged = new int[3][];
        jagged[0] = new int[2];  // Row 0 has 2 columns
        jagged[1] = new int[4];  // Row 1 has 4 columns
        jagged[2] = new int[3];  // Row 2 has 3 columns
        
        // Get dimensions
        int rows = matrix2.length;           // 3
        int cols = matrix2[0].length;        // 3
        
        System.out.println("Rows: " + rows + ", Cols: " + cols);
    }
}
```

---

### Filling Matrix

```java
public class FillMatrix {
    
    // Fill with specific value
    public static void fillValue(int[][] matrix, int value) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                matrix[i][j] = value;
            }
        }
    }
    
    // Fill with Arrays.fill()
    public static void fillWithArrays(int[][] matrix, int value) {
        for (int[] row : matrix) {
            Arrays.fill(row, value);
        }
    }
    
    // Fill with sequential numbers
    public static void fillSequential(int[][] matrix) {
        int num = 1;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                matrix[i][j] = num++;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = new int[3][3];
        fillSequential(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

---

### Printing Matrix

```java
public class PrintMatrix {
    
    public static void print(int[][] matrix) {
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
    
    public static void printFormatted(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.printf("%4d", matrix[i][j]);
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        print(matrix);
        System.out.println();
        printFormatted(matrix);
    }
}
```

---

<a name="traversal"></a>
## 2. Traversal Patterns

### Row-wise Traversal

```java
public class RowWiseTraversal {
    
    public static void traverseRowWise(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        traverseRowWise(matrix);  // 1 2 3 4 5 6 7 8 9
    }
}
```

---

### Column-wise Traversal

```java
public class ColumnWiseTraversal {
    
    public static void traverseColumnWise(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        for (int j = 0; j < cols; j++) {
            for (int i = 0; i < rows; i++) {
                System.out.print(matrix[i][j] + " ");
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        traverseColumnWise(matrix);  // 1 4 7 2 5 8 3 6 9
    }
}
```

---

### Spiral Traversal ⭐ (Very Common!)

**Pattern:** Traverse in spiral order (clockwise).

```
Matrix:           Spiral Order:
1  2  3           1 → 2 → 3
4  5  6              ↓     ↓
7  8  9           4 → 5   6
                  ↓       ↓
                  7 → 8 ← 9

Output: 1, 2, 3, 6, 9, 8, 7, 4, 5
```

```java
public class SpiralTraversal {
    
    public static List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        
        if (matrix == null || matrix.length == 0) {
            return result;
        }
        
        int top = 0;
        int bottom = matrix.length - 1;
        int left = 0;
        int right = matrix[0].length - 1;
        
        while (top <= bottom && left <= right) {
            // Traverse right
            for (int j = left; j <= right; j++) {
                result.add(matrix[top][j]);
            }
            top++;
            
            // Traverse down
            for (int i = top; i <= bottom; i++) {
                result.add(matrix[i][right]);
            }
            right--;
            
            // Traverse left (if still rows remaining)
            if (top <= bottom) {
                for (int j = right; j >= left; j--) {
                    result.add(matrix[bottom][j]);
                }
                bottom--;
            }
            
            // Traverse up (if still columns remaining)
            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    result.add(matrix[i][left]);
                }
                left++;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        System.out.println(spiralOrder(matrix));
        // [1, 2, 3, 6, 9, 8, 7, 4, 5]
    }
}
```

**Time:** O(m × n), **Space:** O(1) excluding result

---

### Diagonal Traversal

**Main Diagonal (top-left to bottom-right):**

```java
public class DiagonalTraversal {
    
    // Main diagonal (i == j)
    public static void mainDiagonal(int[][] matrix) {
        int n = matrix.length;
        
        for (int i = 0; i < n; i++) {
            System.out.print(matrix[i][i] + " ");
        }
    }
    
    // Anti-diagonal (i + j == n - 1)
    public static void antiDiagonal(int[][] matrix) {
        int n = matrix.length;
        
        for (int i = 0; i < n; i++) {
            System.out.print(matrix[i][n - 1 - i] + " ");
        }
    }
    
    // All diagonals (top-left to bottom-right)
    public static void allDiagonals(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Diagonals starting from first row
        for (int col = 0; col < cols; col++) {
            int i = 0, j = col;
            while (i < rows && j < cols) {
                System.out.print(matrix[i][j] + " ");
                i++;
                j++;
            }
            System.out.println();
        }
        
        // Diagonals starting from first column (skip [0][0])
        for (int row = 1; row < rows; row++) {
            int i = row, j = 0;
            while (i < rows && j < cols) {
                System.out.print(matrix[i][j] + " ");
                i++;
                j++;
            }
            System.out.println();
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        System.out.print("Main diagonal: ");
        mainDiagonal(matrix);    // 1 5 9
        System.out.println();
        
        System.out.print("Anti-diagonal: ");
        antiDiagonal(matrix);    // 3 5 7
        System.out.println();
    }
}
```

---

### Zigzag Traversal

**Pattern:** Traverse in zigzag (alternating left-to-right and right-to-left).

```java
public class ZigzagTraversal {
    
    public static void zigzag(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        for (int i = 0; i < rows; i++) {
            if (i % 2 == 0) {
                // Left to right
                for (int j = 0; j < cols; j++) {
                    System.out.print(matrix[i][j] + " ");
                }
            } else {
                // Right to left
                for (int j = cols - 1; j >= 0; j--) {
                    System.out.print(matrix[i][j] + " ");
                }
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        zigzag(matrix);  // 1 2 3 6 5 4 7 8 9
    }
}
```

---

<a name="transformations"></a>
## 3. Matrix Transformations

### Transpose

**Transpose:** Swap rows and columns (matrix[i][j] ↔ matrix[j][i]).

```java
public class Transpose {
    
    // For square matrix (in-place)
    public static void transposeSquare(int[][] matrix) {
        int n = matrix.length;
        
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
    
    // For rectangular matrix (new matrix)
    public static int[][] transposeRectangular(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        int[][] result = new int[cols][rows];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                result[j][i] = matrix[i][j];
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        transposeSquare(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(n²), **Space:** O(1) for square, O(m×n) for rectangular

---

### Rotation

**90° Clockwise = Transpose + Reverse each row**

```java
public class MatrixRotation {
    
    public static void rotate90Clockwise(int[][] matrix) {
        int n = matrix.length;
        
        // Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Reverse each row
        for (int i = 0; i < n; i++) {
            reverse(matrix[i]);
        }
    }
    
    private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        rotate90Clockwise(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
        // Output:
        // [7, 4, 1]
        // [8, 5, 2]
        // [9, 6, 3]
    }
}
```

---

### Flip Horizontally / Vertically

```java
public class FlipMatrix {
    
    // Flip horizontally (reverse each row)
    public static void flipHorizontal(int[][] matrix) {
        for (int[] row : matrix) {
            reverse(row);
        }
    }
    
    // Flip vertically (reverse row order)
    public static void flipVertical(int[][] matrix) {
        int top = 0;
        int bottom = matrix.length - 1;
        
        while (top < bottom) {
            int[] temp = matrix[top];
            matrix[top] = matrix[bottom];
            matrix[bottom] = temp;
            top++;
            bottom--;
        }
    }
    
    private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix1 = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        flipHorizontal(matrix1);
        System.out.println("Horizontal flip:");
        for (int[] row : matrix1) {
            System.out.println(Arrays.toString(row));
        }
        // [3, 2, 1]
        // [6, 5, 4]
        // [9, 8, 7]
    }
}
```

---

<a name="search"></a>
## 4. Search Operations

### Linear Search

```java
public class MatrixSearch {
    
    public static boolean linearSearch(int[][] matrix, int target) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == target) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        System.out.println(linearSearch(matrix, 5));  // true
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Search in Row-wise and Column-wise Sorted Matrix ⭐

**Pattern:** Start from top-right or bottom-left!

```java
public class SearchSortedMatrix {
    
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        
        int row = 0;
        int col = matrix[0].length - 1;
        
        while (row < matrix.length && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] > target) {
                col--;  // Move left
            } else {
                row++;  // Move down
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 4, 7, 11},
            {2, 5, 8, 12},
            {3, 6, 9, 16},
            {10, 13, 14, 17}
        };
        
        System.out.println(searchMatrix(matrix, 5));   // true
        System.out.println(searchMatrix(matrix, 20));  // false
    }
}
```

**Time:** O(m + n), **Space:** O(1)

**Why start from top-right?**
- If current > target → move left
- If current < target → move down
- Each comparison eliminates one row or column!

---

### Search in Fully Sorted Matrix

**Pattern:** Treat as 1D sorted array + binary search!

```java
public class SearchFullySorted {
    
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        int left = 0;
        int right = rows * cols - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int midValue = matrix[mid / cols][mid % cols];
            
            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 3, 5, 7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        
        System.out.println(searchMatrix(matrix, 3));   // true
        System.out.println(searchMatrix(matrix, 13));  // false
    }
}
```

**Time:** O(log(m × n)), **Space:** O(1)

**Mapping:** 
- `row = mid / cols`
- `col = mid % cols`

---

<a name="boundary-diagonal"></a>
## 5. Boundary & Diagonal Operations

### Boundary Traversal

```java
public class BoundaryTraversal {
    
    public static List<Integer> boundaryTraversal(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        if (rows == 1) {
            for (int j = 0; j < cols; j++) {
                result.add(matrix[0][j]);
            }
            return result;
        }
        
        if (cols == 1) {
            for (int i = 0; i < rows; i++) {
                result.add(matrix[i][0]);
            }
            return result;
        }
        
        // Top row
        for (int j = 0; j < cols; j++) {
            result.add(matrix[0][j]);
        }
        
        // Right column (skip top corner)
        for (int i = 1; i < rows; i++) {
            result.add(matrix[i][cols - 1]);
        }
        
        // Bottom row (skip right corner)
        for (int j = cols - 2; j >= 0; j--) {
            result.add(matrix[rows - 1][j]);
        }
        
        // Left column (skip both corners)
        for (int i = rows - 2; i > 0; i--) {
            result.add(matrix[i][0]);
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12},
            {13, 14, 15, 16}
        };
        
        System.out.println(boundaryTraversal(matrix));
        // [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5]
    }
}
```

---

### Set Matrix Zeroes ⭐

**Problem:** If element is 0, set entire row and column to 0.

```java
public class SetMatrixZeroes {
    
    // Method 1: O(m + n) space
    public static void setZeroesSpace(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        boolean[] zeroRows = new boolean[rows];
        boolean[] zeroCols = new boolean[cols];
        
        // Mark rows and columns
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    zeroRows[i] = true;
                    zeroCols[j] = true;
                }
            }
        }
        
        // Set zeroes
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (zeroRows[i] || zeroCols[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
    
    // Method 2: O(1) space (use first row/column as markers)
    public static void setZeroesConstant(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        boolean firstRowZero = false;
        boolean firstColZero = false;
        
        // Check if first row has zero
        for (int j = 0; j < cols; j++) {
            if (matrix[0][j] == 0) {
                firstRowZero = true;
                break;
            }
        }
        
        // Check if first column has zero
        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) {
                firstColZero = true;
                break;
            }
        }
        
        // Use first row and column as markers
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        // Set zeroes based on markers
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        // Set first row if needed
        if (firstRowZero) {
            for (int j = 0; j < cols; j++) {
                matrix[0][j] = 0;
            }
        }
        
        // Set first column if needed
        if (firstColZero) {
            for (int i = 0; i < rows; i++) {
                matrix[i][0] = 0;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 1, 1},
            {1, 0, 1},
            {1, 1, 1}
        };
        
        setZeroesConstant(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
        // [1, 0, 1]
        // [0, 0, 0]
        // [1, 0, 1]
    }
}
```

**Time:** O(m × n), **Space:** O(1) for constant space method

---

<a name="advanced"></a>
## 6. Advanced Patterns

### Pattern 1: Valid Sudoku

```java
public class ValidSudoku {
    
    public static boolean isValidSudoku(char[][] board) {
        Set<String> seen = new HashSet<>();
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char current = board[i][j];
                
                if (current != '.') {
                    // Check row, column, and 3x3 box
                    if (!seen.add(current + " in row " + i) ||
                        !seen.add(current + " in col " + j) ||
                        !seen.add(current + " in box " + i/3 + "-" + j/3)) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        char[][] board = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        
        System.out.println(isValidSudoku(board));  // true
    }
}
```

**Time:** O(1) - fixed 9×9, **Space:** O(1)

---

### Pattern 2: Flood Fill

```java
public class FloodFill {
    
    public static int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int originalColor = image[sr][sc];
        
        if (originalColor == newColor) {
            return image;
        }
        
        dfs(image, sr, sc, originalColor, newColor);
        return image;
    }
    
    private static void dfs(int[][] image, int r, int c, int originalColor, int newColor) {
        if (r < 0 || r >= image.length || c < 0 || c >= image[0].length) {
            return;
        }
        
        if (image[r][c] != originalColor) {
            return;
        }
        
        image[r][c] = newColor;
        
        // 4-directional
        dfs(image, r + 1, c, originalColor, newColor);
        dfs(image, r - 1, c, originalColor, newColor);
        dfs(image, r, c + 1, originalColor, newColor);
        dfs(image, r, c - 1, originalColor, newColor);
    }
    
    public static void main(String[] args) {
        int[][] image = {
            {1, 1, 1},
            {1, 1, 0},
            {1, 0, 1}
        };
        
        int[][] result = floodFill(image, 1, 1, 2);
        
        for (int[] row : result) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(m × n), **Space:** O(m × n) for recursion

---

### Pattern 3: Number of Islands

```java
public class NumberOfIslands {
    
    public static int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }
        
        int count = 0;
        
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        
        return count;
    }
    
    private static void dfs(char[][] grid, int r, int c) {
        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == '0') {
            return;
        }
        
        grid[r][c] = '0';  // Mark as visited
        
        dfs(grid, r + 1, c);
        dfs(grid, r - 1, c);
        dfs(grid, r, c + 1);
        dfs(grid, r, c - 1);
    }
    
    public static void main(String[] args) {
        char[][] grid = {
            {'1', '1', '0', '0', '0'},
            {'1', '1', '0', '0', '0'},
            {'0', '0', '1', '0', '0'},
            {'0', '0', '0', '1', '1'}
        };
        
        System.out.println(numIslands(grid));  // 3
    }
}
```

**Time:** O(m × n), **Space:** O(m × n)

---

### Pattern 4: Maximal Rectangle

```java
public class MaximalRectangle {
    
    public static int maximalRectangle(char[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return 0;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[] heights = new int[cols];
        int maxArea = 0;
        
        for (int i = 0; i < rows; i++) {
            // Update heights
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == '1') {
                    heights[j]++;
                } else {
                    heights[j] = 0;
                }
            }
            
            // Find max rectangle in histogram
            maxArea = Math.max(maxArea, largestRectangleArea(heights));
        }
        
        return maxArea;
    }
    
    private static int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int index = 0;
        
        while (index < heights.length) {
            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {
                stack.push(index++);
            } else {
                int top = stack.pop();
                int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
                maxArea = Math.max(maxArea, area);
            }
        }
        
        while (!stack.isEmpty()) {
            int top = stack.pop();
            int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
            maxArea = Math.max(maxArea, area);
        }
        
        return maxArea;
    }
    
    public static void main(String[] args) {
        char[][] matrix = {
            {'1', '0', '1', '0', '0'},
            {'1', '0', '1', '1', '1'},
            {'1', '1', '1', '1', '1'},
            {'1', '0', '0', '1', '0'}
        };
        
        System.out.println(maximalRectangle(matrix));  // 6
    }
}
```

**Time:** O(m × n), **Space:** O(n)

---

<a name="pitfalls"></a>
## 7. Common Pitfalls

### Pitfall 1: Accessing Invalid Indices

```java
// ❌ WRONG - No bounds check
int[][] matrix = new int[3][4];
int value = matrix[5][2];  // ArrayIndexOutOfBoundsException!

// ✅ CORRECT - Always check bounds
if (i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length) {
    int value = matrix[i][j];
}
```

---

### Pitfall 2: Jagged Array Assumption

```java
// ❌ WRONG - Assumes all rows same length
int[][] jagged = {{1, 2}, {3, 4, 5}, {6}};
int cols = jagged[0].length;  // 2
int value = jagged[1][2];     // Works
int wrong = jagged[2][1];     // Exception! Row 2 has only 1 element

// ✅ CORRECT - Check each row
for (int i = 0; i < jagged.length; i++) {
    for (int j = 0; j < jagged[i].length; j++) {
        // Safe access
    }
}
```

---

### Pitfall 3: Shallow Copy

```java
// ❌ WRONG - Shallow copy
int[][] original = {{1, 2}, {3, 4}};
int[][] copy = original;  // Same reference!
copy[0][0] = 99;
System.out.println(original[0][0]);  // 99 (modified!)

// ✅ CORRECT - Deep copy
int[][] deepCopy = new int[original.length][];
for (int i = 0; i < original.length; i++) {
    deepCopy[i] = original[i].clone();
}
```

---

### Pitfall 4: Empty Matrix Check

```java
// ❌ WRONG - No null/empty check
int[][] matrix = null;
int rows = matrix.length;  // NullPointerException!

int[][] empty = {};
int cols = empty[0].length;  // ArrayIndexOutOfBoundsException!

// ✅ CORRECT - Check first
if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
    return;  // Handle edge case
}
```

---

### Pitfall 5: Modifying During Iteration

```java
// ❌ WRONG - Setting zeroes while iterating
for (int i = 0; i < matrix.length; i++) {
    for (int j = 0; j < matrix[0].length; j++) {
        if (matrix[i][j] == 0) {
            setRowColZero(matrix, i, j);  // Affects future iterations!
        }
    }
}

// ✅ CORRECT - Mark first, then modify
boolean[] zeroRows = new boolean[rows];
boolean[] zeroCols = new boolean[cols];
// First pass: mark
// Second pass: set zeroes
```

---

<a name="interview-questions"></a>
## 8. Top 20 Interview Questions

### Q1: What's the time complexity of spiral traversal?

**Answer:** **O(m × n)** - Visit each element exactly once.  
Space: O(1) excluding result.

---

### Q2: How to search in row-column sorted matrix efficiently?

**Answer:** **Start from top-right (or bottom-left):**
- Current > target → move left
- Current < target → move down
- Time: O(m + n)

---

### Q3: How to rotate matrix 90° in-place?

**Answer:**
1. **Transpose:** Swap matrix[i][j] ↔ matrix[j][i]
2. **Reverse each row**

Time: O(n²), Space: O(1)

---

### Q4: What's the difference between row-major and column-major?

**Answer:**
- **Row-major:** Store row by row in memory (Java, C, C++)
- **Column-major:** Store column by column (Fortran, MATLAB)

Java uses row-major order.

---

### Q5: How to handle jagged arrays?

**Answer:** Check each row's length individually:
```java
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        // arr[i].length varies!
    }
}
```

---

### Q6: Can you do spiral traversal recursively?

**Answer:** **Yes!** Process outer layer, then recurse on inner matrix.

But iterative with four boundaries is clearer.

---

### Q7: How to create deep copy of 2D array?

**Answer:**
```java
int[][] deepCopy = new int[original.length][];
for (int i = 0; i < original.length; i++) {
    deepCopy[i] = original[i].clone();
}
```

---

### Q8: What's the space complexity of DFS on matrix?

**Answer:** **O(m × n)** in worst case - entire matrix could be one connected component.

Recursion depth can be m × n.

---

### Q9: How to optimize set matrix zeroes to O(1) space?

**Answer:** Use first row and column as markers:
1. Record if first row/col needs zeroes
2. Use matrix[i][0] and matrix[0][j] as flags
3. Set zeroes based on flags
4. Handle first row/col separately

---

### Q10: How to traverse all diagonals?

**Answer:** Two loops:
1. Start from each column in first row
2. Start from each row in first column (skip [0][0])

Move i++, j++ for each diagonal.

---

### Q11: What's the best way to fill matrix?

**Answer:** For simple fill:
```java
for (int[] row : matrix) {
    Arrays.fill(row, value);
}
```

---

### Q12: Can binary search work on 2D matrix?

**Answer:** **Yes!** If fully sorted (each row's first > previous row's last):
- Treat as 1D array of size m × n
- row = mid / cols, col = mid % cols
- Time: O(log(m × n))

---

### Q13: How to detect cycle in matrix (graph)?

**Answer:** Use DFS with three states:
- **White (0):** Unvisited
- **Gray (1):** Visiting
- **Black (2):** Visited

Cycle if we reach gray node.

---

### Q14: What's difference between 4-directional and 8-directional?

**Answer:**
- **4-directional:** Up, down, left, right (common)
- **8-directional:** + 4 diagonals (for some problems)

---

### Q15: How to avoid stack overflow in DFS?

**Answer:**
1. Use iterative DFS with explicit stack
2. Increase stack size: `-Xss` JVM option
3. Use BFS instead (queue)

---

### Q16: Can you transpose rectangular matrix in-place?

**Answer:** **No!** Different dimensions (m×n → n×m).  
Need O(m × n) extra space.

Square matrix (n×n) can be transposed in-place.

---

### Q17: How to print matrix in nice format?

**Answer:**
```java
for (int[] row : matrix) {
    for (int val : row) {
        System.out.printf("%4d", val);
    }
    System.out.println();
}
```

---

### Q18: What's the spiral pattern strategy?

**Answer:** Four boundaries:
- top, bottom, left, right
- Process: right → down → left → up
- Shrink boundaries after each direction
- Check boundaries before left/up passes

---

### Q19: How to handle matrix with duplicates?

**Answer:** Depends on problem:
- Searching: Same algorithms work
- Counting: Use HashMap
- Unique paths: May need visited array

---

### Q20: What's the memory layout of 2D array?

**Answer:** Java stores array of references:
```
matrix → [ref1, ref2, ref3]
           ↓     ↓     ↓
        [1,2,3] [4,5,6] [7,8,9]
```
Not contiguous like C arrays!

---

<a name="practice-problems"></a>
## 9. Practice Problems with Solutions

### Problem 1: Spiral Matrix (LeetCode 54)

**Problem:** Return elements in spiral order.

```java
public class SpiralMatrix {
    
    public static List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if (matrix == null || matrix.length == 0) return result;
        
        int top = 0, bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;
        
        while (top <= bottom && left <= right) {
            for (int j = left; j <= right; j++) result.add(matrix[top][j]);
            top++;
            
            for (int i = top; i <= bottom; i++) result.add(matrix[i][right]);
            right--;
            
            if (top <= bottom) {
                for (int j = right; j >= left; j--) result.add(matrix[bottom][j]);
                bottom--;
            }
            
            if (left <= right) {
                for (int i = bottom; i >= top; i--) result.add(matrix[i][left]);
                left++;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        System.out.println(spiralOrder(matrix));
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Problem 2: Rotate Image (LeetCode 48)

**Problem:** Rotate n×n matrix 90° clockwise in-place.

```java
public class RotateImage {
    
    public static void rotate(int[][] matrix) {
        int n = matrix.length;
        
        // Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Reverse rows
        for (int i = 0; i < n; i++) {
            int left = 0, right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        rotate(matrix);
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### Problem 3: Set Matrix Zeroes (LeetCode 73)

**Problem:** If element is 0, set entire row and column to 0.

```java
public class SetZeroes {
    
    public static void setZeroes(int[][] matrix) {
        int rows = matrix.length, cols = matrix[0].length;
        boolean firstRowZero = false, firstColZero = false;
        
        for (int j = 0; j < cols; j++) {
            if (matrix[0][j] == 0) firstRowZero = true;
        }
        
        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) firstColZero = true;
        }
        
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        if (firstRowZero) {
            for (int j = 0; j < cols; j++) matrix[0][j] = 0;
        }
        
        if (firstColZero) {
            for (int i = 0; i < rows; i++) matrix[i][0] = 0;
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1,1,1},{1,0,1},{1,1,1}};
        setZeroes(matrix);
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Problem 4: Search 2D Matrix II (LeetCode 240)

**Problem:** Search in row-column sorted matrix.

```java
public class Search2DMatrix {
    
    public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) return false;
        
        int row = 0, col = matrix[0].length - 1;
        
        while (row < matrix.length && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] > target) {
                col--;
            } else {
                row++;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1,4,7,11},{2,5,8,12},{3,6,9,16},{10,13,14,17}};
        System.out.println(searchMatrix(matrix, 5));   // true
        System.out.println(searchMatrix(matrix, 20));  // false
    }
}
```

**Time:** O(m + n), **Space:** O(1)

---

### Problem 5: Number of Islands (LeetCode 200)

**Problem:** Count connected components of '1's.

```java
public class NumIslands {
    
    public static int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) return 0;
        
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        
        return count;
    }
    
    private static void dfs(char[][] grid, int r, int c) {
        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] == '0') {
            return;
        }
        
        grid[r][c] = '0';
        dfs(grid, r + 1, c);
        dfs(grid, r - 1, c);
        dfs(grid, r, c + 1);
        dfs(grid, r, c - 1);
    }
    
    public static void main(String[] args) {
        char[][] grid = {
            {'1','1','0','0','0'},
            {'1','1','0','0','0'},
            {'0','0','1','0','0'},
            {'0','0','0','1','1'}
        };
        System.out.println(numIslands(grid));  // 3
    }
}
```

**Time:** O(m × n), **Space:** O(m × n)

---

### Problem 6: Valid Sudoku (LeetCode 36)

**Problem:** Check if 9×9 Sudoku board is valid.

```java
public class ValidSudokuSolution {
    
    public static boolean isValidSudoku(char[][] board) {
        Set<String> seen = new HashSet<>();
        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    char num = board[i][j];
                    if (!seen.add(num + " row " + i) ||
                        !seen.add(num + " col " + j) ||
                        !seen.add(num + " box " + i/3 + "-" + j/3)) {
                        return false;
                    }
                }
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        char[][] board = {
            {'5','3','.','.','7','.','.','.','.'},
            {'6','.','.','1','9','5','.','.','.'},
            {'.','9','8','.','.','.','.','6','.'},
            {'8','.','.','.','6','.','.','.','3'},
            {'4','.','.','8','.','3','.','.','1'},
            {'7','.','.','.','2','.','.','.','6'},
            {'.','6','.','.','.','.','2','8','.'},
            {'.','.','.','4','1','9','.','.','5'},
            {'.','.','.','.','8','.','.','7','9'}
        };
        System.out.println(isValidSudoku(board));
    }
}
```

**Time:** O(1), **Space:** O(1)

---

### Problem 7: Diagonal Traverse (LeetCode 498)

**Problem:** Traverse matrix diagonally in alternating directions.

```java
public class DiagonalTraverse {
    
    public static int[] findDiagonalOrder(int[][] matrix) {
        if (matrix == null || matrix.length == 0) return new int[0];
        
        int rows = matrix.length, cols = matrix[0].length;
        int[] result = new int[rows * cols];
        int index = 0;
        
        for (int sum = 0; sum < rows + cols - 1; sum++) {
            if (sum % 2 == 0) {
                // Going up
                int row = Math.min(sum, rows - 1);
                int col = sum - row;
                while (row >= 0 && col < cols) {
                    result[index++] = matrix[row][col];
                    row--;
                    col++;
                }
            } else {
                // Going down
                int col = Math.min(sum, cols - 1);
                int row = sum - col;
                while (col >= 0 && row < rows) {
                    result[index++] = matrix[row][col];
                    row++;
                    col--;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        System.out.println(Arrays.toString(findDiagonalOrder(matrix)));
        // [1, 2, 4, 7, 5, 3, 6, 8, 9]
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Problem 8: Maximal Square (LeetCode 221)

**Problem:** Find largest square containing only 1's.

```java
public class MaximalSquare {
    
    public static int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0) return 0;
        
        int rows = matrix.length, cols = matrix[0].length;
        int[][] dp = new int[rows + 1][cols + 1];
        int maxSide = 0;
        
        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                if (matrix[i-1][j-1] == '1') {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }
        
        return maxSide * maxSide;
    }
    
    public static void main(String[] args) {
        char[][] matrix = {
            {'1','0','1','0','0'},
            {'1','0','1','1','1'},
            {'1','1','1','1','1'},
            {'1','0','0','1','0'}
        };
        System.out.println(maximalSquare(matrix));  // 4
    }
}
```

**Time:** O(m × n), **Space:** O(m × n)

---

## Summary Cheat Sheet

### Essential Traversal Patterns

| Pattern | Use Case | Time |
|---------|----------|------|
| **Row-wise** | Standard iteration | O(m×n) |
| **Column-wise** | Column operations | O(m×n) |
| **Spiral** ⭐ | Spiral order | O(m×n) |
| **Diagonal** | Diagonal operations | O(m×n) |
| **Boundary** | Frame/border | O(m+n) |
| **Zigzag** | Alternating direction | O(m×n) |

---

### Search Techniques

| Matrix Type | Method | Time |
|-------------|--------|------|
| **Unsorted** | Linear search | O(m×n) |
| **Row-col sorted** | Top-right start ⭐ | O(m+n) |
| **Fully sorted** | Binary search | O(log(m×n)) |

---

### Transformation Templates

#### Transpose (Square)
```java
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        swap(matrix[i][j], matrix[j][i]);
    }
}
```

#### Rotate 90° Clockwise
```java
transpose(matrix);
reverseRows(matrix);
```

#### Flip Horizontal
```java
for (int[] row : matrix) {
    reverse(row);
}
```

---

### Common Directions

```java
// 4-directional
int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

// 8-directional
int[][] dirs = {{-1,0}, {1,0}, {0,-1}, {0,1},
                {-1,-1}, {-1,1}, {1,-1}, {1,1}};
```

---

### Boundary Template

```java
int top = 0, bottom = rows - 1;
int left = 0, right = cols - 1;

while (top <= bottom && left <= right) {
    // Process boundaries
    // Shrink boundaries
}
```

---

## Key Takeaways

✅ **Spiral traversal** - Four boundaries (most common interview pattern)  
✅ **Search row-col sorted** - Start from top-right, O(m+n)  
✅ **Rotate 90°** - Transpose + Reverse rows  
✅ **Set zeroes O(1) space** - Use first row/col as markers  
✅ **Deep copy** - Clone each row individually  
✅ **Always check bounds** - Prevent index out of bounds  
✅ **DFS on matrix** - Watch for stack overflow, mark visited  
✅ **Binary search on matrix** - row = mid/cols, col = mid%cols  
✅ **4-directional is common** - up, down, left, right  
✅ **Master spiral, rotation, search** - Top 3 interview topics!  

---

[← Back: Array Rotation](./Array-Rotation.md) | [Next: Practice Problems →](./Practice-Problems.md)
