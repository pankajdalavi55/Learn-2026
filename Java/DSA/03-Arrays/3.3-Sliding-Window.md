# Sliding Window Technique - Complete Guide

## Why Sliding Window?

**50% of subarray/substring problems use Sliding Window!**

- **Reduces time complexity:** O(n²) → O(n)
- **Pattern for:** Subarrays, substrings, consecutive elements
- **Essential for:** Maximum/minimum sum, longest/shortest substring
- **Foundation for:** Many Google/Facebook/Amazon questions

**Master this = Ace substring/subarray problems!**

---

## Table of Contents

1. [What is Sliding Window?](#what-is)
2. [Types of Sliding Window](#types)
3. [Pattern Recognition](#recognition)
4. [Fixed Size Window](#fixed-size)
5. [Variable Size Window](#variable-size)
6. [Templates & Patterns](#templates)
7. [Common Pitfalls](#pitfalls)
8. [Time/Space Complexity](#complexity)
9. [Interview Questions](#interview-questions)
10. [Practice Problems](#practice-problems)

---

<a name="what-is"></a>
## 1. What is Sliding Window?

**Concept:** Maintain a window (subarray/substring) and slide it across the array/string to find optimal solution.

### Without Sliding Window (Brute Force)

```java
// Find maximum sum of subarray of size k - O(n*k)
public class BruteForce {
    public static int maxSum(int[] arr, int k) {
        int maxSum = Integer.MIN_VALUE;
        
        for (int i = 0; i <= arr.length - k; i++) {
            int currentSum = 0;
            // Calculate sum for each window
            for (int j = i; j < i + k; j++) {
                currentSum += arr[j];
            }
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
}
```

**Time:** O(n × k), **Space:** O(1)

---

### With Sliding Window (Optimized)

```java
// Find maximum sum of subarray of size k - O(n)
public class SlidingWindow {
    public static int maxSum(int[] arr, int k) {
        int windowSum = 0;
        int maxSum = 0;
        
        // Calculate sum of first window
        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }
        maxSum = windowSum;
        
        // Slide the window
        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];  // Add new, remove old
            maxSum = Math.max(maxSum, windowSum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 1, 3, 2};
        int k = 3;
        System.out.println(maxSum(arr, k));  // 9 (5 + 1 + 3)
    }
}
```

**Time:** O(n), **Space:** O(1)

**Key Insight:** Instead of recalculating entire window sum, just **add new element** and **remove old element**!

---

<a name="types"></a>
## 2. Types of Sliding Window

### Type 1: Fixed Size Window

```
Window size = 3 (fixed)

[2, 1, 5, 1, 3, 2]
 └─┴─┘              Window 1: [2, 1, 5] sum = 8

[2, 1, 5, 1, 3, 2]
    └─┴─┘           Window 2: [1, 5, 1] sum = 7

[2, 1, 5, 1, 3, 2]
       └─┴─┘        Window 3: [5, 1, 3] sum = 9 ← Max
```

**Characteristics:**
- Window size is **constant** (k)
- Add one element, remove one element
- Simple increment logic

**Use Cases:**
- Maximum/minimum sum of k elements
- Average of k elements
- First negative in window of size k

---

### Type 2: Variable Size Window (Expandable/Shrinkable)

```
Find longest substring with k distinct characters

"araaci", k = 2

a r a a c i
└─────┘        Window: "araa" (2 distinct: a, r) length = 4

a r a a c i
  └─────┘      Window: "raac" (3 distinct) - shrink!

a r a a c i
    └───┘      Window: "aac" (2 distinct: a, c) length = 3
```

**Characteristics:**
- Window size **changes** dynamically
- Expand when condition not met
- Shrink when condition violated
- Track left and right pointers

**Use Cases:**
- Longest substring with k distinct characters
- Minimum window substring
- Longest substring without repeating characters

---

<a name="recognition"></a>
## 3. Pattern Recognition - When to Use Sliding Window?

✅ **Use Sliding Window when you see:**

| Keyword | Type | Example |
|---------|------|---------|
| **"Subarray of size k"** | Fixed | Max sum subarray of size k |
| **"Consecutive elements"** | Fixed | Average of k consecutive |
| **"Longest substring"** | Variable | Longest substring without repeating |
| **"Shortest subarray"** | Variable | Minimum size subarray sum |
| **"Maximum/Minimum in window"** | Fixed | Max in each window of size k |
| **"Contiguous"** | Both | Contiguous elements |
| **"K distinct/unique"** | Variable | K distinct characters |

---

### Quick Decision Tree

```
Problem has subarray/substring?
  ↓ YES
Is size fixed (k given)?
  ↓ YES → FIXED SIZE WINDOW
  ↓ NO
Is it about longest/shortest/minimum/maximum?
  ↓ YES → VARIABLE SIZE WINDOW
```

---

<a name="fixed-size"></a>
## 4. Fixed Size Window Problems

### Template for Fixed Size Window

```java
public int fixedWindowTemplate(int[] arr, int k) {
    // Step 1: Calculate first window
    int windowResult = 0;
    for (int i = 0; i < k; i++) {
        // Process arr[i]
        windowResult += arr[i];
    }
    
    int result = windowResult;
    
    // Step 2: Slide the window
    for (int i = k; i < arr.length; i++) {
        // Remove element going out (arr[i - k])
        // Add element coming in (arr[i])
        windowResult = windowResult - arr[i - k] + arr[i];
        
        // Update result
        result = Math.max(result, windowResult);
    }
    
    return result;
}
```

---

### Problem 1: Maximum Sum Subarray of Size K

```java
public class MaxSumSubarray {
    
    public static int maxSumSubarray(int[] arr, int k) {
        if (arr.length < k) return -1;
        
        // First window
        int windowSum = 0;
        for (int i = 0; i < k; i++) {
            windowSum += arr[i];
        }
        
        int maxSum = windowSum;
        
        // Slide window
        for (int i = k; i < arr.length; i++) {
            windowSum += arr[i] - arr[i - k];
            maxSum = Math.max(maxSum, windowSum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] arr = {2, 1, 5, 1, 3, 2};
        System.out.println(maxSumSubarray(arr, 3));  // 9
        
        int[] arr2 = {2, 3, 4, 1, 5};
        System.out.println(maxSumSubarray(arr2, 2));  // 7
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: First Negative in Every Window of Size K

```java
import java.util.*;

public class FirstNegativeWindow {
    
    public static long[] firstNegative(long[] arr, int k) {
        int n = arr.length;
        long[] result = new long[n - k + 1];
        Queue<Integer> queue = new LinkedList<>();  // Store indices
        
        // Process first window
        for (int i = 0; i < k; i++) {
            if (arr[i] < 0) {
                queue.offer(i);
            }
        }
        
        result[0] = queue.isEmpty() ? 0 : arr[queue.peek()];
        
        // Slide window
        for (int i = k; i < n; i++) {
            // Remove elements outside window
            while (!queue.isEmpty() && queue.peek() <= i - k) {
                queue.poll();
            }
            
            // Add new element if negative
            if (arr[i] < 0) {
                queue.offer(i);
            }
            
            result[i - k + 1] = queue.isEmpty() ? 0 : arr[queue.peek()];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        long[] arr = {12, -1, -7, 8, -15, 30, 16, 28};
        int k = 3;
        System.out.println(Arrays.toString(firstNegative(arr, k)));
        // [-1, -1, -7, -15, -15, 0]
    }
}
```

**Time:** O(n), **Space:** O(k)

---

### Problem 3: Maximum of All Subarrays of Size K

```java
import java.util.*;

public class MaxOfAllSubarrays {
    
    // Using Deque (most efficient)
    public static int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            // Remove indices outside window
            while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            
            // Remove smaller elements (not useful)
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }
            
            deque.offerLast(i);
            
            // Add to result
            if (i >= k - 1) {
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;
        System.out.println(Arrays.toString(maxSlidingWindow(nums, k)));
        // [3, 3, 5, 5, 6, 7]
    }
}
```

**Time:** O(n), **Space:** O(k)

**Key Insight:** Deque maintains indices in decreasing order of values. Front always has max!

---

### Problem 4: Count Occurrences of Anagrams

```java
import java.util.*;

public class CountAnagrams {
    
    public static int countAnagrams(String text, String pattern) {
        int count = 0;
        int k = pattern.length();
        
        // Frequency map for pattern
        Map<Character, Integer> patternMap = new HashMap<>();
        for (char c : pattern.toCharArray()) {
            patternMap.put(c, patternMap.getOrDefault(c, 0) + 1);
        }
        
        // Frequency map for window
        Map<Character, Integer> windowMap = new HashMap<>();
        int matched = 0;
        
        for (int i = 0; i < text.length(); i++) {
            // Add character to window
            char c = text.charAt(i);
            windowMap.put(c, windowMap.getOrDefault(c, 0) + 1);
            
            if (patternMap.containsKey(c) && 
                windowMap.get(c).equals(patternMap.get(c))) {
                matched++;
            }
            
            // Remove character going out
            if (i >= k) {
                char out = text.charAt(i - k);
                if (patternMap.containsKey(out) && 
                    windowMap.get(out).equals(patternMap.get(out))) {
                    matched--;
                }
                
                windowMap.put(out, windowMap.get(out) - 1);
                if (windowMap.get(out) == 0) {
                    windowMap.remove(out);
                }
            }
            
            // Check if anagram
            if (matched == patternMap.size()) {
                count++;
            }
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        System.out.println(countAnagrams("forxxorfxdofr", "for"));  // 3
        System.out.println(countAnagrams("aabaabaa", "aaba"));      // 4
    }
}
```

**Time:** O(n), **Space:** O(k)

---

<a name="variable-size"></a>
## 5. Variable Size Window Problems

### Template for Variable Size Window

```java
public int variableWindowTemplate(int[] arr, int target) {
    int left = 0;
    int right = 0;
    int windowResult = 0;
    int result = 0;
    
    while (right < arr.length) {
        // Expand window - add arr[right]
        windowResult += arr[right];
        
        // Shrink window while condition violated
        while (windowResult > target) {
            windowResult -= arr[left];
            left++;
        }
        
        // Update result
        result = Math.max(result, right - left + 1);
        
        right++;
    }
    
    return result;
}
```

---

### Problem 1: Longest Substring Without Repeating Characters

```java
import java.util.*;

public class LongestSubstringNoRepeat {
    
    public static int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            
            // Shrink window until no duplicate
            while (set.contains(c)) {
                set.remove(s.charAt(left));
                left++;
            }
            
            set.add(c);
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    // Alternative: Using HashMap (more efficient)
    public static int lengthOfLongestSubstringMap(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            
            // If duplicate, move left pointer
            if (map.containsKey(c)) {
                left = Math.max(left, map.get(c) + 1);
            }
            
            map.put(c, right);
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb"));  // 3 (abc)
        System.out.println(lengthOfLongestSubstring("bbbbb"));     // 1 (b)
        System.out.println(lengthOfLongestSubstring("pwwkew"));    // 3 (wke)
    }
}
```

**Time:** O(n), **Space:** O(min(n, m)) where m = charset size

---

### Problem 2: Longest Substring with K Distinct Characters

```java
import java.util.*;

public class LongestKDistinct {
    
    public static int longestKDistinct(String s, int k) {
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            map.put(c, map.getOrDefault(c, 0) + 1);
            
            // Shrink window if more than k distinct
            while (map.size() > k) {
                char leftChar = s.charAt(left);
                map.put(leftChar, map.get(leftChar) - 1);
                
                if (map.get(leftChar) == 0) {
                    map.remove(leftChar);
                }
                
                left++;
            }
            
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(longestKDistinct("araaci", 2));  // 4 (araa)
        System.out.println(longestKDistinct("araaci", 1));  // 2 (aa)
        System.out.println(longestKDistinct("cbbebi", 3));  // 5 (cbbeb)
    }
}
```

**Time:** O(n), **Space:** O(k)

---

### Problem 3: Minimum Window Substring

```java
import java.util.*;

public class MinimumWindowSubstring {
    
    public static String minWindow(String s, String t) {
        if (s.length() < t.length()) return "";
        
        // Frequency map for t
        Map<Character, Integer> tMap = new HashMap<>();
        for (char c : t.toCharArray()) {
            tMap.put(c, tMap.getOrDefault(c, 0) + 1);
        }
        
        int left = 0;
        int minLength = Integer.MAX_VALUE;
        int minStart = 0;
        int matched = 0;
        Map<Character, Integer> windowMap = new HashMap<>();
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            windowMap.put(c, windowMap.getOrDefault(c, 0) + 1);
            
            if (tMap.containsKey(c) && 
                windowMap.get(c).intValue() == tMap.get(c).intValue()) {
                matched++;
            }
            
            // Shrink window while all characters matched
            while (matched == tMap.size()) {
                // Update result
                if (right - left + 1 < minLength) {
                    minLength = right - left + 1;
                    minStart = left;
                }
                
                char leftChar = s.charAt(left);
                windowMap.put(leftChar, windowMap.get(leftChar) - 1);
                
                if (tMap.containsKey(leftChar) && 
                    windowMap.get(leftChar) < tMap.get(leftChar)) {
                    matched--;
                }
                
                left++;
            }
        }
        
        return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
    }
    
    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC"));  // "BANC"
        System.out.println(minWindow("a", "a"));                // "a"
        System.out.println(minWindow("a", "aa"));               // ""
    }
}
```

**Time:** O(m + n), **Space:** O(m + n)

---

### Problem 4: Longest Repeating Character Replacement

```java
public class LongestRepeatingReplacement {
    
    public static int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int left = 0;
        int maxCount = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            count[c - 'A']++;
            maxCount = Math.max(maxCount, count[c - 'A']);
            
            // Window size - most frequent char count > k means invalid
            while (right - left + 1 - maxCount > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }
            
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(characterReplacement("ABAB", 2));    // 4 (AAAA or BBBB)
        System.out.println(characterReplacement("AABABBA", 1)); // 4 (AABBB → AAABB)
    }
}
```

**Time:** O(n), **Space:** O(1)

**Key Insight:** If `window_size - max_frequency > k`, we need more than k replacements!

---

### Problem 5: Subarray Sum Equals K

```java
import java.util.*;

public class SubarraySumK {
    
    // Using HashMap (handles negative numbers)
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);  // Empty subarray
        
        int count = 0;
        int sum = 0;
        
        for (int num : nums) {
            sum += num;
            
            // Check if (sum - k) exists
            if (map.containsKey(sum - k)) {
                count += map.get(sum - k);
            }
            
            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 1, 1};
        System.out.println(subarraySum(nums1, 2));  // 2
        
        int[] nums2 = {1, 2, 3};
        System.out.println(subarraySum(nums2, 3));  // 2
    }
}
```

**Time:** O(n), **Space:** O(n)

**Note:** This is prefix sum + HashMap, not pure sliding window (since array can have negatives).

---

### Problem 6: Minimum Size Subarray Sum

```java
public class MinSizeSubarraySum {
    
    public static int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int minLength = Integer.MAX_VALUE;
        
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            
            // Shrink window while sum >= target
            while (sum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {2, 3, 1, 2, 4, 3};
        System.out.println(minSubArrayLen(7, nums1));  // 2 ([4, 3])
        
        int[] nums2 = {1, 4, 4};
        System.out.println(minSubArrayLen(4, nums2));  // 1 ([4])
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="templates"></a>
## 6. Templates & Patterns Summary

### Template 1: Fixed Size Window

```java
// Fixed window of size k
int result = 0;
int windowValue = 0;

// Build first window
for (int i = 0; i < k; i++) {
    windowValue += arr[i];
}
result = windowValue;

// Slide window
for (int i = k; i < arr.length; i++) {
    windowValue += arr[i] - arr[i - k];
    result = Math.max(result, windowValue);
}
```

---

### Template 2: Variable Window (Find Maximum)

```java
// Find longest/maximum window satisfying condition
int left = 0;
int maxLength = 0;

for (int right = 0; right < arr.length; right++) {
    // Add arr[right] to window
    
    // Shrink while condition violated
    while (/* condition violated */) {
        // Remove arr[left] from window
        left++;
    }
    
    maxLength = Math.max(maxLength, right - left + 1);
}
```

---

### Template 3: Variable Window (Find Minimum)

```java
// Find shortest/minimum window satisfying condition
int left = 0;
int minLength = Integer.MAX_VALUE;

for (int right = 0; right < arr.length; right++) {
    // Add arr[right] to window
    
    // Shrink while condition satisfied
    while (/* condition satisfied */) {
        minLength = Math.min(minLength, right - left + 1);
        // Remove arr[left] from window
        left++;
    }
}
```

---

### Template 4: Using HashMap for Character Count

```java
// Variable window with character frequency
Map<Character, Integer> map = new HashMap<>();
int left = 0;
int result = 0;

for (int right = 0; right < s.length(); right++) {
    char c = s.charAt(right);
    map.put(c, map.getOrDefault(c, 0) + 1);
    
    // Shrink while condition violated
    while (/* condition violated */) {
        char leftChar = s.charAt(left);
        map.put(leftChar, map.get(leftChar) - 1);
        if (map.get(leftChar) == 0) {
            map.remove(leftChar);
        }
        left++;
    }
    
    result = Math.max(result, right - left + 1);
}
```

---

<a name="pitfalls"></a>
## 7. Common Pitfalls & Solutions

### Pitfall 1: Forgetting to Remove Elements

```java
// ❌ WRONG - Only adding, not removing
for (int i = k; i < arr.length; i++) {
    windowSum += arr[i];  // Forgot to subtract arr[i - k]
}

// ✅ CORRECT
for (int i = k; i < arr.length; i++) {
    windowSum += arr[i] - arr[i - k];
}
```

---

### Pitfall 2: Off-by-One Errors in Window Size

```java
// ❌ WRONG - Window size calculation
int windowSize = right - left;  // Missing +1

// ✅ CORRECT
int windowSize = right - left + 1;
```

---

### Pitfall 3: Not Handling Empty HashMap Values

```java
// ❌ WRONG - Can cause null pointer
map.put(c, map.get(c) - 1);

// ✅ CORRECT
map.put(c, map.getOrDefault(c, 0) - 1);
if (map.get(c) == 0) {
    map.remove(c);
}
```

---

### Pitfall 4: Shrinking Too Much

```java
// ❌ WRONG - Shrinks even when not needed
while (left < right) {
    // ...
    left++;
}

// ✅ CORRECT - Only shrink when condition violated
while (/* specific condition */) {
    left++;
}
```

---

### Pitfall 5: Using Wrong Data Structure

```java
// ❌ WRONG - List for frequency (slow)
List<Integer> freq = new ArrayList<>();

// ✅ CORRECT - HashMap or array
Map<Character, Integer> freq = new HashMap<>();
// OR for small character set
int[] freq = new int[26];
```

---

<a name="complexity"></a>
## 8. Time/Space Complexity

### Typical Complexities

| Pattern | Time | Space | Why? |
|---------|------|-------|------|
| Fixed window | O(n) | O(1) | Each element processed once |
| Variable window | O(n) | O(1) to O(k) | Left and right each move n times max |
| With HashMap | O(n) | O(k) | k = unique elements in window |
| With Deque | O(n) | O(k) | k = window size |

---

### Why O(n) for Variable Window?

```
Even though we have nested loops, each element is:
- Added once (right pointer moves n times)
- Removed once (left pointer moves n times max)

Total operations: 2n = O(n)
```

---

<a name="interview-questions"></a>
## 9. Top 15 Interview Questions

### Q1: How to identify if a problem needs sliding window?

**Answer:** Look for keywords:
- "Contiguous subarray/substring"
- "Maximum/minimum/longest/shortest"
- "Window of size k"
- "All subarrays/substrings of size k"

---

### Q2: Fixed vs Variable window - when to use which?

**Answer:**

| Fixed Window | Variable Window |
|--------------|-----------------|
| Size k is given | Size unknown |
| "Window of size k" | "Longest/shortest" |
| Simple add/remove | Need shrinking logic |

---

### Q3: Why is variable window still O(n)?

**Answer:** Both pointers move forward only. Each element:
- Added once (by right)
- Removed once (by left)
- Total: 2n operations = O(n)

---

### Q4: When to use HashMap vs Array for frequency?

**Answer:**

```java
// Array - when character set is small (a-z, 0-9)
int[] freq = new int[26];  // Faster, O(1) access

// HashMap - when character set is large (Unicode, numbers)
Map<Character, Integer> freq = new HashMap<>();  // More flexible
```

---

### Q5: How to handle negative numbers in sliding window?

**Answer:** Negative numbers make sum unpredictable!
- ❌ Can't use simple sliding window
- ✅ Use prefix sum + HashMap
- Example: Subarray Sum Equals K

---

### Q6: What's the difference between sliding window and two pointers?

**Answer:**

| Sliding Window | Two Pointers |
|----------------|--------------|
| Contiguous elements | Can skip elements |
| Both pointers move right | Can move opposite |
| Subarray/substring | Pairs, palindromes |

---

### Q7: How to find second maximum in sliding window?

**Answer:** Use TreeMap or maintain two variables:
```java
// Option 1: TreeMap
TreeMap<Integer, Integer> map = new TreeMap<>();

// Option 2: Track two maxes
int max1 = Integer.MIN_VALUE;
int max2 = Integer.MIN_VALUE;
```

---

### Q8: Can sliding window work with 2D arrays?

**Answer:** Yes! For submatrices:
```java
// Fix top and bottom rows, slide window on columns
for (int top = 0; top < rows; top++) {
    for (int bottom = top; bottom < rows; bottom++) {
        // Use 1D sliding window on this row range
    }
}
```

---

### Q9: How to count subarrays instead of finding maximum?

**Answer:** Count when condition is satisfied:
```java
int count = 0;
while (right < n) {
    // Expand
    while (/* condition satisfied */) {
        count += right - left + 1;  // All subarrays ending at right
        left++;
    }
    right++;
}
```

---

### Q10: What if I need to track multiple conditions?

**Answer:** Use multiple counters:
```java
int distinctCount = 0;
int totalCount = 0;
Map<Character, Integer> freq = new HashMap<>();
// Track both conditions separately
```

---

### Q11: How to handle string with spaces/special characters?

**Answer:**
```java
// Option 1: Skip while sliding
while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
    left++;
}

// Option 2: Preprocess
String clean = s.replaceAll("[^a-zA-Z0-9]", "");
```

---

### Q12: Can I have multiple windows simultaneously?

**Answer:** Not with standard sliding window. Use:
- Multiple passes
- Or segment tree / other DS

---

### Q13: What's the maximum space complexity?

**Answer:** 
- HashMap: O(min(n, m)) where m = character set size
- Deque: O(k) where k = window size
- Usually not more than O(n)

---

### Q14: How to optimize HashMap operations?

**Answer:**
```java
// Remove if count becomes 0
if (map.get(c) == 0) {
    map.remove(c);
}

// Check size instead of iterating
if (map.size() == k) { /* ... */ }
```

---

### Q15: Can sliding window solve all subarray problems?

**Answer:** **No!**
- ✅ Works: Contiguous, monotonic conditions
- ❌ Doesn't work: Non-contiguous, complex DP states

---

<a name="practice-problems"></a>
## 10. Practice Problems with Solutions

### Problem 1: Permutation in String

**Problem:** Check if s2 contains permutation of s1.

**Example:** `s1 = "ab", s2 = "eidbaooo"` → `true` (contains "ba")

```java
import java.util.*;

public class PermutationInString {
    
    public static boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        
        int[] s1Count = new int[26];
        int[] s2Count = new int[26];
        
        // Count s1 characters
        for (char c : s1.toCharArray()) {
            s1Count[c - 'a']++;
        }
        
        // Fixed window of size s1.length()
        for (int i = 0; i < s2.length(); i++) {
            s2Count[s2.charAt(i) - 'a']++;
            
            // Remove element going out
            if (i >= s1.length()) {
                s2Count[s2.charAt(i - s1.length()) - 'a']--;
            }
            
            // Check if permutation
            if (Arrays.equals(s1Count, s2Count)) {
                return true;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        System.out.println(checkInclusion("ab", "eidbaooo"));  // true
        System.out.println(checkInclusion("ab", "eidboaoo"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: Fruits into Baskets

**Problem:** Pick fruits from trees, max 2 types, longest sequence.

**Example:** `[1,2,1,2,2]` → `5` (all fruits)

```java
import java.util.*;

public class FruitsIntoBaskets {
    
    public static int totalFruit(int[] fruits) {
        Map<Integer, Integer> basket = new HashMap<>();
        int left = 0;
        int maxFruits = 0;
        
        for (int right = 0; right < fruits.length; right++) {
            basket.put(fruits[right], basket.getOrDefault(fruits[right], 0) + 1);
            
            // Shrink if more than 2 types
            while (basket.size() > 2) {
                int leftFruit = fruits[left];
                basket.put(leftFruit, basket.get(leftFruit) - 1);
                
                if (basket.get(leftFruit) == 0) {
                    basket.remove(leftFruit);
                }
                
                left++;
            }
            
            maxFruits = Math.max(maxFruits, right - left + 1);
        }
        
        return maxFruits;
    }
    
    public static void main(String[] args) {
        int[] fruits1 = {1, 2, 1};
        System.out.println(totalFruit(fruits1));  // 3
        
        int[] fruits2 = {0, 1, 2, 2};
        System.out.println(totalFruit(fruits2));  // 3
        
        int[] fruits3 = {1, 2, 3, 2, 2};
        System.out.println(totalFruit(fruits3));  // 4
    }
}
```

**Time:** O(n), **Space:** O(1) (at most 3 types in map)

---

### Problem 3: Longest Substring with At Most K Distinct Characters

**Problem:** Find longest substring with at most k distinct characters.

**Example:** `s = "eceba", k = 2` → `3` ("ece")

```java
import java.util.*;

public class LongestAtMostKDistinct {
    
    public static int lengthOfLongestSubstringKDistinct(String s, int k) {
        if (k == 0) return 0;
        
        Map<Character, Integer> map = new HashMap<>();
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            char c = s.charAt(right);
            map.put(c, map.getOrDefault(c, 0) + 1);
            
            // Shrink if more than k distinct
            while (map.size() > k) {
                char leftChar = s.charAt(left);
                map.put(leftChar, map.get(leftChar) - 1);
                
                if (map.get(leftChar) == 0) {
                    map.remove(leftChar);
                }
                
                left++;
            }
            
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstringKDistinct("eceba", 2));  // 3
        System.out.println(lengthOfLongestSubstringKDistinct("aa", 1));     // 2
    }
}
```

**Time:** O(n), **Space:** O(k)

---

### Problem 4: Maximum Points from Cards

**Problem:** Pick k cards from either end, maximize sum.

**Example:** `cardPoints = [1,2,3,4,5,6,1], k = 3` → `12` ([6, 5, 1] or [1, 6, 5])

```java
public class MaxPointsFromCards {
    
    public static int maxScore(int[] cardPoints, int k) {
        int n = cardPoints.length;
        
        // Total sum
        int totalSum = 0;
        for (int card : cardPoints) {
            totalSum += card;
        }
        
        // If k == n, take all cards
        if (k == n) return totalSum;
        
        // Find minimum subarray of size (n - k)
        int windowSize = n - k;
        int windowSum = 0;
        
        // First window
        for (int i = 0; i < windowSize; i++) {
            windowSum += cardPoints[i];
        }
        
        int minWindowSum = windowSum;
        
        // Slide window
        for (int i = windowSize; i < n; i++) {
            windowSum += cardPoints[i] - cardPoints[i - windowSize];
            minWindowSum = Math.min(minWindowSum, windowSum);
        }
        
        return totalSum - minWindowSum;
    }
    
    public static void main(String[] args) {
        int[] cards1 = {1, 2, 3, 4, 5, 6, 1};
        System.out.println(maxScore(cards1, 3));  // 12
        
        int[] cards2 = {2, 2, 2};
        System.out.println(maxScore(cards2, 2));  // 4
    }
}
```

**Time:** O(n), **Space:** O(1)

**Key Insight:** Taking k cards from ends = Total - (minimum subarray of size n-k)

---

### Problem 5: Count Number of Nice Subarrays

**Problem:** Count subarrays with exactly k odd numbers.

**Example:** `nums = [1,1,2,1,1], k = 3` → `2` ([1,1,2,1], [1,2,1,1])

```java
import java.util.*;

public class NiceSubarrays {
    
    // Helper: Count subarrays with AT MOST k odd numbers
    private static int atMostK(int[] nums, int k) {
        int left = 0;
        int count = 0;
        int oddCount = 0;
        
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] % 2 == 1) {
                oddCount++;
            }
            
            // Shrink while oddCount > k
            while (oddCount > k) {
                if (nums[left] % 2 == 1) {
                    oddCount--;
                }
                left++;
            }
            
            // All subarrays ending at right
            count += right - left + 1;
        }
        
        return count;
    }
    
    public static int numberOfSubarrays(int[] nums, int k) {
        // Exactly k = At most k - At most (k-1)
        return atMostK(nums, k) - atMostK(nums, k - 1);
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 1, 2, 1, 1};
        System.out.println(numberOfSubarrays(nums1, 3));  // 2
        
        int[] nums2 = {2, 4, 6};
        System.out.println(numberOfSubarrays(nums2, 1));  // 0
    }
}
```

**Time:** O(n), **Space:** O(1)

**Key Insight:** `Exactly k = At most k - At most (k-1)`

---

## Summary Cheat Sheet

### Quick Pattern Recognition

| Problem Type | Window Type | Key Indicator |
|--------------|-------------|---------------|
| Max sum of k elements | Fixed | "Size k" given |
| Longest substring | Variable | "Longest/maximum" |
| Shortest subarray | Variable | "Shortest/minimum" |
| All windows of size k | Fixed | "All/each window" |
| K distinct characters | Variable | "K distinct/unique" |
| Permutation/anagram | Fixed | "Permutation/anagram" |

---

### Decision Tree

```
Is it about subarray/substring?
  ↓ YES
Is size k given?
  ↓ YES → FIXED WINDOW
  ↓ NO
Is it longest/maximum?
  ↓ YES → VARIABLE WINDOW (maximize)
Is it shortest/minimum?
  ↓ YES → VARIABLE WINDOW (minimize)
```

---

## Key Takeaways

✅ **Sliding window reduces O(n²) → O(n)** for subarray/substring problems  
✅ **Two types:** Fixed size (k given) and Variable size (find optimal)  
✅ **Fixed window:** Add new, remove old - simple pattern  
✅ **Variable window:** Expand + Shrink based on condition  
✅ **HashMap for character problems** - Track frequencies  
✅ **Deque for min/max in window** - O(1) access to extremes  
✅ **Space is usually O(k)** - Window size or distinct elements  
✅ **Both pointers move forward** - Each element processed once = O(n)  
✅ **Exactly k = At most k - At most (k-1)** - Counting trick  
✅ **Practice recognition** - 50% of substring problems use this!  

---

[← Back: Two Pointer Technique](./Two-Pointer-Technique.md) | [Next: Prefix Sum →](./Prefix-Sum.md)
