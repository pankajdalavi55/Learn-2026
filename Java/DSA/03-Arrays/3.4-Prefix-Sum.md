# Prefix Sum & Difference Array - Complete Guide

## Why Prefix Sum & Difference Array?

**30% of array problems can be optimized with these techniques!**

- **Prefix Sum:** Reduces range sum from O(n) → O(1)
- **Difference Array:** Reduces range update from O(n) → O(1)
- **Essential for:** Range queries, subarray sums, interval problems
- **Foundation for:** DP, segment trees, fenwick trees

**Master these = Ace range-based problems!**

---

## Table of Contents

1. [Prefix Sum - Basics](#prefix-sum)
2. [Prefix Sum - Advanced Patterns](#prefix-advanced)
3. [Difference Array - Basics](#difference-array)
4. [2D Prefix Sum (Matrix)](#2d-prefix)
5. [Common Patterns](#patterns)
6. [When to Use What](#when-to-use)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)

---

<a name="prefix-sum"></a>
## 1. Prefix Sum - Basics

### What is Prefix Sum?

**Prefix sum at index i = sum of all elements from index 0 to i**

```
Array:      [3, 1, 4, 2, 5]
Prefix:     [3, 4, 8, 10, 15]
             ↑  ↑  ↑   ↑   ↑
             3  3+1 3+1+4 ...
```

### Formula

```
prefix[i] = arr[0] + arr[1] + ... + arr[i]

prefix[0] = arr[0]
prefix[i] = prefix[i-1] + arr[i]
```

---

### Basic Implementation

```java
import java.util.*;

public class PrefixSumBasic {
    
    // Build prefix sum array
    public static int[] buildPrefixSum(int[] arr) {
        int n = arr.length;
        int[] prefix = new int[n];
        
        prefix[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + arr[i];
        }
        
        return prefix;
    }
    
    // Range sum query using prefix sum
    public static int rangeSum(int[] prefix, int left, int right) {
        if (left == 0) {
            return prefix[right];
        }
        return prefix[right] - prefix[left - 1];
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 1, 4, 2, 5};
        int[] prefix = buildPrefixSum(arr);
        
        System.out.println(Arrays.toString(prefix));
        // [3, 4, 8, 10, 15]
        
        System.out.println(rangeSum(prefix, 1, 3));  // 1 + 4 + 2 = 7
        System.out.println(rangeSum(prefix, 0, 4));  // 3 + 1 + 4 + 2 + 5 = 15
    }
}
```

**Time:** Build O(n), Query O(1)  
**Space:** O(n)

---

### Why Prefix Sum?

**Without Prefix Sum:**
```java
// Range sum [left, right] - O(n)
int sum = 0;
for (int i = left; i <= right; i++) {
    sum += arr[i];
}
```

**With Prefix Sum:**
```java
// Range sum [left, right] - O(1)
int sum = prefix[right] - prefix[left - 1];
```

**Perfect for:** Multiple range queries on static array!

---

### Problem 1: Range Sum Query (Immutable)

```java
class NumArray {
    private int[] prefix;
    
    public NumArray(int[] nums) {
        prefix = new int[nums.length];
        prefix[0] = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }
    }
    
    public int sumRange(int left, int right) {
        if (left == 0) {
            return prefix[right];
        }
        return prefix[right] - prefix[left - 1];
    }
}

public class RangeSumQuery {
    public static void main(String[] args) {
        int[] nums = {-2, 0, 3, -5, 2, -1};
        NumArray obj = new NumArray(nums);
        
        System.out.println(obj.sumRange(0, 2));  // -2 + 0 + 3 = 1
        System.out.println(obj.sumRange(2, 5));  // 3 + (-5) + 2 + (-1) = -1
        System.out.println(obj.sumRange(0, 5));  // -3
    }
}
```

**Time:** Constructor O(n), Query O(1)  
**Space:** O(n)

---

<a name="prefix-advanced"></a>
## 2. Prefix Sum - Advanced Patterns

### Pattern 1: Subarray Sum Equals K

**Problem:** Count subarrays with sum equal to k.

**Key Insight:** If `prefix[i] - prefix[j] = k`, then `prefix[j] = prefix[i] - k`

```java
import java.util.*;

public class SubarraySumK {
    
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixCount = new HashMap<>();
        prefixCount.put(0, 1);  // Empty subarray
        
        int sum = 0;
        int count = 0;
        
        for (int num : nums) {
            sum += num;
            
            // Check if (sum - k) exists
            if (prefixCount.containsKey(sum - k)) {
                count += prefixCount.get(sum - k);
            }
            
            // Add current sum
            prefixCount.put(sum, prefixCount.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 1, 1};
        System.out.println(subarraySum(nums1, 2));  // 2
        
        int[] nums2 = {1, 2, 3};
        System.out.println(subarraySum(nums2, 3));  // 2
        
        int[] nums3 = {1, -1, 1, -1, 1};
        System.out.println(subarraySum(nums3, 0));  // 4
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Pattern 2: Subarray Sum Divisible by K

**Problem:** Count subarrays where sum is divisible by k.

**Key Insight:** If `(prefix[i] - prefix[j]) % k = 0`, then `prefix[i] % k = prefix[j] % k`

```java
import java.util.*;

public class SubarrayDivByK {
    
    public static int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> remainderCount = new HashMap<>();
        remainderCount.put(0, 1);  // Empty subarray
        
        int sum = 0;
        int count = 0;
        
        for (int num : nums) {
            sum += num;
            
            // Handle negative remainders
            int remainder = ((sum % k) + k) % k;
            
            // Count subarrays
            count += remainderCount.getOrDefault(remainder, 0);
            
            // Update count
            remainderCount.put(remainder, remainderCount.getOrDefault(remainder, 0) + 1);
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        int[] nums = {4, 5, 0, -2, -3, 1};
        System.out.println(subarraysDivByK(nums, 5));  // 7
    }
}
```

**Time:** O(n), **Space:** O(k)

**Important:** Use `((sum % k) + k) % k` to handle negative remainders!

---

### Pattern 3: Contiguous Array (Equal 0s and 1s)

**Problem:** Find longest subarray with equal number of 0s and 1s.

**Key Insight:** Treat 0 as -1, find longest subarray with sum = 0.

```java
import java.util.*;

public class ContiguousArray {
    
    public static int findMaxLength(int[] nums) {
        Map<Integer, Integer> sumIndex = new HashMap<>();
        sumIndex.put(0, -1);  // Sum 0 at index -1
        
        int sum = 0;
        int maxLength = 0;
        
        for (int i = 0; i < nums.length; i++) {
            sum += (nums[i] == 1) ? 1 : -1;
            
            if (sumIndex.containsKey(sum)) {
                maxLength = Math.max(maxLength, i - sumIndex.get(sum));
            } else {
                sumIndex.put(sum, i);
            }
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {0, 1};
        System.out.println(findMaxLength(nums1));  // 2
        
        int[] nums2 = {0, 1, 0};
        System.out.println(findMaxLength(nums2));  // 2
        
        int[] nums3 = {0, 0, 1, 0, 0, 0, 1, 1};
        System.out.println(findMaxLength(nums3));  // 6
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Pattern 4: Product of Array Except Self

**Problem:** Return array where each element is product of all others (without division).

**Key Insight:** Use prefix product and suffix product!

```java
import java.util.*;

public class ProductExceptSelf {
    
    public static int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        // Left products (prefix)
        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }
        
        // Right products (suffix)
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] *= rightProduct;
            rightProduct *= nums[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4};
        System.out.println(Arrays.toString(productExceptSelf(nums)));
        // [24, 12, 8, 6]
    }
}
```

**Time:** O(n), **Space:** O(1) (excluding output)

---

<a name="difference-array"></a>
## 3. Difference Array - Basics

### What is Difference Array?

**Difference array allows O(1) range updates!**

```
Array:      [3, 5, 7, 9, 11]
Diff:       [3, 2, 2, 2, 2]
             ↑  ↑  ↑  ↑  ↑
             3  5-3 7-5 9-7 11-9
```

### Formula

```
diff[0] = arr[0]
diff[i] = arr[i] - arr[i-1]

To reconstruct array:
arr[i] = diff[0] + diff[1] + ... + diff[i]
```

---

### Basic Implementation

```java
import java.util.*;

public class DifferenceArray {
    
    // Build difference array
    public static int[] buildDiffArray(int[] arr) {
        int n = arr.length;
        int[] diff = new int[n];
        
        diff[0] = arr[0];
        for (int i = 1; i < n; i++) {
            diff[i] = arr[i] - arr[i - 1];
        }
        
        return diff;
    }
    
    // Range update: add value to [left, right]
    public static void rangeUpdate(int[] diff, int left, int right, int value) {
        diff[left] += value;
        if (right + 1 < diff.length) {
            diff[right + 1] -= value;
        }
    }
    
    // Reconstruct array from difference array
    public static int[] reconstruct(int[] diff) {
        int n = diff.length;
        int[] arr = new int[n];
        
        arr[0] = diff[0];
        for (int i = 1; i < n; i++) {
            arr[i] = arr[i - 1] + diff[i];
        }
        
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {0, 0, 0, 0, 0};
        int[] diff = buildDiffArray(arr);
        
        // Update [1, 3] by +2
        rangeUpdate(diff, 1, 3, 2);
        
        // Update [2, 4] by +3
        rangeUpdate(diff, 2, 4, 3);
        
        int[] result = reconstruct(diff);
        System.out.println(Arrays.toString(result));
        // [0, 2, 5, 5, 3]
    }
}
```

**Time:** Build O(n), Update O(1), Reconstruct O(n)  
**Space:** O(n)

---

### Why Difference Array?

**Without Difference Array:**
```java
// Add value to range [left, right] - O(n)
for (int i = left; i <= right; i++) {
    arr[i] += value;
}
```

**With Difference Array:**
```java
// Add value to range [left, right] - O(1)
diff[left] += value;
if (right + 1 < n) diff[right + 1] -= value;
```

**Perfect for:** Multiple range updates, then single query!

---

### Problem 1: Range Addition

```java
import java.util.*;

public class RangeAddition {
    
    public static int[] getModifiedArray(int length, int[][] updates) {
        int[] diff = new int[length];
        
        // Apply all updates to difference array
        for (int[] update : updates) {
            int start = update[0];
            int end = update[1];
            int value = update[2];
            
            diff[start] += value;
            if (end + 1 < length) {
                diff[end + 1] -= value;
            }
        }
        
        // Reconstruct array
        int[] result = new int[length];
        result[0] = diff[0];
        
        for (int i = 1; i < length; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] updates = {
            {1, 3, 2},
            {2, 4, 3},
            {0, 2, -2}
        };
        
        int[] result = getModifiedArray(5, updates);
        System.out.println(Arrays.toString(result));
        // [-2, 0, 3, 5, 3]
    }
}
```

**Time:** O(n + k) where k = number of updates  
**Space:** O(n)

---

### Problem 2: Corporate Flight Bookings

```java
import java.util.*;

public class FlightBookings {
    
    public static int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        
        for (int[] booking : bookings) {
            int first = booking[0] - 1;  // Convert to 0-indexed
            int last = booking[1] - 1;
            int seats = booking[2];
            
            diff[first] += seats;
            if (last + 1 < n) {
                diff[last + 1] -= seats;
            }
        }
        
        // Reconstruct
        int[] result = new int[n];
        result[0] = diff[0];
        
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] bookings = {
            {1, 2, 10},
            {2, 3, 20},
            {2, 5, 25}
        };
        
        int[] result = corpFlightBookings(bookings, 5);
        System.out.println(Arrays.toString(result));
        // [10, 55, 45, 25, 25]
    }
}
```

**Time:** O(n + k), **Space:** O(n)

---

<a name="2d-prefix"></a>
## 4. 2D Prefix Sum (Matrix)

### What is 2D Prefix Sum?

**2D prefix sum = sum of all elements in rectangle from (0,0) to (i,j)**

```
Matrix:         Prefix Sum:
1  2  3         1   3   6
4  5  6    →    5  12  21
7  8  9         12 27  45
```

### Formula

```
prefix[i][j] = sum of all elements in rectangle (0,0) to (i,j)

prefix[i][j] = matrix[i][j] 
             + prefix[i-1][j] 
             + prefix[i][j-1] 
             - prefix[i-1][j-1]
```

---

### 2D Range Sum Implementation

```java
class NumMatrix {
    private int[][] prefix;
    
    public NumMatrix(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) return;
        
        int m = matrix.length;
        int n = matrix[0].length;
        prefix = new int[m + 1][n + 1];  // 1-indexed for easier calculation
        
        // Build 2D prefix sum
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = matrix[i - 1][j - 1]
                             + prefix[i - 1][j]
                             + prefix[i][j - 1]
                             - prefix[i - 1][j - 1];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        // Convert to 1-indexed
        row1++; col1++; row2++; col2++;
        
        return prefix[row2][col2]
             - prefix[row1 - 1][col2]
             - prefix[row2][col1 - 1]
             + prefix[row1 - 1][col1 - 1];
    }
}

public class Matrix2DPrefixSum {
    public static void main(String[] args) {
        int[][] matrix = {
            {3, 0, 1, 4, 2},
            {5, 6, 3, 2, 1},
            {1, 2, 0, 1, 5},
            {4, 1, 0, 1, 7},
            {1, 0, 3, 0, 5}
        };
        
        NumMatrix obj = new NumMatrix(matrix);
        System.out.println(obj.sumRegion(2, 1, 4, 3));  // 8
        System.out.println(obj.sumRegion(1, 1, 2, 2));  // 11
        System.out.println(obj.sumRegion(1, 2, 2, 4));  // 12
    }
}
```

**Time:** Constructor O(m × n), Query O(1)  
**Space:** O(m × n)

---

### Visual Explanation of 2D Range Sum

```
Query: Sum of rectangle from (row1, col1) to (row2, col2)

┌─────────────┬─────┐
│      A      │  B  │
├─────────────┼─────┤
│      C      │  D  │ ← Want sum of D
└─────────────┴─────┘

Sum(D) = prefix[row2][col2]           (A + B + C + D)
       - prefix[row1-1][col2]         (A + B)
       - prefix[row2][col1-1]         (A + C)
       + prefix[row1-1][col1-1]       (A) - added back
```

---

<a name="patterns"></a>
## 5. Common Patterns

### Pattern 1: Count Subarrays with Condition

```java
// Template: Count subarrays where sum meets condition
import java.util.*;

public class CountSubarrays {
    
    // Count subarrays with sum >= k
    public static int countSubarrays(int[] nums, int k) {
        Map<Integer, Integer> prefixCount = new HashMap<>();
        prefixCount.put(0, 1);
        
        int sum = 0;
        int count = 0;
        
        for (int num : nums) {
            sum += num;
            // Count based on condition
            for (int prevSum : prefixCount.keySet()) {
                if (sum - prevSum >= k) {
                    count += prefixCount.get(prevSum);
                }
            }
            prefixCount.put(sum, prefixCount.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
}
```

---

### Pattern 2: Multiple Range Updates

```java
// Template: Multiple range updates, single query
public class MultipleRangeUpdates {
    
    public static int[] applyUpdates(int n, int[][] updates) {
        int[] diff = new int[n];
        
        // Apply all updates - O(1) each
        for (int[] update : updates) {
            int left = update[0];
            int right = update[1];
            int value = update[2];
            
            diff[left] += value;
            if (right + 1 < n) {
                diff[right + 1] -= value;
            }
        }
        
        // Reconstruct - O(n)
        int[] result = new int[n];
        result[0] = diff[0];
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] + diff[i];
        }
        
        return result;
    }
}
```

---

### Pattern 3: XOR Prefix Sum

```java
import java.util.*;

public class XORPrefixSum {
    
    // XOR of subarray [left, right]
    public static int[] buildXORPrefix(int[] arr) {
        int n = arr.length;
        int[] prefix = new int[n];
        
        prefix[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] ^ arr[i];
        }
        
        return prefix;
    }
    
    public static int rangeXOR(int[] prefix, int left, int right) {
        if (left == 0) {
            return prefix[right];
        }
        return prefix[right] ^ prefix[left - 1];
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 8};
        int[] prefix = buildXORPrefix(arr);
        
        System.out.println(rangeXOR(prefix, 1, 2));  // 3 ^ 4 = 7
    }
}
```

**Property:** `XOR[L, R] = prefix[R] ^ prefix[L-1]`

---

<a name="when-to-use"></a>
## 6. When to Use What?

### Prefix Sum vs Difference Array

| Feature | Prefix Sum | Difference Array |
|---------|-----------|------------------|
| **Purpose** | Range queries | Range updates |
| **Operation** | Sum query O(1) | Update O(1) |
| **Best for** | Multiple queries | Multiple updates |
| **Queries after build** | Fast O(1) | Need reconstruction O(n) |
| **Updates after build** | Rebuild O(n) | Fast O(1) |
| **Use case** | Static array, many queries | Many updates, few queries |

---

### Decision Tree

```
Need to process ranges?
  ↓ YES
Multiple QUERIES on static array?
  ↓ YES → PREFIX SUM
Multiple UPDATES then query?
  ↓ YES → DIFFERENCE ARRAY
Need both queries AND updates?
  ↓ YES → Segment Tree / Fenwick Tree
```

---

### Comparison Table

| Problem Type | Technique | Example |
|--------------|-----------|---------|
| Range sum queries | Prefix Sum | Sum of subarray [L, R] |
| Count subarrays | Prefix Sum + HashMap | Subarray sum = k |
| Range updates | Difference Array | Add value to range |
| 2D range queries | 2D Prefix Sum | Sum of rectangle |
| Product queries | Prefix Product | Product except self |
| XOR queries | XOR Prefix | XOR of range |

---

<a name="interview-questions"></a>
## 7. Top 15 Interview Questions

### Q1: What's the difference between prefix sum and cumulative sum?

**Answer:** They're the same thing! Prefix sum = cumulative sum = running sum.

---

### Q2: How to handle negative numbers in prefix sum?

**Answer:** Prefix sum works fine with negatives!
```java
arr = [1, -2, 3]
prefix = [1, -1, 2]  // Works perfectly
```

---

### Q3: Can we use prefix sum for finding max subarray?

**Answer:** Not directly! Use Kadane's algorithm instead.
- Prefix sum: For exact sum queries
- Kadane's: For maximum sum

---

### Q4: Why add `prefix.put(0, 1)` in subarray sum problems?

**Answer:** Handles subarrays starting from index 0!
```java
arr = [1, 2, 3], k = 3
If we don't add (0, 1), we miss subarray [3]
```

---

### Q5: How to handle array with all zeros using difference array?

**Answer:** Difference array of all zeros is `[0, 0, 0, ...]`
```java
arr = [0, 0, 0]
diff = [0, 0, 0]
// Updates still work normally
```

---

### Q6: Can prefix sum reduce space to O(1)?

**Answer:** Yes, if only one query!
```java
// Don't build array, just calculate on the fly
int sum = 0;
for (int i = left; i <= right; i++) {
    sum += arr[i];
}
```

But defeats the purpose! Use when multiple queries needed.

---

### Q7: How to find if any subarray has sum 0?

**Answer:** Use prefix sum with HashSet!
```java
Set<Integer> seen = new HashSet<>();
seen.add(0);
int sum = 0;

for (int num : arr) {
    sum += num;
    if (seen.contains(sum)) return true;
    seen.add(sum);
}
return false;
```

---

### Q8: What if we need range queries AND updates?

**Answer:** Prefix sum and difference array won't work efficiently!
- ✅ Use **Segment Tree** (both operations O(log n))
- ✅ Use **Fenwick Tree** (both operations O(log n))

---

### Q9: Can we use prefix sum for product?

**Answer:** Yes! Prefix product:
```java
prefix[0] = arr[0]
prefix[i] = prefix[i-1] * arr[i]

rangeProduct(L, R) = prefix[R] / prefix[L-1]
```

**Caveat:** Division issues with zeros!

---

### Q10: How to handle modulo in prefix sum?

**Answer:** Apply modulo at each step:
```java
prefix[i] = (prefix[i-1] + arr[i]) % MOD;
```

**Important:** For subtraction, add MOD:
```java
result = ((prefix[R] - prefix[L-1]) % MOD + MOD) % MOD;
```

---

### Q11: Why use 1-indexed for 2D prefix sum?

**Answer:** Avoids boundary checks!
```java
// 0-indexed: Need to check i > 0, j > 0
if (i > 0) sum -= prefix[i-1][j];

// 1-indexed: No checks needed
sum -= prefix[i-1][j];  // Always safe
```

---

### Q12: Can difference array handle multiplication?

**Answer:** **No!** Difference array only works for addition/subtraction.
```java
// ✅ Works
diff[L] += value
diff[R+1] -= value

// ❌ Doesn't work
diff[L] *= value  // Wrong!
```

---

### Q13: How many range updates justify difference array?

**Answer:** If updates > 1, use difference array!
- 1 update: Direct update O(n) is fine
- Multiple updates: Difference array O(k) better than O(k×n)

---

### Q14: Can we combine prefix sum and difference array?

**Answer:** Yes! For complex scenarios:
```java
// Apply updates with difference array
// Then build prefix sum on result
// Now you can do both!
```

---

### Q15: What's the space complexity of 2D prefix sum?

**Answer:** O(m × n) - Same as matrix size
```java
prefix = new int[m+1][n+1];  // Extra row/col for easier calculation
```

---

<a name="practice-problems"></a>
## 8. Practice Problems with Solutions

### Problem 1: Find Pivot Index

**Problem:** Find index where left sum equals right sum.

**Example:** `[1, 7, 3, 6, 5, 6]` → `3` (left = 1+7+3 = 11, right = 5+6 = 11)

```java
public class PivotIndex {
    
    public static int pivotIndex(int[] nums) {
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }
        
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            // Right sum = total - left - current
            if (leftSum == totalSum - leftSum - nums[i]) {
                return i;
            }
            leftSum += nums[i];
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 7, 3, 6, 5, 6};
        System.out.println(pivotIndex(nums1));  // 3
        
        int[] nums2 = {1, 2, 3};
        System.out.println(pivotIndex(nums2));  // -1
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: Continuous Subarray Sum

**Problem:** Check if array has continuous subarray (size >= 2) with sum multiple of k.

**Example:** `[23, 2, 4, 6, 7], k = 6` → `true` ([2, 4] sum = 6)

```java
import java.util.*;

public class ContinuousSubarraySum {
    
    public static boolean checkSubarraySum(int[] nums, int k) {
        Map<Integer, Integer> remainderIndex = new HashMap<>();
        remainderIndex.put(0, -1);  // Remainder 0 at index -1
        
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            int remainder = sum % k;
            
            if (remainderIndex.containsKey(remainder)) {
                // Check if subarray length >= 2
                if (i - remainderIndex.get(remainder) >= 2) {
                    return true;
                }
            } else {
                remainderIndex.put(remainder, i);
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {23, 2, 4, 6, 7};
        System.out.println(checkSubarraySum(nums1, 6));  // true
        
        int[] nums2 = {23, 2, 6, 4, 7};
        System.out.println(checkSubarraySum(nums2, 6));  // true
    }
}
```

**Time:** O(n), **Space:** O(min(n, k))

---

### Problem 3: Car Pooling

**Problem:** Check if all passengers can be picked up with car capacity.

**Example:** `trips = [[2,1,5],[3,3,7]], capacity = 4` → `false`

```java
import java.util.*;

public class CarPooling {
    
    public static boolean carPooling(int[][] trips, int capacity) {
        // Find max location
        int maxLocation = 0;
        for (int[] trip : trips) {
            maxLocation = Math.max(maxLocation, trip[2]);
        }
        
        // Difference array
        int[] diff = new int[maxLocation + 1];
        
        for (int[] trip : trips) {
            int passengers = trip[0];
            int from = trip[1];
            int to = trip[2];
            
            diff[from] += passengers;
            diff[to] -= passengers;
        }
        
        // Check capacity at each location
        int currentPassengers = 0;
        for (int i = 0; i <= maxLocation; i++) {
            currentPassengers += diff[i];
            if (currentPassengers > capacity) {
                return false;
            }
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        int[][] trips1 = {{2, 1, 5}, {3, 3, 7}};
        System.out.println(carPooling(trips1, 4));  // false
        
        int[][] trips2 = {{2, 1, 5}, {3, 3, 7}};
        System.out.println(carPooling(trips2, 5));  // true
    }
}
```

**Time:** O(n + m) where m = max location, **Space:** O(m)

---

### Problem 4: Maximum Absolute Sum

**Problem:** Find maximum absolute sum of any subarray.

**Example:** `[1, -3, 2, 3, -4]` → `5` (subarray [2, 3])

```java
public class MaxAbsoluteSum {
    
    public static int maxAbsoluteSum(int[] nums) {
        int maxSum = 0;
        int minSum = 0;
        int currentMax = 0;
        int currentMin = 0;
        
        for (int num : nums) {
            currentMax = Math.max(num, currentMax + num);
            currentMin = Math.min(num, currentMin + num);
            
            maxSum = Math.max(maxSum, currentMax);
            minSum = Math.min(minSum, currentMin);
        }
        
        return Math.max(maxSum, Math.abs(minSum));
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, -3, 2, 3, -4};
        System.out.println(maxAbsoluteSum(nums1));  // 5
        
        int[] nums2 = {2, -5, 1, -4, 3, -2};
        System.out.println(maxAbsoluteSum(nums2));  // 8
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 5: Count Number of Nice Subarrays (Prefix Sum Approach)

**Problem:** Count subarrays with exactly k odd numbers.

**Example:** `nums = [1, 1, 2, 1, 1], k = 3` → `2`

```java
import java.util.*;

public class NiceSubarrays {
    
    public static int numberOfSubarrays(int[] nums, int k) {
        // Convert to 0s and 1s (even = 0, odd = 1)
        int[] arr = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            arr[i] = nums[i] % 2;
        }
        
        // Now find subarrays with sum = k
        Map<Integer, Integer> prefixCount = new HashMap<>();
        prefixCount.put(0, 1);
        
        int sum = 0;
        int count = 0;
        
        for (int num : arr) {
            sum += num;
            
            if (prefixCount.containsKey(sum - k)) {
                count += prefixCount.get(sum - k);
            }
            
            prefixCount.put(sum, prefixCount.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 1, 2, 1, 1};
        System.out.println(numberOfSubarrays(nums1, 3));  // 2
        
        int[] nums2 = {2, 2, 2, 1, 2, 2, 1, 2, 2, 2};
        System.out.println(numberOfSubarrays(nums2, 2));  // 16
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 6: Maximum Sum of Rectangle No Larger Than K

**Problem:** Find max sum of rectangle in 2D matrix not exceeding k.

**Example:** Complex 2D problem using prefix sum.

```java
import java.util.*;

public class MaxSumRectangle {
    
    public static int maxSumSubmatrix(int[][] matrix, int k) {
        int m = matrix.length;
        int n = matrix[0].length;
        int maxSum = Integer.MIN_VALUE;
        
        // Fix left and right columns
        for (int left = 0; left < n; left++) {
            int[] rowSum = new int[m];
            
            for (int right = left; right < n; right++) {
                // Add current column to rowSum
                for (int i = 0; i < m; i++) {
                    rowSum[i] += matrix[i][right];
                }
                
                // Find max subarray sum <= k in 1D array
                maxSum = Math.max(maxSum, maxSubarraySum(rowSum, k));
            }
        }
        
        return maxSum;
    }
    
    private static int maxSubarraySum(int[] arr, int k) {
        TreeSet<Integer> prefixSet = new TreeSet<>();
        prefixSet.add(0);
        
        int sum = 0;
        int maxSum = Integer.MIN_VALUE;
        
        for (int num : arr) {
            sum += num;
            
            // Find smallest prefix >= (sum - k)
            Integer ceiling = prefixSet.ceiling(sum - k);
            if (ceiling != null) {
                maxSum = Math.max(maxSum, sum - ceiling);
            }
            
            prefixSet.add(sum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1, 0, 1}, {0, -2, 3}};
        System.out.println(maxSumSubmatrix(matrix, 2));  // 2
    }
}
```

**Time:** O(n² × m log m), **Space:** O(m)

---

## Summary Cheat Sheet

### Quick Reference

| Operation | Prefix Sum | Difference Array |
|-----------|-----------|------------------|
| Build | O(n) | O(n) |
| Range Query | O(1) | O(n) reconstruct |
| Range Update | O(n) rebuild | O(1) |
| Best for | Many queries | Many updates |

---

### Common Formulas

```java
// Prefix Sum
prefix[i] = prefix[i-1] + arr[i]
rangeSum(L, R) = prefix[R] - prefix[L-1]

// Difference Array
diff[i] = arr[i] - arr[i-1]
rangeUpdate(L, R, val):
    diff[L] += val
    diff[R+1] -= val

// 2D Prefix Sum
prefix[i][j] = matrix[i][j] + prefix[i-1][j] 
             + prefix[i][j-1] - prefix[i-1][j-1]
```

---

## Key Takeaways

✅ **Prefix sum optimizes range queries:** O(n) → O(1)  
✅ **Difference array optimizes range updates:** O(n) → O(1)  
✅ **Prefix sum + HashMap:** Powerful for subarray problems  
✅ **Handle negatives:** Works fine in prefix sum  
✅ **Handle modulo:** Apply at each step, handle negatives  
✅ **2D prefix sum:** For rectangle range queries  
✅ **Space trade-off:** O(n) space for O(1) operations  
✅ **XOR prefix:** Same concept, different operation  
✅ **Multiple updates:** Difference array shines  
✅ **Static queries:** Prefix sum is perfect  

---

[← Back: Sliding Window](./Sliding-Window.md) | [Next: Kadane's Algorithm →](./Kadanes-Algorithm.md)
