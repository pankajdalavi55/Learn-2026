# Array Practice Problems - Complete Collection

## Why Practice Problems?

**Consolidate everything you've learned!**

- **70+ curated problems** covering all array techniques
- **Organized by difficulty:** Easy → Medium → Hard
- **Pattern-based grouping:** Master one pattern, solve 10 problems
- **Interview frequency:** Focus on most-asked questions
- **LeetCode references:** Direct links to practice

**Complete these = Master arrays for interviews!**

---

## Table of Contents

1. [Easy Problems (20)](#easy)
2. [Medium Problems (30)](#medium)
3. [Hard Problems (20)](#hard)
4. [Pattern-wise Classification](#patterns)
5. [Company-wise Problems](#companies)
6. [Problem-Solving Strategies](#strategies)

---

<a name="easy"></a>
## 1. Easy Problems (20 Problems)

### Problem 1: Two Sum (LeetCode 1)

**Difficulty:** Easy  
**Pattern:** HashMap, Two Pointers  
**Companies:** Amazon, Google, Microsoft

**Problem:** Find two numbers that add up to target.

**Solution:**
```java
public class TwoSum {
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[]{map.get(complement), i};
            }
            map.put(nums[i], i);
        }
        
        return new int[]{};
    }
    
    public static void main(String[] args) {
        int[] nums = {2, 7, 11, 15};
        int[] result = twoSum(nums, 9);
        System.out.println(Arrays.toString(result));  // [0, 1]
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 2: Best Time to Buy and Sell Stock (LeetCode 121)

**Difficulty:** Easy  
**Pattern:** Kadane's Algorithm  
**Companies:** Amazon, Microsoft, Facebook

**Problem:** Maximum profit from one buy and one sell.

**Solution:**
```java
public class BestTimeBuySell {
    public static int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        
        return maxProfit;
    }
    
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(maxProfit(prices));  // 5
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 3: Contains Duplicate (LeetCode 217)

**Difficulty:** Easy  
**Pattern:** HashSet  
**Companies:** Amazon, Microsoft

**Problem:** Check if any value appears at least twice.

**Solution:**
```java
public class ContainsDuplicate {
    public static boolean containsDuplicate(int[] nums) {
        Set<Integer> seen = new HashSet<>();
        
        for (int num : nums) {
            if (!seen.add(num)) {
                return true;
            }
        }
        
        return false;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 1};
        System.out.println(containsDuplicate(nums));  // true
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 4: Move Zeroes (LeetCode 283)

**Difficulty:** Easy  
**Pattern:** Two Pointers  
**Companies:** Facebook, Bloomberg

**Problem:** Move all 0's to end, maintain order.

**Solution:**
```java
public class MoveZeroes {
    public static void moveZeroes(int[] nums) {
        int writeIndex = 0;
        
        // Move non-zero elements forward
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[writeIndex++] = nums[i];
            }
        }
        
        // Fill remaining with zeros
        while (writeIndex < nums.length) {
            nums[writeIndex++] = 0;
        }
    }
    
    public static void main(String[] args) {
        int[] nums = {0, 1, 0, 3, 12};
        moveZeroes(nums);
        System.out.println(Arrays.toString(nums));  // [1, 3, 12, 0, 0]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 5: Majority Element (LeetCode 169)

**Difficulty:** Easy  
**Pattern:** Boyer-Moore Voting  
**Companies:** Google, Amazon

**Problem:** Find element appearing more than ⌊n/2⌋ times.

**Solution:**
```java
public class MajorityElement {
    public static int majorityElement(int[] nums) {
        int candidate = nums[0];
        int count = 0;
        
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
        
        return candidate;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, 2, 3};
        System.out.println(majorityElement(nums));  // 3
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 6: Single Number (LeetCode 136)

**Difficulty:** Easy  
**Pattern:** Bit Manipulation (XOR)  
**Companies:** Amazon, Google

**Problem:** Find number that appears once (others appear twice).

**Solution:**
```java
public class SingleNumber {
    public static int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;  // XOR cancels duplicates
        }
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {4, 1, 2, 1, 2};
        System.out.println(singleNumber(nums));  // 4
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 7: Missing Number (LeetCode 268)

**Difficulty:** Easy  
**Pattern:** Math, XOR  
**Companies:** Amazon, Microsoft

**Problem:** Find missing number from [0, n].

**Solution:**
```java
public class MissingNumber {
    // Method 1: XOR
    public static int missingNumber(int[] nums) {
        int result = nums.length;
        for (int i = 0; i < nums.length; i++) {
            result ^= i ^ nums[i];
        }
        return result;
    }
    
    // Method 2: Sum formula
    public static int missingNumberSum(int[] nums) {
        int n = nums.length;
        int expectedSum = n * (n + 1) / 2;
        int actualSum = 0;
        for (int num : nums) {
            actualSum += num;
        }
        return expectedSum - actualSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, 0, 1};
        System.out.println(missingNumber(nums));  // 2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 8: Intersection of Two Arrays (LeetCode 349)

**Difficulty:** Easy  
**Pattern:** HashSet  
**Companies:** Facebook

**Problem:** Find unique common elements.

**Solution:**
```java
public class IntersectionArrays {
    public static int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        for (int num : nums1) {
            set1.add(num);
        }
        
        Set<Integer> result = new HashSet<>();
        for (int num : nums2) {
            if (set1.contains(num)) {
                result.add(num);
            }
        }
        
        return result.stream().mapToInt(i -> i).toArray();
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 2, 2, 1};
        int[] nums2 = {2, 2};
        System.out.println(Arrays.toString(intersection(nums1, nums2)));  // [2]
    }
}
```

**Time:** O(n + m), **Space:** O(n)

---

### Problem 9: Valid Palindrome (LeetCode 125)

**Difficulty:** Easy  
**Pattern:** Two Pointers  
**Companies:** Facebook, Microsoft

**Problem:** Check if string is palindrome (alphanumeric only).

**Solution:**
```java
public class ValidPalindrome {
    public static boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isPalindrome("A man, a plan, a canal: Panama"));  // true
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 10: Reverse String (LeetCode 344)

**Difficulty:** Easy  
**Pattern:** Two Pointers  
**Companies:** Google

**Problem:** Reverse string in-place.

**Solution:**
```java
public class ReverseString {
    public static void reverseString(char[] s) {
        int left = 0, right = s.length - 1;
        
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        char[] s = {'h', 'e', 'l', 'l', 'o'};
        reverseString(s);
        System.out.println(Arrays.toString(s));  // [o, l, l, e, h]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Easy Problems Summary (11-20)

| # | Problem | Pattern | Difficulty |
|---|---------|---------|------------|
| 11 | **Plus One** (LeetCode 66) | Array Basics | Easy |
| 12 | **Merge Sorted Array** (LeetCode 88) | Two Pointers | Easy |
| 13 | **Remove Duplicates from Sorted Array** (LeetCode 26) | Two Pointers | Easy |
| 14 | **Search Insert Position** (LeetCode 35) | Binary Search | Easy |
| 15 | **Pascal's Triangle** (LeetCode 118) | Array Generation | Easy |
| 16 | **Maximum Subarray** (LeetCode 53) | Kadane's | Easy |
| 17 | **Squares of Sorted Array** (LeetCode 977) | Two Pointers | Easy |
| 18 | **Third Maximum Number** (LeetCode 414) | Array Traversal | Easy |
| 19 | **Find All Disappeared Numbers** (LeetCode 448) | Array Marking | Easy |
| 20 | **Majority Element II** (LeetCode 229) | Boyer-Moore | Easy/Medium |

---

<a name="medium"></a>
## 2. Medium Problems (30 Problems)

### Problem 21: 3Sum (LeetCode 15)

**Difficulty:** Medium  
**Pattern:** Two Pointers  
**Companies:** Amazon, Facebook, Google

**Problem:** Find all unique triplets that sum to zero.

**Solution:**
```java
public class ThreeSum {
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 2; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            int left = i + 1, right = nums.length - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum == 0) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    
                    left++;
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        System.out.println(threeSum(nums));  // [[-1, -1, 2], [-1, 0, 1]]
    }
}
```

**Time:** O(n²), **Space:** O(1) excluding result

---

### Problem 22: Container With Most Water (LeetCode 11)

**Difficulty:** Medium  
**Pattern:** Two Pointers  
**Companies:** Amazon, Facebook

**Problem:** Find two lines that form container with most water.

**Solution:**
```java
public class ContainerMostWater {
    public static int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int maxArea = 0;
        
        while (left < right) {
            int width = right - left;
            int h = Math.min(height[left], height[right]);
            maxArea = Math.max(maxArea, width * h);
            
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
    
    public static void main(String[] args) {
        int[] height = {1, 8, 6, 2, 5, 4, 8, 3, 7};
        System.out.println(maxArea(height));  // 49
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 23: Product of Array Except Self (LeetCode 238)

**Difficulty:** Medium  
**Pattern:** Prefix/Suffix Products  
**Companies:** Amazon, Microsoft, Facebook

**Problem:** Return array where output[i] is product of all except nums[i].

**Solution:**
```java
public class ProductExceptSelf {
    public static int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        // Left products
        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }
        
        // Right products
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] *= rightProduct;
            rightProduct *= nums[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4};
        System.out.println(Arrays.toString(productExceptSelf(nums)));  // [24, 12, 8, 6]
    }
}
```

**Time:** O(n), **Space:** O(1) excluding output

---

### Problem 24: Subarray Sum Equals K (LeetCode 560)

**Difficulty:** Medium  
**Pattern:** Prefix Sum + HashMap  
**Companies:** Facebook, Google

**Problem:** Count subarrays with sum equal to k.

**Solution:**
```java
public class SubarraySumK {
    public static int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSumCount = new HashMap<>();
        prefixSumCount.put(0, 1);
        
        int count = 0;
        int sum = 0;
        
        for (int num : nums) {
            sum += num;
            
            if (prefixSumCount.containsKey(sum - k)) {
                count += prefixSumCount.get(sum - k);
            }
            
            prefixSumCount.put(sum, prefixSumCount.getOrDefault(sum, 0) + 1);
        }
        
        return count;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 1, 1};
        System.out.println(subarraySum(nums, 2));  // 2
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 25: Longest Substring Without Repeating Characters (LeetCode 3)

**Difficulty:** Medium  
**Pattern:** Sliding Window  
**Companies:** Amazon, Google, Facebook

**Problem:** Find length of longest substring without repeating characters.

**Solution:**
```java
public class LongestSubstringNoRepeat {
    public static int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> lastSeen = new HashMap<>();
        int maxLength = 0;
        int start = 0;
        
        for (int end = 0; end < s.length(); end++) {
            char c = s.charAt(end);
            
            if (lastSeen.containsKey(c)) {
                start = Math.max(start, lastSeen.get(c) + 1);
            }
            
            lastSeen.put(c, end);
            maxLength = Math.max(maxLength, end - start + 1);
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        System.out.println(lengthOfLongestSubstring("abcabcbb"));  // 3
    }
}
```

**Time:** O(n), **Space:** O(min(n, charset size))

---

### Problem 26: Find All Duplicates in Array (LeetCode 442)

**Difficulty:** Medium  
**Pattern:** Array Marking  
**Companies:** Amazon

**Problem:** Find all duplicates (each appears twice) in O(n) time, O(1) space.

**Solution:**
```java
public class FindDuplicates {
    public static List<Integer> findDuplicates(int[] nums) {
        List<Integer> result = new ArrayList<>();
        
        for (int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i]) - 1;
            
            if (nums[index] < 0) {
                result.add(index + 1);
            } else {
                nums[index] = -nums[index];
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {4, 3, 2, 7, 8, 2, 3, 1};
        System.out.println(findDuplicates(nums));  // [2, 3]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 27: Rotate Array (LeetCode 189)

**Difficulty:** Medium  
**Pattern:** Array Rotation  
**Companies:** Microsoft, Amazon

**Problem:** Rotate array to right by k steps.

**Solution:**
```java
public class RotateArray {
    public static void rotate(int[] nums, int k) {
        k = k % nums.length;
        
        reverse(nums, 0, nums.length - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.length - 1);
    }
    
    private static void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6, 7};
        rotate(nums, 3);
        System.out.println(Arrays.toString(nums));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 28: Spiral Matrix (LeetCode 54)

**Difficulty:** Medium  
**Pattern:** Matrix Traversal  
**Companies:** Google, Microsoft

**Problem:** Return elements in spiral order.

**Solution:**
```java
public class SpiralMatrix {
    public static List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();
        if (matrix == null || matrix.length == 0) return result;
        
        int top = 0, bottom = matrix.length - 1;
        int left = 0, right = matrix[0].length - 1;
        
        while (top <= bottom && left <= right) {
            for (int j = left; j <= right; j++) result.add(matrix[top][j]);
            top++;
            
            for (int i = top; i <= bottom; i++) result.add(matrix[i][right]);
            right--;
            
            if (top <= bottom) {
                for (int j = right; j >= left; j--) result.add(matrix[bottom][j]);
                bottom--;
            }
            
            if (left <= right) {
                for (int i = bottom; i >= top; i--) result.add(matrix[i][left]);
                left++;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        System.out.println(spiralOrder(matrix));
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Problem 29: Set Matrix Zeroes (LeetCode 73)

**Difficulty:** Medium  
**Pattern:** Matrix Operations  
**Companies:** Amazon, Microsoft

**Problem:** Set entire row and column to 0 if element is 0.

**Solution:**
```java
public class SetMatrixZeroes {
    public static void setZeroes(int[][] matrix) {
        int rows = matrix.length, cols = matrix[0].length;
        boolean firstRowZero = false, firstColZero = false;
        
        for (int j = 0; j < cols; j++) {
            if (matrix[0][j] == 0) firstRowZero = true;
        }
        
        for (int i = 0; i < rows; i++) {
            if (matrix[i][0] == 0) firstColZero = true;
        }
        
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < cols; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        
        if (firstRowZero) {
            for (int j = 0; j < cols; j++) matrix[0][j] = 0;
        }
        
        if (firstColZero) {
            for (int i = 0; i < rows; i++) matrix[i][0] = 0;
        }
    }
}
```

**Time:** O(m × n), **Space:** O(1)

---

### Problem 30: Merge Intervals (LeetCode 56)

**Difficulty:** Medium  
**Pattern:** Sorting + Merging  
**Companies:** Facebook, Google, Amazon

**Problem:** Merge overlapping intervals.

**Solution:**
```java
public class MergeIntervals {
    public static int[][] merge(int[][] intervals) {
        if (intervals.length <= 1) return intervals;
        
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        
        List<int[]> result = new ArrayList<>();
        int[] current = intervals[0];
        result.add(current);
        
        for (int[] interval : intervals) {
            if (interval[0] <= current[1]) {
                current[1] = Math.max(current[1], interval[1]);
            } else {
                current = interval;
                result.add(current);
            }
        }
        
        return result.toArray(new int[result.size()][]);
    }
    
    public static void main(String[] args) {
        int[][] intervals = {{1, 3}, {2, 6}, {8, 10}, {15, 18}};
        int[][] result = merge(intervals);
        for (int[] interval : result) {
            System.out.println(Arrays.toString(interval));
        }
    }
}
```

**Time:** O(n log n), **Space:** O(n)

---

### Medium Problems Summary (31-50)

| # | Problem | Pattern | Companies |
|---|---------|---------|-----------|
| 31 | **Maximum Product Subarray** (LeetCode 152) | Kadane's Variant | Amazon |
| 32 | **Search in Rotated Sorted Array** (LeetCode 33) | Binary Search | Amazon, Microsoft |
| 33 | **Find First and Last Position** (LeetCode 34) | Binary Search | Facebook |
| 34 | **Permutations** (LeetCode 46) | Backtracking | Amazon |
| 35 | **Group Anagrams** (LeetCode 49) | HashMap | Amazon |
| 36 | **Jump Game** (LeetCode 55) | Greedy | Amazon |
| 37 | **Unique Paths** (LeetCode 62) | DP on Grid | Google |
| 38 | **Sort Colors** (LeetCode 75) | Dutch Flag | Amazon |
| 39 | **Search 2D Matrix II** (LeetCode 240) | Matrix Search | Amazon |
| 40 | **Rotate Image** (LeetCode 48) | Matrix Rotation | Microsoft |
| 41 | **Top K Frequent Elements** (LeetCode 347) | Heap/Bucket Sort | Amazon |
| 42 | **Kth Largest Element** (LeetCode 215) | Quickselect/Heap | Facebook |
| 43 | **Find Peak Element** (LeetCode 162) | Binary Search | Google |
| 44 | **Sliding Window Maximum** (LeetCode 239) | Deque | Amazon |
| 45 | **Longest Consecutive Sequence** (LeetCode 128) | HashSet | Google |
| 46 | **Next Permutation** (LeetCode 31) | Array Manipulation | Google |
| 47 | **Valid Sudoku** (LeetCode 36) | Matrix Validation | Amazon |
| 48 | **Maximum Sum Circular Subarray** (LeetCode 918) | Kadane's | Google |
| 49 | **Number of Islands** (LeetCode 200) | DFS/BFS on Matrix | Amazon |
| 50 | **Fruit Into Baskets** (LeetCode 904) | Sliding Window | Amazon |

---

<a name="hard"></a>
## 3. Hard Problems (20 Problems)

### Problem 51: Trapping Rain Water (LeetCode 42)

**Difficulty:** Hard  
**Pattern:** Two Pointers / Stack  
**Companies:** Google, Amazon, Facebook

**Problem:** Calculate total water trapped after raining.

**Solution:**
```java
public class TrappingRainWater {
    public static int trap(int[] height) {
        if (height == null || height.length == 0) return 0;
        
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        int water = 0;
        
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    water += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    water += rightMax - height[right];
                }
                right--;
            }
        }
        
        return water;
    }
    
    public static void main(String[] args) {
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(trap(height));  // 6
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 52: Median of Two Sorted Arrays (LeetCode 4)

**Difficulty:** Hard  
**Pattern:** Binary Search  
**Companies:** Google, Amazon

**Problem:** Find median of two sorted arrays in O(log(m+n)).

**Solution:**
```java
public class MedianTwoSortedArrays {
    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        
        int m = nums1.length, n = nums2.length;
        int left = 0, right = m;
        
        while (left <= right) {
            int partition1 = (left + right) / 2;
            int partition2 = (m + n + 1) / 2 - partition1;
            
            int maxLeft1 = (partition1 == 0) ? Integer.MIN_VALUE : nums1[partition1 - 1];
            int minRight1 = (partition1 == m) ? Integer.MAX_VALUE : nums1[partition1];
            
            int maxLeft2 = (partition2 == 0) ? Integer.MIN_VALUE : nums2[partition2 - 1];
            int minRight2 = (partition2 == n) ? Integer.MAX_VALUE : nums2[partition2];
            
            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
                if ((m + n) % 2 == 0) {
                    return (Math.max(maxLeft1, maxLeft2) + Math.min(minRight1, minRight2)) / 2.0;
                } else {
                    return Math.max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 > minRight2) {
                right = partition1 - 1;
            } else {
                left = partition1 + 1;
            }
        }
        
        throw new IllegalArgumentException();
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, 3};
        int[] nums2 = {2};
        System.out.println(findMedianSortedArrays(nums1, nums2));  // 2.0
    }
}
```

**Time:** O(log(min(m, n))), **Space:** O(1)

---

### Problem 53: Minimum Window Substring (LeetCode 76)

**Difficulty:** Hard  
**Pattern:** Sliding Window  
**Companies:** Facebook, Amazon

**Problem:** Find minimum window in s containing all characters of t.

**Solution:**
```java
public class MinWindowSubstring {
    public static String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return "";
        
        Map<Character, Integer> tCount = new HashMap<>();
        for (char c : t.toCharArray()) {
            tCount.put(c, tCount.getOrDefault(c, 0) + 1);
        }
        
        int required = tCount.size();
        int formed = 0;
        Map<Character, Integer> windowCount = new HashMap<>();
        
        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int minLeft = 0;
        
        while (right < s.length()) {
            char c = s.charAt(right);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
            
            if (tCount.containsKey(c) && 
                windowCount.get(c).intValue() == tCount.get(c).intValue()) {
                formed++;
            }
            
            while (left <= right && formed == required) {
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minLeft = left;
                }
                
                char leftChar = s.charAt(left);
                windowCount.put(leftChar, windowCount.get(leftChar) - 1);
                if (tCount.containsKey(leftChar) && 
                    windowCount.get(leftChar) < tCount.get(leftChar)) {
                    formed--;
                }
                left++;
            }
            
            right++;
        }
        
        return minLen == Integer.MAX_VALUE ? "" : s.substring(minLeft, minLeft + minLen);
    }
    
    public static void main(String[] args) {
        System.out.println(minWindow("ADOBECODEBANC", "ABC"));  // "BANC"
    }
}
```

**Time:** O(|S| + |T|), **Space:** O(|S| + |T|)

---

### Problem 54: Largest Rectangle in Histogram (LeetCode 84)

**Difficulty:** Hard  
**Pattern:** Stack  
**Companies:** Google, Amazon

**Problem:** Find largest rectangle in histogram.

**Solution:**
```java
public class LargestRectangleHistogram {
    public static int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int index = 0;
        
        while (index < heights.length) {
            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {
                stack.push(index++);
            } else {
                int top = stack.pop();
                int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
                maxArea = Math.max(maxArea, area);
            }
        }
        
        while (!stack.isEmpty()) {
            int top = stack.pop();
            int area = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
            maxArea = Math.max(maxArea, area);
        }
        
        return maxArea;
    }
    
    public static void main(String[] args) {
        int[] heights = {2, 1, 5, 6, 2, 3};
        System.out.println(largestRectangleArea(heights));  // 10
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 55: First Missing Positive (LeetCode 41)

**Difficulty:** Hard  
**Pattern:** Array Marking  
**Companies:** Amazon

**Problem:** Find smallest missing positive integer in O(n) time, O(1) space.

**Solution:**
```java
public class FirstMissingPositive {
    public static int firstMissingPositive(int[] nums) {
        int n = nums.length;
        
        // Place each number in its right place
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        
        // Find first missing
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        return n + 1;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, 4, -1, 1};
        System.out.println(firstMissingPositive(nums));  // 2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Hard Problems Summary (56-70)

| # | Problem | Pattern | Companies |
|---|---------|---------|-----------|
| 56 | **Maximal Rectangle** (LeetCode 85) | Stack + DP | Google |
| 57 | **Merge K Sorted Lists** (LeetCode 23) | Heap/Divide&Conquer | Amazon |
| 58 | **Count of Smaller After Self** (LeetCode 315) | Merge Sort/BIT | Google |
| 59 | **Russian Doll Envelopes** (LeetCode 354) | DP + Binary Search | Google |
| 60 | **Max Sum Rectangle** (LeetCode 363) | Kadane's 2D | Google |
| 61 | **Candy** (LeetCode 135) | Greedy | Amazon |
| 62 | **Jump Game II** (LeetCode 45) | Greedy | Amazon |
| 63 | **Sliding Window Median** (LeetCode 480) | Two Heaps | Google |
| 64 | **Longest Increasing Path** (LeetCode 329) | DFS + Memoization | Google |
| 65 | **Word Break II** (LeetCode 140) | DP + Backtracking | Amazon |
| 66 | **Regular Expression Matching** (LeetCode 10) | DP | Google |
| 67 | **Edit Distance** (LeetCode 72) | DP | Amazon |
| 68 | **Interleaving String** (LeetCode 97) | DP | Amazon |
| 69 | **Dungeon Game** (LeetCode 174) | DP | Microsoft |
| 70 | **Maximum Gap** (LeetCode 164) | Bucket Sort | Amazon |

---

<a name="patterns"></a>
## 4. Pattern-wise Classification

### Two Pointers Pattern (15 problems)

**When to use:** 
- Sorted array
- Find pairs/triplets
- Palindrome problems
- In-place operations

**Problems:**
1. Two Sum (sorted)
2. 3Sum
3. 4Sum
4. Container With Most Water
5. Trapping Rain Water
6. Move Zeroes
7. Remove Duplicates
8. Valid Palindrome
9. Reverse String
10. Squares of Sorted Array
11. Sort Colors (Dutch Flag)
12. Merge Sorted Arrays
13. Intersection of Two Arrays
14. Boats to Save People
15. Valid Palindrome II

---

### Sliding Window Pattern (12 problems)

**When to use:**
- Contiguous subarray/substring
- Fixed or variable window
- Min/max window size

**Problems:**
1. Longest Substring Without Repeating
2. Minimum Window Substring
3. Longest Substring with K Distinct
4. Max Sum Subarray of Size K
5. Sliding Window Maximum
6. Fruit Into Baskets
7. Permutation in String
8. Find All Anagrams
9. Character Replacement
10. Minimum Size Subarray Sum
11. Subarrays with K Different Integers
12. Sliding Window Median

---

### Prefix Sum Pattern (10 problems)

**When to use:**
- Range sum queries
- Subarray sum problems
- Cumulative operations

**Problems:**
1. Subarray Sum Equals K
2. Continuous Subarray Sum
3. Find Pivot Index
4. Product Except Self
5. Range Sum Query
6. Subarray Sums Divisible by K
7. Binary Subarrays With Sum
8. Count Nice Subarrays
9. Maximum Size Subarray Sum Equals K
10. Contiguous Array

---

### Kadane's Algorithm Pattern (8 problems)

**When to use:**
- Maximum/minimum subarray
- Product instead of sum
- Circular arrays

**Problems:**
1. Maximum Subarray
2. Maximum Product Subarray
3. Maximum Sum Circular Subarray
4. Best Time to Buy and Sell Stock
5. Maximum Absolute Sum
6. Longest Turbulent Subarray
7. K Concatenation Maximum Sum
8. Maximum Subarray Sum After One Operation

---

### Matrix Operations Pattern (15 problems)

**When to use:**
- 2D grids
- Spiral/diagonal traversal
- Matrix transformation
- Island/region problems

**Problems:**
1. Spiral Matrix
2. Spiral Matrix II
3. Rotate Image
4. Set Matrix Zeroes
5. Search 2D Matrix
6. Search 2D Matrix II
7. Valid Sudoku
8. Number of Islands
9. Surrounded Regions
10. Pacific Atlantic Water Flow
11. Word Search
12. Diagonal Traverse
13. Maximal Rectangle
14. Maximal Square
15. Flood Fill

---

### Binary Search on Array Pattern (10 problems)

**When to use:**
- Sorted array
- Find position/range
- Rotated sorted array

**Problems:**
1. Binary Search
2. Search Insert Position
3. Find First and Last Position
4. Search in Rotated Sorted Array
5. Search in Rotated Sorted Array II
6. Find Minimum in Rotated Sorted Array
7. Find Peak Element
8. Median of Two Sorted Arrays
9. Kth Smallest in Sorted Matrix
10. Split Array Largest Sum

---

### Array Marking Pattern (8 problems)

**When to use:**
- Limited range [1, n]
- O(1) space requirement
- In-place marking

**Problems:**
1. Find All Duplicates
2. Find All Disappeared Numbers
3. First Missing Positive
4. Set Mismatch
5. Array Nesting
6. Find the Duplicate Number
7. Missing Number
8. Single Number variations

---

<a name="companies"></a>
## 5. Company-wise Popular Problems

### Amazon (20 most asked)

1. Two Sum
2. 3Sum
3. Container With Most Water
4. Best Time to Buy and Sell Stock
5. Product of Array Except Self
6. Trapping Rain Water
7. Merge Intervals
8. Rotate Array
9. Subarray Sum Equals K
10. Maximum Subarray
11. Move Zeroes
12. Sort Colors
13. Top K Frequent Elements
14. Number of Islands
15. Word Search
16. Jump Game
17. Search in Rotated Sorted Array
18. First Missing Positive
19. Meeting Rooms II
20. Longest Substring Without Repeating

---

### Google (20 most asked)

1. Longest Substring Without Repeating
2. Median of Two Sorted Arrays
3. Container With Most Water
4. 3Sum
5. Next Permutation
6. Trapping Rain Water
7. Spiral Matrix
8. Jump Game
9. Merge Intervals
10. Unique Paths
11. Maximum Subarray
12. Search 2D Matrix
13. Largest Rectangle in Histogram
14. Maximal Rectangle
15. Best Time to Buy and Sell Stock
16. Longest Consecutive Sequence
17. Product of Array Except Self
18. Find Peak Element
19. Maximum Sum Circular Subarray
20. Count of Smaller Numbers After Self

---

### Facebook (15 most asked)

1. 3Sum
2. Subarray Sum Equals K
3. Product of Array Except Self
4. Move Zeroes
5. Merge Intervals
6. Best Time to Buy and Sell Stock
7. Container With Most Water
8. Valid Palindrome
9. Minimum Window Substring
10. Trapping Rain Water
11. Find First and Last Position
12. Kth Largest Element
13. Top K Frequent Elements
14. Maximum Subarray
15. Longest Consecutive Sequence

---

### Microsoft (15 most asked)

1. Two Sum
2. Best Time to Buy and Sell Stock
3. Rotate Array
4. Contains Duplicate
5. Merge Sorted Array
6. Search in Rotated Sorted Array
7. Spiral Matrix
8. Set Matrix Zeroes
9. Rotate Image
10. Maximum Product Subarray
11. Find Peak Element
12. Intersection of Two Arrays
13. Valid Sudoku
14. Product of Array Except Self
15. Jump Game

---

<a name="strategies"></a>
## 6. Problem-Solving Strategies

### Strategy 1: Pattern Recognition

**Ask yourself:**
1. **Is array sorted?** → Binary Search, Two Pointers
2. **Need contiguous elements?** → Sliding Window, Kadane's
3. **Need range queries?** → Prefix Sum
4. **Matrix problem?** → Check for spiral, rotation, search patterns
5. **Find duplicates/missing?** → Array marking, XOR, HashSet
6. **Need pairs/triplets?** → Two Pointers after sorting

---

### Strategy 2: Time/Space Trade-offs

| Pattern | Time | Space | When to Use |
|---------|------|-------|-------------|
| **Brute Force** | O(n²) | O(1) | Small input, need simple solution |
| **HashMap** | O(n) | O(n) | Need fast lookup, space available |
| **Two Pointers** | O(n) | O(1) | Sorted array, in-place |
| **Sliding Window** | O(n) | O(k) | Contiguous subarray |
| **Prefix Sum** | O(n) | O(n) | Multiple range queries |
| **Binary Search** | O(log n) | O(1) | Sorted array |

---

### Strategy 3: Edge Cases Checklist

✅ **Always check:**
- Empty array: `nums.length == 0`
- Single element: `nums.length == 1`
- All same elements: `[5, 5, 5, 5]`
- All negative/positive
- Duplicates
- Integer overflow
- Sorted vs unsorted
- k > n (for rotation, top k, etc.)

---

### Strategy 4: Optimization Steps

**Step 1:** Get brute force working  
**Step 2:** Identify bottleneck  
**Step 3:** Apply pattern:
- Nested loops → Two Pointers or HashMap
- Repeated range sums → Prefix Sum
- Repeated subarray checks → Sliding Window
- Linear search in sorted → Binary Search

**Step 4:** Optimize space if needed

---

### Strategy 5: Common Tricks

**Trick 1: Use array itself as HashMap**
- For range [1, n]: Use index as key, negate values

**Trick 2: Two-pass solutions**
- Pass 1: Collect info (prefix products, max from left)
- Pass 2: Use info (suffix products, max from right)

**Trick 3: Dummy boundaries**
- Add sentinel values to avoid edge case checks

**Trick 4: XOR for duplicates**
- a ^ a = 0, a ^ 0 = a

**Trick 5: Sort first if O(n log n) acceptable**
- Often simplifies logic dramatically

---

## Quick Reference Cheat Sheet

### Pattern Selection Guide

```
┌─ Sorted Array? ─────────────────┐
│  Yes: Binary Search, Two Pointers│
│  No:  Continue →                 │
└──────────────────────────────────┘
           ↓
┌─ Need contiguous subarray? ─────┐
│  Yes: Sliding Window, Kadane's   │
│  No:  Continue →                 │
└──────────────────────────────────┘
           ↓
┌─ Range sum queries? ─────────────┐
│  Yes: Prefix Sum                 │
│  No:  Continue →                 │
└──────────────────────────────────┘
           ↓
┌─ 2D Matrix? ─────────────────────┐
│  Yes: Matrix patterns            │
│  No:  HashMap / Other            │
└──────────────────────────────────┘
```

---

### Complexity Goals

| Problem Type | Target Time | Target Space |
|--------------|-------------|--------------|
| **Search** | O(log n) | O(1) |
| **Subarray Sum** | O(n) | O(n) |
| **Find Duplicates** | O(n) | O(1) |
| **Matrix Traversal** | O(m×n) | O(1) |
| **Sorting Required** | O(n log n) | O(1) or O(n) |

---

## Key Takeaways

✅ **Master 8 core patterns** - Covers 90% of array problems  
✅ **Two Pointers** - Most versatile for sorted arrays  
✅ **Sliding Window** - Go-to for contiguous subarrays  
✅ **Prefix Sum** - Essential for range queries  
✅ **Kadane's** - All max/min subarray problems  
✅ **Matrix patterns** - Spiral, rotation, search  
✅ **HashMap** - Trade space for time  
✅ **Always optimize** - O(n²) → O(n) → O(log n)  
✅ **Practice 100+ problems** - Pattern recognition comes with practice  
✅ **Focus on company-specific** - Amazon, Google, Facebook lists  

---

**Total Problems:** 70+ curated problems  
**Patterns Covered:** 8 major patterns  
**Companies:** FAANG + Microsoft focus  
**Difficulty Mix:** 20 Easy, 30 Medium, 20 Hard  

---

[← Back: Matrix Operations](./3.7-Matrix-Operations.md) | [Next: Strings →](../04-Strings/)
