# Two Pointer Technique - Master Guide

## Why Two Pointers?

**40% of array problems use Two Pointers!**

- **Reduces time complexity:** O(n²) → O(n)
- **Reduces space complexity:** O(n) → O(1)
- **Essential for:** Sorted arrays, palindromes, pairs, subarrays
- **Foundation for:** Sliding Window, Fast/Slow pointers

**Master this = Solve hundreds of problems!**

---

## Table of Contents

1. [What is Two Pointer Technique?](#what-is)
2. [Types of Two Pointers](#types)
3. [Pattern Recognition](#recognition)
4. [Opposite Direction Pointers](#opposite)
5. [Same Direction Pointers](#same-direction)
6. [Multiple Arrays Two Pointers](#multiple)
7. [Common Patterns & Templates](#templates)
8. [Time/Space Complexity](#complexity)
9. [When NOT to Use](#when-not)
10. [Interview Questions](#interview-questions)
11. [Practice Problems](#practice-problems)

---

<a name="what-is"></a>
## 1. What is Two Pointer Technique?

**Concept:** Use two pointers to traverse array/string simultaneously, reducing nested loops.

### Without Two Pointers (Brute Force)

```java
// Find pair with target sum - O(n²)
public class BruteForce {
    public static int[] twoSumBrute(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] + arr[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{-1, -1};
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### With Two Pointers (Optimized)

```java
// Find pair with target sum - O(n)
public class TwoPointers {
    public static int[] twoSum(int[] arr, int target) {
        // IMPORTANT: Array must be sorted!
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int sum = arr[left] + arr[right];
            
            if (sum == target) {
                return new int[]{left, right};
            } else if (sum < target) {
                left++;  // Need larger sum
            } else {
                right--; // Need smaller sum
            }
        }
        
        return new int[]{-1, -1};
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 6, 8, 9};  // Sorted!
        int[] result = twoSum(arr, 10);
        System.out.println(Arrays.toString(result));  // [1, 5] (2 + 8 = 10)
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="types"></a>
## 2. Types of Two Pointers

### Type 1: Opposite Direction (Left ← → Right)

```
Start:  [1, 2, 3, 4, 5, 6]
         ↑              ↑
        left          right

Move:   [1, 2, 3, 4, 5, 6]
            ↑        ↑
           left    right

End:    [1, 2, 3, 4, 5, 6]
               ↑↑
            left right (crossed)
```

**Use Cases:**
- Palindrome check
- Two Sum (sorted array)
- Container with most water
- Reverse array
- Pair problems

---

### Type 2: Same Direction (Slow → Fast)

```
Start:  [1, 2, 3, 4, 5, 6]
         ↑
       slow/fast

Move:   [1, 2, 3, 4, 5, 6]
         ↑     ↑
       slow   fast

End:    [1, 2, 3, 4, 5, 6]
                  ↑        ↑
                slow      fast
```

**Use Cases:**
- Remove duplicates
- Move zeros
- Partition array
- Floyd's cycle detection

---

### Type 3: Multiple Arrays

```
arr1:   [1, 3, 5, 7]
         ↑
         i

arr2:   [2, 4, 6, 8]
         ↑
         j

Merge both arrays using two pointers
```

**Use Cases:**
- Merge sorted arrays
- Intersection/union of arrays
- Compare two arrays

---

<a name="recognition"></a>
## 3. Pattern Recognition - When to Use Two Pointers?

✅ **Use Two Pointers when you see:**

| Pattern | Indicator | Example |
|---------|-----------|---------|
| **Sorted array** | Array is sorted or can be sorted | Two Sum, 3Sum |
| **Pair/Triplet** | Find pairs that satisfy condition | Pair with target sum |
| **Palindrome** | Check symmetry | Valid palindrome |
| **In-place** | Modify array without extra space | Remove duplicates |
| **Partition** | Separate elements by condition | Move zeros |
| **Merge** | Combine two sorted arrays | Merge sorted arrays |
| **Subarray** | Find contiguous elements | Container with water |

---

<a name="opposite"></a>
## 4. Opposite Direction Pointers

### Pattern 1: Palindrome Check

```java
public class PalindromeCheck {
    
    // Check if string is palindrome
    public static boolean isPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    // Valid palindrome (ignore non-alphanumeric)
    public static boolean isPalindromeIgnoreSpecial(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            // Skip non-alphanumeric from left
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            
            // Skip non-alphanumeric from right
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            // Compare (case-insensitive)
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(isPalindrome("racecar"));  // true
        System.out.println(isPalindrome("hello"));    // false
        
        System.out.println(isPalindromeIgnoreSpecial("A man, a plan, a canal: Panama"));  // true
        System.out.println(isPalindromeIgnoreSpecial("race a car"));  // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 2: Two Sum (Sorted Array)

```java
import java.util.*;

public class TwoSumSorted {
    
    // Find indices of two numbers that add up to target
    public static int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        
        while (left < right) {
            int sum = numbers[left] + numbers[right];
            
            if (sum == target) {
                return new int[]{left + 1, right + 1};  // 1-indexed
            } else if (sum < target) {
                left++;  // Need larger sum
            } else {
                right--; // Need smaller sum
            }
        }
        
        return new int[]{-1, -1};
    }
    
    // Find all pairs with target sum
    public static List<int[]> twoSumAllPairs(int[] arr, int target) {
        List<int[]> result = new ArrayList<>();
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int sum = arr[left] + arr[right];
            
            if (sum == target) {
                result.add(new int[]{arr[left], arr[right]});
                left++;
                right--;
                
                // Skip duplicates
                while (left < right && arr[left] == arr[left - 1]) left++;
                while (left < right && arr[right] == arr[right + 1]) right--;
                
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 6, 8, 9};
        System.out.println(Arrays.toString(twoSum(arr, 10)));  // [2, 6] (1-indexed)
        
        int[] arr2 = {1, 2, 2, 3, 4, 4, 6};
        List<int[]> pairs = twoSumAllPairs(arr2, 6);
        for (int[] pair : pairs) {
            System.out.println(Arrays.toString(pair));
        }
        // [2, 4]
        // [2, 4]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3: Container with Most Water

```java
public class ContainerWithWater {
    
    // Find maximum water container can hold
    public static int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxWater = 0;
        
        while (left < right) {
            // Water = min height × width
            int width = right - left;
            int minHeight = Math.min(height[left], height[right]);
            int water = width * minHeight;
            
            maxWater = Math.max(maxWater, water);
            
            // Move pointer with smaller height
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxWater;
    }
    
    public static void main(String[] args) {
        int[] height = {1, 8, 6, 2, 5, 4, 8, 3, 7};
        System.out.println(maxArea(height));  // 49
        // Max water between index 1 (height 8) and index 8 (height 7)
        // Water = 7 × 7 = 49
    }
}
```

**Time:** O(n), **Space:** O(1)

**Why it works:** Moving the smaller height pointer might find a taller bar, increasing area. Moving the taller pointer will only decrease width with no chance of increasing area.

---

### Pattern 4: 3Sum (Find Triplets)

```java
import java.util.*;

public class ThreeSum {
    
    // Find all unique triplets that sum to zero
    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        
        // Sort array
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for first element
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            // Two pointer approach for remaining two elements
            int left = i + 1;
            int right = nums.length - 1;
            int target = -nums[i];
            
            while (left < right) {
                int sum = nums[left] + nums[right];
                
                if (sum == target) {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    // Skip duplicates
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    
                    left++;
                    right--;
                    
                } else if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {-1, 0, 1, 2, -1, -4};
        List<List<Integer>> result = threeSum(nums);
        System.out.println(result);
        // [[-1, -1, 2], [-1, 0, 1]]
    }
}
```

**Time:** O(n²), **Space:** O(1) (excluding output)

---

### Pattern 5: Reverse Array/String

```java
import java.util.*;

public class ReverseArray {
    
    // Reverse entire array
    public static void reverse(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            // Swap
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            
            left++;
            right--;
        }
    }
    
    // Reverse substring
    public static String reverseString(String s, int start, int end) {
        char[] chars = s.toCharArray();
        
        while (start < end) {
            char temp = chars[start];
            chars[start] = chars[end];
            chars[end] = temp;
            start++;
            end--;
        }
        
        return new String(chars);
    }
    
    // Reverse words in string
    public static String reverseWords(String s) {
        // Split by spaces
        String[] words = s.trim().split("\\s+");
        
        int left = 0;
        int right = words.length - 1;
        
        while (left < right) {
            String temp = words[left];
            words[left] = words[right];
            words[right] = temp;
            left++;
            right--;
        }
        
        return String.join(" ", words);
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        reverse(arr);
        System.out.println(Arrays.toString(arr));  // [5, 4, 3, 2, 1]
        
        System.out.println(reverseString("hello", 1, 3));  // hlelo
        
        System.out.println(reverseWords("the sky is blue"));  // "blue is sky the"
    }
}
```

**Time:** O(n), **Space:** O(1) or O(n) for string

---

<a name="same-direction"></a>
## 5. Same Direction Pointers (Slow-Fast)

### Pattern 1: Remove Duplicates (Sorted Array)

```java
import java.util.*;

public class RemoveDuplicates {
    
    // Remove duplicates in-place, return new length
    public static int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        
        int slow = 0;  // Position of last unique element
        
        for (int fast = 1; fast < nums.length; fast++) {
            if (nums[fast] != nums[slow]) {
                slow++;
                nums[slow] = nums[fast];
            }
        }
        
        return slow + 1;  // New length
    }
    
    // Allow duplicates at most twice
    public static int removeDuplicatesAllowTwo(int[] nums) {
        if (nums.length <= 2) return nums.length;
        
        int slow = 2;  // First two elements always valid
        
        for (int fast = 2; fast < nums.length; fast++) {
            // Compare with element 2 positions back
            if (nums[fast] != nums[slow - 2]) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        
        return slow;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 1, 2, 2, 3, 4, 4, 5};
        int len1 = removeDuplicates(arr1);
        System.out.println(Arrays.toString(Arrays.copyOf(arr1, len1)));
        // [1, 2, 3, 4, 5]
        
        int[] arr2 = {1, 1, 1, 2, 2, 3};
        int len2 = removeDuplicatesAllowTwo(arr2);
        System.out.println(Arrays.toString(Arrays.copyOf(arr2, len2)));
        // [1, 1, 2, 2, 3]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 2: Move Zeros to End

```java
import java.util.*;

public class MoveZeros {
    
    // Move all zeros to end, maintain order of non-zeros
    public static void moveZeroes(int[] nums) {
        int slow = 0;  // Position to place next non-zero
        
        // Move all non-zeros to front
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        
        // Fill remaining with zeros
        while (slow < nums.length) {
            nums[slow] = 0;
            slow++;
        }
    }
    
    // Alternative: Swap-based (fewer writes)
    public static void moveZeroesSwap(int[] nums) {
        int slow = 0;
        
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                // Swap
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {0, 1, 0, 3, 12, 0, 5};
        moveZeroes(arr);
        System.out.println(Arrays.toString(arr));
        // [1, 3, 12, 5, 0, 0, 0]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3: Partition Array (Dutch National Flag)

```java
import java.util.*;

public class PartitionArray {
    
    // Partition: elements < x, then x, then > x
    public static void partition(int[] arr, int x) {
        int slow = 0;  // Boundary for elements < x
        
        // Move all elements < x to front
        for (int fast = 0; fast < arr.length; fast++) {
            if (arr[fast] < x) {
                int temp = arr[slow];
                arr[slow] = arr[fast];
                arr[fast] = temp;
                slow++;
            }
        }
    }
    
    // Sort colors: 0s, 1s, 2s (Dutch National Flag)
    public static void sortColors(int[] nums) {
        int low = 0;   // Boundary for 0s
        int mid = 0;   // Current element
        int high = nums.length - 1;  // Boundary for 2s
        
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low, mid);
                low++;
                mid++;
            } else if (nums[mid] == 1) {
                mid++;
            } else {  // nums[mid] == 2
                swap(nums, mid, high);
                high--;
                // Don't increment mid (check swapped element)
            }
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {5, 2, 8, 3, 9, 1, 7};
        partition(arr1, 5);
        System.out.println(Arrays.toString(arr1));
        // [2, 3, 1, 5, 9, 8, 7] (< 5, then >= 5)
        
        int[] arr2 = {2, 0, 2, 1, 1, 0};
        sortColors(arr2);
        System.out.println(Arrays.toString(arr2));
        // [0, 0, 1, 1, 2, 2]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 4: Remove Element

```java
import java.util.*;

public class RemoveElement {
    
    // Remove all occurrences of val, return new length
    public static int removeElement(int[] nums, int val) {
        int slow = 0;
        
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        
        return slow;
    }
    
    // Alternative: Swap with last element (when order doesn't matter)
    public static int removeElementSwap(int[] nums, int val) {
        int i = 0;
        int n = nums.length;
        
        while (i < n) {
            if (nums[i] == val) {
                nums[i] = nums[n - 1];
                n--;  // Reduce size
            } else {
                i++;
            }
        }
        
        return n;
    }
    
    public static void main(String[] args) {
        int[] arr = {3, 2, 2, 3, 4, 5, 3};
        int len = removeElement(arr, 3);
        System.out.println(Arrays.toString(Arrays.copyOf(arr, len)));
        // [2, 2, 4, 5]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="multiple"></a>
## 6. Multiple Arrays Two Pointers

### Pattern 1: Merge Two Sorted Arrays

```java
import java.util.*;

public class MergeSortedArrays {
    
    // Merge arr2 into arr1 (arr1 has enough space)
    public static void merge(int[] arr1, int m, int[] arr2, int n) {
        int i = m - 1;      // Last element in arr1
        int j = n - 1;      // Last element in arr2
        int k = m + n - 1;  // Last position in merged array
        
        // Merge from end to beginning
        while (i >= 0 && j >= 0) {
            if (arr1[i] > arr2[j]) {
                arr1[k--] = arr1[i--];
            } else {
                arr1[k--] = arr2[j--];
            }
        }
        
        // Copy remaining from arr2
        while (j >= 0) {
            arr1[k--] = arr2[j--];
        }
    }
    
    // Create new merged array
    public static int[] mergeNew(int[] arr1, int[] arr2) {
        int[] result = new int[arr1.length + arr2.length];
        int i = 0, j = 0, k = 0;
        
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] < arr2[j]) {
                result[k++] = arr1[i++];
            } else {
                result[k++] = arr2[j++];
            }
        }
        
        // Copy remaining
        while (i < arr1.length) result[k++] = arr1[i++];
        while (j < arr2.length) result[k++] = arr2[j++];
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 0, 0, 0};
        int[] arr2 = {2, 5, 6};
        merge(arr1, 3, arr2, 3);
        System.out.println(Arrays.toString(arr1));
        // [1, 2, 2, 3, 5, 6]
        
        int[] arr3 = {1, 3, 5};
        int[] arr4 = {2, 4, 6};
        System.out.println(Arrays.toString(mergeNew(arr3, arr4)));
        // [1, 2, 3, 4, 5, 6]
    }
}
```

**Time:** O(m + n), **Space:** O(1) for in-place, O(m + n) for new array

---

### Pattern 2: Intersection of Two Arrays

```java
import java.util.*;

public class ArrayIntersection {
    
    // Find intersection of two sorted arrays
    public static List<Integer> intersection(int[] arr1, int[] arr2) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < arr1.length && j < arr2.length) {
            if (arr1[i] == arr2[j]) {
                result.add(arr1[i]);
                i++;
                j++;
            } else if (arr1[i] < arr2[j]) {
                i++;
            } else {
                j++;
            }
        }
        
        return result;
    }
    
    // Find intersection (unique elements only)
    public static List<Integer> intersectionUnique(int[] arr1, int[] arr2) {
        List<Integer> result = new ArrayList<>();
        int i = 0, j = 0;
        
        while (i < arr1.length && j < arr2.length) {
            // Skip duplicates in arr1
            if (i > 0 && arr1[i] == arr1[i - 1]) {
                i++;
                continue;
            }
            
            // Skip duplicates in arr2
            if (j > 0 && arr2[j] == arr2[j - 1]) {
                j++;
                continue;
            }
            
            if (arr1[i] == arr2[j]) {
                result.add(arr1[i]);
                i++;
                j++;
            } else if (arr1[i] < arr2[j]) {
                i++;
            } else {
                j++;
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 2, 3, 4, 5};
        int[] arr2 = {2, 2, 3, 5, 6};
        
        System.out.println(intersection(arr1, arr2));
        // [2, 2, 3, 5]
        
        System.out.println(intersectionUnique(arr1, arr2));
        // [2, 3, 5]
    }
}
```

**Time:** O(m + n), **Space:** O(1) (excluding output)

---

### Pattern 3: Compare Strings with Backspace

```java
public class BackspaceCompare {
    
    // Compare two strings with backspace (#)
    public static boolean backspaceCompare(String s, String t) {
        int i = s.length() - 1;
        int j = t.length() - 1;
        
        while (i >= 0 || j >= 0) {
            i = getNextValidChar(s, i);
            j = getNextValidChar(t, j);
            
            // Both exhausted
            if (i < 0 && j < 0) return true;
            
            // One exhausted
            if (i < 0 || j < 0) return false;
            
            // Different characters
            if (s.charAt(i) != t.charAt(j)) return false;
            
            i--;
            j--;
        }
        
        return true;
    }
    
    private static int getNextValidChar(String s, int index) {
        int backspaceCount = 0;
        
        while (index >= 0) {
            if (s.charAt(index) == '#') {
                backspaceCount++;
                index--;
            } else if (backspaceCount > 0) {
                backspaceCount--;
                index--;
            } else {
                break;
            }
        }
        
        return index;
    }
    
    public static void main(String[] args) {
        System.out.println(backspaceCompare("ab#c", "ad#c"));  // true
        System.out.println(backspaceCompare("ab##", "c#d#"));  // true
        System.out.println(backspaceCompare("a#c", "b"));      // false
    }
}
```

**Time:** O(m + n), **Space:** O(1)

---

<a name="templates"></a>
## 7. Common Patterns & Templates

### Template 1: Opposite Direction

```java
// General template for opposite direction two pointers
public void oppositeDirection(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left < right) {
        // Process current elements
        // arr[left] and arr[right]
        
        if (/* some condition */) {
            // Found solution or process
            left++;
            right--;
        } else if (/* move left */) {
            left++;
        } else {
            right--;
        }
    }
}
```

---

### Template 2: Same Direction (Slow-Fast)

```java
// General template for same direction two pointers
public int sameDirection(int[] arr) {
    int slow = 0;  // Position to write
    
    for (int fast = 0; fast < arr.length; fast++) {
        if (/* condition to keep element */) {
            arr[slow] = arr[fast];
            slow++;
        }
    }
    
    return slow;  // New length or position
}
```

---

### Template 3: Multiple Arrays

```java
// General template for merging/comparing two arrays
public void multipleArrays(int[] arr1, int[] arr2) {
    int i = 0;  // Pointer for arr1
    int j = 0;  // Pointer for arr2
    
    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] == arr2[j]) {
            // Both match
            i++;
            j++;
        } else if (arr1[i] < arr2[j]) {
            i++;
        } else {
            j++;
        }
    }
    
    // Process remaining elements
    while (i < arr1.length) { /* ... */ i++; }
    while (j < arr2.length) { /* ... */ j++; }
}
```

---

<a name="complexity"></a>
## 8. Time/Space Complexity

### Typical Complexities

| Pattern | Time | Space | Why? |
|---------|------|-------|------|
| Opposite direction | O(n) | O(1) | Single pass, no extra space |
| Same direction | O(n) | O(1) | Single pass, in-place |
| Multiple arrays | O(m + n) | O(1) | One pass each array |
| With sorting | O(n log n) | O(1) | Sort first, then two pointers |

---

### Comparison with Brute Force

| Problem | Brute Force | Two Pointers | Improvement |
|---------|-------------|--------------|-------------|
| Two Sum (sorted) | O(n²) | O(n) | n times faster! |
| Palindrome | O(n) | O(n) | Same, but simpler |
| Remove duplicates | O(n²) | O(n) | n times faster! |
| Container water | O(n²) | O(n) | n times faster! |
| Merge sorted | O(m + n) | O(m + n) | Same, but in-place |

---

<a name="when-not"></a>
## 9. When NOT to Use Two Pointers?

❌ **Don't use when:**

1. **Unsorted array and can't sort**
   - Use HashMap instead
   - Example: Two Sum in unsorted array → HashMap O(n)

2. **Need all possible pairs/combinations**
   - Two pointers finds one solution
   - Example: All pairs that sum to target → Need backtracking

3. **Order matters and can't be changed**
   - Two pointers often reorders elements
   - Example: Maintain original indices

4. **Non-linear data structure**
   - Trees, graphs → Use DFS/BFS
   - Linked lists (cycle detection) → Use Fast/Slow pointers (different pattern)

5. **Complex conditions between distant elements**
   - Sliding window might be better
   - Example: Subarray with sum divisible by k

---

<a name="interview-questions"></a>
## 10. Top 15 Interview Questions

### Q1: When should I use two pointers vs HashMap?

**Answer:**

| Use Two Pointers | Use HashMap |
|------------------|-------------|
| Array is sorted or can be sorted | Array is unsorted and order matters |
| Need O(1) space | O(n) space is acceptable |
| Finding pairs/triplets | Finding complements/frequencies |
| In-place modification | Need to preserve original |

---

### Q2: Can two pointers work on unsorted arrays?

**Answer:** Yes, but only for specific patterns:
- ✅ Remove element (order doesn't matter)
- ✅ Move zeros (maintain relative order)
- ✅ Partition array
- ❌ Two Sum (need sorted or HashMap)
- ❌ 3Sum (need sorted)

---

### Q3: How to handle duplicates in two pointer problems?

**Answer:**
```java
// Skip duplicates after processing
while (left < right && arr[left] == arr[left + 1]) left++;
while (left < right && arr[right] == arr[right - 1]) right--;
```

---

### Q4: What's the difference between slow-fast pointers and two pointers?

**Answer:**
- **Two pointers:** Technique for arrays/strings (this guide)
- **Fast-slow pointers:** Pattern for linked lists (cycle detection)
- Both use two pointers, different purposes

---

### Q5: Why move from end in merge sorted arrays?

**Answer:** To avoid overwriting elements!
```java
// Forward: Overwrites arr1[0]!
// Backward: Safe, uses empty space at end
```

---

### Q6: Can two pointers solve substring problems?

**Answer:** Not usually! Use **Sliding Window** for:
- Longest substring without repeating characters
- Minimum window substring
- Maximum sum subarray of size k

Two pointers for:
- Palindrome substrings
- Reverse string

---

### Q7: How to convert brute force to two pointers?

**Answer:**
1. Check if array is sorted or can be sorted
2. Identify inner loop that searches for complement
3. Replace inner loop with second pointer
4. Move pointers based on condition

---

### Q8: What if I need to return indices in unsorted array?

**Answer:** Two pointers changes order!
```java
// Solution 1: Store original indices before sorting
int[][] pairs = new int[arr.length][2];
for (int i = 0; i < arr.length; i++) {
    pairs[i] = new int[]{arr[i], i};
}
Arrays.sort(pairs, (a, b) -> a[0] - b[0]);

// Solution 2: Use HashMap
Map<Integer, Integer> map = new HashMap<>();
```

---

### Q9: Can I have more than two pointers?

**Answer:** Yes!
- **3 pointers:** Dutch National Flag (low, mid, high)
- **4 pointers:** Merge 3 sorted arrays
- **N pointers:** Merge K sorted arrays (use min heap instead)

---

### Q10: How to debug two pointer problems?

**Answer:**
```java
// Print pointers at each step
while (left < right) {
    System.out.printf("left=%d, right=%d, arr[left]=%d, arr[right]=%d\n",
                      left, right, arr[left], arr[right]);
    // ... logic
}
```

---

### Q11: What's the pattern for finding triplets?

**Answer:**
```java
// Fix first element, two pointers for remaining
for (int i = 0; i < n - 2; i++) {
    int left = i + 1;
    int right = n - 1;
    while (left < right) {
        // Two sum logic for arr[left] + arr[right]
    }
}
```
**Time:** O(n²)

---

### Q12: Can two pointers work with strings?

**Answer:** Yes! Convert to char array:
```java
char[] chars = s.toCharArray();
int left = 0, right = chars.length - 1;
// Use two pointers on chars array
```

---

### Q13: How to avoid infinite loop?

**Answer:** Ensure pointers always move:
```java
// ✅ Good
while (left < right) {
    if (condition) {
        left++;
        right--;
    } else if (someCondition) {
        left++;  // Always moves!
    } else {
        right--;  // Always moves!
    }
}

// ❌ Bad
while (left < right) {
    if (condition) {
        // Forgot to move pointers!
    }
}
```

---

### Q14: Can I use binary search with two pointers?

**Answer:** Yes, for sorted arrays:
```java
// Use binary search to find target
// Then use two pointers to find pairs
```

---

### Q15: What problems are solved by two pointers?

**Answer:**

**Easy:**
- Valid Palindrome
- Remove Duplicates
- Move Zeroes
- Reverse String

**Medium:**
- Two Sum (sorted)
- 3Sum
- Container with Most Water
- Sort Colors

**Hard:**
- Trapping Rain Water
- 4Sum

---

<a name="practice-problems"></a>
## 11. Practice Problems with Solutions

### Problem 1: Valid Palindrome II

**Problem:** Check if string can be palindrome after deleting at most one character.

**Example:** `"abca"` → `true` (delete 'c')

```java
public class ValidPalindromeII {
    
    public static boolean validPalindrome(String s) {
        int left = 0;
        int right = s.length() - 1;
        
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                // Try deleting left or right character
                return isPalindrome(s, left + 1, right) || 
                       isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }
        
        return true;
    }
    
    private static boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    
    public static void main(String[] args) {
        System.out.println(validPalindrome("aba"));   // true
        System.out.println(validPalindrome("abca"));  // true
        System.out.println(validPalindrome("abc"));   // false
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: 4Sum

**Problem:** Find all unique quadruplets that sum to target.

**Example:** `[1, 0, -1, 0, -2, 2], target = 0` → `[[-2,-1,1,2], [-2,0,0,2], [-1,0,0,1]]`

```java
import java.util.*;

public class FourSum {
    
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        
        for (int i = 0; i < nums.length - 3; i++) {
            // Skip duplicates
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            
            for (int j = i + 1; j < nums.length - 2; j++) {
                // Skip duplicates
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                
                // Two pointers for remaining two numbers
                int left = j + 1;
                int right = nums.length - 1;
                long remaining = (long)target - nums[i] - nums[j];
                
                while (left < right) {
                    int sum = nums[left] + nums[right];
                    
                    if (sum == remaining) {
                        result.add(Arrays.asList(nums[i], nums[j], 
                                                 nums[left], nums[right]));
                        
                        // Skip duplicates
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        
                        left++;
                        right--;
                        
                    } else if (sum < remaining) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 0, -1, 0, -2, 2};
        List<List<Integer>> result = fourSum(nums, 0);
        System.out.println(result);
        // [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]
    }
}
```

**Time:** O(n³), **Space:** O(1)

---

### Problem 3: Trapping Rain Water

**Problem:** Calculate how much water can be trapped after raining.

**Example:** `[0,1,0,2,1,0,1,3,2,1,2,1]` → `6`

```java
public class TrappingRainWater {
    
    // Two pointer approach
    public static int trap(int[] height) {
        if (height.length == 0) return 0;
        
        int left = 0;
        int right = height.length - 1;
        int leftMax = 0;
        int rightMax = 0;
        int water = 0;
        
        while (left < right) {
            if (height[left] < height[right]) {
                // Process left side
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    water += leftMax - height[left];
                }
                left++;
            } else {
                // Process right side
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    water += rightMax - height[right];
                }
                right--;
            }
        }
        
        return water;
    }
    
    public static void main(String[] args) {
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        System.out.println(trap(height));  // 6
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 4: Squares of Sorted Array

**Problem:** Given sorted array (can have negatives), return sorted array of squares.

**Example:** `[-4, -1, 0, 3, 10]` → `[0, 1, 9, 16, 100]`

```java
import java.util.*;

public class SortedSquares {
    
    public static int[] sortedSquares(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        int left = 0;
        int right = n - 1;
        int index = n - 1;  // Fill from end
        
        while (left <= right) {
            int leftSquare = nums[left] * nums[left];
            int rightSquare = nums[right] * nums[right];
            
            if (leftSquare > rightSquare) {
                result[index] = leftSquare;
                left++;
            } else {
                result[index] = rightSquare;
                right--;
            }
            index--;
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums = {-4, -1, 0, 3, 10};
        System.out.println(Arrays.toString(sortedSquares(nums)));
        // [0, 1, 9, 16, 100]
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 5: Boats to Save People

**Problem:** Each boat carries max 2 people, max weight limit. Find min boats needed.

**Example:** `people = [3,2,2,1], limit = 3` → `3` (boats: [1,2], [2], [3])

```java
import java.util.*;

public class BoatsToSavePeople {
    
    public static int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        
        int left = 0;
        int right = people.length - 1;
        int boats = 0;
        
        while (left <= right) {
            // Try pairing lightest with heaviest
            if (people[left] + people[right] <= limit) {
                left++;  // Can fit both
            }
            right--;  // Heavy person always goes
            boats++;
        }
        
        return boats;
    }
    
    public static void main(String[] args) {
        int[] people1 = {1, 2};
        System.out.println(numRescueBoats(people1, 3));  // 1
        
        int[] people2 = {3, 2, 2, 1};
        System.out.println(numRescueBoats(people2, 3));  // 3
        
        int[] people3 = {3, 5, 3, 4};
        System.out.println(numRescueBoats(people3, 5));  // 4
    }
}
```

**Time:** O(n log n), **Space:** O(1)

---

## Summary Cheat Sheet

### When to Use Two Pointers?

| Scenario | Pattern | Example |
|----------|---------|---------|
| Sorted array + pair | Opposite direction | Two Sum |
| Palindrome check | Opposite direction | Valid Palindrome |
| In-place modification | Same direction | Remove Duplicates |
| Merge sorted arrays | Multiple arrays | Merge Sorted |
| Partition array | Same direction | Sort Colors |
| Container/water problems | Opposite direction | Container Water |

---

### Quick Decision Tree

```
Is array involved?
  ↓ YES
Is it sorted or can be sorted?
  ↓ YES
Finding pairs/triplets?
  ↓ YES
  → Use TWO POINTERS (opposite direction)

Need to modify in-place?
  ↓ YES
  → Use TWO POINTERS (same direction)

Multiple sorted arrays?
  ↓ YES
  → Use TWO POINTERS (multiple arrays)
```

---

## Key Takeaways

✅ **Two pointers reduces O(n²) → O(n)** for many problems  
✅ **Three types:** Opposite direction, Same direction, Multiple arrays  
✅ **Opposite direction:** Sorted arrays, palindromes, pairs  
✅ **Same direction:** In-place modifications, remove/move elements  
✅ **Always check if sorted** - Critical for opposite direction  
✅ **Handle duplicates** - Skip with while loops  
✅ **Space optimization** - Usually O(1)  
✅ **Template memorization** - Saves time in interviews  
✅ **Move vs Swap** - Choose based on problem  
✅ **Practice recognition** - 40% of array problems use this!  

---

[← Back: Array Basics](./Array-Basics.md) | [Next: Sliding Window →](./Sliding-Window.md)
