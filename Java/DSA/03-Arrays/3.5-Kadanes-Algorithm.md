# Kadane's Algorithm - Complete Guide

## Why Kadane's Algorithm?

**The most famous DP algorithm for arrays!**

- **Reduces time complexity:** O(n²) → O(n)
- **Space complexity:** O(1)
- **Essential for:** Maximum/minimum subarray problems
- **Foundation for:** Dynamic Programming concepts

**Master this = Solve all subarray sum problems!**

---

## Table of Contents

1. [What is Kadane's Algorithm?](#what-is)
2. [How It Works](#how-it-works)
3. [Basic Implementation](#basic)
4. [Variations](#variations)
5. [Advanced Patterns](#advanced)
6. [Common Pitfalls](#pitfalls)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)

---

<a name="what-is"></a>
## 1. What is Kadane's Algorithm?

**Problem:** Find the contiguous subarray with the maximum sum.

**Example:**
```
Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]
Maximum subarray: [4, -1, 2, 1]
Maximum sum: 6
```

---

### Brute Force Approach

```java
// Check all possible subarrays - O(n²)
public class BruteForce {
    public static int maxSubarrayBrute(int[] nums) {
        int maxSum = Integer.MIN_VALUE;
        
        for (int i = 0; i < nums.length; i++) {
            int currentSum = 0;
            for (int j = i; j < nums.length; j++) {
                currentSum += nums[j];
                maxSum = Math.max(maxSum, currentSum);
            }
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubarrayBrute(nums));  // 6
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### Kadane's Algorithm Approach

```java
// Kadane's Algorithm - O(n)
public class KadaneAlgorithm {
    public static int maxSubArray(int[] nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            // Either extend current subarray or start new one
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubArray(nums));  // 6
    }
}
```

**Time:** O(n), **Space:** O(1)

**Magic:** Decided at each step - extend current subarray or start fresh!

---

<a name="how-it-works"></a>
## 2. How It Works - Step by Step

### The Key Insight

**At each position, ask:** Should I continue the current subarray or start a new one?

```java
currentSum = Math.max(nums[i], currentSum + nums[i]);
              ↑                    ↑
         Start new          Extend current
```

---

### Visual Walkthrough

```
Array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]

Index 0: nums[0] = -2
    currentSum = -2
    maxSum = -2

Index 1: nums[1] = 1
    currentSum = max(1, -2 + 1) = max(1, -1) = 1  (start new!)
    maxSum = max(-2, 1) = 1

Index 2: nums[2] = -3
    currentSum = max(-3, 1 + (-3)) = max(-3, -2) = -2  (extend)
    maxSum = max(1, -2) = 1

Index 3: nums[3] = 4
    currentSum = max(4, -2 + 4) = max(4, 2) = 4  (start new!)
    maxSum = max(1, 4) = 4

Index 4: nums[4] = -1
    currentSum = max(-1, 4 + (-1)) = max(-1, 3) = 3  (extend)
    maxSum = max(4, 3) = 4

Index 5: nums[5] = 2
    currentSum = max(2, 3 + 2) = max(2, 5) = 5  (extend)
    maxSum = max(4, 5) = 5

Index 6: nums[6] = 1
    currentSum = max(1, 5 + 1) = max(1, 6) = 6  (extend)
    maxSum = max(5, 6) = 6  ← Final answer!

Index 7: nums[7] = -5
    currentSum = max(-5, 6 + (-5)) = max(-5, 1) = 1  (extend)
    maxSum = max(6, 1) = 6

Index 8: nums[8] = 4
    currentSum = max(4, 1 + 4) = max(4, 5) = 5  (extend)
    maxSum = max(6, 5) = 6

Final Maximum Sum: 6
```

---

### Why It Works?

**Greedy Choice:**
- If `currentSum + nums[i]` is negative, starting fresh from `nums[i]` is better
- We're making locally optimal choices that lead to globally optimal solution

**DP Perspective:**
```
dp[i] = maximum sum ending at index i
dp[i] = max(nums[i], dp[i-1] + nums[i])

Space optimized: Only need previous value (currentSum)
```

---

<a name="basic"></a>
## 3. Basic Implementation Variations

### Implementation 1: Classic Kadane's

```java
public class ClassicKadane {
    public static int maxSubArray(int[] nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
}
```

---

### Implementation 2: Alternative Form

```java
public class AlternativeKadane {
    public static int maxSubArray(int[] nums) {
        int currentSum = 0;
        int maxSum = Integer.MIN_VALUE;
        
        for (int num : nums) {
            currentSum += num;
            maxSum = Math.max(maxSum, currentSum);
            
            // Reset if negative
            if (currentSum < 0) {
                currentSum = 0;
            }
        }
        
        return maxSum;
    }
}
```

**Note:** This form doesn't handle all-negative arrays correctly!

---

### Implementation 3: With Subarray Indices

```java
public class KadaneWithIndices {
    
    public static class Result {
        int maxSum;
        int start;
        int end;
        
        Result(int maxSum, int start, int end) {
            this.maxSum = maxSum;
            this.start = start;
            this.end = end;
        }
    }
    
    public static Result maxSubArrayWithIndices(int[] nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];
        
        int start = 0;
        int end = 0;
        int tempStart = 0;
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > currentSum + nums[i]) {
                currentSum = nums[i];
                tempStart = i;  // New subarray starts here
            } else {
                currentSum = currentSum + nums[i];
            }
            
            if (currentSum > maxSum) {
                maxSum = currentSum;
                start = tempStart;
                end = i;
            }
        }
        
        return new Result(maxSum, start, end);
    }
    
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        Result result = maxSubArrayWithIndices(nums);
        
        System.out.println("Max Sum: " + result.maxSum);
        System.out.println("Start Index: " + result.start);
        System.out.println("End Index: " + result.end);
        
        // Print subarray
        System.out.print("Subarray: [");
        for (int i = result.start; i <= result.end; i++) {
            System.out.print(nums[i]);
            if (i < result.end) System.out.print(", ");
        }
        System.out.println("]");
    }
}
```

**Output:**
```
Max Sum: 6
Start Index: 3
End Index: 6
Subarray: [4, -1, 2, 1]
```

---

<a name="variations"></a>
## 4. Variations of Kadane's Algorithm

### Variation 1: Minimum Subarray Sum

```java
public class MinimumSubarray {
    
    public static int minSubArray(int[] nums) {
        int currentSum = nums[0];
        int minSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.min(nums[i], currentSum + nums[i]);
            minSum = Math.min(minSum, currentSum);
        }
        
        return minSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {3, -4, 2, -3, -1, 7, -5};
        System.out.println(minSubArray(nums));  // -6 ([-4, 2, -3, -1])
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Variation 2: Maximum Product Subarray

**Problem:** Find contiguous subarray with maximum product.

**Challenge:** Negative × negative = positive (need to track both max and min!)

```java
public class MaximumProduct {
    
    public static int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        
        int maxProduct = nums[0];
        int currentMax = nums[0];
        int currentMin = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            // If negative, swap max and min
            if (nums[i] < 0) {
                int temp = currentMax;
                currentMax = currentMin;
                currentMin = temp;
            }
            
            // Update max and min
            currentMax = Math.max(nums[i], currentMax * nums[i]);
            currentMin = Math.min(nums[i], currentMin * nums[i]);
            
            maxProduct = Math.max(maxProduct, currentMax);
        }
        
        return maxProduct;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {2, 3, -2, 4};
        System.out.println(maxProduct(nums1));  // 6 ([2, 3])
        
        int[] nums2 = {-2, 0, -1};
        System.out.println(maxProduct(nums2));  // 0
        
        int[] nums3 = {-2, 3, -4};
        System.out.println(maxProduct(nums3));  // 24 ([-2, 3, -4])
    }
}
```

**Time:** O(n), **Space:** O(1)

**Key Insight:** Track both max and min because negative numbers can flip them!

---

### Variation 3: Circular Maximum Subarray

**Problem:** Array is circular (last element connects to first).

**Approach:** 
1. Case 1: Max subarray doesn't wrap → Normal Kadane's
2. Case 2: Max subarray wraps → Total - Min subarray in middle

```java
public class CircularSubarray {
    
    public static int maxSubarraySumCircular(int[] nums) {
        int totalSum = 0;
        int maxSum = Integer.MIN_VALUE;
        int minSum = Integer.MAX_VALUE;
        int currentMax = 0;
        int currentMin = 0;
        
        for (int num : nums) {
            totalSum += num;
            
            // Normal Kadane's for max
            currentMax = Math.max(currentMax + num, num);
            maxSum = Math.max(maxSum, currentMax);
            
            // Kadane's for min
            currentMin = Math.min(currentMin + num, num);
            minSum = Math.min(minSum, currentMin);
        }
        
        // Edge case: all negative numbers
        if (maxSum < 0) {
            return maxSum;
        }
        
        // Max of: normal max OR circular max (total - min)
        return Math.max(maxSum, totalSum - minSum);
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, -2, 3, -2};
        System.out.println(maxSubarraySumCircular(nums1));  // 3
        
        int[] nums2 = {5, -3, 5};
        System.out.println(maxSubarraySumCircular(nums2));  // 10 (circular [5, 5])
        
        int[] nums3 = {-3, -2, -3};
        System.out.println(maxSubarraySumCircular(nums3));  // -2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Variation 4: Maximum Subarray with At Least K Elements

**Problem:** Find maximum sum of subarray with at least k elements.

```java
public class MaxSubarrayKElements {
    
    public static int maxSubarrayKElements(int[] nums, int k) {
        int n = nums.length;
        
        // Prefix sum
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + nums[i];
        }
        
        int maxSum = Integer.MIN_VALUE;
        int minPrefix = 0;
        
        for (int i = k; i <= n; i++) {
            // Sum of last k elements ending at i
            maxSum = Math.max(maxSum, prefix[i] - prefix[i - k]);
            
            // Try extending beyond k elements
            minPrefix = Math.min(minPrefix, prefix[i - k]);
            maxSum = Math.max(maxSum, prefix[i] - minPrefix);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, -2, 3, -4, 5};
        System.out.println(maxSubarrayKElements(nums, 2));  // 4 ([3, -4, 5])
    }
}
```

**Time:** O(n), **Space:** O(n)

---

<a name="advanced"></a>
## 5. Advanced Patterns

### Pattern 1: Maximum Sum with At Most K Elements

```java
public class MaxSumAtMostK {
    
    public static int maxSumAtMostK(int[] nums, int k) {
        int maxSum = Integer.MIN_VALUE;
        
        for (int len = 1; len <= Math.min(k, nums.length); len++) {
            int currentSum = 0;
            
            // First window of size len
            for (int i = 0; i < len; i++) {
                currentSum += nums[i];
            }
            maxSum = Math.max(maxSum, currentSum);
            
            // Slide window
            for (int i = len; i < nums.length; i++) {
                currentSum += nums[i] - nums[i - len];
                maxSum = Math.max(maxSum, currentSum);
            }
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {-1, 4, -2, 3, -2, 3};
        System.out.println(maxSumAtMostK(nums, 2));  // 5 ([3, 3] would be wrong, it's [4])
    }
}
```

**Time:** O(n × k), **Space:** O(1)

---

### Pattern 2: Maximum Average Subarray

```java
public class MaxAverageSubarray {
    
    // Fixed length k
    public static double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        
        // First window
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        
        int maxSum = sum;
        
        // Slide window
        for (int i = k; i < nums.length; i++) {
            sum += nums[i] - nums[i - k];
            maxSum = Math.max(maxSum, sum);
        }
        
        return (double) maxSum / k;
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 12, -5, -6, 50, 3};
        System.out.println(findMaxAverage(nums, 4));  // 12.75
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 3: Best Time to Buy and Sell Stock

**Problem:** Find max profit from one buy and one sell.

**Key Insight:** This is Kadane's on price differences!

```java
public class BestTimeBuySell {
    
    // Method 1: Traditional approach
    public static int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        
        return maxProfit;
    }
    
    // Method 2: Kadane's on differences
    public static int maxProfitKadane(int[] prices) {
        int maxProfit = 0;
        int currentProfit = 0;
        
        for (int i = 1; i < prices.length; i++) {
            int diff = prices[i] - prices[i - 1];
            currentProfit = Math.max(0, currentProfit + diff);
            maxProfit = Math.max(maxProfit, currentProfit);
        }
        
        return maxProfit;
    }
    
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(maxProfit(prices));        // 5
        System.out.println(maxProfitKadane(prices));  // 5
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Pattern 4: Maximum Absolute Sum

```java
public class MaxAbsoluteSum {
    
    public static int maxAbsoluteSum(int[] nums) {
        int maxSum = 0;
        int minSum = 0;
        int currentMax = 0;
        int currentMin = 0;
        
        for (int num : nums) {
            // Kadane's for maximum
            currentMax = Math.max(num, currentMax + num);
            maxSum = Math.max(maxSum, currentMax);
            
            // Kadane's for minimum
            currentMin = Math.min(num, currentMin + num);
            minSum = Math.min(minSum, currentMin);
        }
        
        return Math.max(maxSum, Math.abs(minSum));
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, -3, 2, 3, -4};
        System.out.println(maxAbsoluteSum(nums1));  // 5 (|2 + 3| = 5)
        
        int[] nums2 = {2, -5, 1, -4, 3, -2};
        System.out.println(maxAbsoluteSum(nums2));  // 8 (|-5 + 1 + -4| = 8)
    }
}
```

**Time:** O(n), **Space:** O(1)

---

<a name="pitfalls"></a>
## 6. Common Pitfalls & Solutions

### Pitfall 1: All Negative Numbers

```java
// ❌ WRONG - Returns 0 for all negative
int currentSum = 0;
int maxSum = 0;
for (int num : nums) {
    currentSum = Math.max(0, currentSum + num);
    maxSum = Math.max(maxSum, currentSum);
}
// For [-3, -2, -1], returns 0 instead of -1

// ✅ CORRECT - Initialize with first element
int currentSum = nums[0];
int maxSum = nums[0];
for (int i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
}
```

---

### Pitfall 2: Empty Array

```java
// ❌ WRONG - No check for empty array
public int maxSubArray(int[] nums) {
    int currentSum = nums[0];  // ArrayIndexOutOfBoundsException!
    // ...
}

// ✅ CORRECT - Check first
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;  // or throw exception
    }
    // ...
}
```

---

### Pitfall 3: Integer Overflow

```java
// ❌ WRONG - May overflow
int currentSum = nums[0];
for (int i = 1; i < nums.length; i++) {
    currentSum = currentSum + nums[i];  // Can overflow!
}

// ✅ CORRECT - Use long for large arrays
long currentSum = nums[0];
long maxSum = nums[0];
for (int i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
}
```

---

### Pitfall 4: Forgetting to Update Max

```java
// ❌ WRONG - Only updates currentSum
int currentSum = nums[0];
int maxSum = nums[0];
for (int i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    // Forgot: maxSum = Math.max(maxSum, currentSum);
}
return currentSum;  // Wrong! Returns last subarray sum

// ✅ CORRECT
maxSum = Math.max(maxSum, currentSum);
```

---

### Pitfall 5: Modifying Input Array

```java
// ❌ WRONG - Modifying input
for (int i = 1; i < nums.length; i++) {
    nums[i] = Math.max(nums[i], nums[i] + nums[i-1]);
}
return nums[nums.length - 1];
// Input array is now modified!

// ✅ CORRECT - Use separate variable
int currentSum = nums[0];
int maxSum = nums[0];
// Don't modify nums
```

---

<a name="interview-questions"></a>
## 7. Top 15 Interview Questions

### Q1: What's the time and space complexity of Kadane's?

**Answer:** 
- **Time:** O(n) - Single pass through array
- **Space:** O(1) - Only two variables needed

---

### Q2: Why is it called Kadane's Algorithm?

**Answer:** Named after **Jay Kadane** who discovered it in 1984. It's a classic example of dynamic programming optimized to O(1) space.

---

### Q3: Does Kadane's work for all-negative arrays?

**Answer:** **Yes!** If you initialize correctly:
```java
// ✅ Correct initialization
int currentSum = nums[0];
int maxSum = nums[0];

// ❌ Wrong initialization
int currentSum = 0;
int maxSum = 0;  // Returns 0 for all-negative
```

---

### Q4: How to modify Kadane's for maximum product?

**Answer:** Track both max and min (because negative × negative = positive):
```java
currentMax = Math.max(nums[i], Math.max(currentMax * nums[i], currentMin * nums[i]));
currentMin = Math.min(nums[i], Math.min(oldMax * nums[i], currentMin * nums[i]));
```

---

### Q5: Can Kadane's find the actual subarray (not just sum)?

**Answer:** **Yes!** Track start and end indices:
```java
int start = 0, end = 0, tempStart = 0;
if (nums[i] > currentSum + nums[i]) {
    tempStart = i;  // New subarray starts
}
if (currentSum > maxSum) {
    start = tempStart;
    end = i;
}
```

---

### Q6: What if we need maximum sum with exactly k elements?

**Answer:** Use sliding window:
```java
// First window of size k
int sum = 0;
for (int i = 0; i < k; i++) sum += nums[i];
int maxSum = sum;

// Slide window
for (int i = k; i < n; i++) {
    sum += nums[i] - nums[i - k];
    maxSum = Math.max(maxSum, sum);
}
```

---

### Q7: How does Kadane's relate to DP?

**Answer:** It's space-optimized DP!
```java
// DP definition
dp[i] = max sum ending at index i
dp[i] = max(nums[i], dp[i-1] + nums[i])

// Space optimization (Kadane's)
currentSum = max(nums[i], currentSum + nums[i])
// Only need previous value, not entire array!
```

---

### Q8: Can we use Kadane's for 2D arrays?

**Answer:** **Yes!** Fix two rows, apply Kadane's on column sums:
```java
for (int top = 0; top < rows; top++) {
    int[] colSum = new int[cols];
    for (int bottom = top; bottom < rows; bottom++) {
        // Add row to column sum
        // Apply Kadane's on colSum
    }
}
```
**Time:** O(rows² × cols)

---

### Q9: What's the greedy choice in Kadane's?

**Answer:** At each position:
- **Extend** current subarray if it helps (currentSum + nums[i] > nums[i])
- **Start new** subarray if current is dragging down (nums[i] > currentSum + nums[i])

---

### Q10: How to find minimum subarray sum?

**Answer:** Change `max` to `min`:
```java
currentSum = Math.min(nums[i], currentSum + nums[i]);
minSum = Math.min(minSum, currentSum);
```

---

### Q11: Can Kadane's handle circular arrays?

**Answer:** **Yes!** Two cases:
1. Max doesn't wrap: Normal Kadane's
2. Max wraps: `Total sum - Min subarray in middle`

Return `max(case1, case2)`

---

### Q12: What if array can be empty?

**Answer:** Handle edge case:
```java
if (nums == null || nums.length == 0) {
    throw new IllegalArgumentException("Empty array");
    // or return 0, or return Integer.MIN_VALUE
}
```

---

### Q13: How to prove Kadane's is correct?

**Answer:** **Proof by contradiction:**
- Assume optimal subarray from [i, j]
- If sum[0...i-1] < 0, better to start from i (contradiction!)
- Therefore, we can build optimal solution greedily

---

### Q14: Can we parallelize Kadane's?

**Answer:** **No!** Each step depends on previous:
```java
currentSum = max(nums[i], currentSum + nums[i])
                            ↑ depends on previous
```
Not suitable for parallel processing.

---

### Q15: What problems use Kadane's algorithm?

**Answer:**

**Direct Applications:**
- Maximum subarray sum
- Maximum product subarray
- Best time to buy and sell stock

**Variations:**
- Circular maximum subarray
- Maximum absolute sum
- Minimum subarray sum
- Maximum sum with k elements

---

<a name="practice-problems"></a>
## 8. Practice Problems with Solutions

### Problem 1: Maximum Subarray (LeetCode 53)

**Problem:** Find contiguous subarray with maximum sum.

**Example:** `[-2,1,-3,4,-1,2,1,-5,4]` → `6`

```java
public class MaximumSubarray {
    
    public static int maxSubArray(int[] nums) {
        int currentSum = nums[0];
        int maxSum = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]);
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        System.out.println(maxSubArray(nums));  // 6
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: Maximum Product Subarray (LeetCode 152)

**Problem:** Find contiguous subarray with maximum product.

**Example:** `[2,3,-2,4]` → `6`

```java
public class MaxProductSubarray {
    
    public static int maxProduct(int[] nums) {
        int result = nums[0];
        int currentMax = nums[0];
        int currentMin = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < 0) {
                int temp = currentMax;
                currentMax = currentMin;
                currentMin = temp;
            }
            
            currentMax = Math.max(nums[i], currentMax * nums[i]);
            currentMin = Math.min(nums[i], currentMin * nums[i]);
            
            result = Math.max(result, currentMax);
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] nums1 = {2, 3, -2, 4};
        System.out.println(maxProduct(nums1));  // 6
        
        int[] nums2 = {-2, 0, -1};
        System.out.println(maxProduct(nums2));  // 0
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 3: Maximum Sum Circular Subarray (LeetCode 918)

**Problem:** Find maximum sum in circular array.

**Example:** `[5,-3,5]` → `10`

```java
public class MaxSumCircular {
    
    public static int maxSubarraySumCircular(int[] nums) {
        int totalSum = 0;
        int maxKadane = Integer.MIN_VALUE;
        int minKadane = Integer.MAX_VALUE;
        int currentMax = 0;
        int currentMin = 0;
        
        for (int num : nums) {
            totalSum += num;
            
            currentMax = Math.max(currentMax + num, num);
            maxKadane = Math.max(maxKadane, currentMax);
            
            currentMin = Math.min(currentMin + num, num);
            minKadane = Math.min(minKadane, currentMin);
        }
        
        // All negative case
        if (maxKadane < 0) {
            return maxKadane;
        }
        
        return Math.max(maxKadane, totalSum - minKadane);
    }
    
    public static void main(String[] args) {
        int[] nums1 = {1, -2, 3, -2};
        System.out.println(maxSubarraySumCircular(nums1));  // 3
        
        int[] nums2 = {5, -3, 5};
        System.out.println(maxSubarraySumCircular(nums2));  // 10
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 4: Best Time to Buy and Sell Stock (LeetCode 121)

**Problem:** Max profit from one buy and one sell.

**Example:** `[7,1,5,3,6,4]` → `5`

```java
public class BestTimeBuySellStock {
    
    public static int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            minPrice = Math.min(minPrice, price);
            maxProfit = Math.max(maxProfit, price - minPrice);
        }
        
        return maxProfit;
    }
    
    public static void main(String[] args) {
        int[] prices = {7, 1, 5, 3, 6, 4};
        System.out.println(maxProfit(prices));  // 5
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 5: Longest Turbulent Subarray (LeetCode 978)

**Problem:** Find longest subarray where comparisons alternate.

**Example:** `[9,4,2,10,7,8,8,1,9]` → `5`

```java
public class LongestTurbulent {
    
    public static int maxTurbulenceSize(int[] arr) {
        if (arr.length <= 1) return arr.length;
        
        int maxLength = 1;
        int up = 1;    // Length ending with arr[i] > arr[i-1]
        int down = 1;  // Length ending with arr[i] < arr[i-1]
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > arr[i - 1]) {
                up = down + 1;
                down = 1;
            } else if (arr[i] < arr[i - 1]) {
                down = up + 1;
                up = 1;
            } else {
                up = 1;
                down = 1;
            }
            
            maxLength = Math.max(maxLength, Math.max(up, down));
        }
        
        return maxLength;
    }
    
    public static void main(String[] args) {
        int[] arr = {9, 4, 2, 10, 7, 8, 8, 1, 9};
        System.out.println(maxTurbulenceSize(arr));  // 5
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 6: K-Concatenation Maximum Sum (LeetCode 1191)

**Problem:** Find max subarray sum in array concatenated k times.

**Example:** `arr = [1,2], k = 3` → `9`

```java
public class KConcatenation {
    
    private static final int MOD = 1_000_000_007;
    
    public static int kConcatenationMaxSum(int[] arr, int k) {
        long totalSum = 0;
        for (int num : arr) {
            totalSum += num;
        }
        
        long maxKadane = kadane(arr);
        
        if (k == 1) {
            return (int) (maxKadane % MOD);
        }
        
        // Try with 2 concatenations
        long max2 = kadaneDouble(arr);
        
        if (totalSum > 0) {
            // Add (k-2) full arrays
            long result = max2 + (k - 2) * totalSum;
            return (int) (result % MOD);
        } else {
            return (int) (Math.max(0, max2) % MOD);
        }
    }
    
    private static long kadane(int[] arr) {
        long currentSum = 0;
        long maxSum = 0;
        
        for (int num : arr) {
            currentSum = Math.max(0, currentSum + num);
            maxSum = Math.max(maxSum, currentSum);
        }
        
        return maxSum;
    }
    
    private static long kadaneDouble(int[] arr) {
        long currentSum = 0;
        long maxSum = 0;
        
        // Process array twice
        for (int round = 0; round < 2; round++) {
            for (int num : arr) {
                currentSum = Math.max(0, currentSum + num);
                maxSum = Math.max(maxSum, currentSum);
            }
        }
        
        return maxSum;
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2};
        System.out.println(kConcatenationMaxSum(arr1, 3));  // 9
        
        int[] arr2 = {1, -2, 1};
        System.out.println(kConcatenationMaxSum(arr2, 5));  // 2
    }
}
```

**Time:** O(n), **Space:** O(1)

---

## Summary Cheat Sheet

### Core Template

```java
// Kadane's Algorithm Template
int currentSum = nums[0];
int maxSum = nums[0];

for (int i = 1; i < nums.length; i++) {
    currentSum = Math.max(nums[i], currentSum + nums[i]);
    maxSum = Math.max(maxSum, currentSum);
}

return maxSum;
```

---

### Quick Variations

| Problem | Key Modification |
|---------|-----------------|
| **Maximum Sum** | `currentSum = max(num, currentSum + num)` |
| **Minimum Sum** | `currentSum = min(num, currentSum + num)` |
| **Maximum Product** | Track both max and min |
| **Circular Array** | `max(kadane, total - minKadane)` |
| **With Indices** | Track start, end, tempStart |
| **K Elements** | Use sliding window |

---

### When to Use Kadane's

✅ **Use when:**
- Finding maximum/minimum subarray sum
- Product instead of sum (with modification)
- Stock profit problems
- Contiguous elements required
- O(n) solution needed

❌ **Don't use when:**
- Non-contiguous elements allowed
- Need all subarrays (not just max)
- Complex constraints (use DP)
- 2D problems (need different approach)

---

## Key Takeaways

✅ **Kadane's reduces O(n²) → O(n)** for max subarray  
✅ **Space complexity is O(1)** - only two variables  
✅ **Core decision:** Extend current or start new subarray  
✅ **Initialize with first element** - handles all-negative  
✅ **Variation for product:** Track both max and min  
✅ **Circular arrays:** Total - min subarray  
✅ **DP perspective:** Space-optimized DP  
✅ **Greedy approach:** Locally optimal → globally optimal  
✅ **Can track indices:** For actual subarray  
✅ **Classic interview problem:** Know it cold!  

---

[← Back: Prefix Sum](./Prefix-Sum.md) | [Next: Array Rotation →](./Array-Rotation.md)
