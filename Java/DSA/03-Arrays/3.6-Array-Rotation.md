# Array Rotation & Reversal - Complete Guide

## Why Array Rotation & Reversal?

**Super common in interviews and real-world applications!**

- **Appeared in:** Google, Amazon, Microsoft, Facebook interviews
- **Use cases:** Circular buffers, image processing, string manipulation
- **Foundation for:** Advanced array manipulation techniques
- **Time optimization:** O(n²) → O(n) with right approach

**Master these = Handle 15+ LeetCode problems!**

---

## Table of Contents

1. [Array Reversal](#reversal)
2. [Array Rotation - Right](#rotation-right)
3. [Array Rotation - Left](#rotation-left)
4. [Advanced Rotation Techniques](#advanced)
5. [2D Array Rotation](#2d-rotation)
6. [Common Patterns](#patterns)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)

---

<a name="reversal"></a>
## 1. Array Reversal

### Basic Reversal - Two Pointers

**Problem:** Reverse entire array in-place.

```java
public class ArrayReversal {
    
    // Method 1: Two Pointers (Most Common)
    public static void reverse(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            // Swap
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        reverse(arr);
        System.out.println(Arrays.toString(arr));  // [5, 4, 3, 2, 1]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Reverse a Range

**Problem:** Reverse elements from index `start` to `end`.

```java
public class ReverseRange {
    
    public static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6};
        reverse(arr, 1, 4);  // Reverse indices 1 to 4
        System.out.println(Arrays.toString(arr));  // [1, 5, 4, 3, 2, 6]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Reversal Without Extra Variable

```java
public class ReverseXOR {
    
    // Using XOR (works for integers)
    public static void reverseXOR(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            arr[left] = arr[left] ^ arr[right];
            arr[right] = arr[left] ^ arr[right];
            arr[left] = arr[left] ^ arr[right];
            left++;
            right--;
        }
    }
    
    // Using arithmetic (can overflow!)
    public static void reverseArithmetic(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            arr[left] = arr[left] + arr[right];
            arr[right] = arr[left] - arr[right];
            arr[left] = arr[left] - arr[right];
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5};
        reverseXOR(arr1);
        System.out.println(Arrays.toString(arr1));
        
        int[] arr2 = {1, 2, 3, 4, 5};
        reverseArithmetic(arr2);
        System.out.println(Arrays.toString(arr2));
    }
}
```

**Note:** XOR method is a trick, but temp variable is clearer!

---

<a name="rotation-right"></a>
## 2. Array Rotation - Right

**Problem:** Rotate array to the right by `k` positions.

**Example:**
```
Original: [1, 2, 3, 4, 5, 6, 7]
Rotate right by 3:
Step 1: [7, 1, 2, 3, 4, 5, 6]
Step 2: [6, 7, 1, 2, 3, 4, 5]
Step 3: [5, 6, 7, 1, 2, 3, 4]
Result: [5, 6, 7, 1, 2, 3, 4]
```

---

### Method 1: Brute Force (One by One)

```java
public class RotateRightBrute {
    
    public static void rotateRight(int[] arr, int k) {
        int n = arr.length;
        k = k % n;  // Handle k > n
        
        for (int i = 0; i < k; i++) {
            rotateByOne(arr);
        }
    }
    
    private static void rotateByOne(int[] arr) {
        int last = arr[arr.length - 1];
        
        // Shift all elements right by 1
        for (int i = arr.length - 1; i > 0; i--) {
            arr[i] = arr[i - 1];
        }
        
        arr[0] = last;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateRight(arr, 3);
        System.out.println(Arrays.toString(arr));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n × k), **Space:** O(1)  
**Problem:** Too slow for large k!

---

### Method 2: Using Extra Array

```java
public class RotateRightTemp {
    
    public static void rotateRight(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        int[] temp = new int[n];
        
        // Copy elements to their new positions
        for (int i = 0; i < n; i++) {
            temp[(i + k) % n] = arr[i];
        }
        
        // Copy back
        for (int i = 0; i < n; i++) {
            arr[i] = temp[i];
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateRight(arr, 3);
        System.out.println(Arrays.toString(arr));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n), **Space:** O(n)  
**Problem:** Uses extra space!

---

### Method 3: Reversal Algorithm ⭐ (BEST!)

**Idea:** Reverse in three steps!

```
Original: [1, 2, 3, 4, 5, 6, 7]  k = 3

Step 1: Reverse entire array
Result:   [7, 6, 5, 4, 3, 2, 1]

Step 2: Reverse first k elements
Result:   [5, 6, 7, 4, 3, 2, 1]

Step 3: Reverse remaining n-k elements
Result:   [5, 6, 7, 1, 2, 3, 4]  ✓
```

```java
public class RotateRightReversal {
    
    public static void rotateRight(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        if (k == 0) return;
        
        // Step 1: Reverse entire array
        reverse(arr, 0, n - 1);
        
        // Step 2: Reverse first k elements
        reverse(arr, 0, k - 1);
        
        // Step 3: Reverse remaining elements
        reverse(arr, k, n - 1);
    }
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateRight(arr, 3);
        System.out.println(Arrays.toString(arr));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n), **Space:** O(1)  
**✅ BEST SOLUTION!** - Fast and in-place!

---

### Method 4: Cyclic Replacements (Juggling)

```java
public class RotateRightJuggling {
    
    public static void rotateRight(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        if (k == 0) return;
        
        int cycles = gcd(n, k);
        
        for (int start = 0; start < cycles; start++) {
            int current = start;
            int temp = arr[start];
            
            do {
                int next = (current + k) % n;
                int temp2 = arr[next];
                arr[next] = temp;
                temp = temp2;
                current = next;
            } while (current != start);
        }
    }
    
    private static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateRight(arr, 3);
        System.out.println(Arrays.toString(arr));  // [5, 6, 7, 1, 2, 3, 4]
    }
}
```

**Time:** O(n), **Space:** O(1)  
**Note:** Complex but efficient!

---

<a name="rotation-left"></a>
## 3. Array Rotation - Left

**Problem:** Rotate array to the left by `k` positions.

**Example:**
```
Original: [1, 2, 3, 4, 5, 6, 7]
Rotate left by 3: [4, 5, 6, 7, 1, 2, 3]
```

---

### Method 1: Brute Force

```java
public class RotateLeftBrute {
    
    public static void rotateLeft(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        for (int i = 0; i < k; i++) {
            rotateByOne(arr);
        }
    }
    
    private static void rotateByOne(int[] arr) {
        int first = arr[0];
        
        for (int i = 0; i < arr.length - 1; i++) {
            arr[i] = arr[i + 1];
        }
        
        arr[arr.length - 1] = first;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateLeft(arr, 3);
        System.out.println(Arrays.toString(arr));  // [4, 5, 6, 7, 1, 2, 3]
    }
}
```

**Time:** O(n × k), **Space:** O(1)

---

### Method 2: Reversal Algorithm ⭐ (BEST!)

```
Original: [1, 2, 3, 4, 5, 6, 7]  k = 3

Step 1: Reverse first k elements
Result:   [3, 2, 1, 4, 5, 6, 7]

Step 2: Reverse remaining n-k elements
Result:   [3, 2, 1, 7, 6, 5, 4]

Step 3: Reverse entire array
Result:   [4, 5, 6, 7, 1, 2, 3]  ✓
```

```java
public class RotateLeftReversal {
    
    public static void rotateLeft(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        if (k == 0) return;
        
        // Step 1: Reverse first k elements
        reverse(arr, 0, k - 1);
        
        // Step 2: Reverse remaining elements
        reverse(arr, k, n - 1);
        
        // Step 3: Reverse entire array
        reverse(arr, 0, n - 1);
    }
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateLeft(arr, 3);
        System.out.println(Arrays.toString(arr));  // [4, 5, 6, 7, 1, 2, 3]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Relationship: Left ↔ Right Rotation

**Key Insight:** Rotating left by k = Rotating right by (n - k)!

```java
public class RotationRelation {
    
    public static void rotateLeft(int[] arr, int k) {
        rotateRight(arr, arr.length - k);
    }
    
    public static void rotateRight(int[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        reverse(arr, 0, n - 1);
        reverse(arr, 0, k - 1);
        reverse(arr, k, n - 1);
    }
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5, 6, 7};
        rotateLeft(arr1, 3);
        System.out.println(Arrays.toString(arr1));  // [4, 5, 6, 7, 1, 2, 3]
        
        int[] arr2 = {1, 2, 3, 4, 5, 6, 7};
        rotateRight(arr2, 4);  // n - 3 = 7 - 3 = 4
        System.out.println(Arrays.toString(arr2));  // [4, 5, 6, 7, 1, 2, 3]
    }
}
```

---

<a name="advanced"></a>
## 4. Advanced Rotation Techniques

### Block Swap Algorithm

**Idea:** Divide array into blocks and swap.

```java
public class BlockSwap {
    
    public static void rotateLeft(int[] arr, int k) {
        k = k % arr.length;
        if (k == 0) return;
        
        blockSwap(arr, 0, arr.length, k);
    }
    
    private static void blockSwap(int[] arr, int start, int n, int k) {
        if (k == 0 || k == n) return;
        
        if (k == n - k) {
            // Equal blocks - swap and done
            swap(arr, start, start + k, k);
            return;
        }
        
        if (k < n - k) {
            swap(arr, start, start + n - k, k);
            blockSwap(arr, start, n - k, k);
        } else {
            swap(arr, start, start + k, n - k);
            blockSwap(arr, start + n - k, k, k - (n - k));
        }
    }
    
    private static void swap(int[] arr, int i, int j, int count) {
        for (int c = 0; c < count; c++) {
            int temp = arr[i + c];
            arr[i + c] = arr[j + c];
            arr[j + c] = temp;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7};
        rotateLeft(arr, 3);
        System.out.println(Arrays.toString(arr));  // [4, 5, 6, 7, 1, 2, 3]
    }
}
```

**Time:** O(n), **Space:** O(log n) for recursion

---

### Rotation with Custom Objects

```java
public class RotateObjects {
    
    static class Person {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static <T> void rotateRight(T[] arr, int k) {
        int n = arr.length;
        k = k % n;
        
        reverse(arr, 0, n - 1);
        reverse(arr, 0, k - 1);
        reverse(arr, k, n - 1);
    }
    
    private static <T> void reverse(T[] arr, int start, int end) {
        while (start < end) {
            T temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        Person[] people = {
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 35)
        };
        
        rotateRight(people, 1);
        System.out.println(Arrays.toString(people));
        // [Charlie(35), Alice(25), Bob(30)]
    }
}
```

---

<a name="2d-rotation"></a>
## 5. 2D Array Rotation

### Rotate Matrix 90° Clockwise

**Problem:** Rotate n×n matrix 90° clockwise.

**Example:**
```
Input:          Output:
1 2 3           7 4 1
4 5 6    →      8 5 2
7 8 9           9 6 3
```

**Approach:** Transpose + Reverse rows

```java
public class RotateMatrix90 {
    
    public static void rotate90Clockwise(int[][] matrix) {
        int n = matrix.length;
        
        // Step 1: Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Step 2: Reverse each row
        for (int i = 0; i < n; i++) {
            reverse(matrix[i]);
        }
    }
    
    private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        rotate90Clockwise(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### Rotate Matrix 90° Counter-Clockwise

**Approach:** Transpose + Reverse columns

```java
public class RotateMatrix90CCW {
    
    public static void rotate90CounterClockwise(int[][] matrix) {
        int n = matrix.length;
        
        // Step 1: Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Step 2: Reverse each column
        for (int j = 0; j < n; j++) {
            int top = 0, bottom = n - 1;
            while (top < bottom) {
                int temp = matrix[top][j];
                matrix[top][j] = matrix[bottom][j];
                matrix[bottom][j] = temp;
                top++;
                bottom--;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        rotate90CounterClockwise(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
        // Output:
        // [3, 6, 9]
        // [2, 5, 8]
        // [1, 4, 7]
    }
}
```

---

### Rotate Matrix 180°

```java
public class RotateMatrix180 {
    
    public static void rotate180(int[][] matrix) {
        int n = matrix.length;
        
        // Reverse entire matrix as 1D array
        for (int i = 0; i < n / 2; i++) {
            for (int j = 0; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = temp;
            }
        }
        
        // If odd dimension, reverse middle row
        if (n % 2 == 1) {
            int mid = n / 2;
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[mid][j];
                matrix[mid][j] = matrix[mid][n - 1 - j];
                matrix[mid][n - 1 - j] = temp;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        rotate180(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
        // Output:
        // [9, 8, 7]
        // [6, 5, 4]
        // [3, 2, 1]
    }
}
```

---

### Layer-by-Layer Rotation

**For non-square or more complex rotations:**

```java
public class LayerRotation {
    
    public static void rotateLayerByLayer(int[][] matrix) {
        int n = matrix.length;
        
        for (int layer = 0; layer < n / 2; layer++) {
            int first = layer;
            int last = n - 1 - layer;
            
            for (int i = first; i < last; i++) {
                int offset = i - first;
                
                // Save top
                int top = matrix[first][i];
                
                // left → top
                matrix[first][i] = matrix[last - offset][first];
                
                // bottom → left
                matrix[last - offset][first] = matrix[last][last - offset];
                
                // right → bottom
                matrix[last][last - offset] = matrix[i][last];
                
                // top → right
                matrix[i][last] = top;
            }
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3, 4},
            {5, 6, 7, 8},
            {9, 10, 11, 12},
            {13, 14, 15, 16}
        };
        
        rotateLayerByLayer(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

---

<a name="patterns"></a>
## 6. Common Patterns

### Pattern 1: Check If Array is Rotation

```java
public class CheckRotation {
    
    public static boolean isRotation(int[] arr1, int[] arr2) {
        if (arr1.length != arr2.length) return false;
        
        // Create double array
        StringBuilder sb = new StringBuilder();
        for (int num : arr1) {
            sb.append(num).append(",");
        }
        for (int num : arr1) {
            sb.append(num).append(",");
        }
        
        String double1 = sb.toString();
        
        sb = new StringBuilder();
        for (int num : arr2) {
            sb.append(num).append(",");
        }
        String arr2Str = sb.toString();
        
        return double1.contains(arr2Str);
    }
    
    public static void main(String[] args) {
        int[] arr1 = {1, 2, 3, 4, 5};
        int[] arr2 = {3, 4, 5, 1, 2};
        int[] arr3 = {3, 4, 5, 2, 1};
        
        System.out.println(isRotation(arr1, arr2));  // true
        System.out.println(isRotation(arr1, arr3));  // false
    }
}
```

---

### Pattern 2: Count Rotations in Sorted Array

```java
public class CountRotations {
    
    // For sorted rotated array
    public static int countRotations(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // Already sorted
            if (arr[left] <= arr[right]) {
                return left;
            }
            
            int mid = left + (right - left) / 2;
            int next = (mid + 1) % arr.length;
            int prev = (mid - 1 + arr.length) % arr.length;
            
            // Minimum element (rotation point)
            if (arr[mid] <= arr[next] && arr[mid] <= arr[prev]) {
                return mid;
            }
            
            if (arr[mid] <= arr[right]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        
        return 0;
    }
    
    public static void main(String[] args) {
        int[] arr = {15, 18, 2, 3, 6, 12};
        System.out.println(countRotations(arr));  // 2
    }
}
```

---

### Pattern 3: Rotate Subarray

```java
public class RotateSubarray {
    
    public static void rotateSubarray(int[] arr, int start, int end, int k) {
        int len = end - start + 1;
        k = k % len;
        
        if (k == 0) return;
        
        // Reverse entire subarray
        reverse(arr, start, end);
        
        // Reverse first k
        reverse(arr, start, start + k - 1);
        
        // Reverse remaining
        reverse(arr, start + k, end);
    }
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        rotateSubarray(arr, 2, 6, 2);  // Rotate [3,4,5,6,7] right by 2
        System.out.println(Arrays.toString(arr));
        // [1, 2, 6, 7, 3, 4, 5, 8, 9]
    }
}
```

---

### Pattern 4: Reverse Words in String

```java
public class ReverseWords {
    
    public static String reverseWords(String s) {
        char[] chars = s.toCharArray();
        
        // Reverse entire string
        reverse(chars, 0, chars.length - 1);
        
        // Reverse each word
        int start = 0;
        for (int i = 0; i <= chars.length; i++) {
            if (i == chars.length || chars[i] == ' ') {
                reverse(chars, start, i - 1);
                start = i + 1;
            }
        }
        
        return new String(chars);
    }
    
    private static void reverse(char[] arr, int start, int end) {
        while (start < end) {
            char temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        System.out.println(reverseWords("hello world"));  // "world hello"
        System.out.println(reverseWords("the sky is blue"));  // "blue is sky the"
    }
}
```

---

<a name="interview-questions"></a>
## 7. Top 20 Interview Questions

### Q1: What's the best method for array rotation?

**Answer:** **Reversal algorithm** - O(n) time, O(1) space:
1. Reverse entire array
2. Reverse first k elements
3. Reverse remaining elements

---

### Q2: How do you rotate right vs left?

**Answer:**

**Right rotation by k:**
```java
reverse(arr, 0, n-1);
reverse(arr, 0, k-1);
reverse(arr, k, n-1);
```

**Left rotation by k:**
```java
reverse(arr, 0, k-1);
reverse(arr, k, n-1);
reverse(arr, 0, n-1);
```

Or: `rotateLeft(k) = rotateRight(n - k)`

---

### Q3: Why do we use k = k % n?

**Answer:** 
- Rotating by n positions returns to original
- k = 15, n = 7 → same as k = 1
- Handles k > n efficiently
- Prevents unnecessary operations

---

### Q4: Can you rotate in less than O(n) time?

**Answer:** **No!** Must touch every element at least once.  
Lower bound is Ω(n).

---

### Q5: What if array has duplicates?

**Answer:** All rotation methods work the same! Duplicates don't affect rotation logic.

---

### Q6: How to check if one array is rotation of another?

**Answer:** 
```java
// Create double of first array
String double = Arrays.toString(arr1) + Arrays.toString(arr1);
return double.contains(Arrays.toString(arr2));
```

---

### Q7: What's the juggling algorithm?

**Answer:** Cyclic replacement using GCD:
- Move elements in cycles
- Number of cycles = gcd(n, k)
- O(n) time, O(1) space
- Complex but elegant!

---

### Q8: How to rotate 2D matrix 90° clockwise?

**Answer:**
1. **Transpose:** matrix[i][j] ↔ matrix[j][i]
2. **Reverse each row**

**Time:** O(n²), **Space:** O(1)

---

### Q9: How to reverse array without temp variable?

**Answer:** XOR swap:
```java
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j];
arr[i] = arr[i] ^ arr[j];
```
**Note:** Clever but less readable!

---

### Q10: Can you rotate part of array?

**Answer:** **Yes!** Apply rotation to range [start, end]:
```java
rotateSubarray(arr, start, end, k);
// Uses reversal algorithm on subarray
```

---

### Q11: What's space complexity of rotation?

**Answer:**
- **Reversal algorithm:** O(1)
- **Temp array:** O(n)
- **Juggling:** O(1)
- **Brute force:** O(1)

---

### Q12: How to find rotation count in sorted rotated array?

**Answer:** Find index of minimum element using binary search:
```java
// Rotation count = index of minimum element
```
**Time:** O(log n)

---

### Q13: Does rotation preserve sorted order?

**Answer:** **No!** Rotation breaks sorted order (unless k = 0 or k = n).

But: Creates two sorted subarrays!

---

### Q14: Can you rotate linked list?

**Answer:** **Yes!**
1. Make it circular (connect tail to head)
2. Move to new head (n - k steps from old head)
3. Break the circle

---

### Q15: What's time complexity of one-by-one rotation?

**Answer:** **O(n × k)** - Too slow!
- Each rotation: O(n)
- k rotations: O(n × k)

---

### Q16: How to rotate string?

**Answer:** Convert to char array and apply array rotation:
```java
char[] chars = s.toCharArray();
rotateRight(chars, k);
return new String(chars);
```

---

### Q17: Can rotation be done recursively?

**Answer:** **Yes!** Block swap algorithm uses recursion:
```java
blockSwap(arr, start, n, k);
// Divides into blocks and swaps recursively
```
**Space:** O(log n) for call stack

---

### Q18: What if k is negative?

**Answer:** 
```java
k = k % n;
if (k < 0) k += n;  // Convert to positive
```

---

### Q19: How to rotate matrix 180°?

**Answer:** Two options:
1. Rotate 90° twice
2. Reverse as 1D array with index mapping

---

### Q20: What's the catch with arithmetic swap?

**Answer:**
```java
a = a + b;
b = a - b;
a = a - b;
```
**Problem:** Can overflow with large numbers!  
**Use:** XOR or temp variable instead.

---

<a name="practice-problems"></a>
## 8. Practice Problems with Solutions

### Problem 1: Rotate Array (LeetCode 189)

**Problem:** Rotate array to the right by k steps.

**Example:** `[1,2,3,4,5,6,7], k=3` → `[5,6,7,1,2,3,4]`

```java
public class RotateArray {
    
    public static void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;
        
        if (k == 0) return;
        
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }
    
    private static void reverse(int[] arr, int start, int end) {
        while (start < end) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }
    
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6, 7};
        rotate(nums, 3);
        System.out.println(Arrays.toString(nums));
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 2: Rotate Image (LeetCode 48)

**Problem:** Rotate n×n matrix 90° clockwise in-place.

```java
public class RotateImage {
    
    public static void rotate(int[][] matrix) {
        int n = matrix.length;
        
        // Transpose
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Reverse rows
        for (int i = 0; i < n; i++) {
            reverse(matrix[i]);
        }
    }
    
    private static void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        rotate(matrix);
        
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }
}
```

**Time:** O(n²), **Space:** O(1)

---

### Problem 3: Reverse String (LeetCode 344)

**Problem:** Reverse string in-place.

```java
public class ReverseString {
    
    public static void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        
        while (left < right) {
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
    
    public static void main(String[] args) {
        char[] s = {'h', 'e', 'l', 'l', 'o'};
        reverseString(s);
        System.out.println(Arrays.toString(s));  // [o, l, l, e, h]
    }
}
```

**Time:** O(n), **Space:** O(1)

---

### Problem 4: Rotate String (LeetCode 796)

**Problem:** Check if string A is rotation of string B.

**Example:** `A = "abcde", B = "cdeab"` → `true`

```java
public class RotateStringCheck {
    
    public static boolean rotateString(String A, String B) {
        if (A.length() != B.length()) return false;
        
        String doubled = A + A;
        return doubled.contains(B);
    }
    
    public static void main(String[] args) {
        System.out.println(rotateString("abcde", "cdeab"));  // true
        System.out.println(rotateString("abcde", "abced"));  // false
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 5: Reverse Words in String (LeetCode 151)

**Problem:** Reverse words in string, removing extra spaces.

**Example:** `"  hello world  "` → `"world hello"`

```java
public class ReverseWordsInString {
    
    public static String reverseWords(String s) {
        // Trim and split by spaces
        String[] words = s.trim().split("\\s+");
        
        // Reverse array
        int left = 0;
        int right = words.length - 1;
        
        while (left < right) {
            String temp = words[left];
            words[left] = words[right];
            words[right] = temp;
            left++;
            right--;
        }
        
        return String.join(" ", words);
    }
    
    public static void main(String[] args) {
        System.out.println(reverseWords("  hello world  "));  // "world hello"
        System.out.println(reverseWords("the sky is blue"));  // "blue is sky the"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 6: Reverse Vowels (LeetCode 345)

**Problem:** Reverse only vowels in string.

**Example:** `"hello"` → `"holle"`

```java
public class ReverseVowels {
    
    public static String reverseVowels(String s) {
        char[] chars = s.toCharArray();
        int left = 0;
        int right = chars.length - 1;
        String vowels = "aeiouAEIOU";
        
        while (left < right) {
            while (left < right && vowels.indexOf(chars[left]) == -1) {
                left++;
            }
            while (left < right && vowels.indexOf(chars[right]) == -1) {
                right--;
            }
            
            if (left < right) {
                char temp = chars[left];
                chars[left] = chars[right];
                chars[right] = temp;
                left++;
                right--;
            }
        }
        
        return new String(chars);
    }
    
    public static void main(String[] args) {
        System.out.println(reverseVowels("hello"));     // "holle"
        System.out.println(reverseVowels("leetcode"));  // "leotcede"
    }
}
```

**Time:** O(n), **Space:** O(n)

---

### Problem 7: Search in Rotated Sorted Array (LeetCode 33)

**Problem:** Search in sorted rotated array.

**Example:** `[4,5,6,7,0,1,2], target=0` → `4`

```java
public class SearchRotatedArray {
    
    public static int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // Left half is sorted
            if (nums[left] <= nums[mid]) {
                if (target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            // Right half is sorted
            else {
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
    
    public static void main(String[] args) {
        int[] nums = {4, 5, 6, 7, 0, 1, 2};
        System.out.println(search(nums, 0));  // 4
        System.out.println(search(nums, 3));  // -1
    }
}
```

**Time:** O(log n), **Space:** O(1)

---

### Problem 8: Find Minimum in Rotated Sorted Array (LeetCode 153)

**Problem:** Find minimum in rotated sorted array.

**Example:** `[3,4,5,1,2]` → `1`

```java
public class FindMinRotated {
    
    public static int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                // Minimum is in right half
                left = mid + 1;
            } else {
                // Minimum is in left half or mid
                right = mid;
            }
        }
        
        return nums[left];
    }
    
    public static void main(String[] args) {
        int[] nums1 = {3, 4, 5, 1, 2};
        System.out.println(findMin(nums1));  // 1
        
        int[] nums2 = {4, 5, 6, 7, 0, 1, 2};
        System.out.println(findMin(nums2));  // 0
    }
}
```

**Time:** O(log n), **Space:** O(1)

---

## Summary Cheat Sheet

### Rotation Templates

#### Right Rotation (Reversal Method)
```java
void rotateRight(int[] arr, int k) {
    k = k % arr.length;
    reverse(arr, 0, n - 1);      // Reverse all
    reverse(arr, 0, k - 1);      // Reverse first k
    reverse(arr, k, n - 1);      // Reverse rest
}
```

#### Left Rotation (Reversal Method)
```java
void rotateLeft(int[] arr, int k) {
    k = k % arr.length;
    reverse(arr, 0, k - 1);      // Reverse first k
    reverse(arr, k, n - 1);      // Reverse rest
    reverse(arr, 0, n - 1);      // Reverse all
}
```

#### Helper: Reverse
```java
void reverse(int[] arr, int start, int end) {
    while (start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}
```

---

### Matrix Rotation Templates

#### 90° Clockwise
```java
// 1. Transpose
// 2. Reverse each row
```

#### 90° Counter-Clockwise
```java
// 1. Transpose
// 2. Reverse each column
```

#### 180°
```java
// 1. Rotate 90° twice
// OR reverse as 1D array
```

---

### Complexity Comparison

| Method | Time | Space | Notes |
|--------|------|-------|-------|
| **Reversal** ⭐ | O(n) | O(1) | **Best!** |
| **Temp Array** | O(n) | O(n) | Simple but extra space |
| **Juggling** | O(n) | O(1) | Complex |
| **Brute Force** | O(n×k) | O(1) | Too slow! |
| **Block Swap** | O(n) | O(log n) | Recursive |

---

### When to Use What

| Problem Type | Method |
|--------------|--------|
| **Rotate array k times** | Reversal algorithm |
| **Rotate matrix 90°** | Transpose + Reverse |
| **Check if rotation** | Double array + contains |
| **Find rotation count** | Binary search |
| **Reverse subarray** | Two pointers |
| **Reverse words** | Reverse all + reverse each |

---

## Key Takeaways

✅ **Reversal algorithm is BEST** - O(n) time, O(1) space  
✅ **Left rotation by k = Right rotation by (n-k)**  
✅ **Always use k = k % n** - handles k > n  
✅ **Matrix 90° clockwise** = Transpose + Reverse rows  
✅ **Check rotation** = Double array contains  
✅ **Two pointers** for in-place reversal  
✅ **GCD determines cycles** in juggling algorithm  
✅ **Reversal works on any type** (generic method)  
✅ **Three reverses do the trick!**  
✅ **Know all 4 rotation methods** for interviews!  

---

[← Back: Kadane's Algorithm](./Kadanes-Algorithm.md) | [Next: Matrix Operations →](./Matrix-Operations.md)
