# 8.4 Monotonic Stack

## Table of Contents
1. [Introduction](#introduction)
2. [Monotonic Stack Fundamentals](#monotonic-stack-fundamentals)
3. [Types of Monotonic Stacks](#types-of-monotonic-stacks)
4. [Core Patterns](#core-patterns)
5. [Classic Problems](#classic-problems)
6. [Advanced Applications](#advanced-applications)
7. [Problem-Solving Templates](#problem-solving-templates)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)
10. [Summary](#summary)

---

## Introduction

### What is a Monotonic Stack?

A **Monotonic Stack** is a stack that maintains elements in a specific order:
- **Monotonically Increasing**: Elements from bottom to top are in increasing order
- **Monotonically Decreasing**: Elements from bottom to top are in decreasing order

**Key Idea**: When pushing a new element, pop elements that violate the monotonic property.

### Why Use Monotonic Stack?

**Purpose**: Efficiently find the **next/previous greater/smaller** element for each element in an array.

**Without Monotonic Stack**: O(n²)
```java
// Brute force: For each element, scan right to find next greater
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        if (arr[j] > arr[i]) {
            result[i] = arr[j];
            break;
        }
    }
}
```

**With Monotonic Stack**: O(n)
```java
// Process all elements in one pass using stack
for (int i = n - 1; i >= 0; i--) {
    while (!stack.isEmpty() && stack.peek() <= arr[i]) {
        stack.pop();
    }
    result[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(arr[i]);
}
```

### Real-World Applications

1. **Stock Span Problem**: Days until higher stock price
2. **Temperature Forecast**: Days until warmer temperature
3. **Histogram**: Largest rectangle area
4. **Building View**: Which buildings can see the ocean
5. **Price Tracking**: Best buy/sell days

---

## Monotonic Stack Fundamentals

### Visual Representation

**Monotonically Increasing Stack**:
```
Stack (bottom to top): [1, 3, 5, 7]
                        ↑  ↑  ↑  ↑
                     Small → Large

Push(6): Valid (6 > 5)
Push(4): Pop 7, 5, 6 until stack top < 4
```

**Monotonically Decreasing Stack**:
```
Stack (bottom to top): [9, 6, 4, 2]
                        ↑  ↑  ↑  ↑
                     Large → Small

Push(5): Valid (5 < 6)
Push(7): Pop 2, 4, 5 until stack top > 7
```

### Basic Pattern

```java
// Monotonically increasing stack
Deque<Integer> stack = new ArrayDeque<>();

for (int i = 0; i < arr.length; i++) {
    // Pop elements while they violate increasing property
    while (!stack.isEmpty() && stack.peek() >= arr[i]) {
        stack.pop();
    }
    
    // Stack top is smaller than current
    // Process based on problem requirement
    
    stack.push(arr[i]);
}
```

### Key Properties

1. **Each element pushed once**: O(n) pushes
2. **Each element popped once**: O(n) pops
3. **Total time**: O(n) despite nested loop
4. **Space**: O(n) worst case (all elements in stack)

---

## Types of Monotonic Stacks

### 1. Monotonically Increasing Stack

**Maintains**: `stack[0] < stack[1] < ... < stack[top]`

**Use For**: Finding next/previous **smaller** element

**Pattern**:
```java
while (!stack.isEmpty() && stack.peek() >= current) {
    stack.pop();  // Remove larger or equal elements
}
```

**Example**:
```
Array: [4, 3, 2, 5, 6, 1]

Process each element:
4: stack = [4]
3: pop 4 (4 >= 3), stack = [3]
2: pop 3 (3 >= 2), stack = [2]
5: stack = [2, 5] (5 > 2, valid)
6: stack = [2, 5, 6] (6 > 5, valid)
1: pop 6, 5, 2 (all >= 1), stack = [1]
```

---

### 2. Monotonically Decreasing Stack

**Maintains**: `stack[0] > stack[1] > ... > stack[top]`

**Use For**: Finding next/previous **greater** element

**Pattern**:
```java
while (!stack.isEmpty() && stack.peek() <= current) {
    stack.pop();  // Remove smaller or equal elements
}
```

**Example**:
```
Array: [4, 3, 2, 5, 6, 1]

Process each element:
4: stack = [4]
3: stack = [4, 3] (3 < 4, valid)
2: stack = [4, 3, 2] (2 < 3, valid)
5: pop 2, 3, 4 (all <= 5), stack = [5]
6: pop 5 (5 <= 6), stack = [6]
1: stack = [6, 1] (1 < 6, valid)
```

---

### 3. Strictly vs Non-Strictly Monotonic

**Strictly Increasing**: `<` (no duplicates)
```java
while (!stack.isEmpty() && stack.peek() >= current) // Use >=
```

**Non-Strictly Increasing**: `≤` (allows duplicates)
```java
while (!stack.isEmpty() && stack.peek() > current)  // Use >
```

---

## Core Patterns

### Pattern 1: Next Greater Element ⭐⭐⭐

**Problem**: For each element, find the next greater element to its right.

**Input**: `[4, 5, 2, 10, 8]`
**Output**: `[5, 10, 10, -1, -1]`

**Solution** (Traverse right to left):
```java
public class NextGreaterElement {
    public static int[] nextGreaterElement(int[] arr) {
        int n = arr.length;
        int[] result = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Pop elements <= current (maintain decreasing stack)
            while (!stack.isEmpty() && stack.peek() <= arr[i]) {
                stack.pop();
            }
            
            // Stack top is next greater (or -1 if empty)
            result[i] = stack.isEmpty() ? -1 : stack.peek();
            
            // Push current element
            stack.push(arr[i]);
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr = {4, 5, 2, 10, 8};
        int[] result = nextGreaterElement(arr);
        
        System.out.println("Array:  " + Arrays.toString(arr));
        System.out.println("Result: " + Arrays.toString(result));
        // Result: [5, 10, 10, -1, -1]
    }
}
```

**Why Right to Left?**
- For each element, we need info about elements to the **right**
- Processing right-to-left builds up this information

**Dry Run**:
```
Array: [4, 5, 2, 10, 8]
       
i=4 (8):  stack=[], result[4]=-1, stack=[8]
i=3 (10): pop 8, stack=[], result[3]=-1, stack=[10]
i=2 (2):  stack=[10], result[2]=10, stack=[10,2]
i=1 (5):  pop 2, stack=[10], result[1]=10, stack=[10,5]
i=0 (4):  stack=[10,5], result[0]=5, stack=[10,5,4]

Result: [5, 10, 10, -1, -1]
```

**LeetCode**: 496, 503

**Time**: O(n) | **Space**: O(n)

---

### Pattern 2: Next Smaller Element

**Problem**: For each element, find the next smaller element to its right.

**Input**: `[4, 5, 2, 10, 8]`
**Output**: `[2, 2, -1, 8, -1]`

**Solution**:
```java
public static int[] nextSmallerElement(int[] arr) {
    int n = arr.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    // Traverse from right to left
    for (int i = n - 1; i >= 0; i--) {
        // Pop elements >= current (maintain increasing stack)
        while (!stack.isEmpty() && stack.peek() >= arr[i]) {
            stack.pop();
        }
        
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(arr[i]);
    }
    
    return result;
}
```

**Note**: Just flip the comparison from `<=` to `>=`

---

### Pattern 3: Previous Greater Element

**Problem**: For each element, find the previous greater element to its left.

**Input**: `[4, 5, 2, 10, 8]`
**Output**: `[-1, -1, 5, -1, 10]`

**Solution** (Traverse left to right):
```java
public static int[] previousGreaterElement(int[] arr) {
    int n = arr.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    // Traverse from left to right
    for (int i = 0; i < n; i++) {
        // Pop elements <= current
        while (!stack.isEmpty() && stack.peek() <= arr[i]) {
            stack.pop();
        }
        
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(arr[i]);
    }
    
    return result;
}
```

**Dry Run**:
```
Array: [4, 5, 2, 10, 8]

i=0 (4):  stack=[], result[0]=-1, stack=[4]
i=1 (5):  pop 4, stack=[], result[1]=-1, stack=[5]
i=2 (2):  stack=[5], result[2]=5, stack=[5,2]
i=3 (10): pop 2,5, stack=[], result[3]=-1, stack=[10]
i=4 (8):  stack=[10], result[4]=10, stack=[10,8]

Result: [-1, -1, 5, -1, 10]
```

---

### Pattern 4: Previous Smaller Element

**Input**: `[4, 5, 2, 10, 8]`
**Output**: `[-1, 4, -1, 2, 2]`

**Solution**:
```java
public static int[] previousSmallerElement(int[] arr) {
    int n = arr.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = 0; i < n; i++) {
        while (!stack.isEmpty() && stack.peek() >= arr[i]) {
            stack.pop();
        }
        
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(arr[i]);
    }
    
    return result;
}
```

---

### Pattern Summary Table

| Pattern | Direction | Stack Type | Comparison |
|---------|-----------|------------|------------|
| Next Greater | Right → Left | Decreasing | `peek() <= current` |
| Next Smaller | Right → Left | Increasing | `peek() >= current` |
| Previous Greater | Left → Right | Decreasing | `peek() <= current` |
| Previous Smaller | Left → Right | Increasing | `peek() >= current` |

**Template**:
```java
// Next Greater/Smaller: Right to left
for (int i = n - 1; i >= 0; i--) {
    while (!stack.isEmpty() && condition) stack.pop();
    result[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(arr[i]);
}

// Previous Greater/Smaller: Left to right
for (int i = 0; i < n; i++) {
    while (!stack.isEmpty() && condition) stack.pop();
    result[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(arr[i]);
}
```

---

## Classic Problems

### Problem 1: Daily Temperatures ⭐⭐⭐

**LeetCode 739** | **Frequency: Very High**

**Problem**: Given daily temperatures, for each day find how many days until warmer.

**Input**: `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`
**Output**: `[1, 1, 4, 2, 1, 1, 0, 0]`

**Explanation**:
- Day 0 (73°): Next warmer is day 1 (74°) → wait 1 day
- Day 1 (74°): Next warmer is day 2 (75°) → wait 1 day
- Day 2 (75°): Next warmer is day 6 (76°) → wait 4 days

**Solution**:
```java
public class DailyTemperatures {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] answer = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            // Pop while current temp > stack top temp
            while (!stack.isEmpty() && 
                   temperatures[i] > temperatures[stack.peek()]) {
                int prevIndex = stack.pop();
                answer[prevIndex] = i - prevIndex;
            }
            
            stack.push(i);
        }
        
        return answer;
    }
    
    public static void main(String[] args) {
        DailyTemperatures solution = new DailyTemperatures();
        int[] temps = {73, 74, 75, 71, 69, 72, 76, 73};
        int[] result = solution.dailyTemperatures(temps);
        
        System.out.println("Temperatures: " + Arrays.toString(temps));
        System.out.println("Days to wait: " + Arrays.toString(result));
        // Days to wait: [1, 1, 4, 2, 1, 1, 0, 0]
    }
}
```

**Why Store Indices?**
- Need to calculate distance: `i - prevIndex`
- Indices also give us access to temperatures: `temperatures[index]`

**Dry Run**:
```
temps = [73, 74, 75, 71, 69, 72, 76, 73]

i=0: stack=[0]
i=1: 74>73, pop 0, answer[0]=1-0=1, stack=[1]
i=2: 75>74, pop 1, answer[1]=2-1=1, stack=[2]
i=3: 71<75, stack=[2,3]
i=4: 69<71, stack=[2,3,4]
i=5: 72>69, pop 4, answer[4]=5-4=1
     72>71, pop 3, answer[3]=5-3=2
     72<75, stack=[2,5]
i=6: 76>72, pop 5, answer[5]=6-5=1
     76>75, pop 2, answer[2]=6-2=4
     stack=[6]
i=7: 73<76, stack=[6,7]

Final: answer = [1, 1, 4, 2, 1, 1, 0, 0]
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 2: Stock Span Problem ⭐⭐⭐

**LeetCode 901** | **Frequency: High**

**Problem**: Calculate span = consecutive days with price ≤ current.

**Input**: `[100, 80, 60, 70, 60, 75, 85]`
**Output**: `[1, 1, 1, 2, 1, 4, 6]`

**Explanation**:
- Day 0 (100): span = 1 (only itself)
- Day 3 (70): span = 2 (includes day 2: 60 ≤ 70)
- Day 5 (75): span = 4 (includes days 2,3,4)
- Day 6 (85): span = 6 (includes days 1-5, not day 0)

**Solution**:
```java
public class StockSpanner {
    private Deque<int[]> stack;  // [price, span]
    
    public StockSpanner() {
        stack = new ArrayDeque<>();
    }
    
    public int next(int price) {
        int span = 1;
        
        // Pop prices <= current and accumulate their spans
        while (!stack.isEmpty() && stack.peek()[0] <= price) {
            span += stack.pop()[1];
        }
        
        stack.push(new int[]{price, span});
        return span;
    }
    
    public static void main(String[] args) {
        StockSpanner spanner = new StockSpanner();
        int[] prices = {100, 80, 60, 70, 60, 75, 85};
        
        System.out.print("Spans: ");
        for (int price : prices) {
            System.out.print(spanner.next(price) + " ");
        }
        // Spans: 1 1 1 2 1 4 6
    }
}
```

**Alternative** (Store indices):
```java
public int next(int price) {
    int span = 1;
    
    while (!stack.isEmpty() && prices[stack.peek()] <= price) {
        stack.pop();
    }
    
    span = stack.isEmpty() ? (currentDay + 1) : (currentDay - stack.peek());
    stack.push(currentDay++);
    
    return span;
}
```

**Time**: O(1) amortized per call | **Space**: O(n)

---

### Problem 3: Largest Rectangle in Histogram ⭐⭐⭐⭐

**LeetCode 84** | **Frequency: Very High** | **Difficulty: Hard**

**Problem**: Find largest rectangle area in histogram.

**Input**: `heights = [2, 1, 5, 6, 2, 3]`
**Output**: `10`

**Explanation**:
```
     6
   5 █
   █ █
   █ █   3
   █ █ 2 █
 2 █ █ █ █
 █ █ █ █ █
───────────
 0 1 2 3 4 5

Largest rectangle: width=2, height=5, area=10 (bars 2-3)
```

**Key Insight**: For each bar, find:
- **Left boundary**: Previous smaller element
- **Right boundary**: Next smaller element
- **Width**: `right - left - 1`
- **Area**: `height × width`

**Solution**:
```java
public class LargestRectangle {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        Deque<Integer> stack = new ArrayDeque<>();  // Monotonically increasing
        int maxArea = 0;
        
        for (int i = 0; i <= n; i++) {
            int h = (i == n) ? 0 : heights[i];  // Sentinel at end
            
            // Pop bars taller than current
            while (!stack.isEmpty() && heights[stack.peek()] > h) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack.push(i);
        }
        
        return maxArea;
    }
    
    public static void main(String[] args) {
        LargestRectangle solution = new LargestRectangle();
        int[] heights = {2, 1, 5, 6, 2, 3};
        
        System.out.println("Max Area: " + solution.largestRectangleArea(heights));
        // Max Area: 10
    }
}
```

**Detailed Dry Run**:
```
heights = [2, 1, 5, 6, 2, 3]

i=0, h=2: stack=[0]

i=1, h=1: 
  Pop 0 (height=2 > 1): height=2, width=1 (empty stack), area=2
  stack=[1]

i=2, h=5: stack=[1,2]

i=3, h=6: stack=[1,2,3]

i=4, h=2:
  Pop 3 (height=6 > 2): height=6, width=4-2-1=1, area=6
  Pop 2 (height=5 > 2): height=5, width=4-1-1=2, area=10 ✓
  stack=[1,4]

i=5, h=3: stack=[1,4,5]

i=6, h=0 (sentinel):
  Pop 5 (height=3 > 0): height=3, width=6-4-1=1, area=3
  Pop 4 (height=2 > 0): height=2, width=6-1-1=4, area=8
  Pop 1 (height=1 > 0): height=1, width=6 (empty), area=6
  stack=[6]

Max Area: 10
```

**Why Sentinel 0 at End?**
- Forces all remaining bars to be processed
- Ensures every bar gets its area calculated

**Time**: O(n) | **Space**: O(n)

---

### Problem 4: Trapping Rain Water ⭐⭐⭐⭐

**LeetCode 42** | **Frequency: Very High** | **Difficulty: Hard**

**Problem**: Calculate trapped rainwater between bars.

**Input**: `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
**Output**: `6`

**Visualization**:
```
       █
   █▓▓▓█▓█
 █▓█▓█▓█▓█
─────────────
 0 1 2 3 4 5 6

Water (▓): 1 unit between bars 1-2, 2 units between bars 2-3, etc.
Total: 6 units
```

**Solution 1: Monotonic Stack**
```java
public class TrappingRainWater {
    public int trap(int[] height) {
        Deque<Integer> stack = new ArrayDeque<>();  // Monotonically decreasing
        int water = 0;
        
        for (int i = 0; i < height.length; i++) {
            // Process while current bar is taller than stack top
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int bottom = stack.pop();
                
                if (stack.isEmpty()) break;
                
                int left = stack.peek();
                int right = i;
                
                int h = Math.min(height[left], height[right]) - height[bottom];
                int w = right - left - 1;
                
                water += h * w;
            }
            
            stack.push(i);
        }
        
        return water;
    }
    
    public static void main(String[] args) {
        TrappingRainWater solution = new TrappingRainWater();
        int[] height = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};
        
        System.out.println("Trapped water: " + solution.trap(height));
        // Trapped water: 6
    }
}
```

**Solution 2: Two Pointers** (More efficient):
```java
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    
    return water;
}
```

**Time**: O(n) | **Space**: O(1) for two pointers, O(n) for stack

---

### Problem 5: Next Greater Element II (Circular) ⭐⭐

**LeetCode 503** | **Frequency: Medium**

**Problem**: Find next greater element in circular array.

**Input**: `nums = [1, 2, 1]`
**Output**: `[2, -1, 2]`

**Explanation**:
- First 1: Next greater is 2
- 2: No greater element (circular check: 1, 2, 1)
- Second 1: Next greater is 2 (wrap around)

**Solution**:
```java
public class NextGreaterCircular {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Process array twice to simulate circular
        for (int i = 0; i < 2 * n; i++) {
            int num = nums[i % n];
            
            while (!stack.isEmpty() && nums[stack.peek()] < num) {
                result[stack.pop()] = num;
            }
            
            // Only push indices in first pass
            if (i < n) {
                stack.push(i);
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        NextGreaterCircular solution = new NextGreaterCircular();
        int[] nums = {1, 2, 1};
        int[] result = solution.nextGreaterElements(nums);
        
        System.out.println("Input:  " + Arrays.toString(nums));
        System.out.println("Output: " + Arrays.toString(result));
        // Output: [2, -1, 2]
    }
}
```

**Why Process Twice?**
- Simulate circular array: after last element, continue from first
- `i % n` wraps around indices
- Only push in first pass to avoid duplicates

**Time**: O(n) | **Space**: O(n)

---

## Advanced Applications

### Application 1: Maximum Rectangle in Binary Matrix

**LeetCode 85** | **Difficulty: Hard**

**Problem**: Find largest rectangle of 1s in binary matrix.

**Input**:
```
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```
**Output**: `6` (rectangle at rows 1-2, columns 2-4)

**Solution**: Convert to histogram problem for each row.

```java
public class MaximalRectangle {
    public int maximalRectangle(char[][] matrix) {
        if (matrix.length == 0) return 0;
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[] heights = new int[cols];
        int maxArea = 0;
        
        for (int i = 0; i < rows; i++) {
            // Update heights array
            for (int j = 0; j < cols; j++) {
                if (matrix[i][j] == '1') {
                    heights[j]++;
                } else {
                    heights[j] = 0;
                }
            }
            
            // Find max rectangle in current histogram
            maxArea = Math.max(maxArea, largestRectangleArea(heights));
        }
        
        return maxArea;
    }
    
    private int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        int maxArea = 0;
        int n = heights.length;
        
        for (int i = 0; i <= n; i++) {
            int h = (i == n) ? 0 : heights[i];
            
            while (!stack.isEmpty() && heights[stack.peek()] > h) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack.push(i);
        }
        
        return maxArea;
    }
}
```

**Time**: O(rows × cols) | **Space**: O(cols)

---

### Application 2: Remove K Digits ⭐⭐⭐

**LeetCode 402** | **Frequency: Medium**

**Problem**: Remove k digits to get smallest number.

**Input**: `num = "1432219", k = 3`
**Output**: `"1219"`

**Explanation**: Remove 4, 3, 2 → get 1219

**Solution**: Use monotonic increasing stack.

```java
public class RemoveKDigits {
    public String removeKdigits(String num, int k) {
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char digit : num.toCharArray()) {
            // Remove larger digits while k > 0
            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {
                stack.pop();
                k--;
            }
            stack.push(digit);
        }
        
        // Remove remaining k digits from end
        while (k > 0) {
            stack.pop();
            k--;
        }
        
        // Build result (remove leading zeros)
        StringBuilder sb = new StringBuilder();
        boolean leadingZero = true;
        
        for (char digit : stack) {
            if (digit == '0' && leadingZero) continue;
            leadingZero = false;
            sb.append(digit);
        }
        
        return sb.length() == 0 ? "0" : sb.toString();
    }
    
    public static void main(String[] args) {
        RemoveKDigits solution = new RemoveKDigits();
        System.out.println(solution.removeKdigits("1432219", 3));  // "1219"
        System.out.println(solution.removeKdigits("10200", 1));     // "200"
        System.out.println(solution.removeKdigits("10", 2));        // "0"
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Application 3: Sum of Subarray Minimums ⭐⭐⭐

**LeetCode 907** | **Frequency: Medium**

**Problem**: Sum of minimum element in every subarray.

**Input**: `arr = [3, 1, 2, 4]`
**Output**: `17`

**Explanation**:
```
Subarrays: min(subarray)
[3]:       3
[1]:       1
[2]:       2
[4]:       4
[3,1]:     1
[1,2]:     1
[2,4]:     2
[3,1,2]:   1
[1,2,4]:   1
[3,1,2,4]: 1

Sum: 3+1+2+4+1+1+2+1+1+1 = 17
```

**Solution**: For each element, find how many subarrays it's minimum for.

```java
public class SumSubarrayMinimums {
    public int sumSubarrayMins(int[] arr) {
        int MOD = 1_000_000_007;
        int n = arr.length;
        
        // Find previous and next smaller elements
        int[] prevSmaller = new int[n];
        int[] nextSmaller = new int[n];
        
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Previous smaller
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            prevSmaller[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }
        
        stack.clear();
        
        // Next smaller
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                stack.pop();
            }
            nextSmaller[i] = stack.isEmpty() ? n : stack.peek();
            stack.push(i);
        }
        
        // Calculate sum
        long sum = 0;
        for (int i = 0; i < n; i++) {
            long left = i - prevSmaller[i];
            long right = nextSmaller[i] - i;
            sum = (sum + arr[i] * left * right) % MOD;
        }
        
        return (int) sum;
    }
}
```

**Formula**: For element at index `i`:
- Count of subarrays where `arr[i]` is minimum = `left × right`
- `left` = distance to previous smaller
- `right` = distance to next smaller

**Time**: O(n) | **Space**: O(n)

---

## Problem-Solving Templates

### Template 1: Next Greater/Smaller

```java
public int[] solve(int[] arr) {
    int n = arr.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    // Direction: left-to-right OR right-to-left
    for (int i = START; CONDITION; i += STEP) {
        // Pop condition: depends on greater/smaller
        while (!stack.isEmpty() && COMPARE) {
            stack.pop();
        }
        
        result[i] = stack.isEmpty() ? DEFAULT : stack.peek();
        stack.push(arr[i]);  // or push index
    }
    
    return result;
}
```

**Customization Points**:
1. **Direction**: `0 to n` or `n-1 to 0`
2. **Compare**: `<=` or `>=`
3. **Stack content**: Values or indices
4. **Default**: `-1`, `0`, `n`, etc.

---

### Template 2: Monotonic Stack with Processing

```java
public void solve(int[] arr) {
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = 0; i < arr.length; i++) {
        while (!stack.isEmpty() && shouldPop(arr, stack.peek(), i)) {
            int poppedIndex = stack.pop();
            
            // Process popped element
            process(poppedIndex, i, stack);
        }
        
        stack.push(i);
    }
    
    // Process remaining elements
    while (!stack.isEmpty()) {
        processRemaining(stack.pop());
    }
}
```

---

### Template 3: Histogram-Style Problems

```java
public int maxArea(int[] heights) {
    Deque<Integer> stack = new ArrayDeque<>();
    int maxResult = 0;
    
    for (int i = 0; i <= heights.length; i++) {
        int h = (i == heights.length) ? 0 : heights[i];
        
        while (!stack.isEmpty() && heights[stack.peek()] > h) {
            int height = heights[stack.pop()];
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            maxResult = Math.max(maxResult, height * width);
        }
        
        stack.push(i);
    }
    
    return maxResult;
}
```

---

## Interview Questions

### Question 1: Find 132 Pattern ⭐⭐⭐

**LeetCode 456** | **Difficulty: Medium**

**Problem**: Find if there exists i < j < k such that `nums[i] < nums[k] < nums[j]`.

**Input**: `nums = [3, 1, 4, 2]`
**Output**: `true` (i=1, j=2, k=3: 1 < 2 < 4)

**Solution**:
```java
public class Find132Pattern {
    public boolean find132pattern(int[] nums) {
        int n = nums.length;
        if (n < 3) return false;
        
        Deque<Integer> stack = new ArrayDeque<>();
        int third = Integer.MIN_VALUE;  // nums[k]
        
        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            if (nums[i] < third) {
                return true;  // Found nums[i] < nums[k] < nums[j]
            }
            
            // Maintain decreasing stack
            while (!stack.isEmpty() && nums[i] > stack.peek()) {
                third = stack.pop();  // This becomes nums[k]
            }
            
            stack.push(nums[i]);
        }
        
        return false;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Question 2: Online Stock Span with Indices

**Problem**: Return span and the day indices included.

**Solution**:
```java
class StockSpannerDetailed {
    private Deque<int[]> stack;  // [index, price, span]
    private int day;
    
    public StockSpannerDetailed() {
        stack = new ArrayDeque<>();
        day = 0;
    }
    
    public int[] next(int price) {
        int span = 1;
        
        while (!stack.isEmpty() && stack.peek()[1] <= price) {
            int[] prev = stack.pop();
            span += prev[2];
        }
        
        stack.push(new int[]{day, price, span});
        
        int startDay = day - span + 1;
        day++;
        
        return new int[]{span, startDay, day - 1};
    }
}
```

---

### Question 3: Remove Duplicate Letters ⭐⭐⭐

**LeetCode 316** | **Difficulty: Medium**

**Problem**: Remove duplicates to get lexicographically smallest result.

**Input**: `s = "bcabc"`
**Output**: `"abc"`

**Solution**:
```java
public class RemoveDuplicateLetters {
    public String removeDuplicateLetters(String s) {
        int[] count = new int[26];
        boolean[] inStack = new boolean[26];
        
        // Count occurrences
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            count[c - 'a']--;
            
            if (inStack[c - 'a']) continue;
            
            // Remove larger characters if they appear later
            while (!stack.isEmpty() && stack.peek() > c && 
                   count[stack.peek() - 'a'] > 0) {
                char removed = stack.pop();
                inStack[removed - 'a'] = false;
            }
            
            stack.push(c);
            inStack[c - 'a'] = true;
        }
        
        StringBuilder sb = new StringBuilder();
        for (char c : stack) {
            sb.append(c);
        }
        
        return sb.toString();
    }
}
```

**Time**: O(n) | **Space**: O(1) (fixed alphabet size)

---

## Practice Problems

### Easy Problems (Foundational)

| # | Problem | LeetCode | Pattern |
|---|---------|----------|---------|
| 1 | Next Greater Element I | 496 | Basic NGE |
| 2 | Baseball Game | 682 | Stack Simulation |
| 3 | Remove All Adjacent Duplicates | 1047 | Monotonic |
| 4 | Make String Great | 1544 | Stack |
| 5 | Final Prices With Special Discount | 1475 | Next Smaller |

### Medium Problems (Essential)

| # | Problem | LeetCode | Pattern | Importance |
|---|---------|----------|---------|------------|
| 1 | Daily Temperatures | 739 | NGE with indices | ⭐⭐⭐⭐⭐ |
| 2 | Online Stock Span | 901 | Monotonic decreasing | ⭐⭐⭐⭐⭐ |
| 3 | Next Greater Element II | 503 | Circular array | ⭐⭐⭐⭐ |
| 4 | Asteroid Collision | 735 | Stack simulation | ⭐⭐⭐ |
| 5 | Remove K Digits | 402 | Greedy + monotonic | ⭐⭐⭐⭐ |
| 6 | 132 Pattern | 456 | Monotonic decreasing | ⭐⭐⭐ |
| 7 | Remove Duplicate Letters | 316 | Greedy + monotonic | ⭐⭐⭐ |
| 8 | Sum of Subarray Minimums | 907 | Contribution technique | ⭐⭐⭐⭐ |
| 9 | Sum of Subarray Ranges | 2104 | Min/Max contribution | ⭐⭐⭐ |
| 10 | Car Fleet | 853 | Monotonic | ⭐⭐⭐ |
| 11 | Shortest Unsorted Continuous Subarray | 581 | Monotonic | ⭐⭐ |
| 12 | Find Most Competitive Subsequence | 1673 | Greedy + monotonic | ⭐⭐⭐ |

### Hard Problems (Advanced)

| # | Problem | LeetCode | Pattern | Importance |
|---|---------|----------|---------|------------|
| 1 | Largest Rectangle in Histogram | 84 | Histogram technique | ⭐⭐⭐⭐⭐ |
| 2 | Trapping Rain Water | 42 | Water trapping | ⭐⭐⭐⭐⭐ |
| 3 | Maximal Rectangle | 85 | Histogram + matrix | ⭐⭐⭐⭐⭐ |
| 4 | Longest Valid Parentheses | 32 | Stack indices | ⭐⭐⭐⭐ |
| 5 | Maximum Number of Visible People | 1944 | Monotonic decreasing | ⭐⭐⭐ |
| 6 | Count Submatrices With All Ones | 1504 | Histogram | ⭐⭐⭐ |
| 7 | Number of Visible People in Queue | 1944 | Monotonic stack | ⭐⭐⭐ |

---

## Summary

### Key Concepts

**1. Monotonic Stack Definition**:
- Maintains elements in increasing or decreasing order
- Pop elements that violate the monotonic property

**2. Core Use Cases**:
```
✅ Next/Previous Greater/Smaller Element
✅ Histogram Problems (area calculations)
✅ Range Queries (min/max in subarrays)
✅ Lexicographical Ordering (remove k digits)
✅ Contribution Techniques (sum of mins/maxs)
```

**3. Time Complexity**:
- Always O(n) for n elements
- Each element pushed once, popped once
- Total operations: 2n = O(n)

### Pattern Recognition Guide

**Use Monotonic Stack When**:
1. Problem asks for "next/previous greater/smaller"
2. Need to find range where element is min/max
3. Histogram or area calculation involved
4. Need to maintain lexicographical order
5. Problem involves spans or visibility

**Keywords to Watch**:
- "Next greater/smaller"
- "Previous greater/smaller"
- "Largest rectangle"
- "Visible from position"
- "Stock span"
- "Temperature forecast"
- "Remove to minimize/maximize"

### Template Selection

| Problem Type | Direction | Stack Type | Store |
|-------------|-----------|------------|-------|
| Next Greater | Right→Left | Decreasing | Values/Indices |
| Next Smaller | Right→Left | Increasing | Values/Indices |
| Previous Greater | Left→Right | Decreasing | Values/Indices |
| Previous Smaller | Left→Right | Increasing | Values/Indices |
| Histogram | Left→Right | Increasing | Indices |
| Contribution | Both | Both | Indices |

### Complexity Cheat Sheet

| Problem | Time | Space | Key Trick |
|---------|------|-------|-----------|
| Next Greater/Smaller | O(n) | O(n) | Monotonic property |
| Daily Temperatures | O(n) | O(n) | Store indices |
| Stock Span | O(n) | O(n) | Accumulate spans |
| Histogram | O(n) | O(n) | Sentinel at end |
| Rain Water | O(n) | O(n) or O(1) | Two pointers better |
| Sum of Mins | O(n) | O(n) | Contribution formula |

### Common Mistakes to Avoid

1. ❌ **Wrong comparison**: Using `<` instead of `<=` (or vice versa)
2. ❌ **Wrong direction**: Processing left-to-right for next elements
3. ❌ **Forgetting sentinel**: Not handling remaining stack elements
4. ❌ **Stack contents**: Storing values when indices needed
5. ❌ **Circular arrays**: Not processing twice or using modulo

### Interview Success Tips

1. ✅ **Draw it out**: Visualize stack state at each step
2. ✅ **Dry run**: Walk through small example
3. ✅ **Clarify**: Greater vs greater-or-equal matters!
4. ✅ **Edge cases**: Empty array, all same, strictly increasing/decreasing
5. ✅ **Optimize**: Mention two-pointer alternative when applicable

### Must Master Problems

**Top 5 Essential**:
1. ✅ **Next Greater Element** (Foundation)
2. ✅ **Daily Temperatures** (Most common interview)
3. ✅ **Stock Span** (Real-world application)
4. ✅ **Largest Rectangle in Histogram** (Hard but crucial)
5. ✅ **Trapping Rain Water** (Classic hard problem)

**Practice Path**:
1. Start with Next Greater Element (both versions)
2. Master Daily Temperatures
3. Practice Stock Span
4. Attempt Remove K Digits
5. Challenge: Largest Rectangle in Histogram
6. Ultimate: Maximal Rectangle

### Quick Reference Code

```java
// Next Greater Element Template
public int[] nextGreaterElement(int[] arr) {
    int n = arr.length;
    int[] result = new int[n];
    Deque<Integer> stack = new ArrayDeque<>();
    
    for (int i = n - 1; i >= 0; i--) {
        while (!stack.isEmpty() && stack.peek() <= arr[i]) {
            stack.pop();
        }
        result[i] = stack.isEmpty() ? -1 : stack.peek();
        stack.push(arr[i]);
    }
    
    return result;
}
```

### Next Steps

- **Next**: [8.5 Stack Applications](8.5-Stack-Applications.md)
- **Practice**: Solve all Medium problems first
- **Master**: Histogram pattern (most important for hard problems)

---

**Previous**: [8.3 Stack Using Linked List](8.3-Stack-Using-Linked-List.md)

**Remember**: Monotonic stack is one of the most important patterns for competitive programming and interviews!
