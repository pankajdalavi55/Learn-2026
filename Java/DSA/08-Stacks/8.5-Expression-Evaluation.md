# 8.5 Expression Evaluation

## Table of Contents
1. [Introduction](#introduction)
2. [Expression Notations](#expression-notations)
3. [Postfix Evaluation](#postfix-evaluation)
4. [Prefix Evaluation](#prefix-evaluation)
5. [Infix to Postfix Conversion](#infix-to-postfix-conversion)
6. [Infix to Prefix Conversion](#infix-to-prefix-conversion)
7. [Infix Evaluation](#infix-evaluation)
8. [Calculator Problems](#calculator-problems)
9. [Advanced Problems](#advanced-problems)
10. [Interview Questions](#interview-questions)
11. [Practice Problems](#practice-problems)
12. [Summary](#summary)

---

## Introduction

### What is Expression Evaluation?

**Expression Evaluation** involves computing the result of mathematical expressions represented in different notations:
- **Infix**: Operators between operands (e.g., `A + B`)
- **Postfix** (RPN): Operators after operands (e.g., `A B +`)
- **Prefix** (Polish): Operators before operands (e.g., `+ A B`)

### Why Different Notations?

**Infix** (Human-friendly):
- Natural for humans: `2 + 3 * 4`
- Requires parentheses and operator precedence
- Ambiguous without rules

**Postfix** (Computer-friendly):
- No parentheses needed
- No precedence rules
- Easy stack-based evaluation
- Used by calculators and compilers

**Prefix** (Less common):
- No parentheses needed
- Evaluation from right to left
- Used in some programming languages (Lisp)

### Examples

```
Infix:    (A + B) * C
Postfix:  A B + C *
Prefix:   * + A B C

Infix:    A + B * C
Postfix:  A B C * +
Prefix:   + A * B C
```

---

## Expression Notations

### Infix Notation

**Format**: Operand Operator Operand

**Examples**:
```
Simple: A + B
Complex: (A + B) * (C - D)
With precedence: A + B * C → A + (B * C)
```

**Characteristics**:
- ✅ Human-readable
- ❌ Requires parentheses for clarity
- ❌ Needs operator precedence rules
- ❌ Complex to evaluate directly

---

### Postfix Notation (RPN)

**Format**: Operand Operand Operator

**Examples**:
```
Infix:   A + B          → Postfix: A B +
Infix:   (A + B) * C    → Postfix: A B + C *
Infix:   A + B * C      → Postfix: A B C * +
Infix:   (A + B) * (C - D) → Postfix: A B + C D - *
```

**Characteristics**:
- ✅ No parentheses needed
- ✅ No precedence rules
- ✅ Easy stack evaluation
- ❌ Not human-friendly

**Evaluation**: Left to right with stack

---

### Prefix Notation (Polish)

**Format**: Operator Operand Operand

**Examples**:
```
Infix:   A + B          → Prefix: + A B
Infix:   (A + B) * C    → Prefix: * + A B C
Infix:   A + B * C      → Prefix: + A * B C
Infix:   (A + B) * (C - D) → Prefix: * + A B - C D
```

**Characteristics**:
- ✅ No parentheses needed
- ✅ No precedence rules
- ❌ Evaluation from right to left
- ❌ Less commonly used

---

## Postfix Evaluation

### Algorithm

```
1. Scan postfix expression from left to right
2. If operand: push to stack
3. If operator:
   - Pop two operands (b = pop, a = pop)
   - Compute: a operator b
   - Push result to stack
4. Final stack top is the result
```

### Implementation

```java
public class PostfixEvaluation {
    public static int evaluatePostfix(String expression) {
        Deque<Integer> stack = new ArrayDeque<>();
        String[] tokens = expression.split(" ");
        
        for (String token : tokens) {
            if (isOperator(token)) {
                // Pop two operands (order matters!)
                int b = stack.pop();  // Second operand
                int a = stack.pop();  // First operand
                
                int result = applyOperator(token, a, b);
                stack.push(result);
            } else {
                // Operand: push to stack
                stack.push(Integer.parseInt(token));
            }
        }
        
        return stack.pop();
    }
    
    private static boolean isOperator(String token) {
        return token.equals("+") || token.equals("-") || 
               token.equals("*") || token.equals("/");
    }
    
    private static int applyOperator(String op, int a, int b) {
        switch (op) {
            case "+": return a + b;
            case "-": return a - b;
            case "*": return a * b;
            case "/": return a / b;
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
    
    public static void main(String[] args) {
        // Test cases
        System.out.println(evaluatePostfix("2 3 +"));           // 5
        System.out.println(evaluatePostfix("2 3 + 5 *"));       // 25
        System.out.println(evaluatePostfix("4 13 5 / +"));      // 6
        System.out.println(evaluatePostfix("10 6 9 3 + -11 * / * 17 + 5 +")); // 22
    }
}
```

**LeetCode 150** - Evaluate Reverse Polish Notation

### Detailed Dry Run

```
Expression: "2 3 + 5 *"

Token | Action              | Stack
------|---------------------|----------
2     | Push 2              | [2]
3     | Push 3              | [2, 3]
+     | Pop 3, 2; Push 5    | [5]
5     | Push 5              | [5, 5]
*     | Pop 5, 5; Push 25   | [25]

Result: 25
```

**Complex Example**:
```
Expression: "4 13 5 / +"
Infix: 4 + (13 / 5) = 4 + 2 = 6

Token | Action              | Stack
------|---------------------|----------
4     | Push 4              | [4]
13    | Push 13             | [4, 13]
5     | Push 5              | [4, 13, 5]
/     | Pop 5, 13; Push 2   | [4, 2]
+     | Pop 2, 4; Push 6    | [6]

Result: 6
```

**Time**: O(n) | **Space**: O(n)

---

### Advanced Postfix Evaluation (with exponentiation)

```java
public class PostfixAdvanced {
    public static double evaluatePostfix(String expression) {
        Deque<Double> stack = new ArrayDeque<>();
        String[] tokens = expression.split(" ");
        
        for (String token : tokens) {
            if (isOperator(token)) {
                double b = stack.pop();
                double a = stack.pop();
                stack.push(applyOperator(token, a, b));
            } else {
                stack.push(Double.parseDouble(token));
            }
        }
        
        return stack.pop();
    }
    
    private static boolean isOperator(String token) {
        return "+-*/^".contains(token);
    }
    
    private static double applyOperator(String op, double a, double b) {
        switch (op) {
            case "+": return a + b;
            case "-": return a - b;
            case "*": return a * b;
            case "/": return a / b;
            case "^": return Math.pow(a, b);
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
    
    public static void main(String[] args) {
        System.out.println(evaluatePostfix("2 3 ^"));      // 8 (2^3)
        System.out.println(evaluatePostfix("4 2 + 3 5 1 - * +"));  // 14
    }
}
```

---

## Prefix Evaluation

### Algorithm

```
1. Scan prefix expression from RIGHT to LEFT
2. If operand: push to stack
3. If operator:
   - Pop two operands (a = pop, b = pop)
   - Compute: a operator b
   - Push result to stack
4. Final stack top is the result
```

### Implementation

```java
public class PrefixEvaluation {
    public static int evaluatePrefix(String expression) {
        Deque<Integer> stack = new ArrayDeque<>();
        String[] tokens = expression.split(" ");
        
        // Scan from RIGHT to LEFT
        for (int i = tokens.length - 1; i >= 0; i--) {
            String token = tokens[i];
            
            if (isOperator(token)) {
                // Pop two operands (order matters!)
                int a = stack.pop();  // First operand
                int b = stack.pop();  // Second operand
                
                int result = applyOperator(token, a, b);
                stack.push(result);
            } else {
                // Operand: push to stack
                stack.push(Integer.parseInt(token));
            }
        }
        
        return stack.pop();
    }
    
    private static boolean isOperator(String token) {
        return token.equals("+") || token.equals("-") || 
               token.equals("*") || token.equals("/");
    }
    
    private static int applyOperator(String op, int a, int b) {
        switch (op) {
            case "+": return a + b;
            case "-": return a - b;
            case "*": return a * b;
            case "/": return a / b;
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
    
    public static void main(String[] args) {
        // Test cases
        System.out.println(evaluatePrefix("+ 2 3"));         // 5
        System.out.println(evaluatePrefix("* + 2 3 5"));     // 25
        System.out.println(evaluatePrefix("+ 4 / 13 5"));    // 6
        System.out.println(evaluatePrefix("- * + 2 3 4 5")); // 15
    }
}
```

### Dry Run

```
Expression: "* + 2 3 5"
Infix: (2 + 3) * 5 = 25

Scan from RIGHT to LEFT:

Token | Action              | Stack
------|---------------------|----------
5     | Push 5              | [5]
3     | Push 3              | [5, 3]
2     | Push 2              | [5, 3, 2]
+     | Pop 2, 3; Push 5    | [5, 5]
*     | Pop 5, 5; Push 25   | [25]

Result: 25
```

**Time**: O(n) | **Space**: O(n)

---

## Infix to Postfix Conversion

### Algorithm

```
1. Scan infix expression from left to right
2. If operand: add to output
3. If '(': push to stack
4. If ')': pop until '(' and add to output
5. If operator:
   - Pop operators with higher/equal precedence
   - Push current operator
6. Pop remaining operators to output
```

### Operator Precedence

```
^  (Exponentiation)     : Highest (Right-to-left associative)
*, / (Multiply, Divide) : Medium
+, - (Add, Subtract)    : Lowest
```

### Implementation

```java
public class InfixToPostfix {
    public static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : infix.toCharArray()) {
            // Operand: add to output
            if (Character.isLetterOrDigit(c)) {
                postfix.append(c);
            }
            // Left parenthesis: push to stack
            else if (c == '(') {
                stack.push(c);
            }
            // Right parenthesis: pop until '('
            else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop();  // Remove '('
            }
            // Operator
            else if (isOperator(c)) {
                while (!stack.isEmpty() && 
                       precedence(c) <= precedence(stack.peek())) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        // Pop remaining operators
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        
        return postfix.toString();
    }
    
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
    }
    
    private static int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return -1;
        }
    }
    
    public static void main(String[] args) {
        System.out.println(infixToPostfix("A+B*C"));        // ABC*+
        System.out.println(infixToPostfix("(A+B)*C"));      // AB+C*
        System.out.println(infixToPostfix("A+B*C-D/E"));    // ABC*+DE/-
        System.out.println(infixToPostfix("A*(B+C)/D"));    // ABC+*D/
        System.out.println(infixToPostfix("A+B^C*D"));      // ABC^D*+
    }
}
```

### Detailed Dry Run

```
Infix: "A+B*C"

Char | Action                        | Stack    | Postfix
-----|-------------------------------|----------|--------
A    | Operand → output              | []       | A
+    | Operator → push               | [+]      | A
B    | Operand → output              | [+]      | AB
*    | * > + → push                  | [+, *]   | AB
C    | Operand → output              | [+, *]   | ABC
End  | Pop all                       | []       | ABC*+

Result: ABC*+
```

**Complex Example**:
```
Infix: "(A+B)*C"

Char | Action                        | Stack    | Postfix
-----|-------------------------------|----------|--------
(    | Left paren → push             | [(]      | 
A    | Operand → output              | [(]      | A
+    | Operator → push               | [(, +]   | A
B    | Operand → output              | [(, +]   | AB
)    | Pop until '(' → output        | []       | AB+
*    | Operator → push               | [*]      | AB+
C    | Operand → output              | [*]      | AB+C
End  | Pop all                       | []       | AB+C*

Result: AB+C*
```

**Time**: O(n) | **Space**: O(n)

---

### Right-to-Left Associative Operators

For exponentiation (^), which is right-to-left associative:

```java
private static int precedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return -1;
    }
}

// Modify the operator comparison for right-to-left
while (!stack.isEmpty() && precedence(c) < precedence(stack.peek())) {
    // Use < instead of <= for right-to-left
    postfix.append(stack.pop());
}
```

**Example**:
```
Infix:   A^B^C
Postfix: ABC^^ (not AB^C^)

Because: A^(B^C) not (A^B)^C
```

---

## Infix to Prefix Conversion

### Algorithm

```
1. Reverse the infix expression
2. Replace '(' with ')' and vice versa
3. Convert to postfix
4. Reverse the result
```

### Implementation

```java
public class InfixToPrefix {
    public static String infixToPrefix(String infix) {
        // Step 1: Reverse the infix
        String reversed = new StringBuilder(infix).reverse().toString();
        
        // Step 2: Swap parentheses
        reversed = reversed.replace('(', 'x')
                          .replace(')', '(')
                          .replace('x', ')');
        
        // Step 3: Convert to postfix
        String postfix = infixToPostfix(reversed);
        
        // Step 4: Reverse the postfix
        return new StringBuilder(postfix).reverse().toString();
    }
    
    private static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : infix.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                postfix.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop();
            } else if (isOperator(c)) {
                // Note: Use < for right-to-left after reversal
                while (!stack.isEmpty() && 
                       precedence(c) < precedence(stack.peek())) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        
        return postfix.toString();
    }
    
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
    }
    
    private static int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return -1;
        }
    }
    
    public static void main(String[] args) {
        System.out.println(infixToPrefix("A+B*C"));        // +A*BC
        System.out.println(infixToPrefix("(A+B)*C"));      // *+ABC
        System.out.println(infixToPrefix("A*(B+C)/D"));    // /*A+BCD
    }
}
```

### Dry Run

```
Infix: "(A+B)*C"

Step 1: Reverse → "C*)B+A("
Step 2: Swap parentheses → "C*(B+A)"
Step 3: Infix to Postfix → "CBA+*"
Step 4: Reverse result → "*+ABC"

Result: *+ABC (Prefix)
```

**Time**: O(n) | **Space**: O(n)

---

## Infix Evaluation

### Two-Stack Method

**Algorithm**: Use two stacks - one for operands, one for operators.

```java
public class InfixEvaluation {
    public static int evaluateInfix(String expression) {
        Deque<Integer> operands = new ArrayDeque<>();
        Deque<Character> operators = new ArrayDeque<>();
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            
            // Skip whitespace
            if (c == ' ') continue;
            
            // Operand: parse and push
            if (Character.isDigit(c)) {
                int num = 0;
                while (i < expression.length() && 
                       Character.isDigit(expression.charAt(i))) {
                    num = num * 10 + (expression.charAt(i) - '0');
                    i++;
                }
                i--;  // Adjust for loop increment
                operands.push(num);
            }
            // Left parenthesis: push
            else if (c == '(') {
                operators.push(c);
            }
            // Right parenthesis: evaluate until '('
            else if (c == ')') {
                while (operators.peek() != '(') {
                    operands.push(applyOperation(operators.pop(), 
                                                 operands.pop(), 
                                                 operands.pop()));
                }
                operators.pop();  // Remove '('
            }
            // Operator
            else if (isOperator(c)) {
                // Process higher precedence operators first
                while (!operators.isEmpty() && 
                       precedence(c) <= precedence(operators.peek())) {
                    operands.push(applyOperation(operators.pop(), 
                                                 operands.pop(), 
                                                 operands.pop()));
                }
                operators.push(c);
            }
        }
        
        // Process remaining operators
        while (!operators.isEmpty()) {
            operands.push(applyOperation(operators.pop(), 
                                        operands.pop(), 
                                        operands.pop()));
        }
        
        return operands.pop();
    }
    
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
    
    private static int precedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        return 0;
    }
    
    private static int applyOperation(char op, int b, int a) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }
    
    public static void main(String[] args) {
        System.out.println(evaluateInfix("10 + 2 * 6"));        // 22
        System.out.println(evaluateInfix("100 * 2 + 12"));      // 212
        System.out.println(evaluateInfix("100 * ( 2 + 12 )"));  // 1400
        System.out.println(evaluateInfix("100 * ( 2 + 12 ) / 14")); // 100
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Calculator Problems

### Problem 1: Basic Calculator (LC 224) ⭐⭐⭐⭐

**Problem**: Evaluate expression with `+`, `-`, `(`, `)`.

**Input**: `s = "(1+(4+5+2)-3)+(6+8)"`
**Output**: `23`

**Solution**:
```java
public class BasicCalculator {
    public int calculate(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        int result = 0;
        int number = 0;
        int sign = 1;  // 1 for positive, -1 for negative
        
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                number = number * 10 + (c - '0');
            } else if (c == '+') {
                result += sign * number;
                number = 0;
                sign = 1;
            } else if (c == '-') {
                result += sign * number;
                number = 0;
                sign = -1;
            } else if (c == '(') {
                // Push result and sign to stack
                stack.push(result);
                stack.push(sign);
                // Reset for expression inside parentheses
                result = 0;
                sign = 1;
            } else if (c == ')') {
                result += sign * number;
                number = 0;
                // Pop sign and previous result
                result *= stack.pop();  // sign
                result += stack.pop();  // previous result
            }
        }
        
        // Add last number
        result += sign * number;
        
        return result;
    }
    
    public static void main(String[] args) {
        BasicCalculator calc = new BasicCalculator();
        System.out.println(calc.calculate("1 + 1"));              // 2
        System.out.println(calc.calculate(" 2-1 + 2 "));          // 3
        System.out.println(calc.calculate("(1+(4+5+2)-3)+(6+8)")); // 23
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 2: Basic Calculator II (LC 227) ⭐⭐⭐

**Problem**: Evaluate with `+`, `-`, `*`, `/` (no parentheses).

**Input**: `s = "3+2*2"`
**Output**: `7`

**Solution**:
```java
public class BasicCalculatorII {
    public int calculate(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        int number = 0;
        char operation = '+';
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (Character.isDigit(c)) {
                number = number * 10 + (c - '0');
            }
            
            // Process when operator found or at end
            if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {
                if (operation == '+') {
                    stack.push(number);
                } else if (operation == '-') {
                    stack.push(-number);
                } else if (operation == '*') {
                    stack.push(stack.pop() * number);
                } else if (operation == '/') {
                    stack.push(stack.pop() / number);
                }
                
                operation = c;
                number = 0;
            }
        }
        
        // Sum all values in stack
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        BasicCalculatorII calc = new BasicCalculatorII();
        System.out.println(calc.calculate("3+2*2"));      // 7
        System.out.println(calc.calculate(" 3/2 "));      // 1
        System.out.println(calc.calculate(" 3+5 / 2 "));  // 5
    }
}
```

**Key Idea**: Handle `*` and `/` immediately, push `+` and `-` results to stack.

**Time**: O(n) | **Space**: O(n)

---

### Problem 3: Basic Calculator III (LC 772) ⭐⭐⭐⭐

**Problem**: Evaluate with `+`, `-`, `*`, `/`, `(`, `)`.

**Solution**: Combine both approaches.

```java
public class BasicCalculatorIII {
    private int index = 0;
    
    public int calculate(String s) {
        index = 0;
        return evaluate(s);
    }
    
    private int evaluate(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        int number = 0;
        char operation = '+';
        
        while (index < s.length()) {
            char c = s.charAt(index++);
            
            if (Character.isDigit(c)) {
                number = number * 10 + (c - '0');
            } else if (c == '(') {
                number = evaluate(s);  // Recursive call
            }
            
            if (c == ')' || (!Character.isDigit(c) && c != ' ') || 
                index == s.length()) {
                
                if (operation == '+') {
                    stack.push(number);
                } else if (operation == '-') {
                    stack.push(-number);
                } else if (operation == '*') {
                    stack.push(stack.pop() * number);
                } else if (operation == '/') {
                    stack.push(stack.pop() / number);
                }
                
                if (c == ')') break;
                
                operation = c;
                number = 0;
            }
        }
        
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        BasicCalculatorIII calc = new BasicCalculatorIII();
        System.out.println(calc.calculate("1 + 1"));           // 2
        System.out.println(calc.calculate("6-4/2"));           // 4
        System.out.println(calc.calculate("2*(5+5*2)/3+(6/2+8)")); // 21
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Advanced Problems

### Problem 1: Different Ways to Add Parentheses ⭐⭐⭐

**LeetCode 241** | **Difficulty: Medium**

**Problem**: Return all possible results from different parenthesizations.

**Input**: `expression = "2-1-1"`
**Output**: `[0, 2]`

**Explanation**:
```
((2-1)-1) = 0
(2-(1-1)) = 2
```

**Solution**:
```java
public class DifferentWaysToAddParentheses {
    public List<Integer> diffWaysToCompute(String expression) {
        List<Integer> result = new ArrayList<>();
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            
            if (c == '+' || c == '-' || c == '*') {
                // Divide: split at operator
                String left = expression.substring(0, i);
                String right = expression.substring(i + 1);
                
                // Conquer: recursively compute both parts
                List<Integer> leftResults = diffWaysToCompute(left);
                List<Integer> rightResults = diffWaysToCompute(right);
                
                // Combine: apply operator to all combinations
                for (int l : leftResults) {
                    for (int r : rightResults) {
                        if (c == '+') {
                            result.add(l + r);
                        } else if (c == '-') {
                            result.add(l - r);
                        } else if (c == '*') {
                            result.add(l * r);
                        }
                    }
                }
            }
        }
        
        // Base case: single number
        if (result.isEmpty()) {
            result.add(Integer.parseInt(expression));
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        DifferentWaysToAddParentheses solution = new DifferentWaysToAddParentheses();
        System.out.println(solution.diffWaysToCompute("2-1-1"));     // [0, 2]
        System.out.println(solution.diffWaysToCompute("2*3-4*5"));   // [-34, -14, -10, -10, 10]
    }
}
```

**With Memoization**:
```java
public List<Integer> diffWaysToCompute(String expression) {
    Map<String, List<Integer>> memo = new HashMap<>();
    return compute(expression, memo);
}

private List<Integer> compute(String expression, Map<String, List<Integer>> memo) {
    if (memo.containsKey(expression)) {
        return memo.get(expression);
    }
    
    List<Integer> result = new ArrayList<>();
    
    for (int i = 0; i < expression.length(); i++) {
        char c = expression.charAt(i);
        
        if (c == '+' || c == '-' || c == '*') {
            List<Integer> left = compute(expression.substring(0, i), memo);
            List<Integer> right = compute(expression.substring(i + 1), memo);
            
            for (int l : left) {
                for (int r : right) {
                    if (c == '+') result.add(l + r);
                    else if (c == '-') result.add(l - r);
                    else if (c == '*') result.add(l * r);
                }
            }
        }
    }
    
    if (result.isEmpty()) {
        result.add(Integer.parseInt(expression));
    }
    
    memo.put(expression, result);
    return result;
}
```

**Time**: O(2^n) without memo, O(n × 2^n) with memo
**Space**: O(2^n)

---

### Problem 2: Parsing Boolean Expression ⭐⭐⭐

**LeetCode 1106** | **Difficulty: Hard**

**Problem**: Parse boolean expression with `&` (AND), `|` (OR), `!` (NOT).

**Input**: `expression = "!(f)"`
**Output**: `true`

**Solution**:
```java
public class ParseBooleanExpression {
    private int index = 0;
    
    public boolean parseBoolExpr(String expression) {
        index = 0;
        return parse(expression);
    }
    
    private boolean parse(String expr) {
        char c = expr.charAt(index++);
        
        if (c == 't') return true;
        if (c == 'f') return false;
        
        // Operator: &, |, !
        index++;  // Skip '('
        
        List<Boolean> values = new ArrayList<>();
        
        while (expr.charAt(index) != ')') {
            if (expr.charAt(index) == ',') {
                index++;
            } else {
                values.add(parse(expr));
            }
        }
        
        index++;  // Skip ')'
        
        // Apply operator
        if (c == '&') {
            return values.stream().allMatch(b -> b);
        } else if (c == '|') {
            return values.stream().anyMatch(b -> b);
        } else {  // c == '!'
            return !values.get(0);
        }
    }
    
    public static void main(String[] args) {
        ParseBooleanExpression solution = new ParseBooleanExpression();
        System.out.println(solution.parseBoolExpr("!(f)"));        // true
        System.out.println(solution.parseBoolExpr("|(f,t)"));      // true
        System.out.println(solution.parseBoolExpr("&(t,f)"));      // false
        System.out.println(solution.parseBoolExpr("|(&(t,f,t),!(t))")); // false
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

## Interview Questions

### Question 1: Evaluate Expression with Variables

**Problem**: Evaluate expression where operands can be variables.

**Example**:
```
Expression: "A + B * C"
Variables: A=2, B=3, C=4
Result: 2 + 3 * 4 = 14
```

**Solution**:
```java
public class ExpressionWithVariables {
    public static int evaluate(String expression, Map<Character, Integer> vars) {
        // Convert to postfix
        String postfix = infixToPostfix(expression);
        
        // Evaluate postfix with variable substitution
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (char c : postfix.toCharArray()) {
            if (Character.isLetter(c)) {
                stack.push(vars.get(c));
            } else if (isOperator(c)) {
                int b = stack.pop();
                int a = stack.pop();
                stack.push(applyOperator(c, a, b));
            }
        }
        
        return stack.pop();
    }
    
    // ... (include infixToPostfix and helper methods from earlier)
    
    public static void main(String[] args) {
        Map<Character, Integer> vars = new HashMap<>();
        vars.put('A', 2);
        vars.put('B', 3);
        vars.put('C', 4);
        
        System.out.println(evaluate("A+B*C", vars));  // 14
        System.out.println(evaluate("(A+B)*C", vars)); // 20
    }
}
```

---

### Question 2: Check if Expression is Valid

**Problem**: Check if mathematical expression has valid syntax.

**Solution**:
```java
public class ValidExpression {
    public static boolean isValid(String expression) {
        Deque<Character> stack = new ArrayDeque<>();
        boolean expectOperand = true;
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            
            if (c == ' ') continue;
            
            if (c == '(') {
                stack.push(c);
                expectOperand = true;
            } else if (c == ')') {
                if (stack.isEmpty() || expectOperand) return false;
                stack.pop();
                expectOperand = false;
            } else if (Character.isLetterOrDigit(c)) {
                if (!expectOperand) return false;
                expectOperand = false;
            } else if (isOperator(c)) {
                if (expectOperand) return false;
                expectOperand = true;
            } else {
                return false;  // Invalid character
            }
        }
        
        return stack.isEmpty() && !expectOperand;
    }
    
    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/';
    }
    
    public static void main(String[] args) {
        System.out.println(isValid("A+B*C"));      // true
        System.out.println(isValid("(A+B)*C"));    // true
        System.out.println(isValid("A++B"));       // false
        System.out.println(isValid("(A+B"));       // false
        System.out.println(isValid("A+B)"));       // false
    }
}
```

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Key Concept |
|---|---------|----------|-------------|
| 1 | Evaluate Reverse Polish Notation | 150 | Postfix evaluation |
| 2 | Valid Parentheses | 20 | Stack matching |
| 3 | Score of Parentheses | 856 | Stack depth |
| 4 | Maximum Nesting Depth | 1614 | Parentheses count |
| 5 | Remove Outermost Parentheses | 1021 | Stack depth tracking |

### Medium Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Basic Calculator II | 227 | No parentheses | ⭐⭐⭐⭐⭐ |
| 2 | Decode String | 394 | Nested encoding | ⭐⭐⭐⭐ |
| 3 | Different Ways to Add Parentheses | 241 | Divide & conquer | ⭐⭐⭐ |
| 4 | Evaluate Division | 399 | Graph + division | ⭐⭐⭐ |
| 5 | Ternary Expression Parser | 439 | Stack or recursion | ⭐⭐ |
| 6 | Mini Parser | 385 | Nested list | ⭐⭐ |
| 7 | Remove Comments | 722 | State machine | ⭐⭐ |
| 8 | Check If Word Is Valid | 678 | Stack matching | ⭐⭐⭐ |

### Hard Problems

| # | Problem | LeetCode | Key Concept | Importance |
|---|---------|----------|-------------|------------|
| 1 | Basic Calculator | 224 | Full calculator | ⭐⭐⭐⭐⭐ |
| 2 | Basic Calculator III | 772 | All operators | ⭐⭐⭐⭐⭐ |
| 3 | Parsing A Boolean Expression | 1106 | Boolean logic | ⭐⭐⭐ |
| 4 | Expression Add Operators | 282 | Backtracking | ⭐⭐⭐⭐ |
| 5 | Basic Calculator IV | 770 | Polynomial | ⭐⭐⭐ |

---

## Summary

### Key Concepts

**1. Expression Notations**:
```
Infix:   A + B * C        (Human-friendly)
Postfix: A B C * +        (Computer-friendly)
Prefix:  + A * B C        (Lisp-style)
```

**2. Evaluation Algorithms**:
- **Postfix**: Scan left→right, use stack
- **Prefix**: Scan right→left, use stack
- **Infix**: Convert to postfix or use two stacks

**3. Conversion Algorithms**:
- **Infix → Postfix**: Operator precedence stack
- **Infix → Prefix**: Reverse, convert, reverse
- **Postfix → Infix**: Use stack with parentheses

### Operator Precedence Table

| Operator | Precedence | Associativity |
|----------|------------|---------------|
| `^` | 3 (Highest) | Right-to-left |
| `*`, `/` | 2 | Left-to-right |
| `+`, `-` | 1 | Left-to-right |
| `(`, `)` | 0 (Special) | - |

### Algorithm Comparison

| Task | Algorithm | Time | Space |
|------|-----------|------|-------|
| Postfix Eval | Stack (L→R) | O(n) | O(n) |
| Prefix Eval | Stack (R→L) | O(n) | O(n) |
| Infix→Postfix | Operator Stack | O(n) | O(n) |
| Infix→Prefix | Reverse+Convert | O(n) | O(n) |
| Infix Eval | Two Stacks | O(n) | O(n) |

### Templates

**Postfix Evaluation Template**:
```java
for (String token : tokens) {
    if (isOperator(token)) {
        int b = stack.pop();
        int a = stack.pop();
        stack.push(apply(op, a, b));
    } else {
        stack.push(Integer.parseInt(token));
    }
}
return stack.pop();
```

**Infix to Postfix Template**:
```java
for (char c : infix) {
    if (isOperand(c)) {
        output.append(c);
    } else if (c == '(') {
        stack.push(c);
    } else if (c == ')') {
        while (stack.peek() != '(')
            output.append(stack.pop());
        stack.pop();
    } else {  // operator
        while (!stack.isEmpty() && 
               precedence(c) <= precedence(stack.peek()))
            output.append(stack.pop());
        stack.push(c);
    }
}
```

### Calculator Problem Patterns

**Calculator I** (LC 224):
- Operators: `+`, `-`, `(`, `)`
- Handle signs with stack
- O(n) time

**Calculator II** (LC 227):
- Operators: `+`, `-`, `*`, `/`
- No parentheses
- Process `*`, `/` immediately

**Calculator III** (LC 772):
- All operators
- Recursion for parentheses
- Combines both approaches

### Common Mistakes

1. ❌ **Operand order**: `a - b` vs `b - a` when popping
2. ❌ **Precedence**: Forgetting right-to-left for `^`
3. ❌ **Parentheses**: Not handling nested properly
4. ❌ **Multi-digit**: Not parsing numbers correctly
5. ❌ **Division**: Integer vs float division
6. ❌ **Edge cases**: Empty string, single operand

### Interview Tips

1. ✅ **Clarify notation**: Infix, postfix, or prefix?
2. ✅ **Ask about operators**: Which ones are supported?
3. ✅ **Handle whitespace**: Should spaces be ignored?
4. ✅ **Multi-digit numbers**: How to parse?
5. ✅ **Error handling**: What if expression is invalid?
6. ✅ **Optimization**: Can you avoid conversion?

### Must Master Problems

**Top 5 Essential**:
1. ✅ **Evaluate Reverse Polish Notation** (LC 150) - Foundation
2. ✅ **Basic Calculator II** (LC 227) - Most common
3. ✅ **Basic Calculator** (LC 224) - With parentheses
4. ✅ **Infix to Postfix** - Classic conversion
5. ✅ **Different Ways to Add Parentheses** (LC 241) - Creative

**Practice Path**:
1. Start with postfix evaluation
2. Master infix to postfix conversion
3. Practice Calculator II (no parentheses)
4. Attempt Calculator I (with parentheses)
5. Challenge: Calculator III (complete)

### Quick Reference

**Postfix Evaluation**:
```java
if (isOperator) {
    b = pop(); a = pop();
    push(a op b);
} else {
    push(operand);
}
```

**Infix to Postfix**:
```java
if (operand) output += c;
else if (c == '(') push(c);
else if (c == ')') popUntil('(');
else {  // operator
    popHigherPrecedence();
    push(c);
}
```

### Next Steps

- **Next**: [8.6 Stack Practice Problems](8.6-Stack-Practice-Problems.md)
- **Master**: Calculator I, II, III sequence
- **Challenge**: Expression Add Operators (LC 282)

---

**Previous**: [8.4 Monotonic Stack](8.4-Monotonic-Stack.md)

**Remember**: Expression evaluation is crucial for compiler design and calculator implementations!
