# 8.6 Stack Practice Problems

## Table of Contents
1. [Problem Categories](#problem-categories)
2. [Easy Problems](#easy-problems)
3. [Medium Problems](#medium-problems)
4. [Hard Problems](#hard-problems)
5. [Pattern Recognition Guide](#pattern-recognition-guide)
6. [Solutions](#solutions)
7. [Summary](#summary)

---

## Problem Categories

### 1. Parentheses Matching (5 problems)
- Valid Parentheses
- Generate Parentheses
- Minimum Remove to Make Valid
- Longest Valid Parentheses
- Remove Invalid Parentheses

### 2. Monotonic Stack (8 problems)
- Next Greater Element
- Daily Temperatures
- Stock Span Problem
- Largest Rectangle in Histogram
- Trapping Rain Water
- Maximal Rectangle
- Sum of Subarray Minimums
- Remove K Digits

### 3. Expression Evaluation (6 problems)
- Evaluate Reverse Polish Notation
- Basic Calculator I, II, III
- Different Ways to Add Parentheses
- Parsing Boolean Expression

### 4. String Problems (5 problems)
- Decode String
- Remove Duplicate Letters
- Simplify Path
- Asteroid Collision
- Valid Palindrome II

### 5. Design Problems (4 problems)
- Min Stack
- Max Stack
- Implement Queue using Stacks
- Implement Stack using Queues

### 6. Advanced (7 problems)
- Largest Rectangle in Histogram
- Car Fleet
- Online Stock Span
- Exclusive Time of Functions
- Flatten Nested List Iterator

---

## Easy Problems

### Problem 1: Valid Parentheses ⭐⭐⭐⭐⭐

**LeetCode 20** | **Difficulty: Easy** | **Frequency: Very High**

**Problem**: Given string with `()`, `{}`, `[]`, check if valid.

**Input**: `s = "()[]{}"`
**Output**: `true`

**Constraints**:
- 1 ≤ s.length ≤ 10^4
- s consists of parentheses only

**Solution**:
```java
public class ValidParentheses {
    public boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                
                char top = stack.pop();
                if (c == ')' && top != '(') return false;
                if (c == '}' && top != '{') return false;
                if (c == ']' && top != '[') return false;
            }
        }
        
        return stack.isEmpty();
    }
    
    // Alternative: Using HashMap for cleaner code
    public boolean isValidMap(String s) {
        Map<Character, Character> map = new HashMap<>();
        map.put(')', '(');
        map.put('}', '{');
        map.put(']', '[');
        
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            if (map.containsKey(c)) {
                char top = stack.isEmpty() ? '#' : stack.pop();
                if (top != map.get(c)) return false;
            } else {
                stack.push(c);
            }
        }
        
        return stack.isEmpty();
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Key Points**:
- Push opening brackets
- Match closing with top of stack
- Stack must be empty at end

---

### Problem 2: Remove Outermost Parentheses ⭐⭐

**LeetCode 1021** | **Difficulty: Easy**

**Problem**: Remove outermost parentheses from every primitive string.

**Input**: `s = "(()())(())"`
**Output**: `"()()()"`

**Explanation**: 
- `(()())` → `()()`
- `(())` → `()`

**Solution**:
```java
public class RemoveOutermostParentheses {
    public String removeOuterParentheses(String s) {
        StringBuilder result = new StringBuilder();
        int depth = 0;
        
        for (char c : s.toCharArray()) {
            if (c == '(') {
                if (depth > 0) {
                    result.append(c);
                }
                depth++;
            } else {
                depth--;
                if (depth > 0) {
                    result.append(c);
                }
            }
        }
        
        return result.toString();
    }
    
    // Alternative: Using Stack
    public String removeOuterParenthesesStack(String s) {
        StringBuilder result = new StringBuilder();
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            if (c == '(') {
                if (!stack.isEmpty()) {
                    result.append(c);
                }
                stack.push(c);
            } else {
                stack.pop();
                if (!stack.isEmpty()) {
                    result.append(c);
                }
            }
        }
        
        return result.toString();
    }
}
```

**Time**: O(n) | **Space**: O(1) without stack, O(n) with stack

---

### Problem 3: Baseball Game ⭐⭐

**LeetCode 682** | **Difficulty: Easy**

**Problem**: Track baseball score with special operations.

**Operations**:
- Integer: Add score
- `+`: Add sum of last two scores
- `D`: Add double of last score
- `C`: Remove last score

**Input**: `ops = ["5","2","C","D","+"]`
**Output**: `30`

**Explanation**:
```
"5" → [5] (sum 5)
"2" → [5, 2] (sum 7)
"C" → [5] (sum 5)
"D" → [5, 10] (sum 15)
"+" → [5, 10, 15] (sum 30)
```

**Solution**:
```java
public class BaseballGame {
    public int calPoints(String[] operations) {
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (String op : operations) {
            if (op.equals("+")) {
                int top = stack.pop();
                int newScore = top + stack.peek();
                stack.push(top);
                stack.push(newScore);
            } else if (op.equals("D")) {
                stack.push(2 * stack.peek());
            } else if (op.equals("C")) {
                stack.pop();
            } else {
                stack.push(Integer.parseInt(op));
            }
        }
        
        int sum = 0;
        while (!stack.isEmpty()) {
            sum += stack.pop();
        }
        
        return sum;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 4: Next Greater Element I ⭐⭐⭐

**LeetCode 496** | **Difficulty: Easy**

**Problem**: Find next greater element for nums1 elements in nums2.

**Input**: `nums1 = [4,1,2]`, `nums2 = [1,3,4,2]`
**Output**: `[-1,3,-1]`

**Explanation**:
- 4: No greater in nums2 → -1
- 1: Next greater is 3
- 2: No greater → -1

**Solution**:
```java
public class NextGreaterElementI {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> nextGreater = new HashMap<>();
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Build next greater map for nums2
        for (int num : nums2) {
            while (!stack.isEmpty() && stack.peek() < num) {
                nextGreater.put(stack.pop(), num);
            }
            stack.push(num);
        }
        
        // Build result for nums1
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreater.getOrDefault(nums1[i], -1);
        }
        
        return result;
    }
}
```

**Time**: O(n + m) | **Space**: O(n)

---

### Problem 5: Backspace String Compare ⭐⭐⭐

**LeetCode 844** | **Difficulty: Easy**

**Problem**: Compare two strings with backspace character `#`.

**Input**: `s = "ab#c"`, `t = "ad#c"`
**Output**: `true`

**Explanation**: Both become `"ac"`.

**Solution 1: Using Stack**:
```java
public class BackspaceStringCompare {
    public boolean backspaceCompare(String s, String t) {
        return build(s).equals(build(t));
    }
    
    private String build(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            if (c != '#') {
                stack.push(c);
            } else if (!stack.isEmpty()) {
                stack.pop();
            }
        }
        
        return stack.toString();
    }
}
```

**Solution 2: Two Pointers (O(1) Space)**:
```java
public boolean backspaceCompare(String s, String t) {
    int i = s.length() - 1;
    int j = t.length() - 1;
    
    while (i >= 0 || j >= 0) {
        i = findNextValidChar(s, i);
        j = findNextValidChar(t, j);
        
        if (i >= 0 && j >= 0 && s.charAt(i) != t.charAt(j)) {
            return false;
        }
        
        if ((i >= 0) != (j >= 0)) {
            return false;
        }
        
        i--;
        j--;
    }
    
    return true;
}

private int findNextValidChar(String s, int index) {
    int backspace = 0;
    
    while (index >= 0) {
        if (s.charAt(index) == '#') {
            backspace++;
        } else if (backspace > 0) {
            backspace--;
        } else {
            break;
        }
        index--;
    }
    
    return index;
}
```

**Time**: O(n + m)
**Space**: O(n + m) with stack, O(1) with two pointers

---

## Medium Problems

### Problem 6: Daily Temperatures ⭐⭐⭐⭐⭐

**LeetCode 739** | **Difficulty: Medium** | **Frequency: Very High**

**Problem**: Find days until warmer temperature.

**Input**: `temperatures = [73,74,75,71,69,72,76,73]`
**Output**: `[1,1,4,2,1,1,0,0]`

**Solution**:
```java
public class DailyTemperatures {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] result = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && 
                   temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                result[idx] = i - idx;
            }
            stack.push(i);
        }
        
        return result;
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Pattern**: Monotonic decreasing stack for next greater element.

---

### Problem 7: Decode String ⭐⭐⭐⭐

**LeetCode 394** | **Difficulty: Medium** | **Frequency: High**

**Problem**: Decode encoded string `k[encoded_string]`.

**Input**: `s = "3[a2[c]]"`
**Output**: `"accaccacc"`

**Explanation**:
```
2[c] = "cc"
a2[c] = "acc"
3[acc] = "accaccacc"
```

**Solution**:
```java
public class DecodeString {
    public String decodeString(String s) {
        Deque<Integer> countStack = new ArrayDeque<>();
        Deque<StringBuilder> stringStack = new ArrayDeque<>();
        StringBuilder current = new StringBuilder();
        int k = 0;
        
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                k = k * 10 + (c - '0');
            } else if (c == '[') {
                countStack.push(k);
                stringStack.push(current);
                current = new StringBuilder();
                k = 0;
            } else if (c == ']') {
                StringBuilder decoded = stringStack.pop();
                int count = countStack.pop();
                for (int i = 0; i < count; i++) {
                    decoded.append(current);
                }
                current = decoded;
            } else {
                current.append(c);
            }
        }
        
        return current.toString();
    }
}
```

**Time**: O(n × k) where k is max repeat count
**Space**: O(n)

**Key Points**:
- Use two stacks: count and string
- Build string incrementally
- Repeat when `]` encountered

---

### Problem 8: Asteroid Collision ⭐⭐⭐⭐

**LeetCode 735** | **Difficulty: Medium**

**Problem**: Simulate asteroid collisions.

**Rules**:
- Positive = moving right
- Negative = moving left
- Same size → both explode
- Different size → smaller explodes

**Input**: `asteroids = [5,10,-5]`
**Output**: `[5,10]`

**Explanation**: -5 and 10 collide, 10 survives.

**Solution**:
```java
public class AsteroidCollision {
    public int[] asteroidCollision(int[] asteroids) {
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (int asteroid : asteroids) {
            boolean alive = true;
            
            while (alive && asteroid < 0 && !stack.isEmpty() && stack.peek() > 0) {
                // Collision: right-moving vs left-moving
                if (stack.peek() < -asteroid) {
                    stack.pop();  // Top asteroid explodes
                    continue;
                } else if (stack.peek() == -asteroid) {
                    stack.pop();  // Both explode
                }
                alive = false;  // Current asteroid explodes
            }
            
            if (alive) {
                stack.push(asteroid);
            }
        }
        
        // Convert stack to array
        int[] result = new int[stack.size()];
        for (int i = result.length - 1; i >= 0; i--) {
            result[i] = stack.pop();
        }
        
        return result;
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Key Points**:
- Stack stores surviving asteroids
- Only right-moving can collide with left-moving
- Handle all three collision cases

---

### Problem 9: Simplify Path ⭐⭐⭐

**LeetCode 71** | **Difficulty: Medium**

**Problem**: Simplify Unix file path.

**Input**: `path = "/a/./b/../../c/"`
**Output**: `"/c"`

**Rules**:
- `.` = current directory (ignore)
- `..` = parent directory (pop)
- Multiple `/` = single `/`

**Solution**:
```java
public class SimplifyPath {
    public String simplifyPath(String path) {
        Deque<String> stack = new ArrayDeque<>();
        String[] parts = path.split("/");
        
        for (String part : parts) {
            if (part.equals("..")) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!part.isEmpty() && !part.equals(".")) {
                stack.push(part);
            }
        }
        
        // Build result from bottom to top
        StringBuilder result = new StringBuilder();
        for (String dir : stack) {
            result.insert(0, "/" + dir);
        }
        
        return result.length() == 0 ? "/" : result.toString();
    }
    
    // Alternative: Using Collections.reverse
    public String simplifyPathReverse(String path) {
        Deque<String> stack = new ArrayDeque<>();
        String[] parts = path.split("/");
        
        for (String part : parts) {
            if (part.equals("..")) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!part.isEmpty() && !part.equals(".")) {
                stack.push(part);
            }
        }
        
        List<String> list = new ArrayList<>(stack);
        Collections.reverse(list);
        
        return "/" + String.join("/", list);
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 10: Remove K Digits ⭐⭐⭐⭐

**LeetCode 402** | **Difficulty: Medium**

**Problem**: Remove k digits to get smallest number.

**Input**: `num = "1432219"`, `k = 3`
**Output**: `"1219"`

**Explanation**: Remove 4, 3, 2 → `"1219"`.

**Solution**:
```java
public class RemoveKDigits {
    public String removeKdigits(String num, int k) {
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char digit : num.toCharArray()) {
            // Remove larger digits while possible
            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {
                stack.pop();
                k--;
            }
            stack.push(digit);
        }
        
        // Remove remaining k digits from end
        while (k > 0) {
            stack.pop();
            k--;
        }
        
        // Build result and remove leading zeros
        StringBuilder result = new StringBuilder();
        boolean leadingZero = true;
        
        for (char c : stack) {
            if (c != '0' || !leadingZero) {
                result.append(c);
                leadingZero = false;
            }
        }
        
        return result.length() == 0 ? "0" : result.toString();
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Pattern**: Monotonic increasing stack.

---

### Problem 11: Online Stock Span ⭐⭐⭐⭐

**LeetCode 901** | **Difficulty: Medium**

**Problem**: Design class to calculate stock price span.

**Span**: Maximum consecutive days (today + before) with price ≤ today's price.

**Solution**:
```java
public class StockSpanner {
    private Deque<int[]> stack;  // [price, span]
    
    public StockSpanner() {
        stack = new ArrayDeque<>();
    }
    
    public int next(int price) {
        int span = 1;
        
        while (!stack.isEmpty() && stack.peek()[0] <= price) {
            span += stack.pop()[1];
        }
        
        stack.push(new int[]{price, span});
        return span;
    }
}

/**
 * Usage:
 * StockSpanner obj = new StockSpanner();
 * obj.next(100);  // 1
 * obj.next(80);   // 1
 * obj.next(60);   // 1
 * obj.next(70);   // 2
 * obj.next(60);   // 1
 * obj.next(75);   // 4
 * obj.next(85);   // 6
 */
```

**Time**: O(1) amortized | **Space**: O(n)

---

### Problem 12: Car Fleet ⭐⭐⭐

**LeetCode 853** | **Difficulty: Medium**

**Problem**: Calculate number of car fleets reaching destination.

**Input**: 
```
target = 12
position = [10,8,0,5,3]
speed = [2,4,1,1,3]
```
**Output**: `3`

**Explanation**: Cars form 3 fleets: [0], [3,5], [8,10].

**Solution**:
```java
public class CarFleet {
    public int carFleet(int target, int[] position, int[] speed) {
        int n = position.length;
        double[][] cars = new double[n][2];
        
        // [position, time to reach target]
        for (int i = 0; i < n; i++) {
            cars[i][0] = position[i];
            cars[i][1] = (double)(target - position[i]) / speed[i];
        }
        
        // Sort by position (descending)
        Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0]));
        
        Deque<Double> stack = new ArrayDeque<>();
        
        for (double[] car : cars) {
            double time = car[1];
            
            // If current car takes longer, it forms new fleet
            if (stack.isEmpty() || time > stack.peek()) {
                stack.push(time);
            }
        }
        
        return stack.size();
    }
}
```

**Time**: O(n log n) | **Space**: O(n)

**Key Points**:
- Sort cars by position
- Car taking longer time forms new fleet
- Faster car catches slower → same fleet

---

### Problem 13: Minimum Remove to Make Valid Parentheses ⭐⭐⭐

**LeetCode 1249** | **Difficulty: Medium**

**Problem**: Remove minimum parentheses to make string valid.

**Input**: `s = "lee(t(c)o)de)"`
**Output**: `"lee(t(c)o)de"`

**Solution**:
```java
public class MinimumRemoveToMakeValid {
    public String minRemoveToMakeValid(String s) {
        Set<Integer> toRemove = new HashSet<>();
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Find indices to remove
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (c == '(') {
                stack.push(i);
            } else if (c == ')') {
                if (stack.isEmpty()) {
                    toRemove.add(i);
                } else {
                    stack.pop();
                }
            }
        }
        
        // Add unmatched '(' to remove set
        while (!stack.isEmpty()) {
            toRemove.add(stack.pop());
        }
        
        // Build result
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (!toRemove.contains(i)) {
                result.append(s.charAt(i));
            }
        }
        
        return result.toString();
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 14: Sum of Subarray Minimums ⭐⭐⭐⭐

**LeetCode 907** | **Difficulty: Medium**

**Problem**: Sum of minimums of all subarrays.

**Input**: `arr = [3,1,2,4]`
**Output**: `17`

**Explanation**:
```
Subarrays and mins:
[3] → 3
[1] → 1
[2] → 2
[4] → 4
[3,1] → 1
[1,2] → 1
[2,4] → 2
[3,1,2] → 1
[1,2,4] → 1
[3,1,2,4] → 1
Sum = 17
```

**Solution**:
```java
public class SumOfSubarrayMinimums {
    private static final int MOD = 1_000_000_007;
    
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        
        // left[i] = number of elements arr[i] is minimum for (to the left)
        int[] left = new int[n];
        // right[i] = number of elements arr[i] is minimum for (to the right)
        int[] right = new int[n];
        
        // Calculate left array (previous smaller)
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
                stack.pop();
            }
            left[i] = stack.isEmpty() ? i + 1 : i - stack.peek();
            stack.push(i);
        }
        
        // Calculate right array (next smaller or equal)
        stack.clear();
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            right[i] = stack.isEmpty() ? n - i : stack.peek() - i;
            stack.push(i);
        }
        
        // Calculate sum
        long result = 0;
        for (int i = 0; i < n; i++) {
            result = (result + (long)arr[i] * left[i] * right[i]) % MOD;
        }
        
        return (int)result;
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Pattern**: Contribution technique with monotonic stack.

---

## Hard Problems

### Problem 15: Largest Rectangle in Histogram ⭐⭐⭐⭐⭐

**LeetCode 84** | **Difficulty: Hard** | **Frequency: Very High**

**Problem**: Find largest rectangle area in histogram.

**Input**: `heights = [2,1,5,6,2,3]`
**Output**: `10`

**Explanation**: Largest rectangle is 5×2 = 10.

**Solution**:
```java
public class LargestRectangleInHistogram {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        int maxArea = 0;
        int n = heights.length;
        
        for (int i = 0; i <= n; i++) {
            int h = (i == n) ? 0 : heights[i];
            
            while (!stack.isEmpty() && h < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack.push(i);
        }
        
        return maxArea;
    }
}
```

**Time**: O(n) | **Space**: O(n)

**Key Points**:
- Monotonic increasing stack
- When smaller height found, calculate area
- Width = current index - previous index - 1

---

### Problem 16: Trapping Rain Water ⭐⭐⭐⭐⭐

**LeetCode 42** | **Difficulty: Hard** | **Frequency: Very High**

**Problem**: Calculate trapped rainwater.

**Input**: `height = [0,1,0,2,1,0,1,3,2,1,2,1]`
**Output**: `6`

**Solution 1: Stack**:
```java
public class TrappingRainWater {
    public int trap(int[] height) {
        Deque<Integer> stack = new ArrayDeque<>();
        int water = 0;
        
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                
                if (stack.isEmpty()) break;
                
                int distance = i - stack.peek() - 1;
                int boundedHeight = Math.min(height[i], height[stack.peek()]) - height[top];
                water += distance * boundedHeight;
            }
            
            stack.push(i);
        }
        
        return water;
    }
}
```

**Solution 2: Two Pointers (Optimal)**:
```java
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int leftMax = 0, rightMax = 0;
    int water = 0;
    
    while (left < right) {
        if (height[left] < height[right]) {
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                water += leftMax - height[left];
            }
            left++;
        } else {
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                water += rightMax - height[right];
            }
            right--;
        }
    }
    
    return water;
}
```

**Time**: O(n)
**Space**: O(n) with stack, O(1) with two pointers

---

### Problem 17: Maximal Rectangle ⭐⭐⭐⭐⭐

**LeetCode 85** | **Difficulty: Hard**

**Problem**: Find largest rectangle containing only 1's in binary matrix.

**Input**:
```
matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
```
**Output**: `6`

**Solution**:
```java
public class MaximalRectangle {
    public int maximalRectangle(char[][] matrix) {
        if (matrix.length == 0) return 0;
        
        int m = matrix.length;
        int n = matrix[0].length;
        int[] heights = new int[n];
        int maxArea = 0;
        
        for (int i = 0; i < m; i++) {
            // Update heights array
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    heights[j]++;
                } else {
                    heights[j] = 0;
                }
            }
            
            // Find max rectangle in histogram
            maxArea = Math.max(maxArea, largestRectangleArea(heights));
        }
        
        return maxArea;
    }
    
    private int largestRectangleArea(int[] heights) {
        Deque<Integer> stack = new ArrayDeque<>();
        int maxArea = 0;
        
        for (int i = 0; i <= heights.length; i++) {
            int h = (i == heights.length) ? 0 : heights[i];
            
            while (!stack.isEmpty() && h < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack.push(i);
        }
        
        return maxArea;
    }
}
```

**Time**: O(m × n) | **Space**: O(n)

**Key Idea**: Convert each row to histogram problem.

---

### Problem 18: Basic Calculator ⭐⭐⭐⭐⭐

**LeetCode 224** | **Difficulty: Hard**

**Problem**: Evaluate expression with `+`, `-`, `(`, `)`.

**Input**: `s = "(1+(4+5+2)-3)+(6+8)"`
**Output**: `23`

**Solution**:
```java
public class BasicCalculator {
    public int calculate(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        int result = 0;
        int number = 0;
        int sign = 1;
        
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                number = number * 10 + (c - '0');
            } else if (c == '+') {
                result += sign * number;
                number = 0;
                sign = 1;
            } else if (c == '-') {
                result += sign * number;
                number = 0;
                sign = -1;
            } else if (c == '(') {
                stack.push(result);
                stack.push(sign);
                result = 0;
                sign = 1;
            } else if (c == ')') {
                result += sign * number;
                number = 0;
                result *= stack.pop();  // sign
                result += stack.pop();  // previous result
            }
        }
        
        result += sign * number;
        return result;
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 19: Longest Valid Parentheses ⭐⭐⭐⭐

**LeetCode 32** | **Difficulty: Hard**

**Problem**: Find length of longest valid parentheses substring.

**Input**: `s = ")()())"`
**Output**: `4`

**Explanation**: `"()()"` is the longest valid.

**Solution 1: Stack**:
```java
public class LongestValidParentheses {
    public int longestValidParentheses(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(-1);  // Base for valid substring
        int maxLen = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                
                if (stack.isEmpty()) {
                    stack.push(i);  // New base
                } else {
                    maxLen = Math.max(maxLen, i - stack.peek());
                }
            }
        }
        
        return maxLen;
    }
}
```

**Solution 2: Two Pass (Optimal)**:
```java
public int longestValidParentheses(String s) {
    int left = 0, right = 0, maxLen = 0;
    
    // Left to right
    for (char c : s.toCharArray()) {
        if (c == '(') left++;
        else right++;
        
        if (left == right) {
            maxLen = Math.max(maxLen, 2 * right);
        } else if (right > left) {
            left = right = 0;
        }
    }
    
    left = right = 0;
    
    // Right to left
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == '(') left++;
        else right++;
        
        if (left == right) {
            maxLen = Math.max(maxLen, 2 * left);
        } else if (left > right) {
            left = right = 0;
        }
    }
    
    return maxLen;
}
```

**Time**: O(n)
**Space**: O(n) with stack, O(1) with two pass

---

### Problem 20: Expression Add Operators ⭐⭐⭐⭐

**LeetCode 282** | **Difficulty: Hard**

**Problem**: Add operators `+`, `-`, `*` to make expression equal target.

**Input**: `num = "123"`, `target = 6`
**Output**: `["1+2+3", "1*2*3"]`

**Solution**:
```java
public class ExpressionAddOperators {
    public List<String> addOperators(String num, int target) {
        List<String> result = new ArrayList<>();
        backtrack(num, target, 0, 0, 0, "", result);
        return result;
    }
    
    private void backtrack(String num, int target, int index, 
                          long value, long prev, String expr, 
                          List<String> result) {
        if (index == num.length()) {
            if (value == target) {
                result.add(expr);
            }
            return;
        }
        
        for (int i = index; i < num.length(); i++) {
            // Skip leading zeros
            if (i != index && num.charAt(index) == '0') break;
            
            String current = num.substring(index, i + 1);
            long currentNum = Long.parseLong(current);
            
            if (index == 0) {
                // First number, no operator
                backtrack(num, target, i + 1, currentNum, currentNum, 
                         current, result);
            } else {
                // Add '+'
                backtrack(num, target, i + 1, value + currentNum, 
                         currentNum, expr + "+" + current, result);
                
                // Add '-'
                backtrack(num, target, i + 1, value - currentNum, 
                         -currentNum, expr + "-" + current, result);
                
                // Add '*'
                backtrack(num, target, i + 1, 
                         value - prev + prev * currentNum,
                         prev * currentNum, expr + "*" + current, result);
            }
        }
    }
}
```

**Time**: O(4^n) | **Space**: O(n)

**Key Points**:
- Backtracking with operator insertion
- Handle multiplication precedence
- Skip numbers with leading zeros

---

## Pattern Recognition Guide

### When to Use Stack?

**1. Matching/Balancing**:
- Valid Parentheses
- Remove Invalid Parentheses
- Minimum Add to Make Valid
→ **Pattern**: Push opening, pop on closing

**2. Next Greater/Smaller**:
- Daily Temperatures
- Next Greater Element
- Stock Span
→ **Pattern**: Monotonic stack

**3. Expression Evaluation**:
- Calculator problems
- Evaluate RPN
- Decode String
→ **Pattern**: Operand/operator stacks

**4. String Processing**:
- Simplify Path
- Backspace String
- Remove Duplicates
→ **Pattern**: Process and modify

**5. Area Calculation**:
- Largest Rectangle
- Maximal Rectangle
- Trapping Rain Water
→ **Pattern**: Histogram problems

### Stack Type Selection

| Problem Type | Stack Content | Processing |
|--------------|---------------|------------|
| Parentheses | Characters | Match pairs |
| NGE/NSE | Indices | Compare values |
| Calculator | Numbers/Operators | Evaluate |
| Histogram | Indices | Calculate area |
| Path | Directory names | Build path |

### Common Stack Patterns

**Pattern 1: Monotonic Stack**
```java
for (int i = 0; i < n; i++) {
    while (!stack.isEmpty() && arr[i] > arr[stack.peek()]) {
        int idx = stack.pop();
        // Process idx with current i
    }
    stack.push(i);
}
```

**Pattern 2: Balanced Parentheses**
```java
for (char c : s.toCharArray()) {
    if (isOpening(c)) {
        stack.push(c);
    } else {
        if (stack.isEmpty() || !matches(stack.peek(), c)) {
            return false;
        }
        stack.pop();
    }
}
return stack.isEmpty();
```

**Pattern 3: Expression Evaluation**
```java
for (String token : tokens) {
    if (isOperator(token)) {
        int b = stack.pop();
        int a = stack.pop();
        stack.push(apply(a, op, b));
    } else {
        stack.push(Integer.parseInt(token));
    }
}
```

---

## Solutions

### Complete Solution Template

```java
import java.util.*;

public class StackProblemTemplate {
    // Generic monotonic stack for NGE
    public int[] nextGreaterElement(int[] arr) {
        int n = arr.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Deque<Integer> stack = new ArrayDeque<>();
        
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[i] > arr[stack.peek()]) {
                result[stack.pop()] = arr[i];
            }
            stack.push(i);
        }
        
        return result;
    }
    
    // Generic balanced parentheses
    public boolean isValidParentheses(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        Map<Character, Character> map = Map.of(')', '(', '}', '{', ']', '[');
        
        for (char c : s.toCharArray()) {
            if (map.containsKey(c)) {
                if (stack.isEmpty() || stack.pop() != map.get(c)) {
                    return false;
                }
            } else {
                stack.push(c);
            }
        }
        
        return stack.isEmpty();
    }
    
    // Generic calculator (basic)
    public int calculate(String s) {
        Deque<Integer> stack = new ArrayDeque<>();
        int num = 0;
        char op = '+';
        
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            
            if (Character.isDigit(c)) {
                num = num * 10 + (c - '0');
            }
            
            if ((!Character.isDigit(c) && c != ' ') || i == s.length() - 1) {
                if (op == '+') stack.push(num);
                else if (op == '-') stack.push(-num);
                else if (op == '*') stack.push(stack.pop() * num);
                else if (op == '/') stack.push(stack.pop() / num);
                
                op = c;
                num = 0;
            }
        }
        
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        return result;
    }
}
```

---

## Summary

### Problem Frequency by Category

| Category | Easy | Medium | Hard | Total |
|----------|------|--------|------|-------|
| Parentheses | 2 | 2 | 2 | 6 |
| Monotonic Stack | 1 | 5 | 2 | 8 |
| Expression Eval | 1 | 1 | 3 | 5 |
| String Processing | 1 | 3 | 0 | 4 |
| Design | 0 | 2 | 0 | 2 |

### Top 10 Must-Practice Problems

1. ⭐⭐⭐⭐⭐ **Valid Parentheses** (LC 20) - Foundation
2. ⭐⭐⭐⭐⭐ **Daily Temperatures** (LC 739) - Monotonic stack
3. ⭐⭐⭐⭐⭐ **Largest Rectangle in Histogram** (LC 84) - Classic
4. ⭐⭐⭐⭐⭐ **Trapping Rain Water** (LC 42) - Multiple approaches
5. ⭐⭐⭐⭐⭐ **Basic Calculator** (LC 224) - Expression evaluation
6. ⭐⭐⭐⭐ **Decode String** (LC 394) - Nested processing
7. ⭐⭐⭐⭐ **Asteroid Collision** (LC 735) - Simulation
8. ⭐⭐⭐⭐ **Remove K Digits** (LC 402) - Greedy + monotonic
9. ⭐⭐⭐⭐ **Online Stock Span** (LC 901) - Design
10. ⭐⭐⭐⭐ **Maximal Rectangle** (LC 85) - 2D histogram

### Learning Path

**Week 1: Basics**
- Day 1-2: Valid Parentheses, Baseball Game
- Day 3-4: Next Greater Element I, Backspace String
- Day 5-7: Remove Outermost Parentheses, practice variations

**Week 2: Monotonic Stack**
- Day 1-2: Daily Temperatures
- Day 3-4: Online Stock Span, Car Fleet
- Day 5-6: Remove K Digits, Sum of Subarray Minimums
- Day 7: Practice and review

**Week 3: Expression & String**
- Day 1-2: Decode String, Simplify Path
- Day 3-4: Asteroid Collision, Minimum Remove
- Day 5-7: Calculator II, practice variations

**Week 4: Advanced**
- Day 1-2: Largest Rectangle in Histogram
- Day 3-4: Trapping Rain Water
- Day 5-6: Maximal Rectangle, Basic Calculator
- Day 7: Longest Valid Parentheses

### Complexity Reference

| Problem Type | Time | Space | Key Technique |
|--------------|------|-------|---------------|
| Valid Parentheses | O(n) | O(n) | Stack matching |
| Next Greater | O(n) | O(n) | Monotonic stack |
| Calculator | O(n) | O(n) | Two stacks |
| Histogram | O(n) | O(n) | Increasing stack |
| Rain Water | O(n) | O(1) | Two pointers |
| Decode String | O(n×k) | O(n) | Nested stacks |

### Quick Pattern Lookup

**Need to find next/previous greater/smaller?**
→ Use monotonic stack

**Need to match/balance brackets?**
→ Use stack with character matching

**Need to evaluate expression?**
→ Use operator/operand stacks

**Need to calculate area in histogram?**
→ Use monotonic increasing stack

**Need to process nested structures?**
→ Use stack to track levels

### Common Pitfalls

1. ❌ Not checking `stack.isEmpty()` before `pop()/peek()`
2. ❌ Wrong operand order: `a - b` vs `b - a`
3. ❌ Forgetting to handle remaining stack elements
4. ❌ Not using indices instead of values (for distance)
5. ❌ Incorrect monotonic stack direction
6. ❌ Missing edge cases (empty input, single element)

### Interview Strategy

**Step 1: Identify Pattern**
- Matching? → Stack with pairs
- Next greater? → Monotonic stack
- Expression? → Evaluation stack

**Step 2: Choose Data Structure**
- Need index? → Stack<Integer>
- Need value? → Stack<T>
- Need both? → Stack<Pair> or separate tracking

**Step 3: Handle Edge Cases**
- Empty input
- Single element
- All same elements
- Stack overflow/underflow

**Step 4: Optimize**
- Can you use two pointers instead?
- Do you need actual stack or just counter?
- Can you reuse input array?

### Resources for Further Practice

**LeetCode Lists**:
- Stack Tag: 170+ problems
- Monotonic Stack: 40+ problems
- Expression Parsing: 15+ problems

**Problem Sets**:
- Easy: 20, 682, 844, 1021, 496
- Medium: 739, 394, 735, 71, 402, 901
- Hard: 84, 42, 85, 224, 32

---

**Previous**: [8.5 Expression Evaluation](8.5-Expression-Evaluation.md)

**Next**: [09-Queues](../09-Queues/)

**Remember**: Stack problems are about recognizing patterns - master the core patterns and you can solve most problems!
