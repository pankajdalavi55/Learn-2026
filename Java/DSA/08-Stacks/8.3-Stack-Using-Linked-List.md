# 8.3 Stack Using Linked List

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Generic Implementation](#generic-implementation)
4. [Operations Deep Dive](#operations-deep-dive)
5. [Advanced Implementations](#advanced-implementations)
6. [Comparison with Array Stack](#comparison-with-array-stack)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### Why Linked List for Stack?

**Advantages** ✅:
- Dynamic size (no capacity limit)
- No resize overhead
- Efficient memory usage (no pre-allocation)
- O(1) push and pop (true O(1), not amortized)
- No stack overflow (until system memory exhausted)

**Disadvantages** ❌:
- Extra memory for pointers/references
- Poor cache locality (scattered in memory)
- Slightly higher constant factors
- More complex implementation

### Linked List vs Array for Stack

| Feature | Linked List | Array |
|---------|-------------|-------|
| **Size** | Dynamic | Fixed/Dynamic |
| **Memory** | Scattered | Contiguous |
| **Cache** | Poor | Excellent |
| **Overhead** | Node pointers | None (fixed) / Resize (dynamic) |
| **Push** | True O(1) | O(1) amortized |
| **Pop** | True O(1) | O(1) amortized |
| **Space Waste** | Minimal | Possible (array) |

### Visual Representation

**Stack using Singly Linked List**:
```
top → [30|•] → [20|•] → [10|null]
      (push)   (next)   (bottom)
```

**Operations**:
```
Push(40):
top → [40|•] → [30|•] → [20|•] → [10|null]

Pop():
Returns 40, top moves to 30:
top → [30|•] → [20|•] → [10|null]
```

---

## Basic Implementation

### Node Class

```java
public class LinkedListStack {
    // Inner Node class
    private static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node top;
    private int size;
    
    // Constructor
    public LinkedListStack() {
        top = null;
        size = 0;
    }
    
    // Push operation
    public void push(int x) {
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    // Pop operation
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty - Cannot pop");
        }
        
        int data = top.data;
        top = top.next;
        size--;
        return data;
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty - Cannot peek");
        }
        return top.data;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        Node current = top;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
    
    // Clear stack
    public void clear() {
        top = null;
        size = 0;
    }
}
```

### Step-by-Step Example

```java
public class TestLinkedListStack {
    public static void main(String[] args) {
        LinkedListStack stack = new LinkedListStack();
        
        System.out.println("Is empty? " + stack.isEmpty());  // true
        
        // Push elements
        System.out.println("\n=== Pushing elements ===");
        stack.push(10);
        stack.display();  // 10
        
        stack.push(20);
        stack.display();  // 20 10
        
        stack.push(30);
        stack.display();  // 30 20 10
        
        stack.push(40);
        stack.display();  // 40 30 20 10
        
        // Stack operations
        System.out.println("\n=== Stack operations ===");
        System.out.println("Size: " + stack.size());      // 4
        System.out.println("Peek: " + stack.peek());      // 40
        System.out.println("Pop: " + stack.pop());        // 40
        System.out.println("Pop: " + stack.pop());        // 30
        
        stack.display();  // 20 10
        System.out.println("Size: " + stack.size());      // 2
        
        // Push more
        stack.push(50);
        stack.push(60);
        stack.display();  // 60 50 20 10
        
        // Clear
        stack.clear();
        System.out.println("\nAfter clear:");
        System.out.println("Is empty? " + stack.isEmpty());  // true
        System.out.println("Size: " + stack.size());          // 0
    }
}
```

**Output**:
```
Is empty? true

=== Pushing elements ===
Stack (top to bottom): 10
Stack (top to bottom): 20 10
Stack (top to bottom): 30 20 10
Stack (top to bottom): 40 30 20 10

=== Stack operations ===
Size: 4
Peek: 40
Pop: 40
Pop: 30
Stack (top to bottom): 20 10
Size: 2
Stack (top to bottom): 60 50 20 10

After clear:
Is empty? true
Size: 0
```

---

## Generic Implementation

### Generic Linked List Stack

```java
public class GenericLinkedStack<T> {
    // Inner Node class
    private static class Node<T> {
        T data;
        Node<T> next;
        
        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node<T> top;
    private int size;
    
    // Constructor
    public GenericLinkedStack() {
        top = null;
        size = 0;
    }
    
    // Push operation
    public void push(T item) {
        Node<T> newNode = new Node<>(item);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    // Pop operation
    public T pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        
        T data = top.data;
        top = top.next;
        size--;
        return data;
    }
    
    // Peek operation
    public T peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        Node<T> current = top;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
    
    // Search for element (returns position from top, -1 if not found)
    public int search(T item) {
        Node<T> current = top;
        int position = 0;
        
        while (current != null) {
            if (current.data.equals(item)) {
                return position;
            }
            current = current.next;
            position++;
        }
        
        return -1;  // Not found
    }
    
    // Convert to array
    public Object[] toArray() {
        Object[] array = new Object[size];
        Node<T> current = top;
        int index = 0;
        
        while (current != null) {
            array[index++] = current.data;
            current = current.next;
        }
        
        return array;
    }
    
    // Clear stack
    public void clear() {
        top = null;
        size = 0;
    }
    
    // Iterator support
    public java.util.Iterator<T> iterator() {
        return new StackIterator();
    }
    
    private class StackIterator implements java.util.Iterator<T> {
        private Node<T> current = top;
        
        @Override
        public boolean hasNext() {
            return current != null;
        }
        
        @Override
        public T next() {
            if (!hasNext()) {
                throw new java.util.NoSuchElementException();
            }
            T data = current.data;
            current = current.next;
            return data;
        }
    }
}
```

### Generic Stack Usage

```java
public class TestGenericLinkedStack {
    public static void main(String[] args) {
        // Integer stack
        GenericLinkedStack<Integer> intStack = new GenericLinkedStack<>();
        intStack.push(10);
        intStack.push(20);
        intStack.push(30);
        
        System.out.println("Integer Stack:");
        intStack.display();
        System.out.println("Search 20: position " + intStack.search(20));
        
        // String stack
        GenericLinkedStack<String> strStack = new GenericLinkedStack<>();
        strStack.push("Java");
        strStack.push("Python");
        strStack.push("C++");
        
        System.out.println("\nString Stack:");
        strStack.display();
        
        // Iterate
        System.out.print("Using iterator: ");
        for (String s : (Iterable<String>) strStack::iterator) {
            System.out.print(s + " ");
        }
        System.out.println();
        
        // Custom object stack
        GenericLinkedStack<Employee> empStack = new GenericLinkedStack<>();
        empStack.push(new Employee(1, "Alice", 50000));
        empStack.push(new Employee(2, "Bob", 60000));
        empStack.push(new Employee(3, "Charlie", 55000));
        
        System.out.println("\nEmployee Stack:");
        while (!empStack.isEmpty()) {
            System.out.println(empStack.pop());
        }
    }
}

class Employee {
    int id;
    String name;
    double salary;
    
    Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    @Override
    public String toString() {
        return String.format("Employee[id=%d, name=%s, salary=%.2f]", 
                           id, name, salary);
    }
}
```

---

## Operations Deep Dive

### 1. Push Operation - Detailed Analysis

**Code**:
```java
public void push(int x) {
    Node newNode = new Node(x);  // Step 1: Create new node
    newNode.next = top;           // Step 2: Link to current top
    top = newNode;                // Step 3: Update top
    size++;                       // Step 4: Increment size
}
```

**Visual Steps**:
```
Initial state:
top → [30] → [20] → [10] → null

Push(40):

Step 1: Create new node
        [40]
        
Step 2: Link to current top
        [40] → [30] → [20] → [10] → null
        
Step 3: Update top
top → [40] → [30] → [20] → [10] → null

Final: size = 4
```

**Time Complexity**: O(1) - constant time
- Create node: O(1)
- Update pointers: O(1)
- No traversal needed

**Space Complexity**: O(1) per operation

---

### 2. Pop Operation - Detailed Analysis

**Code**:
```java
public int pop() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    
    int data = top.data;     // Step 1: Get data
    top = top.next;          // Step 2: Move top to next
    size--;                  // Step 3: Decrement size
    return data;             // Step 4: Return data
}
```

**Visual Steps**:
```
Initial state:
top → [40] → [30] → [20] → [10] → null

Pop():

Step 1: Get data (40)

Step 2: Move top to next
        [40]   (orphaned, will be garbage collected)
top → [30] → [20] → [10] → null

Step 3: size = 3

Return: 40
```

**Time Complexity**: O(1) - constant time
**Space Complexity**: O(1)

**Note**: In Java, orphaned node is automatically garbage collected.

---

### 3. Peek Operation

**Code**:
```java
public int peek() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    return top.data;
}
```

**Visual**:
```
top → [40] → [30] → [20] → [10] → null
       ↑
    Just read, don't remove
    
Returns: 40
Stack remains unchanged
```

**Time Complexity**: O(1)
**Space Complexity**: O(1)

---

### 4. Search Operation

**Code**:
```java
public int search(int item) {
    Node current = top;
    int position = 0;
    
    while (current != null) {
        if (current.data == item) {
            return position;
        }
        current = current.next;
        position++;
    }
    
    return -1;  // Not found
}
```

**Visual**:
```
Search for 20:

top → [40] → [30] → [20] → [10] → null
       0      1      2 ✓    3

Position 0 (top): 40 ≠ 20
Position 1: 30 ≠ 20
Position 2: 20 = 20 ✓

Returns: 2
```

**Time Complexity**: O(n) - may need to traverse entire stack
**Space Complexity**: O(1)

---

### 5. Display Operation

**Code**:
```java
public void display() {
    if (isEmpty()) {
        System.out.println("Stack is empty");
        return;
    }
    
    System.out.print("Stack (top to bottom): ");
    Node current = top;
    while (current != null) {
        System.out.print(current.data + " ");
        current = current.next;
    }
    System.out.println();
}
```

**Time Complexity**: O(n) - traverse all nodes
**Space Complexity**: O(1) - no extra space

---

## Advanced Implementations

### 1. Stack with Min/Max in O(1)

**Approach 1: Two Stacks**
```java
public class MinMaxStack {
    private static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node top;
    private Node minTop;
    private Node maxTop;
    private int size;
    
    public void push(int x) {
        // Push to main stack
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
        
        // Push to min stack if needed
        if (minTop == null || x <= minTop.data) {
            Node minNode = new Node(x);
            minNode.next = minTop;
            minTop = minNode;
        }
        
        // Push to max stack if needed
        if (maxTop == null || x >= maxTop.data) {
            Node maxNode = new Node(x);
            maxNode.next = maxTop;
            maxTop = maxNode;
        }
        
        size++;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = top.data;
        top = top.next;
        
        // Pop from min stack if needed
        if (data == minTop.data) {
            minTop = minTop.next;
        }
        
        // Pop from max stack if needed
        if (data == maxTop.data) {
            maxTop = maxTop.next;
        }
        
        size--;
        return data;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
    
    public int getMin() {
        if (minTop == null) {
            throw new IllegalStateException("Stack is empty");
        }
        return minTop.data;
    }
    
    public int getMax() {
        if (maxTop == null) {
            throw new IllegalStateException("Stack is empty");
        }
        return maxTop.data;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
    
    public int size() {
        return size;
    }
}
```

**Example**:
```java
MinMaxStack stack = new MinMaxStack();
stack.push(5);   // Main: 5, Min: 5, Max: 5
stack.push(3);   // Main: 3→5, Min: 3→5, Max: 5
stack.push(7);   // Main: 7→3→5, Min: 3→5, Max: 7→5
stack.push(2);   // Main: 2→7→3→5, Min: 2→3→5, Max: 7→5

System.out.println("Min: " + stack.getMin());  // 2
System.out.println("Max: " + stack.getMax());  // 7

stack.pop();     // Remove 2
System.out.println("Min: " + stack.getMin());  // 3
System.out.println("Max: " + stack.getMax());  // 7
```

**Time**: All operations O(1)
**Space**: O(n) for auxiliary stacks

---

**Approach 2: Node with Min/Max**
```java
public class MinMaxStackOptimized {
    private static class Node {
        int data;
        int min;
        int max;
        Node next;
        
        Node(int data, int min, int max) {
            this.data = data;
            this.min = min;
            this.max = max;
        }
    }
    
    private Node top;
    private int size;
    
    public void push(int x) {
        int newMin = (top == null) ? x : Math.min(x, top.min);
        int newMax = (top == null) ? x : Math.max(x, top.max);
        
        Node newNode = new Node(x, newMin, newMax);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = top.data;
        top = top.next;
        size--;
        return data;
    }
    
    public int getMin() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.min;
    }
    
    public int getMax() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.max;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
}
```

**Trade-off**: Each node stores min/max → more memory per node, but simpler logic.

---

### 2. Reverse Stack Using Recursion

**Problem**: Reverse stack without extra space (only recursion stack).

**Solution**:
```java
public class ReverseStackRecursive {
    private static class Node {
        int data;
        Node next;
        Node(int data) { this.data = data; }
    }
    
    private Node top;
    
    public void push(int x) {
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
    }
    
    public int pop() {
        if (top == null) {
            throw new IllegalStateException("Stack is empty");
        }
        int data = top.data;
        top = top.next;
        return data;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
    
    // Reverse stack
    public void reverse() {
        if (isEmpty()) return;
        
        int bottom = popBottom();
        reverse();
        push(bottom);
    }
    
    // Remove and return bottom element
    private int popBottom() {
        int top = pop();
        
        if (isEmpty()) {
            return top;
        }
        
        int bottom = popBottom();
        push(top);
        return bottom;
    }
    
    public void display() {
        Node current = top;
        System.out.print("Stack: ");
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```

**Example**:
```java
ReverseStackRecursive stack = new ReverseStackRecursive();
stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);

stack.display();  // Stack: 4 3 2 1

stack.reverse();

stack.display();  // Stack: 1 2 3 4
```

**Time**: O(n²) - each level processes remaining elements
**Space**: O(n) - recursion stack depth

---

### 3. Sort Stack Using Temporary Stack

**Problem**: Sort stack using one temporary stack.

**Solution**:
```java
public class SortStack {
    private static class Node {
        int data;
        Node next;
        Node(int data) { this.data = data; }
    }
    
    private Node top;
    
    public void push(int x) {
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        int data = top.data;
        top = top.next;
        return data;
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
    
    // Sort stack in ascending order (smallest on top)
    public void sort() {
        SortStack tempStack = new SortStack();
        
        while (!isEmpty()) {
            int temp = pop();
            
            // Move elements from tempStack back to this stack
            // while they are greater than temp
            while (!tempStack.isEmpty() && tempStack.peek() > temp) {
                push(tempStack.pop());
            }
            
            tempStack.push(temp);
        }
        
        // Copy back to original stack
        while (!tempStack.isEmpty()) {
            push(tempStack.pop());
        }
    }
    
    public void display() {
        Node current = top;
        System.out.print("Stack (top to bottom): ");
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```

**Example**:
```java
SortStack stack = new SortStack();
stack.push(34);
stack.push(3);
stack.push(31);
stack.push(98);
stack.push(92);
stack.push(23);

System.out.println("Before sort:");
stack.display();  // 23 92 98 31 3 34

stack.sort();

System.out.println("After sort:");
stack.display();  // 3 23 31 34 92 98 (smallest on top)
```

**Time**: O(n²) worst case
**Space**: O(n) for temporary stack

---

### 4. Stack with Middle Element Operations

**Problem**: Design stack supporting O(1) findMiddle() and deleteMiddle().

**Solution**: Use doubly linked list with middle pointer.

```java
public class StackWithMiddle {
    private static class Node {
        int data;
        Node prev;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node head;
    private Node middle;
    private int count;
    
    public void push(int x) {
        Node newNode = new Node(x);
        count++;
        
        if (head == null) {
            head = newNode;
            middle = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
            
            // Update middle pointer
            if (count % 2 != 0) {
                middle = middle.prev;
            }
        }
    }
    
    public int pop() {
        if (head == null) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = head.data;
        head = head.next;
        
        if (head != null) {
            head.prev = null;
        }
        
        count--;
        
        // Update middle pointer
        if (count % 2 == 0) {
            middle = middle.next;
        }
        
        return data;
    }
    
    public int findMiddle() {
        if (middle == null) {
            throw new IllegalStateException("Stack is empty");
        }
        return middle.data;
    }
    
    public int deleteMiddle() {
        if (middle == null) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = middle.data;
        
        if (middle.prev != null) {
            middle.prev.next = middle.next;
        }
        if (middle.next != null) {
            middle.next.prev = middle.prev;
        }
        
        // Update middle pointer
        if (count % 2 == 0) {
            middle = middle.prev;
        } else {
            middle = middle.next;
        }
        
        count--;
        return data;
    }
    
    public boolean isEmpty() {
        return head == null;
    }
    
    public int size() {
        return count;
    }
}
```

**Example**:
```java
StackWithMiddle stack = new StackWithMiddle();
stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);
stack.push(5);

System.out.println("Middle: " + stack.findMiddle());    // 3
System.out.println("Deleted: " + stack.deleteMiddle()); // 3
System.out.println("Middle: " + stack.findMiddle());    // 2
```

**Time**: All operations O(1)
**Space**: O(n) with extra prev pointers

---

## Comparison with Array Stack

### Memory Analysis

**Array Stack**:
```
Memory for capacity 100, size 50:
- Array: 100 × 4 bytes = 400 bytes (int)
- Overhead: Minimal
- Total: ~400 bytes
- Waste: 50% (50 unused slots)
```

**Linked List Stack**:
```
Memory for size 50:
- Nodes: 50 × (4 bytes data + 8 bytes reference) = 600 bytes
- Overhead: Reference per node
- Total: ~600 bytes
- Waste: 0% (no unused slots)
```

### Performance Characteristics

| Metric | Array Stack | Linked List Stack |
|--------|-------------|-------------------|
| **Push** | O(1) amortized | O(1) true |
| **Pop** | O(1) amortized | O(1) true |
| **Peek** | O(1) | O(1) |
| **Search** | O(n) | O(n) |
| **Memory** | Contiguous | Scattered |
| **Cache** | Better | Worse |
| **Resize** | Yes (cost) | No |
| **Max Size** | Limited | System memory |

### When to Use Each

**Use Array Stack When**:
- ✅ Maximum size is known
- ✅ Need better cache performance
- ✅ Minimal memory overhead desired
- ✅ Frequent access to elements

**Use Linked List Stack When**:
- ✅ Size is unpredictable
- ✅ Want true O(1) operations
- ✅ No resize overhead desired
- ✅ Memory fragmentation acceptable

### Benchmark Comparison

**Hypothetical Performance** (1 million operations):
```
Array Stack:
- Push: ~10ms (with occasional resize)
- Pop:  ~8ms
- Total: ~18ms

Linked List Stack:
- Push: ~12ms (node allocation overhead)
- Pop:  ~10ms (garbage collection)
- Total: ~22ms

Winner: Array (better cache locality)
```

---

## Interview Questions

### Question 1: Implement Stack Using Single Linked List

**Already covered in [Basic Implementation](#basic-implementation)**

---

### Question 2: Reverse Linked List Using Stack

**Problem**: Reverse a linked list using a stack.

**Solution**:
```java
public class ReverseLinkedList {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }
    
    static class Stack {
        static class Node {
            ListNode data;
            Node next;
            Node(ListNode data) { this.data = data; }
        }
        
        Node top;
        
        void push(ListNode node) {
            Node newNode = new Node(node);
            newNode.next = top;
            top = newNode;
        }
        
        ListNode pop() {
            if (top == null) return null;
            ListNode data = top.data;
            top = top.next;
            return data;
        }
        
        boolean isEmpty() {
            return top == null;
        }
    }
    
    public static ListNode reverse(ListNode head) {
        if (head == null) return null;
        
        Stack stack = new Stack();
        
        // Push all nodes to stack
        ListNode current = head;
        while (current != null) {
            stack.push(current);
            current = current.next;
        }
        
        // Pop and build reversed list
        ListNode newHead = stack.pop();
        current = newHead;
        
        while (!stack.isEmpty()) {
            current.next = stack.pop();
            current = current.next;
        }
        
        current.next = null;
        return newHead;
    }
    
    // Helper to print list
    public static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " → ");
            current = current.next;
        }
        System.out.println("null");
    }
    
    public static void main(String[] args) {
        // Create list: 1 → 2 → 3 → 4 → 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        
        System.out.println("Original:");
        printList(head);
        
        head = reverse(head);
        
        System.out.println("Reversed:");
        printList(head);
    }
}
```

**Time**: O(n)
**Space**: O(n) for stack

---

### Question 3: Check for Palindrome Using Stack

**Problem**: Check if linked list is palindrome using stack.

**Solution**:
```java
public class PalindromeCheck {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }
    
    static class Stack {
        static class Node {
            int data;
            Node next;
            Node(int data) { this.data = data; }
        }
        
        Node top;
        
        void push(int data) {
            Node newNode = new Node(data);
            newNode.next = top;
            top = newNode;
        }
        
        int pop() {
            int data = top.data;
            top = top.next;
            return data;
        }
        
        boolean isEmpty() {
            return top == null;
        }
    }
    
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }
        
        // Find middle using slow-fast pointers
        ListNode slow = head;
        ListNode fast = head;
        Stack stack = new Stack();
        
        // Push first half to stack
        while (fast != null && fast.next != null) {
            stack.push(slow.val);
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // If odd length, skip middle
        if (fast != null) {
            slow = slow.next;
        }
        
        // Compare second half with stack
        while (slow != null) {
            if (slow.val != stack.pop()) {
                return false;
            }
            slow = slow.next;
        }
        
        return true;
    }
    
    public static void main(String[] args) {
        // Test case 1: 1 → 2 → 3 → 2 → 1 (palindrome)
        ListNode list1 = new ListNode(1);
        list1.next = new ListNode(2);
        list1.next.next = new ListNode(3);
        list1.next.next.next = new ListNode(2);
        list1.next.next.next.next = new ListNode(1);
        
        System.out.println("List 1 is palindrome? " + isPalindrome(list1));  // true
        
        // Test case 2: 1 → 2 → 3 → 4 (not palindrome)
        ListNode list2 = new ListNode(1);
        list2.next = new ListNode(2);
        list2.next.next = new ListNode(3);
        list2.next.next.next = new ListNode(4);
        
        System.out.println("List 2 is palindrome? " + isPalindrome(list2));  // false
    }
}
```

**Time**: O(n)
**Space**: O(n/2) = O(n) for stack

---

### Question 4: Implement Queue Using Two Stacks

**Problem**: Implement queue using two linked list stacks.

**Solution**:
```java
public class QueueUsingStacks {
    private LinkedListStack stack1;  // For enqueue
    private LinkedListStack stack2;  // For dequeue
    
    public QueueUsingStacks() {
        stack1 = new LinkedListStack();
        stack2 = new LinkedListStack();
    }
    
    // Enqueue: O(1)
    public void enqueue(int x) {
        stack1.push(x);
    }
    
    // Dequeue: O(n) worst case, O(1) amortized
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        
        // If stack2 is empty, transfer from stack1
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        
        return stack2.pop();
    }
    
    // Peek: O(n) worst case, O(1) amortized
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Queue is empty");
        }
        
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        
        return stack2.peek();
    }
    
    public boolean isEmpty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
    
    public int size() {
        return stack1.size() + stack2.size();
    }
}
```

**Example**:
```java
QueueUsingStacks queue = new QueueUsingStacks();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);

System.out.println(queue.dequeue());  // 1
System.out.println(queue.dequeue());  // 2

queue.enqueue(4);

System.out.println(queue.dequeue());  // 3
System.out.println(queue.dequeue());  // 4
```

**Time**: 
- Enqueue: O(1)
- Dequeue: O(1) amortized, O(n) worst case

**Space**: O(n)

---

## Practice Problems

### Easy Problems

| # | Problem | Key Concept | LeetCode |
|---|---------|-------------|----------|
| 1 | Implement Stack Using LL | Basic Implementation | - |
| 2 | Reverse String Using Stack | Basic Operations | - |
| 3 | Valid Parentheses | Stack Matching | 20 |
| 4 | Min Stack | Design | 155 |
| 5 | Implement Queue Using Stacks | Two Stacks | 232 |
| 6 | Remove All Adjacent Duplicates | Stack | 1047 |
| 7 | Baseball Game | Stack Simulation | 682 |
| 8 | Backspace String Compare | Stack | 844 |
| 9 | Next Greater Element I | Monotonic Stack | 496 |
| 10 | Palindrome Linked List | Stack + Two Pointers | 234 |

### Medium Problems

| # | Problem | Key Concept | LeetCode |
|---|---------|-------------|----------|
| 1 | Stack with Middle Operations | DLL + Middle Pointer | - |
| 2 | Sort Stack | Temporary Stack | - |
| 3 | Reverse Stack Using Recursion | Recursion | - |
| 4 | Daily Temperatures | Monotonic Stack | 739 |
| 5 | Decode String | Stack Nesting | 394 |
| 6 | Asteroid Collision | Stack Simulation | 735 |
| 7 | Online Stock Span | Monotonic Stack | 901 |
| 8 | Remove K Digits | Greedy + Stack | 402 |
| 9 | Next Greater Element II | Circular + Stack | 503 |
| 10 | 132 Pattern | Monotonic Stack | 456 |
| 11 | Evaluate Reverse Polish Notation | Expression Evaluation | 150 |
| 12 | Simplify Path | String + Stack | 71 |
| 13 | Flatten Nested List Iterator | Stack + Iterator | 341 |
| 14 | Design Browser History | DLL Stack | 1472 |
| 15 | Score of Parentheses | Stack | 856 |

### Hard Problems

| # | Problem | Key Concept | LeetCode |
|---|---------|-------------|----------|
| 1 | Largest Rectangle in Histogram | Monotonic Stack | 84 |
| 2 | Maximal Rectangle | Stack + DP | 85 |
| 3 | Trapping Rain Water | Monotonic Stack | 42 |
| 4 | Basic Calculator | Expression Parsing | 224 |
| 5 | Longest Valid Parentheses | Stack + DP | 32 |

---

## Summary

### Key Concepts

**1. Structure**:
```java
class Node {
    int data;
    Node next;
}

Node top;      // Points to top of stack
int size;      // Track number of elements
```

**2. Core Operations**:
```java
// Push: O(1)
newNode.next = top;
top = newNode;

// Pop: O(1)
data = top.data;
top = top.next;
```

**3. Advantages**:
- ✅ Dynamic size (no capacity limit)
- ✅ True O(1) operations (no amortization)
- ✅ No resize overhead
- ✅ Efficient memory use (no pre-allocation)

**4. Disadvantages**:
- ❌ Extra memory for pointers
- ❌ Poor cache locality
- ❌ Garbage collection overhead

### Complexity Summary

| Operation | Time | Space |
|-----------|------|-------|
| Push | O(1) | O(1) |
| Pop | O(1) | O(1) |
| Peek | O(1) | O(1) |
| Search | O(n) | O(1) |
| Display | O(n) | O(1) |
| isEmpty | O(1) | O(1) |
| Size | O(1) | O(1) |

### Design Patterns

**1. Single Stack**: Simple LIFO operations
**2. Min/Max Stack**: Auxiliary stack or node fields
**3. Two Stacks**: Implement queue
**4. DLL Stack**: Middle element operations

### Interview Tips

1. ✅ **Mention trade-offs**: LL vs Array
2. ✅ **Handle edge cases**: Empty stack, single element
3. ✅ **Memory management**: Garbage collection in Java
4. ✅ **Generic implementation**: Show understanding of generics
5. ✅ **Time/Space complexity**: State for each operation

### Common Mistakes

1. ❌ Forgetting to update size counter
2. ❌ Not checking for null in pop/peek
3. ❌ Memory leaks (in languages without GC)
4. ❌ Incorrect middle pointer updates
5. ❌ Not handling empty stack in operations

### Master These

**Must Know**:
1. ✅ Basic linked list stack implementation
2. ✅ Generic stack implementation
3. ✅ Min/Max stack
4. ✅ Queue using two stacks
5. ✅ Reverse operations

**Good to Know**:
6. ✅ Stack with middle element
7. ✅ Sort stack using temporary stack
8. ✅ Iterator implementation
9. ✅ Palindrome checking
10. ✅ Expression evaluation

### Quick Reference

```java
// Basic template
class LinkedListStack {
    private Node top;
    private int size;
    
    void push(int x) {
        Node node = new Node(x);
        node.next = top;
        top = node;
        size++;
    }
    
    int pop() {
        if (top == null) throw exception;
        int data = top.data;
        top = top.next;
        size--;
        return data;
    }
}
```

### Next Steps

- **Next**: [8.4 Stack Applications](8.4-Stack-Applications.md)
- **Related**: [8.2 Stack Using Array](8.2-Stack-Using-Array.md)
- **Advanced**: [8.5 Monotonic Stack](8.5-Monotonic-Stack.md)

---

**Previous**: [8.2 Stack Using Array](8.2-Stack-Using-Array.md)
