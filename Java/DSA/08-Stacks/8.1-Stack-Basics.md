# 8.1 Stack Basics

## Table of Contents
1. [Introduction](#introduction)
2. [Stack Fundamentals](#stack-fundamentals)
3. [Stack Implementation](#stack-implementation)
4. [Basic Operations](#basic-operations)
5. [Common Patterns](#common-patterns)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is a Stack?

A **Stack** is a linear data structure that follows the **LIFO (Last In First Out)** principle:
- The last element added is the first one to be removed
- Think of it like a stack of plates: you add/remove from the top only

```
Top → [5]  ← Most recent (will be removed first)
      [3]
      [7]
      [2]
Bottom → [1]  ← Oldest element
```

### Real-World Analogies

1. **Stack of Books**: Add/remove books from the top
2. **Browser History**: Back button removes the most recent page
3. **Undo Operation**: Most recent action is undone first
4. **Function Calls**: Call stack in programming

### Why Use Stacks?

**Advantages**:
- ✅ O(1) push and pop operations
- ✅ Simple and intuitive
- ✅ Natural fit for recursive problems
- ✅ Memory efficient for temporary data

**When to Use**:
- Expression evaluation (postfix, prefix)
- Backtracking algorithms
- Function call management
- Undo/redo functionality
- Parentheses matching
- Depth-First Search (DFS)

---

## Stack Fundamentals

### LIFO Principle

```
Initial Stack: [1, 2, 3]

Push(4):  [1, 2, 3, 4]  ← 4 added to top
Pop():    [1, 2, 3]     ← 4 removed (most recent)
Pop():    [1, 2]        ← 3 removed
Push(5):  [1, 2, 5]     ← 5 added to top
```

### Core Operations

| Operation | Description | Time Complexity |
|-----------|-------------|-----------------|
| `push(x)` | Add element to top | O(1) |
| `pop()` | Remove and return top element | O(1) |
| `peek()/top()` | Return top element without removing | O(1) |
| `isEmpty()` | Check if stack is empty | O(1) |
| `size()` | Return number of elements | O(1) |

### Stack vs Other Data Structures

| Feature | Stack | Queue | Array | Linked List |
|---------|-------|-------|-------|-------------|
| Access Pattern | LIFO | FIFO | Random | Sequential |
| Insert | Top only (O(1)) | Rear (O(1)) | Any (O(n)) | Any (O(1)/O(n)) |
| Delete | Top only (O(1)) | Front (O(1)) | Any (O(n)) | Any (O(1)/O(n)) |
| Use Case | Undo, DFS | BFS, Scheduling | Random access | Dynamic size |

---

## Stack Implementation

### 1. Using Java's Built-in Stack

**java.util.Stack** (Legacy class)
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        
        // Push elements
        stack.push(1);
        stack.push(2);
        stack.push(3);
        
        // Peek top element
        System.out.println("Top: " + stack.peek());  // 3
        
        // Pop elements
        System.out.println("Popped: " + stack.pop());  // 3
        System.out.println("Popped: " + stack.pop());  // 2
        
        // Check if empty
        System.out.println("Is Empty? " + stack.isEmpty());  // false
        
        // Size
        System.out.println("Size: " + stack.size());  // 1
    }
}
```

**Note**: `Stack` class is considered legacy. Modern approach uses `Deque`:

```java
import java.util.Deque;
import java.util.ArrayDeque;

public class ModernStackExample {
    public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();
        
        stack.push(1);       // Add to top
        stack.push(2);
        stack.push(3);
        
        stack.peek();        // View top element
        stack.pop();         // Remove top element
        stack.isEmpty();     // Check if empty
        stack.size();        // Get size
    }
}
```

### 2. Array-Based Implementation

**Fixed-Size Stack**
```java
public class ArrayStack {
    private int[] arr;
    private int top;
    private int capacity;
    
    // Constructor
    public ArrayStack(int size) {
        arr = new int[size];
        capacity = size;
        top = -1;
    }
    
    // Push operation
    public void push(int x) {
        if (isFull()) {
            throw new StackOverflowError("Stack is full");
        }
        arr[++top] = x;
    }
    
    // Pop operation
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top--];
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top];
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == -1;
    }
    
    // Check if full
    public boolean isFull() {
        return top == capacity - 1;
    }
    
    // Get size
    public int size() {
        return top + 1;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        for (int i = top; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

**Usage**:
```java
public class TestArrayStack {
    public static void main(String[] args) {
        ArrayStack stack = new ArrayStack(5);
        
        stack.push(10);
        stack.push(20);
        stack.push(30);
        
        stack.display();  // 30 20 10
        
        System.out.println("Popped: " + stack.pop());  // 30
        System.out.println("Top: " + stack.peek());    // 20
        System.out.println("Size: " + stack.size());   // 2
    }
}
```

**Dynamic Array-Based Stack**
```java
import java.util.Arrays;

public class DynamicArrayStack {
    private int[] arr;
    private int top;
    private int capacity;
    
    // Constructor
    public DynamicArrayStack() {
        capacity = 10;  // Initial capacity
        arr = new int[capacity];
        top = -1;
    }
    
    // Push with auto-resize
    public void push(int x) {
        if (isFull()) {
            resize();
        }
        arr[++top] = x;
    }
    
    // Resize array (double the capacity)
    private void resize() {
        capacity *= 2;
        arr = Arrays.copyOf(arr, capacity);
    }
    
    // Pop operation
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        int item = arr[top--];
        
        // Shrink array if too empty (optional)
        if (top > 0 && top == capacity / 4) {
            capacity /= 2;
            arr = Arrays.copyOf(arr, capacity);
        }
        
        return item;
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top];
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == -1;
    }
    
    // Check if full
    private boolean isFull() {
        return top == capacity - 1;
    }
    
    // Get size
    public int size() {
        return top + 1;
    }
}
```

**Time Complexity**:
- Push: O(1) amortized (O(n) when resizing)
- Pop: O(1) amortized
- Peek: O(1)
- isEmpty/size: O(1)

**Space Complexity**: O(n)

---

### 3. Linked List-Based Implementation

```java
public class LinkedListStack {
    // Node class
    private static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node top;
    private int size;
    
    // Constructor
    public LinkedListStack() {
        top = null;
        size = 0;
    }
    
    // Push operation
    public void push(int x) {
        Node newNode = new Node(x);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    // Pop operation
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        int item = top.data;
        top = top.next;
        size--;
        return item;
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == null;
    }
    
    // Get size
    public int size() {
        return size;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        Node current = top;
        while (current != null) {
            System.out.print(current.data + " ");
            current = current.next;
        }
        System.out.println();
    }
}
```

**Advantages over Array**:
- ✅ Dynamic size (no capacity limit)
- ✅ No resizing overhead
- ✅ No memory waste

**Disadvantages**:
- ❌ Extra memory for node pointers
- ❌ Poor cache locality

**Time Complexity**: All operations O(1)
**Space Complexity**: O(n)

---

### 4. Generic Stack Implementation

```java
public class GenericStack<T> {
    private static class Node<T> {
        T data;
        Node<T> next;
        
        Node(T data) {
            this.data = data;
        }
    }
    
    private Node<T> top;
    private int size;
    
    public GenericStack() {
        top = null;
        size = 0;
    }
    
    public void push(T item) {
        Node<T> newNode = new Node<>(item);
        newNode.next = top;
        top = newNode;
        size++;
    }
    
    public T pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        T item = top.data;
        top = top.next;
        size--;
        return item;
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return top.data;
    }
    
    public boolean isEmpty() {
        return top == null;
    }
    
    public int size() {
        return size;
    }
}
```

**Usage**:
```java
public class TestGenericStack {
    public static void main(String[] args) {
        // Integer stack
        GenericStack<Integer> intStack = new GenericStack<>();
        intStack.push(1);
        intStack.push(2);
        
        // String stack
        GenericStack<String> strStack = new GenericStack<>();
        strStack.push("Hello");
        strStack.push("World");
        
        System.out.println(strStack.pop());  // World
        System.out.println(strStack.pop());  // Hello
    }
}
```

---

## Basic Operations

### 1. Push Operation

**Concept**: Add element to top of stack

**Array Implementation**:
```java
public void push(int x) {
    if (isFull()) {
        throw new StackOverflowError("Stack is full");
    }
    arr[++top] = x;  // Increment top, then insert
}
```

**Linked List Implementation**:
```java
public void push(int x) {
    Node newNode = new Node(x);
    newNode.next = top;
    top = newNode;
    size++;
}
```

**Steps**:
1. Check if stack is full (for array)
2. Increment top pointer
3. Insert element at top position

**Time**: O(1)

---

### 2. Pop Operation

**Concept**: Remove and return top element

**Array Implementation**:
```java
public int pop() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    return arr[top--];  // Return current, then decrement
}
```

**Linked List Implementation**:
```java
public int pop() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    int item = top.data;
    top = top.next;
    size--;
    return item;
}
```

**Steps**:
1. Check if stack is empty
2. Get top element
3. Move top pointer down/back
4. Return element

**Time**: O(1)

---

### 3. Peek/Top Operation

**Concept**: View top element without removing

```java
public int peek() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    return arr[top];  // Array version
    // return top.data;  // Linked list version
}
```

**Use Cases**:
- Check next element to process
- Validation without modification
- Comparison operations

**Time**: O(1)

---

### 4. isEmpty and Size

```java
// Array-based
public boolean isEmpty() {
    return top == -1;
}

public int size() {
    return top + 1;
}

// Linked List-based
public boolean isEmpty() {
    return top == null;
}

public int size() {
    return size;  // Maintained separately
}
```

**Time**: O(1)

---

## Common Patterns

### Pattern 1: Balanced Parentheses ⭐⭐⭐

**Problem**: Check if parentheses/brackets are balanced.

```
Valid: "()", "()[]{}", "{[()]}"
Invalid: "(]", "(()", "]"
```

**Solution**:
```java
public class BalancedParentheses {
    public static boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : s.toCharArray()) {
            // Opening brackets: push to stack
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            }
            // Closing brackets: check matching
            else {
                if (stack.isEmpty()) {
                    return false;
                }
                
                char top = stack.pop();
                
                if (c == ')' && top != '(') return false;
                if (c == '}' && top != '{') return false;
                if (c == ']' && top != '[') return false;
            }
        }
        
        // Stack should be empty if balanced
        return stack.isEmpty();
    }
    
    public static void main(String[] args) {
        System.out.println(isValid("()"));        // true
        System.out.println(isValid("()[]{}"));    // true
        System.out.println(isValid("(]"));        // false
        System.out.println(isValid("([)]"));      // false
        System.out.println(isValid("{[()]}"));    // true
    }
}
```

**LeetCode 20** - Valid Parentheses

**Time**: O(n) | **Space**: O(n)

**Key Points**:
- Push opening brackets
- For closing: check if top matches
- Stack empty = balanced

---

### Pattern 2: Next Greater Element ⭐⭐⭐

**Problem**: For each element, find the next greater element to its right.

```
Input:  [4, 5, 2, 10, 8]
Output: [5, 10, 10, -1, -1]

4 → 5 (next greater)
5 → 10
2 → 10
10 → -1 (no greater)
8 → -1
```

**Solution**:
```java
public class NextGreaterElement {
    public static int[] nextGreaterElement(int[] arr) {
        int n = arr.length;
        int[] result = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();
        
        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Pop elements smaller than current
            while (!stack.isEmpty() && stack.peek() <= arr[i]) {
                stack.pop();
            }
            
            // Top of stack is next greater (or -1 if empty)
            result[i] = stack.isEmpty() ? -1 : stack.peek();
            
            // Push current element
            stack.push(arr[i]);
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr = {4, 5, 2, 10, 8};
        int[] result = nextGreaterElement(arr);
        
        System.out.println(Arrays.toString(result));  // [5, 10, 10, -1, -1]
    }
}
```

**LeetCode 496, 503, 739**

**Time**: O(n) | **Space**: O(n)

**Variations**:
- Next Greater Element II (circular array)
- Next Smaller Element
- Previous Greater/Smaller Element

**Template**:
```java
// Next Greater (right to left)
for (int i = n - 1; i >= 0; i--) {
    while (!stack.isEmpty() && stack.peek() <= arr[i]) {
        stack.pop();
    }
    result[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(arr[i]);
}

// Previous Greater (left to right)
for (int i = 0; i < n; i++) {
    while (!stack.isEmpty() && stack.peek() <= arr[i]) {
        stack.pop();
    }
    result[i] = stack.isEmpty() ? -1 : stack.peek();
    stack.push(arr[i]);
}
```

---

### Pattern 3: Evaluate Postfix Expression ⭐⭐

**Problem**: Evaluate postfix (Reverse Polish Notation) expression.

```
Postfix: "2 3 + 5 *"
Infix: (2 + 3) * 5 = 25

Postfix: "4 13 5 / +"
Infix: 4 + (13 / 5) = 4 + 2 = 6
```

**Solution**:
```java
public class PostfixEvaluation {
    public static int evaluatePostfix(String expression) {
        Deque<Integer> stack = new ArrayDeque<>();
        String[] tokens = expression.split(" ");
        
        for (String token : tokens) {
            // If operator
            if (isOperator(token)) {
                int b = stack.pop();  // Second operand
                int a = stack.pop();  // First operand
                
                int result = applyOperator(token, a, b);
                stack.push(result);
            }
            // If operand
            else {
                stack.push(Integer.parseInt(token));
            }
        }
        
        return stack.pop();
    }
    
    private static boolean isOperator(String token) {
        return token.equals("+") || token.equals("-") || 
               token.equals("*") || token.equals("/");
    }
    
    private static int applyOperator(String op, int a, int b) {
        switch (op) {
            case "+": return a + b;
            case "-": return a - b;
            case "*": return a * b;
            case "/": return a / b;
            default: throw new IllegalArgumentException("Invalid operator");
        }
    }
    
    public static void main(String[] args) {
        System.out.println(evaluatePostfix("2 3 + 5 *"));     // 25
        System.out.println(evaluatePostfix("4 13 5 / +"));    // 6
        System.out.println(evaluatePostfix("10 6 9 3 + -11 * / * 17 + 5 +")); // 22
    }
}
```

**LeetCode 150** - Evaluate Reverse Polish Notation

**Time**: O(n) | **Space**: O(n)

**Algorithm**:
1. Scan tokens left to right
2. If operand: push to stack
3. If operator: pop two operands, apply operator, push result
4. Final stack top is the answer

---

### Pattern 4: Infix to Postfix Conversion ⭐⭐

**Problem**: Convert infix to postfix notation.

```
Infix:    A + B * C
Postfix:  A B C * +

Infix:    (A + B) * C
Postfix:  A B + C *
```

**Solution**:
```java
public class InfixToPostfix {
    public static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Deque<Character> stack = new ArrayDeque<>();
        
        for (char c : infix.toCharArray()) {
            // Operand: add to output
            if (Character.isLetterOrDigit(c)) {
                postfix.append(c);
            }
            // Left parenthesis: push to stack
            else if (c == '(') {
                stack.push(c);
            }
            // Right parenthesis: pop until '('
            else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop();  // Remove '('
            }
            // Operator
            else {
                while (!stack.isEmpty() && 
                       precedence(c) <= precedence(stack.peek())) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }
        
        // Pop remaining operators
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        
        return postfix.toString();
    }
    
    private static int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return -1;
        }
    }
    
    public static void main(String[] args) {
        System.out.println(infixToPostfix("A+B*C"));      // ABC*+
        System.out.println(infixToPostfix("(A+B)*C"));    // AB+C*
        System.out.println(infixToPostfix("A+B*C-D/E"));  // ABC*+DE/-
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Pattern 5: Stock Span Problem ⭐⭐

**Problem**: Find span of stock prices (consecutive days with price ≤ current).

```
Input:  [100, 80, 60, 70, 60, 75, 85]
Output: [1,   1,  1,  2,  1,  4,  6]

Day 0: 100 → span = 1 (only itself)
Day 3: 70  → span = 2 (60, 70)
Day 5: 75  → span = 4 (60, 70, 60, 75)
Day 6: 85  → span = 6 (80, 60, 70, 60, 75, 85)
```

**Solution**:
```java
public class StockSpan {
    public static int[] calculateSpan(int[] prices) {
        int n = prices.length;
        int[] span = new int[n];
        Deque<Integer> stack = new ArrayDeque<>();  // Store indices
        
        for (int i = 0; i < n; i++) {
            // Pop elements while current price >= stack top price
            while (!stack.isEmpty() && prices[stack.peek()] <= prices[i]) {
                stack.pop();
            }
            
            // If stack empty, span = i + 1 (all previous days)
            // Else, span = i - stack.peek()
            span[i] = stack.isEmpty() ? (i + 1) : (i - stack.peek());
            
            stack.push(i);
        }
        
        return span;
    }
    
    public static void main(String[] args) {
        int[] prices = {100, 80, 60, 70, 60, 75, 85};
        int[] span = calculateSpan(prices);
        
        System.out.println(Arrays.toString(span));  // [1, 1, 1, 2, 1, 4, 6]
    }
}
```

**LeetCode 901** - Online Stock Span

**Time**: O(n) | **Space**: O(n)

---

### Pattern 6: Min Stack ⭐⭐⭐

**Problem**: Design stack with getMin() in O(1).

**Solution 1: Two Stacks**
```java
class MinStack {
    private Deque<Integer> stack;
    private Deque<Integer> minStack;
    
    public MinStack() {
        stack = new ArrayDeque<>();
        minStack = new ArrayDeque<>();
    }
    
    public void push(int val) {
        stack.push(val);
        
        if (minStack.isEmpty() || val <= minStack.peek()) {
            minStack.push(val);
        }
    }
    
    public void pop() {
        int val = stack.pop();
        
        if (val == minStack.peek()) {
            minStack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

**Solution 2: Single Stack with Pairs**
```java
class MinStack {
    private Deque<int[]> stack;  // [value, currentMin]
    
    public MinStack() {
        stack = new ArrayDeque<>();
    }
    
    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new int[]{val, val});
        } else {
            int currentMin = Math.min(val, stack.peek()[1]);
            stack.push(new int[]{val, currentMin});
        }
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        return stack.peek()[0];
    }
    
    public int getMin() {
        return stack.peek()[1];
    }
}
```

**LeetCode 155** - Min Stack

**Time**: All operations O(1)
**Space**: O(n)

---

## Interview Questions

### Question 1: Implement Two Stacks in One Array

**Problem**: Efficiently use a single array for two stacks.

**Solution**:
```java
public class TwoStacks {
    private int[] arr;
    private int top1, top2;
    private int size;
    
    public TwoStacks(int n) {
        size = n;
        arr = new int[n];
        top1 = -1;
        top2 = size;
    }
    
    // Push to stack 1
    public void push1(int x) {
        if (top1 < top2 - 1) {
            arr[++top1] = x;
        } else {
            throw new StackOverflowError("Stack Overflow");
        }
    }
    
    // Push to stack 2
    public void push2(int x) {
        if (top1 < top2 - 1) {
            arr[--top2] = x;
        } else {
            throw new StackOverflowError("Stack Overflow");
        }
    }
    
    // Pop from stack 1
    public int pop1() {
        if (top1 >= 0) {
            return arr[top1--];
        } else {
            throw new IllegalStateException("Stack 1 Underflow");
        }
    }
    
    // Pop from stack 2
    public int pop2() {
        if (top2 < size) {
            return arr[top2++];
        } else {
            throw new IllegalStateException("Stack 2 Underflow");
        }
    }
}
```

**Time**: O(1) for all operations
**Space**: O(n)

**Concept**: Stack 1 grows from left, Stack 2 grows from right.

---

### Question 2: Sort Stack Using Temporary Stack

**Problem**: Sort stack using only one temporary stack.

**Solution**:
```java
public class SortStack {
    public static void sortStack(Deque<Integer> stack) {
        Deque<Integer> tempStack = new ArrayDeque<>();
        
        while (!stack.isEmpty()) {
            int temp = stack.pop();
            
            // Move elements from tempStack to stack while they are greater
            while (!tempStack.isEmpty() && tempStack.peek() > temp) {
                stack.push(tempStack.pop());
            }
            
            tempStack.push(temp);
        }
        
        // Copy back to original stack
        while (!tempStack.isEmpty()) {
            stack.push(tempStack.pop());
        }
    }
    
    public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(34);
        stack.push(3);
        stack.push(31);
        stack.push(98);
        stack.push(92);
        stack.push(23);
        
        sortStack(stack);
        
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + " ");  // 98 92 34 31 23 3
        }
    }
}
```

**Time**: O(n²) worst case
**Space**: O(n)

---

### Question 3: Reverse Stack Using Recursion

**Problem**: Reverse stack without using extra space (only recursion stack).

**Solution**:
```java
public class ReverseStack {
    public static void reverseStack(Deque<Integer> stack) {
        if (stack.isEmpty()) {
            return;
        }
        
        // Remove bottom element
        int bottom = popBottom(stack);
        
        // Reverse remaining stack
        reverseStack(stack);
        
        // Push bottom element on top
        stack.push(bottom);
    }
    
    private static int popBottom(Deque<Integer> stack) {
        int top = stack.pop();
        
        if (stack.isEmpty()) {
            return top;
        }
        
        int bottom = popBottom(stack);
        stack.push(top);
        return bottom;
    }
    
    public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        
        System.out.println("Original: " + stack);  // [4, 3, 2, 1]
        
        reverseStack(stack);
        
        System.out.println("Reversed: " + stack);  // [1, 2, 3, 4]
    }
}
```

**Time**: O(n²)
**Space**: O(n) recursion stack

---

### Question 4: Stack with Middle Element Operations

**Problem**: Design stack with O(1) push, pop, and findMiddle/deleteMiddle.

**Solution**: Use doubly linked list with middle pointer.

```java
public class StackWithMiddle {
    class Node {
        int data;
        Node prev, next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    private Node head, middle;
    private int count;
    
    public void push(int data) {
        Node newNode = new Node(data);
        count++;
        
        if (head == null) {
            head = newNode;
            middle = newNode;
        } else {
            newNode.next = head;
            head.prev = newNode;
            head = newNode;
            
            if (count % 2 != 0) {
                middle = middle.prev;
            }
        }
    }
    
    public int pop() {
        if (head == null) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = head.data;
        head = head.next;
        
        if (head != null) {
            head.prev = null;
        }
        
        count--;
        
        if (count % 2 == 0) {
            middle = middle.next;
        }
        
        return data;
    }
    
    public int findMiddle() {
        if (middle == null) {
            throw new IllegalStateException("Stack is empty");
        }
        return middle.data;
    }
    
    public int deleteMiddle() {
        if (middle == null) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int data = middle.data;
        
        if (middle.prev != null) {
            middle.prev.next = middle.next;
        }
        if (middle.next != null) {
            middle.next.prev = middle.prev;
        }
        
        if (count % 2 == 0) {
            middle = middle.prev;
        } else {
            middle = middle.next;
        }
        
        count--;
        return data;
    }
}
```

**Time**: All operations O(1)
**Space**: O(n)

---

## Practice Problems

### Easy Problems

| # | Problem | LeetCode | Pattern |
|---|---------|----------|---------|
| 1 | Valid Parentheses | 20 | Matching |
| 2 | Implement Stack using Queues | 225 | Implementation |
| 3 | Min Stack | 155 | Design |
| 4 | Baseball Game | 682 | Simulation |
| 5 | Next Greater Element I | 496 | Monotonic Stack |
| 6 | Backspace String Compare | 844 | Simulation |
| 7 | Remove All Adjacent Duplicates | 1047 | Stack |
| 8 | Make String Great | 1544 | Stack |
| 9 | Remove Outermost Parentheses | 1021 | Stack |
| 10 | Build Array With Stack Operations | 1441 | Simulation |

### Medium Problems

| # | Problem | LeetCode | Pattern |
|---|---------|----------|---------|
| 1 | Daily Temperatures | 739 | Monotonic Stack |
| 2 | Evaluate Reverse Polish Notation | 150 | Postfix |
| 3 | Decode String | 394 | Stack |
| 4 | Asteroid Collision | 735 | Stack |
| 5 | Online Stock Span | 901 | Monotonic Stack |
| 6 | Validate Stack Sequences | 946 | Simulation |
| 7 | Score of Parentheses | 856 | Stack |
| 8 | Minimum Add to Make Parentheses Valid | 921 | Matching |
| 9 | Remove K Digits | 402 | Greedy + Stack |
| 10 | Next Greater Element II | 503 | Circular + Stack |
| 11 | 132 Pattern | 456 | Monotonic Stack |
| 12 | Remove Duplicate Letters | 316 | Greedy + Stack |
| 13 | Simplify Path | 71 | String + Stack |
| 14 | Basic Calculator II | 227 | Expression |
| 15 | Minimum Remove to Make Valid Parentheses | 1249 | Stack |

### Hard Problems

| # | Problem | LeetCode | Pattern |
|---|---------|----------|---------|
| 1 | Basic Calculator | 224 | Expression |
| 2 | Largest Rectangle in Histogram | 84 | Monotonic Stack |
| 3 | Maximal Rectangle | 85 | Histogram + Stack |
| 4 | Trapping Rain Water | 42 | Monotonic Stack |
| 5 | Longest Valid Parentheses | 32 | Stack + DP |

---

## Summary

### Key Takeaways

**1. Stack Characteristics**:
- LIFO structure (Last In First Out)
- O(1) push, pop, peek operations
- Sequential access only (no random access)

**2. Implementation Choices**:
- **Array**: Fixed/dynamic size, good cache locality
- **Linked List**: Dynamic size, extra pointer overhead
- **Deque**: Modern Java approach (preferred over Stack class)

**3. Common Patterns**:
```
✅ Parentheses/Bracket Matching
✅ Expression Evaluation (Postfix, Infix)
✅ Next Greater/Smaller Element (Monotonic Stack)
✅ Stock Span / Histogram Problems
✅ Backtracking / DFS
✅ Function Call Management
```

### Implementation Comparison

| Feature | Array | Linked List | Java Stack | Deque |
|---------|-------|-------------|------------|-------|
| Size | Fixed/Dynamic | Dynamic | Dynamic | Dynamic |
| Push/Pop | O(1)* | O(1) | O(1) | O(1) |
| Memory | Contiguous | Scattered | Dynamic | Dynamic |
| Cache | Better | Worse | Worse | Better |
| Recommended | Learning | Learning | ❌ Legacy | ✅ Production |

\* Amortized for dynamic array

### Time Complexity Summary

| Operation | Array | Linked List |
|-----------|-------|-------------|
| Push | O(1) amortized | O(1) |
| Pop | O(1) | O(1) |
| Peek | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| Size | O(1) | O(1) |
| Search | O(n) | O(n) |

### Space Complexity

- Array-based: O(n) where n = capacity
- Linked List: O(n) + pointer overhead
- Generic: O(n) + object overhead

### When to Use Stack

✅ **Use Stack When**:
- Need LIFO access pattern
- Backtracking required (DFS, recursion)
- Expression evaluation
- Matching/validation (parentheses)
- Undo/redo functionality

❌ **Don't Use Stack When**:
- Need random access
- FIFO required (use Queue)
- Need to iterate multiple times
- Search operations are frequent

### Common Mistakes to Avoid

1. ❌ Using `Stack` class instead of `Deque`
2. ❌ Not checking isEmpty() before pop/peek
3. ❌ Forgetting to handle edge cases (empty, single element)
4. ❌ Using stack for problems better suited to queues
5. ❌ Not considering space complexity in recursion

### Interview Tips

1. **Always clarify**: Empty stack behavior, max size limits
2. **Consider edge cases**: Empty, single element, full (array)
3. **Mention complexity**: Time and space for each operation
4. **Know multiple approaches**: Array vs Linked List
5. **Practice patterns**: Monotonic stack, expression evaluation

### Master These Problems

**Must Know (Top 5)**:
1. ✅ Valid Parentheses (LC 20)
2. ✅ Min Stack (LC 155)
3. ✅ Daily Temperatures (LC 739)
4. ✅ Evaluate Reverse Polish Notation (LC 150)
5. ✅ Next Greater Element (LC 496)

**Important (Next 5)**:
6. ✅ Decode String (LC 394)
7. ✅ Asteroid Collision (LC 735)
8. ✅ Basic Calculator II (LC 227)
9. ✅ Largest Rectangle in Histogram (LC 84)
10. ✅ Trapping Rain Water (LC 42)

### Quick Reference - Stack Operations

```java
// Modern approach (Deque)
Deque<Integer> stack = new ArrayDeque<>();
stack.push(x);           // Add to top
int top = stack.pop();   // Remove from top
int peek = stack.peek(); // View top
boolean empty = stack.isEmpty();
int size = stack.size();

// Iterate (bottom to top)
Iterator<Integer> it = stack.descendingIterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

### Next Steps

- **Next Topic**: [8.2 Stack Applications](8.2-Stack-Applications.md)
- **Practice**: Complete Easy problems first
- **Deep Dive**: Monotonic Stack pattern (very important!)

---

**Related Topics**:
- [09-Queues](../09-Queues/) - FIFO counterpart
- [07-Linked-Lists](../07-Linked-Lists/) - Used in LL implementation
- [14-Dynamic-Programming](../14-Dynamic-Programming/) - Stack for memoization

**Previous**: [07-Linked-Lists](../07-Linked-Lists/7.6-Practice-Problems.md)
