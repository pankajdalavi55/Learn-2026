# 8.2 Stack Using Array

## Table of Contents
1. [Introduction](#introduction)
2. [Fixed-Size Stack Implementation](#fixed-size-stack-implementation)
3. [Dynamic Stack Implementation](#dynamic-stack-implementation)
4. [Generic Array Stack](#generic-array-stack)
5. [Advanced Implementations](#advanced-implementations)
6. [Common Problems](#common-problems)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### Why Array-Based Stack?

**Advantages** ✅:
- Simple and intuitive implementation
- Excellent cache locality (contiguous memory)
- No pointer overhead
- Fast access (direct indexing)
- Easy to implement and understand

**Disadvantages** ❌:
- Fixed size (for static array)
- Resize overhead (for dynamic array)
- Memory waste if not fully utilized
- Stack overflow possible

### Array vs Linked List for Stack

| Feature | Array Stack | Linked List Stack |
|---------|-------------|-------------------|
| **Memory** | Contiguous | Scattered |
| **Cache** | Better | Worse |
| **Overhead** | None | Pointer per node |
| **Size** | Fixed/Dynamic | Dynamic |
| **Resize** | Required | Not needed |
| **Implementation** | Simpler | More complex |

### When to Use Array Stack

✅ **Use Array Stack When**:
- Maximum size is known in advance
- Need better cache performance
- Memory efficiency is important (no pointers)
- Simple implementation preferred

❌ **Avoid When**:
- Size is highly unpredictable
- Frequent resize operations expected
- Memory fragmentation is a concern

---

## Fixed-Size Stack Implementation

### Basic Implementation

```java
public class ArrayStack {
    private int[] arr;
    private int top;
    private int capacity;
    
    // Constructor
    public ArrayStack(int size) {
        arr = new int[size];
        capacity = size;
        top = -1;
    }
    
    // Push operation
    public void push(int x) {
        if (isFull()) {
            throw new StackOverflowError("Stack is full - Cannot push " + x);
        }
        arr[++top] = x;
    }
    
    // Pop operation
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty - Cannot pop");
        }
        return arr[top--];
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty - Cannot peek");
        }
        return arr[top];
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == -1;
    }
    
    // Check if full
    public boolean isFull() {
        return top == capacity - 1;
    }
    
    // Get current size
    public int size() {
        return top + 1;
    }
    
    // Get capacity
    public int capacity() {
        return capacity;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        for (int i = top; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    
    // Print in array order
    public void printArray() {
        System.out.print("Array: [");
        for (int i = 0; i <= top; i++) {
            System.out.print(arr[i]);
            if (i < top) System.out.print(", ");
        }
        System.out.println("]");
    }
}
```

### Detailed Explanation

**1. Instance Variables**:
```java
private int[] arr;      // Array to store elements
private int top;        // Index of top element (-1 means empty)
private int capacity;   // Maximum capacity
```

**2. Constructor**:
```java
public ArrayStack(int size) {
    arr = new int[size];    // Create array
    capacity = size;         // Store capacity
    top = -1;                // Empty stack
}
```

**Why top = -1?**
- Empty stack indicator
- First push: `arr[++top]` → `arr[0]`
- Makes size calculation simple: `top + 1`

**3. Push Operation**:
```java
public void push(int x) {
    if (isFull()) {
        throw new StackOverflowError("Stack is full");
    }
    arr[++top] = x;  // Pre-increment top, then insert
}
```

**Step-by-step**:
```
Initial: top = -1, arr = [_, _, _]

push(10): top = 0, arr = [10, _, _]
push(20): top = 1, arr = [10, 20, _]
push(30): top = 2, arr = [10, 20, 30]
```

**4. Pop Operation**:
```java
public int pop() {
    if (isEmpty()) {
        throw new IllegalStateException("Stack is empty");
    }
    return arr[top--];  // Return current, then post-decrement
}
```

**Step-by-step**:
```
Initial: top = 2, arr = [10, 20, 30]

pop(): returns 30, top = 1, arr = [10, 20, 30]  // Note: 30 still in array
pop(): returns 20, top = 0, arr = [10, 20, 30]
```

**Note**: We don't actually remove data from array, just move `top` pointer.

### Complete Example

```java
public class TestArrayStack {
    public static void main(String[] args) {
        ArrayStack stack = new ArrayStack(5);
        
        System.out.println("Is empty? " + stack.isEmpty());  // true
        
        // Push elements
        stack.push(10);
        stack.push(20);
        stack.push(30);
        stack.push(40);
        stack.push(50);
        
        stack.display();  // Stack: 50 40 30 20 10
        
        System.out.println("Size: " + stack.size());       // 5
        System.out.println("Is full? " + stack.isFull());  // true
        
        // Try to push when full
        try {
            stack.push(60);  // Should throw exception
        } catch (StackOverflowError e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        // Peek and pop
        System.out.println("Peek: " + stack.peek());  // 50
        System.out.println("Pop: " + stack.pop());    // 50
        System.out.println("Pop: " + stack.pop());    // 40
        
        stack.display();  // Stack: 30 20 10
        
        System.out.println("Size: " + stack.size());  // 3
    }
}
```

**Output**:
```
Is empty? true
Stack (top to bottom): 50 40 30 20 10
Size: 5
Is full? true
Error: Stack is full - Cannot push 60
Peek: 50
Pop: 50
Pop: 40
Stack (top to bottom): 30 20 10
Size: 3
```

### Time and Space Complexity

| Operation | Time Complexity | Space Complexity |
|-----------|-----------------|------------------|
| push(x) | O(1) | - |
| pop() | O(1) | - |
| peek() | O(1) | - |
| isEmpty() | O(1) | - |
| isFull() | O(1) | - |
| size() | O(1) | - |
| display() | O(n) | - |
| **Overall** | - | O(n) |

---

## Dynamic Stack Implementation

### Implementation with Auto-Resize

```java
import java.util.Arrays;

public class DynamicArrayStack {
    private int[] arr;
    private int top;
    private int capacity;
    
    // Default initial capacity
    private static final int DEFAULT_CAPACITY = 10;
    
    // Constructor with default capacity
    public DynamicArrayStack() {
        this(DEFAULT_CAPACITY);
    }
    
    // Constructor with custom capacity
    public DynamicArrayStack(int initialCapacity) {
        if (initialCapacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive");
        }
        arr = new int[initialCapacity];
        capacity = initialCapacity;
        top = -1;
    }
    
    // Push with auto-resize
    public void push(int x) {
        if (isFull()) {
            resize(2 * capacity);  // Double the capacity
        }
        arr[++top] = x;
    }
    
    // Pop with auto-shrink
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        
        int item = arr[top--];
        
        // Shrink if using only 25% of capacity
        if (top > 0 && top == capacity / 4) {
            resize(capacity / 2);
        }
        
        return item;
    }
    
    // Peek operation
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top];
    }
    
    // Resize array
    private void resize(int newCapacity) {
        int[] newArr = new int[newCapacity];
        
        // Copy elements
        for (int i = 0; i <= top; i++) {
            newArr[i] = arr[i];
        }
        
        arr = newArr;
        capacity = newCapacity;
    }
    
    // Alternative resize using Arrays.copyOf
    private void resizeOptimized(int newCapacity) {
        arr = Arrays.copyOf(arr, newCapacity);
        capacity = newCapacity;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == -1;
    }
    
    // Check if full
    private boolean isFull() {
        return top == capacity - 1;
    }
    
    // Get size
    public int size() {
        return top + 1;
    }
    
    // Get capacity
    public int capacity() {
        return capacity;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        for (int i = top; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    
    // Display with capacity info
    public void displayWithCapacity() {
        System.out.println("Size: " + size() + ", Capacity: " + capacity);
        display();
    }
}
```

### Resize Strategy

**Growth Strategy**:
```java
// When full, double the capacity
if (isFull()) {
    resize(2 * capacity);  // O(n) but amortized O(1)
}
```

**Shrink Strategy**:
```java
// When using only 25%, halve the capacity
if (top > 0 && top == capacity / 4) {
    resize(capacity / 2);
}
```

**Why 25% instead of 50%?**
- Avoids thrashing (repeated resize on push/pop near boundary)
- Example with 50%:
  ```
  Capacity: 100, Size: 50
  Pop → Size: 49, resize to 50
  Push → Size: 50, resize to 100
  Pop → Size: 49, resize to 50
  // Continuous resizing!
  ```

### Amortized Analysis

**Push Operation**:
```
Sequence of n pushes:
- Regular pushes: n × O(1)
- Resize operations: 1 + 2 + 4 + 8 + ... + n (geometric series)
- Total resize cost: 2n
- Total cost: n + 2n = 3n
- Amortized: 3n/n = O(1)
```

**Visualization**:
```
Capacity: 4 → 8 → 16 → 32
Pushes:   4   4    8    16

Total pushes: 32
Resize cost: 4 + 8 + 16 = 28
Total: 32 + 28 = 60
Amortized per push: 60/32 ≈ 2 = O(1)
```

### Example Usage

```java
public class TestDynamicStack {
    public static void main(String[] args) {
        DynamicArrayStack stack = new DynamicArrayStack(2);  // Start small
        
        // Push elements (will trigger resize)
        System.out.println("=== Pushing elements ===");
        for (int i = 1; i <= 10; i++) {
            stack.push(i * 10);
            stack.displayWithCapacity();
        }
        
        // Pop elements (will trigger shrink)
        System.out.println("\n=== Popping elements ===");
        for (int i = 0; i < 7; i++) {
            System.out.println("Popped: " + stack.pop());
            stack.displayWithCapacity();
        }
    }
}
```

**Output**:
```
=== Pushing elements ===
Size: 1, Capacity: 2
Stack (top to bottom): 10
Size: 2, Capacity: 2
Stack (top to bottom): 20 10
Size: 3, Capacity: 4  // Resized!
Stack (top to bottom): 30 20 10
Size: 4, Capacity: 4
Stack (top to bottom): 40 30 20 10
Size: 5, Capacity: 8  // Resized!
...

=== Popping elements ===
Popped: 100
Size: 9, Capacity: 16
Stack (top to bottom): 90 80 70 60 50 40 30 20 10
...
Size: 3, Capacity: 8
Stack (top to bottom): 30 20 10
Popped: 30
Size: 2, Capacity: 4  // Shrunk!
Stack (top to bottom): 20 10
```

### Complexity Analysis

| Operation | Worst Case | Amortized | Notes |
|-----------|------------|-----------|-------|
| push() | O(n) | O(1) | Resize when full |
| pop() | O(n) | O(1) | Shrink when 25% full |
| peek() | O(1) | O(1) | - |
| isEmpty() | O(1) | O(1) | - |
| Space | O(n) | O(n) | Can have up to 4× waste |

---

## Generic Array Stack

### Implementation Using Generics

```java
@SuppressWarnings("unchecked")
public class GenericArrayStack<T> {
    private T[] arr;
    private int top;
    private int capacity;
    
    private static final int DEFAULT_CAPACITY = 10;
    
    // Constructor
    public GenericArrayStack() {
        this(DEFAULT_CAPACITY);
    }
    
    public GenericArrayStack(int initialCapacity) {
        if (initialCapacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive");
        }
        
        // Cannot create generic array directly: new T[capacity]
        // Must use Object array and cast
        arr = (T[]) new Object[initialCapacity];
        capacity = initialCapacity;
        top = -1;
    }
    
    // Push operation
    public void push(T item) {
        if (isFull()) {
            resize(2 * capacity);
        }
        arr[++top] = item;
    }
    
    // Pop operation
    public T pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        
        T item = arr[top];
        arr[top] = null;  // Help garbage collection
        top--;
        
        // Shrink if necessary
        if (top > 0 && top == capacity / 4) {
            resize(capacity / 2);
        }
        
        return item;
    }
    
    // Peek operation
    public T peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top];
    }
    
    // Resize array
    private void resize(int newCapacity) {
        T[] newArr = (T[]) new Object[newCapacity];
        
        for (int i = 0; i <= top; i++) {
            newArr[i] = arr[i];
        }
        
        arr = newArr;
        capacity = newCapacity;
    }
    
    // Check if empty
    public boolean isEmpty() {
        return top == -1;
    }
    
    // Check if full
    private boolean isFull() {
        return top == capacity - 1;
    }
    
    // Get size
    public int size() {
        return top + 1;
    }
    
    // Get capacity
    public int capacity() {
        return capacity;
    }
    
    // Display stack
    public void display() {
        if (isEmpty()) {
            System.out.println("Stack is empty");
            return;
        }
        
        System.out.print("Stack (top to bottom): ");
        for (int i = top; i >= 0; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
    
    // Convert to array
    public T[] toArray() {
        T[] result = (T[]) new Object[size()];
        for (int i = 0; i <= top; i++) {
            result[i] = arr[i];
        }
        return result;
    }
}
```

### Generic Stack Usage

```java
public class TestGenericStack {
    public static void main(String[] args) {
        // Integer stack
        GenericArrayStack<Integer> intStack = new GenericArrayStack<>();
        intStack.push(10);
        intStack.push(20);
        intStack.push(30);
        
        System.out.println("Integer Stack:");
        intStack.display();
        System.out.println("Popped: " + intStack.pop());
        
        // String stack
        GenericArrayStack<String> strStack = new GenericArrayStack<>(3);
        strStack.push("Hello");
        strStack.push("World");
        strStack.push("Java");
        
        System.out.println("\nString Stack:");
        strStack.display();
        System.out.println("Peek: " + strStack.peek());
        
        // Custom object stack
        GenericArrayStack<Person> personStack = new GenericArrayStack<>();
        personStack.push(new Person("Alice", 25));
        personStack.push(new Person("Bob", 30));
        
        System.out.println("\nPerson Stack:");
        while (!personStack.isEmpty()) {
            System.out.println(personStack.pop());
        }
    }
}

class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}
```

### Why Generic Array is Tricky

```java
// ❌ This doesn't work in Java
T[] arr = new T[capacity];  // Compile error: Cannot create array of generic type

// ✅ Correct approach
T[] arr = (T[]) new Object[capacity];  // Create Object array and cast

// Warning suppression needed
@SuppressWarnings("unchecked")
```

**Reasons**:
- Java generics use type erasure
- At runtime, `T` becomes `Object`
- Cannot create generic arrays at runtime
- Must use `Object[]` and cast

---

## Advanced Implementations

### 1. Two Stacks in One Array

**Problem**: Implement two stacks sharing one array efficiently.

**Solution**:
```java
public class TwoStacks {
    private int[] arr;
    private int top1;  // Stack 1 grows from left
    private int top2;  // Stack 2 grows from right
    private int size;
    
    public TwoStacks(int n) {
        size = n;
        arr = new int[n];
        top1 = -1;
        top2 = size;
    }
    
    // Push to stack 1
    public void push1(int x) {
        if (top1 < top2 - 1) {
            arr[++top1] = x;
        } else {
            throw new StackOverflowError("Stack Overflow");
        }
    }
    
    // Push to stack 2
    public void push2(int x) {
        if (top1 < top2 - 1) {
            arr[--top2] = x;
        } else {
            throw new StackOverflowError("Stack Overflow");
        }
    }
    
    // Pop from stack 1
    public int pop1() {
        if (top1 >= 0) {
            return arr[top1--];
        }
        throw new IllegalStateException("Stack 1 Underflow");
    }
    
    // Pop from stack 2
    public int pop2() {
        if (top2 < size) {
            return arr[top2++];
        }
        throw new IllegalStateException("Stack 2 Underflow");
    }
    
    // Check if stack 1 is empty
    public boolean isEmpty1() {
        return top1 == -1;
    }
    
    // Check if stack 2 is empty
    public boolean isEmpty2() {
        return top2 == size;
    }
    
    // Display both stacks
    public void display() {
        System.out.print("Stack 1 (bottom to top): ");
        for (int i = 0; i <= top1; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
        
        System.out.print("Stack 2 (bottom to top): ");
        for (int i = size - 1; i >= top2; i--) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
        
        System.out.print("Array: ");
        for (int i = 0; i < size; i++) {
            if (i <= top1 || i >= top2) {
                System.out.print(arr[i] + " ");
            } else {
                System.out.print("_ ");
            }
        }
        System.out.println("\n");
    }
}
```

**Example**:
```java
public class TestTwoStacks {
    public static void main(String[] args) {
        TwoStacks stacks = new TwoStacks(10);
        
        // Push to stack 1
        stacks.push1(1);
        stacks.push1(2);
        stacks.push1(3);
        
        // Push to stack 2
        stacks.push2(10);
        stacks.push2(20);
        stacks.push2(30);
        
        stacks.display();
        /*
        Stack 1 (bottom to top): 1 2 3
        Stack 2 (bottom to top): 30 20 10
        Array: 1 2 3 _ _ _ _ 30 20 10
        */
        
        System.out.println("Pop from Stack 1: " + stacks.pop1());  // 3
        System.out.println("Pop from Stack 2: " + stacks.pop2());  // 10
        
        stacks.display();
    }
}
```

**Visualization**:
```
Initial: [_, _, _, _, _, _, _, _, _, _]
         ↑                             ↑
        top1=-1                      top2=10

After push1(1,2,3) and push2(10,20,30):
         [1, 2, 3, _, _, _, _, 30, 20, 10]
               ↑                 ↑
             top1=2            top2=7
```

**Time**: O(1) for all operations
**Space**: O(n) - efficiently uses entire array

---

### 2. K Stacks in One Array

**Problem**: Implement k stacks in one array.

**Approach 1: Divide array into k equal parts**
```java
public class KStacksFixed {
    private int[] arr;
    private int[] top;
    private int k;
    private int n;
    
    public KStacksFixed(int k, int n) {
        this.k = k;
        this.n = n;
        arr = new int[n];
        top = new int[k];
        
        // Initialize top for each stack
        for (int i = 0; i < k; i++) {
            top[i] = -1;
        }
    }
    
    public void push(int stackNum, int value) {
        if (isFull(stackNum)) {
            throw new StackOverflowError("Stack " + stackNum + " is full");
        }
        
        int index = stackNum * (n / k) + (top[stackNum] + 1);
        arr[index] = value;
        top[stackNum]++;
    }
    
    public int pop(int stackNum) {
        if (isEmpty(stackNum)) {
            throw new IllegalStateException("Stack " + stackNum + " is empty");
        }
        
        int index = stackNum * (n / k) + top[stackNum];
        int value = arr[index];
        top[stackNum]--;
        return value;
    }
    
    public boolean isEmpty(int stackNum) {
        return top[stackNum] == -1;
    }
    
    public boolean isFull(int stackNum) {
        return top[stackNum] == (n / k) - 1;
    }
}
```

**Disadvantage**: Wastes space if stacks grow unevenly.

**Approach 2: Efficient space usage (Advanced)**
```java
public class KStacksEfficient {
    private int[] arr;      // Array to store elements
    private int[] top;      // Top of each stack
    private int[] next;     // Next free slot or next element in stack
    private int free;       // Index of first free slot
    private int k;          // Number of stacks
    private int n;          // Size of array
    
    public KStacksEfficient(int k, int n) {
        this.k = k;
        this.n = n;
        arr = new int[n];
        top = new int[k];
        next = new int[n];
        
        // Initialize all stacks as empty
        Arrays.fill(top, -1);
        
        // Initialize free list
        free = 0;
        for (int i = 0; i < n - 1; i++) {
            next[i] = i + 1;
        }
        next[n - 1] = -1;  // End of free list
    }
    
    public void push(int stackNum, int value) {
        if (free == -1) {
            throw new StackOverflowError("Array is full");
        }
        
        // Get free index
        int i = free;
        
        // Update free to next free slot
        free = next[i];
        
        // Insert value
        arr[i] = value;
        
        // Update next to point to previous top
        next[i] = top[stackNum];
        
        // Update top
        top[stackNum] = i;
    }
    
    public int pop(int stackNum) {
        if (top[stackNum] == -1) {
            throw new IllegalStateException("Stack " + stackNum + " is empty");
        }
        
        // Get top index
        int i = top[stackNum];
        
        // Update top to next element
        top[stackNum] = next[i];
        
        // Add this slot to free list
        next[i] = free;
        free = i;
        
        return arr[i];
    }
    
    public boolean isEmpty(int stackNum) {
        return top[stackNum] == -1;
    }
}
```

**Time**: O(1) for all operations
**Space**: O(n + k) - efficiently uses all space

---

### 3. Stack with getMin() in O(1)

```java
public class MinStack {
    private int[] arr;
    private int[] minArr;
    private int top;
    private int capacity;
    
    public MinStack(int capacity) {
        this.capacity = capacity;
        arr = new int[capacity];
        minArr = new int[capacity];
        top = -1;
    }
    
    public void push(int x) {
        if (isFull()) {
            throw new StackOverflowError("Stack is full");
        }
        
        arr[++top] = x;
        
        if (top == 0) {
            minArr[top] = x;
        } else {
            minArr[top] = Math.min(x, minArr[top - 1]);
        }
    }
    
    public int pop() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top--];
    }
    
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return arr[top];
    }
    
    public int getMin() {
        if (isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return minArr[top];
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
    
    public boolean isFull() {
        return top == capacity - 1;
    }
}
```

**Example**:
```java
MinStack stack = new MinStack(5);
stack.push(5);    // arr=[5], minArr=[5]
stack.push(3);    // arr=[5,3], minArr=[5,3]
stack.push(7);    // arr=[5,3,7], minArr=[5,3,3]
stack.push(2);    // arr=[5,3,7,2], minArr=[5,3,3,2]

stack.getMin();   // Returns 2
stack.pop();      // Removes 2
stack.getMin();   // Returns 3
```

**Space-Optimized Version** (without extra array):
```java
public class MinStackOptimized {
    private long[] arr;
    private int top;
    private long min;
    
    public void push(int x) {
        if (top == -1) {
            arr[++top] = x;
            min = x;
        } else {
            if (x >= min) {
                arr[++top] = x;
            } else {
                // Store encoded value
                arr[++top] = 2L * x - min;
                min = x;
            }
        }
    }
    
    public int pop() {
        long val = arr[top--];
        
        if (val < min) {
            // Actual value was min
            int result = (int) min;
            // Restore previous min
            min = 2 * min - val;
            return result;
        }
        
        return (int) val;
    }
    
    public int getMin() {
        return (int) min;
    }
}
```

**Time**: All operations O(1)
**Space**: O(n) vs O(2n) for two-array approach

---

## Common Problems

### Problem 1: Implement Stack Using Array (Basic)

**LeetCode variation**: Design your own stack

**Solution**: Already covered in [Fixed-Size Stack](#fixed-size-stack-implementation)

---

### Problem 2: Stock Span Problem

**Problem**: Calculate span for each day (consecutive days with price ≤ current).

**Array Stack Solution**:
```java
public class StockSpan {
    public static int[] calculateSpan(int[] prices) {
        int n = prices.length;
        int[] span = new int[n];
        int[] stack = new int[n];  // Store indices
        int top = -1;
        
        for (int i = 0; i < n; i++) {
            // Pop while current price >= price at stack top
            while (top >= 0 && prices[stack[top]] <= prices[i]) {
                top--;
            }
            
            // Calculate span
            span[i] = (top == -1) ? (i + 1) : (i - stack[top]);
            
            // Push current index
            stack[++top] = i;
        }
        
        return span;
    }
    
    public static void main(String[] args) {
        int[] prices = {100, 80, 60, 70, 60, 75, 85};
        int[] span = calculateSpan(prices);
        
        System.out.println("Prices: " + Arrays.toString(prices));
        System.out.println("Span:   " + Arrays.toString(span));
        // Span: [1, 1, 1, 2, 1, 4, 6]
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 3: Next Greater Element

**Problem**: For each element, find next greater element.

**Array Stack Solution**:
```java
public class NextGreaterElement {
    public static int[] nextGreater(int[] arr) {
        int n = arr.length;
        int[] result = new int[n];
        int[] stack = new int[n];
        int top = -1;
        
        // Traverse from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Pop elements <= current
            while (top >= 0 && stack[top] <= arr[i]) {
                top--;
            }
            
            // Set result
            result[i] = (top == -1) ? -1 : stack[top];
            
            // Push current element
            stack[++top] = arr[i];
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        int[] arr = {4, 5, 2, 10, 8};
        int[] result = nextGreater(arr);
        
        System.out.println("Array:  " + Arrays.toString(arr));
        System.out.println("Result: " + Arrays.toString(result));
        // Result: [5, 10, 10, -1, -1]
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Problem 4: Largest Rectangle in Histogram

**Problem**: Find largest rectangle in histogram.

**Array Stack Solution**:
```java
public class LargestRectangle {
    public static int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] stack = new int[n + 1];
        int top = -1;
        int maxArea = 0;
        
        for (int i = 0; i <= n; i++) {
            int h = (i == n) ? 0 : heights[i];
            
            while (top >= 0 && heights[stack[top]] > h) {
                int height = heights[stack[top--]];
                int width = (top == -1) ? i : i - stack[top] - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            
            stack[++top] = i;
        }
        
        return maxArea;
    }
    
    public static void main(String[] args) {
        int[] heights = {2, 1, 5, 6, 2, 3};
        System.out.println("Max Area: " + largestRectangleArea(heights));
        // Output: 10 (width=2, height=5)
    }
}
```

**LeetCode 84** - Largest Rectangle in Histogram

**Time**: O(n) | **Space**: O(n)

---

## Interview Questions

### Question 1: Design a Stack that Supports Increment Operation

**Problem**: Design stack with `increment(k, val)` - add val to bottom k elements.

**Solution**:
```java
public class CustomStack {
    private int[] arr;
    private int[] increment;
    private int top;
    private int maxSize;
    
    public CustomStack(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        increment = new int[maxSize];
        top = -1;
    }
    
    public void push(int x) {
        if (top < maxSize - 1) {
            arr[++top] = x;
        }
    }
    
    public int pop() {
        if (top == -1) {
            return -1;
        }
        
        // Apply increment
        int result = arr[top] + increment[top];
        
        // Pass increment to element below
        if (top > 0) {
            increment[top - 1] += increment[top];
        }
        
        increment[top] = 0;
        top--;
        
        return result;
    }
    
    public void increment(int k, int val) {
        int limit = Math.min(k, top + 1) - 1;
        if (limit >= 0) {
            increment[limit] += val;
        }
    }
}
```

**LeetCode 1381** - Design a Stack With Increment Operation

**Time**: All operations O(1)
**Space**: O(n)

---

### Question 2: Sort Array Using Stack

**Problem**: Sort array using only stack operations.

**Solution**:
```java
public class SortArrayUsingStack {
    public static void sortArray(int[] arr) {
        int[] stack = new int[arr.length];
        int top = -1;
        
        // Push all elements to stack
        for (int num : arr) {
            stack[++top] = num;
        }
        
        // Sort using temporary stack
        int[] tempStack = new int[arr.length];
        int tempTop = -1;
        
        while (top >= 0) {
            int temp = stack[top--];
            
            // Move elements from tempStack to stack
            while (tempTop >= 0 && tempStack[tempTop] > temp) {
                stack[++top] = tempStack[tempTop--];
            }
            
            tempStack[++tempTop] = temp;
        }
        
        // Copy back to array
        for (int i = 0; i <= tempTop; i++) {
            arr[i] = tempStack[tempTop - i];
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {34, 3, 31, 98, 92, 23};
        System.out.println("Before: " + Arrays.toString(arr));
        
        sortArray(arr);
        
        System.out.println("After:  " + Arrays.toString(arr));
        // After: [3, 23, 31, 34, 92, 98]
    }
}
```

**Time**: O(n²) worst case
**Space**: O(n)

---

### Question 3: Reverse Array Using Stack

**Problem**: Reverse array using stack.

**Solution**:
```java
public class ReverseArrayUsingStack {
    public static void reverseArray(int[] arr) {
        int n = arr.length;
        int[] stack = new int[n];
        int top = -1;
        
        // Push all elements
        for (int num : arr) {
            stack[++top] = num;
        }
        
        // Pop and store back
        for (int i = 0; i < n; i++) {
            arr[i] = stack[top--];
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        reverseArray(arr);
        
        System.out.println("Reversed: " + Arrays.toString(arr));
        // Reversed: [5, 4, 3, 2, 1]
    }
}
```

**Time**: O(n) | **Space**: O(n)

---

### Question 4: Check if Array Represents Valid Stack Sequence

**Problem**: Given push/pop sequences, check if valid.

**Solution**:
```java
public class ValidStackSequence {
    public static boolean validateSequence(int[] pushed, int[] popped) {
        int n = pushed.length;
        int[] stack = new int[n];
        int top = -1;
        int j = 0;
        
        for (int x : pushed) {
            stack[++top] = x;
            
            // Pop while top matches popped sequence
            while (top >= 0 && stack[top] == popped[j]) {
                top--;
                j++;
            }
        }
        
        return top == -1;
    }
    
    public static void main(String[] args) {
        int[] pushed = {1, 2, 3, 4, 5};
        int[] popped1 = {4, 5, 3, 2, 1};
        int[] popped2 = {4, 3, 5, 1, 2};
        
        System.out.println(validateSequence(pushed, popped1));  // true
        System.out.println(validateSequence(pushed, popped2));  // false
    }
}
```

**LeetCode 946** - Validate Stack Sequences

**Time**: O(n) | **Space**: O(n)

---

## Practice Problems

### Easy Problems

| # | Problem | Concept | Difficulty |
|---|---------|---------|------------|
| 1 | Implement Stack Using Array | Basic | ⭐ |
| 2 | Reverse Array Using Stack | Basic | ⭐ |
| 3 | Balanced Parentheses | Stack | ⭐⭐ |
| 4 | Stack with getMin() | Design | ⭐⭐ |
| 5 | Remove Adjacent Duplicates | Stack | ⭐ |
| 6 | Baseball Game | Simulation | ⭐ |
| 7 | Next Greater Element | Monotonic | ⭐⭐ |
| 8 | Valid Parentheses | Stack | ⭐⭐ |
| 9 | Implement Queue Using Stacks | Design | ⭐⭐ |
| 10 | Backspace String Compare | Stack | ⭐ |

### Medium Problems

| # | Problem | Concept | Difficulty |
|---|---------|---------|------------|
| 1 | Two Stacks in One Array | Space Optimization | ⭐⭐ |
| 2 | Sort Stack | Sorting | ⭐⭐ |
| 3 | Stock Span Problem | Monotonic Stack | ⭐⭐⭐ |
| 4 | Daily Temperatures | Monotonic Stack | ⭐⭐⭐ |
| 5 | Validate Stack Sequences | Simulation | ⭐⭐ |
| 6 | Decode String | Stack | ⭐⭐⭐ |
| 7 | Asteroid Collision | Stack | ⭐⭐ |
| 8 | Design Stack with Increment | Design | ⭐⭐ |
| 9 | Remove K Digits | Greedy + Stack | ⭐⭐⭐ |
| 10 | Next Greater Element II | Circular | ⭐⭐ |

### Hard Problems

| # | Problem | Concept | Difficulty |
|---|---------|---------|------------|
| 1 | Largest Rectangle in Histogram | Monotonic Stack | ⭐⭐⭐⭐ |
| 2 | Maximal Rectangle | Stack + DP | ⭐⭐⭐⭐ |
| 3 | K Stacks in One Array | Space Optimization | ⭐⭐⭐⭐ |
| 4 | Trapping Rain Water | Monotonic Stack | ⭐⭐⭐⭐ |
| 5 | Basic Calculator | Expression | ⭐⭐⭐⭐ |

---

## Summary

### Key Concepts

**1. Array Stack Fundamentals**:
```java
int[] arr;         // Storage
int top = -1;      // Top pointer (-1 = empty)
int capacity;      // Max size

// Push: arr[++top] = x;
// Pop:  return arr[top--];
// Peek: return arr[top];
```

**2. Fixed vs Dynamic**:
- **Fixed**: Simple, predictable, wastes space if oversized
- **Dynamic**: Flexible, resize overhead, better space utilization

**3. Resize Strategy**:
- **Grow**: Double when full (2× capacity)
- **Shrink**: Halve when 25% full (avoid thrashing)
- **Amortized**: O(1) for both push and pop

### Implementation Comparison

| Feature | Fixed Array | Dynamic Array | Linked List |
|---------|-------------|---------------|-------------|
| Memory | Contiguous | Contiguous | Scattered |
| Size | Fixed | Dynamic | Dynamic |
| Resize | No | Yes (O(n)) | Not needed |
| Cache | Excellent | Excellent | Poor |
| Overhead | None | Resize cost | Pointers |
| Best For | Known size | Unknown size | Frequent insert/delete |

### Complexity Summary

| Operation | Fixed Array | Dynamic Array (Amortized) |
|-----------|-------------|---------------------------|
| Push | O(1) | O(1) |
| Pop | O(1) | O(1) |
| Peek | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| Size | O(1) | O(1) |
| **Space** | **O(n)** | **O(n)** |

### Common Patterns

**1. Monotonic Stack**:
```java
// Next greater element template
for (int i = n - 1; i >= 0; i--) {
    while (top >= 0 && stack[top] <= arr[i]) {
        top--;
    }
    result[i] = (top == -1) ? -1 : stack[top];
    stack[++top] = arr[i];
}
```

**2. Two Stacks**:
```java
// Stack 1 from left, Stack 2 from right
top1 = -1;
top2 = n;
// Overflow when: top1 + 1 == top2
```

**3. Min/Max Stack**:
```java
// Maintain auxiliary array
minArr[i] = Math.min(current, minArr[i-1]);
```

### Interview Tips

1. ✅ **Always check**: Empty and full conditions
2. ✅ **Mention**: Time and space complexity
3. ✅ **Consider**: Fixed vs dynamic based on requirements
4. ✅ **Know**: Common patterns (monotonic stack, two stacks)
5. ✅ **Practice**: Implementing from scratch without library

### Common Mistakes

1. ❌ Forgetting to check `isFull()` before push
2. ❌ Forgetting to check `isEmpty()` before pop/peek
3. ❌ Off-by-one errors with top pointer
4. ❌ Not handling resize properly (forgetting to copy elements)
5. ❌ Using `arr[top++]` instead of `arr[++top]` for push

### Master These

**Must Know**:
1. ✅ Fixed-size stack implementation
2. ✅ Dynamic stack with resize
3. ✅ Generic stack implementation
4. ✅ Two stacks in one array
5. ✅ Min stack

**Good to Know**:
6. ✅ K stacks in one array
7. ✅ Stack with increment operation
8. ✅ Monotonic stack pattern

### Next Topics

- **Next**: [8.3 Stack Using Linked List](8.3-Stack-Using-Linked-List.md)
- **Related**: [8.4 Stack Applications](8.4-Stack-Applications.md)
- **Advanced**: [8.5 Monotonic Stack](8.5-Monotonic-Stack.md)

---

**Previous**: [8.1 Stack Basics](8.1-Stack-Basics.md)
