# 6.8 Radix Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Variations](#variations)
4. [Applications](#applications)
5. [Interview Questions](#interview-questions)
6. [Practice Problems](#practice-problems)
7. [Summary](#summary)

---

## Introduction

### What is Radix Sort?

**Radix sort** is a **non-comparison** based sorting algorithm that:
- Sorts integers by processing individual **digits**
- Uses **counting sort** as a subroutine
- Processes digits from **least significant** to **most significant** (LSD)
- Or from **most significant** to **least significant** (MSD)
- Achieves **linear time** O(d(n + k)) where d = digits, k = base

### Visual Example

```
Original: [170, 45, 75, 90, 802, 24, 2, 66]

LSD Radix Sort (base 10):

Pass 1 - Sort by ones digit (least significant):
170, 90, 802, 2, 24, 45, 75, 66
 ↑   ↑    ↑  ↑   ↑   ↑   ↑   ↑
 0   0    2  2   4   5   5   6

Pass 2 - Sort by tens digit:
802, 2, 24, 45, 66, 170, 75, 90
  ↑  ↑   ↑   ↑   ↑    ↑   ↑   ↑
  0  0   2   4   6    7   7   9

Pass 3 - Sort by hundreds digit:
2, 24, 45, 66, 75, 90, 170, 802
↑   ↑   ↑   ↑   ↑   ↑    ↑    ↑
0   0   0   0   0   0    1    8

Final: [2, 24, 45, 66, 75, 90, 170, 802]
```

### Key Characteristics

- **Time Complexity**: O(d(n + k))
  - d = number of digits
  - n = elements
  - k = base (usually 10)
- **Space Complexity**: O(n + k)
- **Stability**: **Stable** (uses stable counting sort)
- **Non-comparison**: No element comparisons
- **Linear time**: When d is constant, O(n)

### When to Use

**Use Radix Sort**:
- ✅ Sorting **integers** with limited digits
- ✅ When **d is small** relative to n
- ✅ Need **stability**
- ✅ Strings of equal length
- ✅ Want O(n) time

**Avoid Radix Sort**:
- ❌ Variable-length data
- ❌ Floating point numbers
- ❌ Large number of digits (d is large)
- ❌ Arbitrary objects
- ❌ Small datasets (overhead not worth it)

---

## Basic Implementation

### LSD Radix Sort (Least Significant Digit)

```java
public class RadixSort {
    /**
     * LSD Radix Sort - sorts from rightmost to leftmost digit
     * Time: O(d(n + k)), Space: O(n + k)
     * d = max digits, k = base (10)
     */
    public void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // Find maximum number to determine number of digits
        int max = Arrays.stream(arr).max().getAsInt();
        
        // Sort by each digit (LSD to MSD)
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    /**
     * Counting sort by specific digit position
     * exp = 1 (ones), 10 (tens), 100 (hundreds), etc.
     */
    private void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10]; // Base 10: digits 0-9
        
        // Count occurrences of each digit
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }
        
        // Cumulative count (positions)
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output (right to left for stability)
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        // Copy to original
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // Test
    public static void main(String[] args) {
        RadixSort rs = new RadixSort();
        
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        System.out.println("Original: " + Arrays.toString(arr));
        
        rs.radixSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [170, 45, 75, 90, 802, 24, 2, 66]
Sorted: [2, 24, 45, 66, 75, 90, 170, 802]
```

---

### With Negative Numbers

```java
public class RadixSortNegative {
    /**
     * Radix sort handling negative numbers
     * Separate into negative and positive, sort each, merge
     */
    public void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        // Separate negative and non-negative
        List<Integer> negative = new ArrayList<>();
        List<Integer> nonNegative = new ArrayList<>();
        
        for (int num : arr) {
            if (num < 0) {
                negative.add(-num); // Make positive for sorting
            } else {
                nonNegative.add(num);
            }
        }
        
        // Sort both parts
        int[] negArr = negative.stream().mapToInt(i -> i).toArray();
        int[] posArr = nonNegative.stream().mapToInt(i -> i).toArray();
        
        radixSortPositive(negArr);
        radixSortPositive(posArr);
        
        // Merge: negatives in reverse, then positives
        int idx = 0;
        for (int i = negArr.length - 1; i >= 0; i--) {
            arr[idx++] = -negArr[i];
        }
        for (int i = 0; i < posArr.length; i++) {
            arr[idx++] = posArr[i];
        }
    }
    
    private void radixSortPositive(int[] arr) {
        if (arr.length == 0) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // Test
    public static void main(String[] args) {
        RadixSortNegative rsn = new RadixSortNegative();
        
        int[] arr = {-5, 10, -3, 8, 0, -1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        rsn.radixSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

---

## Variations

### MSD Radix Sort (Most Significant Digit)

```java
public class MSDRadixSort {
    /**
     * MSD Radix Sort - sorts from leftmost to rightmost digit
     * Recursive approach, can stop early
     */
    public void radixSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        int maxDigits = String.valueOf(max).length();
        
        radixSortMSD(arr, 0, arr.length - 1, maxDigits - 1);
    }
    
    private void radixSortMSD(int[] arr, int low, int high, int digit) {
        if (low >= high || digit < 0) return;
        
        int divisor = (int) Math.pow(10, digit);
        int[] count = new int[11]; // 0-9 plus overflow
        int[] output = new int[high - low + 1];
        
        // Count digits
        for (int i = low; i <= high; i++) {
            int d = (arr[i] / divisor) % 10;
            count[d + 1]++;
        }
        
        // Cumulative
        for (int i = 0; i < 10; i++) {
            count[i + 1] += count[i];
        }
        
        // Build output
        for (int i = low; i <= high; i++) {
            int d = (arr[i] / divisor) % 10;
            output[count[d]++] = arr[i];
        }
        
        // Copy back
        System.arraycopy(output, 0, arr, low, high - low + 1);
        
        // Recursively sort each bucket
        for (int i = 0; i < 10; i++) {
            radixSortMSD(arr, low + count[i], low + count[i + 1] - 1, digit - 1);
        }
    }
}
```

---

### Different Base (Binary/Hexadecimal)

```java
public class RadixSortBase {
    /**
     * Radix sort with custom base
     * Base 2 (binary), 16 (hex), etc.
     */
    public void radixSort(int[] arr, int base) {
        if (arr == null || arr.length <= 1) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        
        for (int exp = 1; max / exp > 0; exp *= base) {
            countingSortByDigit(arr, exp, base);
        }
    }
    
    private void countingSortByDigit(int[] arr, int exp, int base) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[base];
        
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % base;
            count[digit]++;
        }
        
        for (int i = 1; i < base; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % base;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // Test
    public static void main(String[] args) {
        RadixSortBase rsb = new RadixSortBase();
        
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        
        // Base 2 (binary)
        int[] arr1 = arr.clone();
        rsb.radixSort(arr1, 2);
        System.out.println("Base 2: " + Arrays.toString(arr1));
        
        // Base 16 (hexadecimal)
        int[] arr2 = arr.clone();
        rsb.radixSort(arr2, 16);
        System.out.println("Base 16: " + Arrays.toString(arr2));
    }
}
```

---

### Radix Sort for Strings

```java
public class RadixSortStrings {
    /**
     * Radix sort for strings of equal length
     * MSD approach from left to right
     */
    public void radixSort(String[] arr, int maxLen) {
        for (int d = maxLen - 1; d >= 0; d--) {
            countingSortByChar(arr, d);
        }
    }
    
    private void countingSortByChar(String[] arr, int d) {
        int n = arr.length;
        String[] output = new String[n];
        int[] count = new int[256]; // ASCII
        
        // Count characters
        for (int i = 0; i < n; i++) {
            char c = d < arr[i].length() ? arr[i].charAt(d) : 0;
            count[c]++;
        }
        
        // Cumulative
        for (int i = 1; i < 256; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output
        for (int i = n - 1; i >= 0; i--) {
            char c = d < arr[i].length() ? arr[i].charAt(d) : 0;
            output[count[c] - 1] = arr[i];
            count[c]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // Test
    public static void main(String[] args) {
        RadixSortStrings rss = new RadixSortStrings();
        
        String[] arr = {"bat", "cat", "rat", "mat", "hat"};
        System.out.println("Original: " + Arrays.toString(arr));
        
        rss.radixSort(arr, 3);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

---

## Applications

### Application 1: Sort Dates

```java
public class SortDates {
    static class Date {
        int day, month, year;
        
        Date(int d, int m, int y) {
            day = d; month = m; year = y;
        }
        
        @Override
        public String toString() {
            return String.format("%02d/%02d/%04d", day, month, year);
        }
    }
    
    /**
     * Sort dates using radix sort
     * Sort by day, then month, then year
     */
    public void sortDates(Date[] dates) {
        // Sort by day (1-31)
        countingSortByField(dates, d -> d.day, 32);
        
        // Sort by month (1-12)
        countingSortByField(dates, d -> d.month, 13);
        
        // Sort by year
        int maxYear = Arrays.stream(dates).mapToInt(d -> d.year).max().getAsInt();
        countingSortByField(dates, d -> d.year, maxYear + 1);
    }
    
    private void countingSortByField(Date[] arr, 
                                     java.util.function.ToIntFunction<Date> field,
                                     int range) {
        int n = arr.length;
        Date[] output = new Date[n];
        int[] count = new int[range];
        
        for (int i = 0; i < n; i++) {
            count[field.applyAsInt(arr[i])]++;
        }
        
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            int val = field.applyAsInt(arr[i]);
            output[count[val] - 1] = arr[i];
            count[val]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // Test
    public static void main(String[] args) {
        SortDates sd = new SortDates();
        
        Date[] dates = {
            new Date(15, 3, 2020),
            new Date(10, 1, 2021),
            new Date(20, 3, 2020),
            new Date(5, 1, 2020)
        };
        
        System.out.println("Original: " + Arrays.toString(dates));
        sd.sortDates(dates);
        System.out.println("Sorted: " + Arrays.toString(dates));
    }
}
```

---

### Application 2: Maximum Number After Digit Swaps

```java
public class MaxNumberDigitSwaps {
    /**
     * Get maximum number by at most k swaps
     * Use radix-like approach
     */
    public String maximumSwap(int num) {
        char[] digits = String.valueOf(num).toCharArray();
        int[] last = new int[10]; // Last occurrence of each digit
        
        // Record last position of each digit
        for (int i = 0; i < digits.length; i++) {
            last[digits[i] - '0'] = i;
        }
        
        // Try to swap with largest digit from left
        for (int i = 0; i < digits.length; i++) {
            for (int d = 9; d > digits[i] - '0'; d--) {
                if (last[d] > i) {
                    // Swap
                    char temp = digits[i];
                    digits[i] = digits[last[d]];
                    digits[last[d]] = temp;
                    return new String(digits);
                }
            }
        }
        
        return String.valueOf(num);
    }
    
    // Test
    public static void main(String[] args) {
        MaxNumberDigitSwaps mnds = new MaxNumberDigitSwaps();
        
        System.out.println(mnds.maximumSwap(2736)); // 7236
        System.out.println(mnds.maximumSwap(9973)); // 9973
    }
}
```

---

## Interview Questions

### Question 1: Sort Array by Increasing Frequency

**Problem**: Sort array by frequency (ascending), then by value (descending).

```java
public class SortByFrequency {
    /**
     * LeetCode 1636
     * Sort by frequency (ascending), value (descending)
     */
    public int[] frequencySort(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        
        return Arrays.stream(nums)
            .boxed()
            .sorted((a, b) -> {
                int freqA = freq.get(a);
                int freqB = freq.get(b);
                if (freqA != freqB) {
                    return freqA - freqB; // Ascending frequency
                }
                return b - a; // Descending value
            })
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```

---

### Question 2: Maximum Gap

**Problem**: Find maximum difference between successive elements in sorted array. O(n) required.

```java
public class MaximumGap {
    /**
     * LeetCode 164 - Using radix sort
     * Time: O(n), Space: O(n)
     */
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2) return 0;
        
        // Radix sort
        radixSort(nums);
        
        // Find max gap
        int maxGap = 0;
        for (int i = 1; i < nums.length; i++) {
            maxGap = Math.max(maxGap, nums[i] - nums[i - 1]);
        }
        
        return maxGap;
    }
    
    private void radixSort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();
        
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSort(arr, exp);
        }
    }
    
    private void countingSort(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

---

### Question 3: Sort Integers by Number of 1 Bits

**Problem**: Sort by number of 1 bits, then by value.

```java
public class SortByBits {
    /**
     * LeetCode 1356
     * Sort by bit count, then by value
     */
    public int[] sortByBits(int[] arr) {
        return Arrays.stream(arr)
            .boxed()
            .sorted((a, b) -> {
                int bitsA = Integer.bitCount(a);
                int bitsB = Integer.bitCount(b);
                if (bitsA != bitsB) {
                    return bitsA - bitsB;
                }
                return a - b;
            })
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    /**
     * Using radix sort concept - sort by bit count first
     */
    public int[] sortByBitsRadix(int[] arr) {
        // Find max bit count
        int maxBits = 0;
        for (int num : arr) {
            maxBits = Math.max(maxBits, Integer.bitCount(num));
        }
        
        // Counting sort by bit count
        List<List<Integer>> buckets = new ArrayList<>();
        for (int i = 0; i <= maxBits; i++) {
            buckets.add(new ArrayList<>());
        }
        
        for (int num : arr) {
            buckets.get(Integer.bitCount(num)).add(num);
        }
        
        // Sort within buckets and merge
        int idx = 0;
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
            for (int num : bucket) {
                arr[idx++] = num;
            }
        }
        
        return arr;
    }
}
```

---

## Practice Problems

### Easy Level

1. **Sort an Array** (LeetCode 912)
   - Can use radix sort for integers
   - O(d·n) time

2. **Sort Integers by Number of 1 Bits** (LeetCode 1356)
   - Radix-like bucketing by bit count

3. **Sort Array by Increasing Frequency** (LeetCode 1636)
   - Multi-criteria sorting

### Medium Level

4. **Maximum Gap** (LeetCode 164)
   - O(n) solution using radix sort
   - Or bucket sort

5. **Sort Colors** (LeetCode 75)
   - Can use counting sort (radix with d=1)
   - Or three-way partition

6. **Largest Number** (LeetCode 179)
   - Custom comparator
   - Not typical radix but digit-based

### Hard Level

7. **Maximum Gap** (LeetCode 164)
   - Requires O(n) time
   - Radix sort perfect fit

### Implementation Practice

```java
public class RadixSortPractice {
    /**
     * Practice 1: Sort by last digit only
     */
    public void sortByLastDigit(int[] arr) {
        int[] count = new int[10];
        int[] output = new int[arr.length];
        
        for (int num : arr) {
            count[num % 10]++;
        }
        
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = arr.length - 1; i >= 0; i--) {
            int digit = arr[i] % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
    
    /**
     * Practice 2: Count sort for small range
     */
    public void optimizedSort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();
        
        // If range is small, use counting sort
        if (max < 1000) {
            int[] count = new int[max + 1];
            for (int num : arr) count[num]++;
            
            int idx = 0;
            for (int i = 0; i <= max; i++) {
                while (count[i]-- > 0) arr[idx++] = i;
            }
        } else {
            // Use radix sort for larger ranges
            for (int exp = 1; max / exp > 0; exp *= 10) {
                countingSort(arr, exp);
            }
        }
    }
    
    private void countingSort(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        for (int i = 0; i < n; i++) {
            count[(arr[i] / exp) % 10]++;
        }
        
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        System.arraycopy(output, 0, arr, 0, n);
    }
}
```

---

## Summary

### Key Takeaways

1. **Digit-by-digit** - processes one digit at a time
2. **Uses counting sort** - stable subroutine is critical
3. **Linear time** - O(d·n) when d is constant
4. **LSD vs MSD** - LSD simpler, MSD can optimize
5. **Requires integers** - or fixed-length strings
6. **Base matters** - larger base = fewer passes

### Complexity Summary

| Aspect | LSD Radix | MSD Radix | Notes |
|--------|-----------|-----------|-------|
| Time | O(d(n + k)) | O(d(n + k)) | d=digits, k=base |
| Space | O(n + k) | O(n + k) | For counting arrays |
| Stability | Stable | Stable | Critical for correctness |
| Best for | Fixed digits | Variable length | Different strengths |

### Comparison with Other Sorts

| Sort | Time | Space | Stable | Works On |
|------|------|-------|--------|----------|
| Radix | O(d·n) | O(n) | Yes | Integers, strings |
| Counting | O(n + k) | O(k) | Yes | Small range integers |
| Quick | O(n log n) | O(log n) | No | Any comparable |
| Merge | O(n log n) | O(n) | Yes | Any comparable |

### When to Use

| Scenario | Use Radix Sort? |
|----------|----------------|
| Integers, d small | ✅ Excellent O(d·n) |
| Fixed-length strings | ✅ Perfect fit |
| Large integers, many digits | ❌ Too many passes |
| Floating point | ❌ Doesn't work |
| Small dataset | ❌ Overhead not worth it |
| Need O(n) time | ✅ One of few options |

### Interview Tips

1. **Explain stability**: Critical for multi-pass correctness
2. **LSD vs MSD**: Know difference and trade-offs
3. **Base selection**: Base 10 vs 2 vs 256
4. **Count digits**: log₁₀(max) or string length
5. **Negative numbers**: Separate and merge technique
6. **Compare to counting**: Radix extends counting to multiple passes
7. **Real applications**: Phone numbers, dates, SSNs

### Common Pitfalls

❌ Forgetting stability in counting sort subroutine
❌ Not handling negative numbers properly
❌ Using on floating point or variable data
❌ Wrong digit extraction: (num / exp) % base
❌ Not considering number of digits (d) in complexity

### Real-World Usage

- **Database sorting**: Fixed-length keys
- **Network routing**: IP addresses
- **Suffix arrays**: String algorithms
- **Parallel computing**: Easy to parallelize
- **Historical**: Card sorting machines

### Advantages

✅ **O(n) time** - when d is constant
✅ **Stable** - preserves order
✅ **No comparisons** - digit operations only
✅ **Predictable** - no worst case like quicksort

### Disadvantages

❌ **Limited data types** - integers, fixed strings
❌ **Space overhead** - O(n + k)
❌ **Not in-place** - requires auxiliary arrays
❌ **Base dependency** - performance varies with base

---

**Next**: [6.9 Bucket Sort](6.9-Bucket-Sort.md) - Learn about bucket sort algorithm

**Previous**: [6.7 Counting Sort](6.7-Counting-Sort.md)
