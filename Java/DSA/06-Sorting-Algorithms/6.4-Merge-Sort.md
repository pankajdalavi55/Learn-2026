# 6.4 Merge Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Optimizations](#optimizations)
4. [Variations](#variations)
5. [Applications](#applications)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is Merge Sort?

**Merge sort** is a divide-and-conquer sorting algorithm that:
- **Divides** array into two halves
- **Recursively sorts** each half
- **Merges** sorted halves into single sorted array

### Visual Example

```
Original: [38, 27, 43, 3, 9, 82, 10]

       [38, 27, 43, 3, 9, 82, 10]
              /              \
      [38, 27, 43, 3]    [9, 82, 10]
         /      \           /      \
    [38, 27]  [43, 3]   [9, 82]   [10]
     /    \    /    \    /    \      |
   [38] [27] [43] [3] [9]  [82]   [10]
     \    /    \    /    \    /      |
    [27, 38]  [3, 43]   [9, 82]   [10]
         \      /           \      /
      [3, 27, 38, 43]    [9, 10, 82]
              \              /
       [3, 9, 10, 27, 38, 43, 82]

Divide phase: Top to bottom
Merge phase: Bottom to top
```

### Merge Process

```
Merge [3, 27, 38, 43] and [9, 10, 82]:

Step 1: Compare 3 and 9 → take 3
        [3, _, _, _, _, _, _]

Step 2: Compare 27 and 9 → take 9
        [3, 9, _, _, _, _, _]

Step 3: Compare 27 and 10 → take 10
        [3, 9, 10, _, _, _, _]

Step 4: Compare 27 and 82 → take 27
        [3, 9, 10, 27, _, _, _]

Step 5-7: Copy remaining elements
        [3, 9, 10, 27, 38, 43, 82]
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n log n)
  - Average: O(n log n)
  - Worst: O(n log n)
- **Space Complexity**: O(n) - requires extra array
- **Stability**: **Stable** - maintains relative order
- **Adaptive**: No - always O(n log n)
- **Divide & Conquer**: Classic example

### When to Use

**Use Merge Sort**:
- ✅ Guaranteed O(n log n) worst case
- ✅ Stability required
- ✅ Sorting linked lists (O(1) extra space)
- ✅ External sorting (large datasets)
- ✅ Parallel processing

**Avoid Merge Sort**:
- ❌ Memory constrained (needs O(n) space)
- ❌ Small datasets (overhead not worth it)
- ❌ Cache performance critical (not cache-friendly)

---

## Basic Implementation

### Recursive Merge Sort

```java
public class MergeSort {
    /**
     * Top-down recursive merge sort
     */
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left >= right) {
            return; // Base case: single element
        }
        
        // Divide
        int mid = left + (right - left) / 2;
        
        // Conquer
        mergeSort(arr, temp, left, mid);      // Sort left half
        mergeSort(arr, temp, mid + 1, right); // Sort right half
        
        // Combine
        merge(arr, temp, left, mid, right);
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // Copy to temp array
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left;      // Left subarray pointer
        int j = mid + 1;   // Right subarray pointer
        int k = left;      // Merged array pointer
        
        // Merge back to arr
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        // Copy remaining left elements
        while (i <= mid) {
            arr[k++] = temp[i++];
        }
        
        // Copy remaining right elements (optional, already in place)
        while (j <= right) {
            arr[k++] = temp[j++];
        }
    }
    
    // Test
    public static void main(String[] args) {
        MergeSort ms = new MergeSort();
        
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
        System.out.println("Original: " + Arrays.toString(arr));
        
        ms.mergeSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [38, 27, 43, 3, 9, 82, 10]
Sorted: [3, 9, 10, 27, 38, 43, 82]
```

**Complexity**: O(n log n) time, O(n) space

---

### With Detailed Steps

```java
public class MergeSortVerbose {
    private int depth = 0;
    
    public void mergeSort(int[] arr) {
        int[] temp = new int[arr.length];
        System.out.println("Starting array: " + Arrays.toString(arr));
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left >= right) return;
        
        depth++;
        String indent = "  ".repeat(depth);
        
        int mid = left + (right - left) / 2;
        
        System.out.println(indent + "Divide: " + 
            Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
        
        mergeSort(arr, temp, left, mid);
        mergeSort(arr, temp, mid + 1, right);
        
        System.out.println(indent + "Merge: " + 
            Arrays.toString(Arrays.copyOfRange(arr, left, mid + 1)) + 
            " + " + 
            Arrays.toString(Arrays.copyOfRange(arr, mid + 1, right + 1)));
        
        merge(arr, temp, left, mid, right);
        
        System.out.println(indent + "Result: " + 
            Arrays.toString(Arrays.copyOfRange(arr, left, right + 1)));
        
        depth--;
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
        while (j <= right) arr[k++] = temp[j++];
    }
    
    // Test
    public static void main(String[] args) {
        MergeSortVerbose msv = new MergeSortVerbose();
        int[] arr = {38, 27, 43, 3};
        msv.mergeSort(arr);
    }
}
```

---

## Optimizations

### Optimization 1: Use Insertion Sort for Small Subarrays

```java
public class OptimizedMergeSort {
    private static final int INSERTION_THRESHOLD = 10;
    
    public void mergeSort(int[] arr) {
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        // Use insertion sort for small subarrays
        if (right - left < INSERTION_THRESHOLD) {
            insertionSort(arr, left, right);
            return;
        }
        
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, temp, left, mid);
        mergeSort(arr, temp, mid + 1, right);
        merge(arr, temp, left, mid, right);
    }
    
    private void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
    }
    
    // Test
    public static void main(String[] args) {
        OptimizedMergeSort oms = new OptimizedMergeSort();
        
        int[] arr = new int[100];
        new Random().ints(100, 0, 1000).toArray();
        for (int i = 0; i < 100; i++) arr[i] = new Random().nextInt(1000);
        
        oms.mergeSort(arr);
        System.out.println("Sorted " + arr.length + " elements");
    }
}
```

**Advantage**: ~10-15% faster for typical data

---

### Optimization 2: Skip Merge if Already Sorted

```java
public class MergeSortSkipMerge {
    public void mergeSort(int[] arr) {
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, temp, left, mid);
        mergeSort(arr, temp, mid + 1, right);
        
        // Skip merge if already sorted
        if (arr[mid] <= arr[mid + 1]) {
            return; // Already in order
        }
        
        merge(arr, temp, left, mid, right);
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
    }
}
```

**Advantage**: O(n) for already sorted arrays

---

### Optimization 3: Natural Merge Sort

```java
public class NaturalMergeSort {
    /**
     * Takes advantage of existing runs (sorted sequences)
     */
    public void naturalMergeSort(int[] arr) {
        int n = arr.length;
        int[] temp = new int[n];
        
        while (true) {
            int numRuns = 0;
            int i = 0;
            
            while (i < n) {
                numRuns++;
                
                // Find end of first run
                int start = i;
                while (i + 1 < n && arr[i] <= arr[i + 1]) {
                    i++;
                }
                int mid = i;
                i++;
                
                if (i >= n) break;
                
                // Find end of second run
                while (i + 1 < n && arr[i] <= arr[i + 1]) {
                    i++;
                }
                int end = i;
                
                // Merge two runs
                merge(arr, temp, start, mid, end);
                i++;
            }
            
            if (numRuns <= 1) break;
        }
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
    }
}
```

**Advantage**: O(n) for already sorted, adapts to existing order

---

## Variations

### Bottom-Up Merge Sort (Iterative)

```java
public class BottomUpMergeSort {
    /**
     * Iterative merge sort - no recursion
     */
    public void mergeSort(int[] arr) {
        int n = arr.length;
        int[] temp = new int[n];
        
        // Start with subarrays of size 1, double each iteration
        for (int size = 1; size < n; size *= 2) {
            // Merge adjacent subarrays
            for (int left = 0; left < n - size; left += 2 * size) {
                int mid = left + size - 1;
                int right = Math.min(left + 2 * size - 1, n - 1);
                
                merge(arr, temp, left, mid, right);
            }
        }
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
    }
    
    // Test
    public static void main(String[] args) {
        BottomUpMergeSort bums = new BottomUpMergeSort();
        
        int[] arr = {38, 27, 43, 3, 9, 82, 10};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bums.mergeSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantage**: No recursion overhead, better for some systems  
**Complexity**: Same O(n log n) time, O(n) space

---

### In-Place Merge Sort (Complex)

```java
public class InPlaceMergeSort {
    /**
     * Attempts in-place merge - still O(n²) worst case for merge
     * Not truly O(1) space in practice
     */
    public void mergeSort(int[] arr, int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        mergeInPlace(arr, left, mid, right);
    }
    
    private void mergeInPlace(int[] arr, int left, int mid, int right) {
        int start2 = mid + 1;
        
        // If already sorted
        if (arr[mid] <= arr[start2]) {
            return;
        }
        
        while (left <= mid && start2 <= right) {
            if (arr[left] <= arr[start2]) {
                left++;
            } else {
                int value = arr[start2];
                int index = start2;
                
                // Shift all elements between left and start2
                while (index != left) {
                    arr[index] = arr[index - 1];
                    index--;
                }
                arr[left] = value;
                
                left++;
                mid++;
                start2++;
            }
        }
    }
}
```

**Note**: While O(1) extra space, merge is O(n²), making total O(n² log n) - worse than standard!

---

### Three-Way Merge Sort

```java
public class ThreeWayMergeSort {
    /**
     * Divide into 3 parts instead of 2
     */
    public void mergeSort(int[] arr) {
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left >= right) return;
        
        // Divide into 3 parts
        int mid1 = left + (right - left) / 3;
        int mid2 = left + 2 * (right - left) / 3;
        
        mergeSort(arr, temp, left, mid1);
        mergeSort(arr, temp, mid1 + 1, mid2);
        mergeSort(arr, temp, mid2 + 1, right);
        
        merge3(arr, temp, left, mid1, mid2, right);
    }
    
    private void merge3(int[] arr, int[] temp, int left, int mid1, 
                       int mid2, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid1 + 1, k = mid2 + 1, m = left;
        
        // Merge 3 arrays
        while (i <= mid1 && j <= mid2 && k <= right) {
            if (temp[i] <= temp[j] && temp[i] <= temp[k]) {
                arr[m++] = temp[i++];
            } else if (temp[j] <= temp[k]) {
                arr[m++] = temp[j++];
            } else {
                arr[m++] = temp[k++];
            }
        }
        
        // Merge remaining pairs
        while (i <= mid1 && j <= mid2) {
            arr[m++] = (temp[i] <= temp[j]) ? temp[i++] : temp[j++];
        }
        while (j <= mid2 && k <= right) {
            arr[m++] = (temp[j] <= temp[k]) ? temp[j++] : temp[k++];
        }
        while (i <= mid1 && k <= right) {
            arr[m++] = (temp[i] <= temp[k]) ? temp[i++] : temp[k++];
        }
        
        // Copy remaining
        while (i <= mid1) arr[m++] = temp[i++];
        while (j <= mid2) arr[m++] = temp[j++];
        while (k <= right) arr[m++] = temp[k++];
    }
}
```

**Note**: Theoretically interesting but not practically better

---

## Applications

### Application 1: Sort Linked List (LeetCode 148)

```java
public class MergeSortLinkedList {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }
    
    /**
     * Merge sort for linked list - O(1) extra space!
     */
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        
        // Find middle using slow/fast pointers
        ListNode slow = head, fast = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        
        // Split into two halves
        prev.next = null;
        
        // Recursively sort both halves
        ListNode left = sortList(head);
        ListNode right = sortList(slow);
        
        // Merge sorted halves
        return merge(left, right);
    }
    
    private ListNode merge(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                curr.next = l1;
                l1 = l1.next;
            } else {
                curr.next = l2;
                l2 = l2.next;
            }
            curr = curr.next;
        }
        
        curr.next = (l1 != null) ? l1 : l2;
        
        return dummy.next;
    }
}
```

**Advantage**: O(1) space for linked lists (vs O(n) for arrays)  
**Complexity**: O(n log n) time, O(log n) space (recursion only)

---

### Application 2: Count Inversions

```java
public class CountInversions {
    /**
     * Count inversions while sorting
     * Inversion: i < j but arr[i] > arr[j]
     */
    public int countInversions(int[] arr) {
        int[] temp = new int[arr.length];
        return mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private int mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left >= right) return 0;
        
        int mid = left + (right - left) / 2;
        
        int inversions = 0;
        inversions += mergeSort(arr, temp, left, mid);
        inversions += mergeSort(arr, temp, mid + 1, right);
        inversions += merge(arr, temp, left, mid, right);
        
        return inversions;
    }
    
    private int merge(int[] arr, int[] temp, int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        int inversions = 0;
        
        while (i <= mid && j <= right) {
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
                // All remaining elements in left are inversions
                inversions += (mid - i + 1);
            }
        }
        
        while (i <= mid) arr[k++] = temp[i++];
        
        return inversions;
    }
    
    // Test
    public static void main(String[] args) {
        CountInversions ci = new CountInversions();
        
        int[] arr = {8, 4, 2, 1};
        int count = ci.countInversions(arr);
        
        System.out.println("Inversions: " + count); // 6
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Use case**: Measuring similarity between rankings  
**Complexity**: O(n log n) time

---

### Application 3: External Sorting

```java
public class ExternalMergeSort {
    /**
     * Sort file larger than memory
     * Break into chunks, sort each, then merge
     */
    public void externalSort(String inputFile, String outputFile, 
                            int chunkSize) throws IOException {
        // Phase 1: Create sorted runs
        List<String> runFiles = createSortedRuns(inputFile, chunkSize);
        
        // Phase 2: Merge runs
        mergeRuns(runFiles, outputFile);
        
        // Clean up temporary files
        for (String file : runFiles) {
            new File(file).delete();
        }
    }
    
    private List<String> createSortedRuns(String inputFile, int chunkSize) 
            throws IOException {
        List<String> runFiles = new ArrayList<>();
        
        try (BufferedReader reader = new BufferedReader(
                new FileReader(inputFile))) {
            
            int runNumber = 0;
            List<Integer> chunk = new ArrayList<>();
            String line;
            
            while ((line = reader.readLine()) != null) {
                chunk.add(Integer.parseInt(line));
                
                if (chunk.size() >= chunkSize) {
                    String runFile = "run_" + runNumber++ + ".txt";
                    Collections.sort(chunk);
                    writeRun(chunk, runFile);
                    runFiles.add(runFile);
                    chunk.clear();
                }
            }
            
            // Write last chunk
            if (!chunk.isEmpty()) {
                String runFile = "run_" + runNumber + ".txt";
                Collections.sort(chunk);
                writeRun(chunk, runFile);
                runFiles.add(runFile);
            }
        }
        
        return runFiles;
    }
    
    private void mergeRuns(List<String> runFiles, String outputFile) 
            throws IOException {
        // K-way merge using priority queue
        PriorityQueue<RunIterator> pq = new PriorityQueue<>();
        
        for (String file : runFiles) {
            RunIterator it = new RunIterator(file);
            if (it.hasNext()) {
                pq.offer(it);
            }
        }
        
        try (BufferedWriter writer = new BufferedWriter(
                new FileWriter(outputFile))) {
            
            while (!pq.isEmpty()) {
                RunIterator it = pq.poll();
                writer.write(it.current() + "\n");
                
                if (it.next()) {
                    pq.offer(it);
                }
            }
        }
    }
    
    private void writeRun(List<Integer> data, String file) 
            throws IOException {
        try (BufferedWriter writer = new BufferedWriter(
                new FileWriter(file))) {
            for (int num : data) {
                writer.write(num + "\n");
            }
        }
    }
    
    static class RunIterator implements Comparable<RunIterator> {
        private BufferedReader reader;
        private Integer current;
        
        RunIterator(String file) throws IOException {
            reader = new BufferedReader(new FileReader(file));
            next();
        }
        
        boolean hasNext() {
            return current != null;
        }
        
        Integer current() {
            return current;
        }
        
        boolean next() throws IOException {
            String line = reader.readLine();
            if (line != null) {
                current = Integer.parseInt(line);
                return true;
            } else {
                reader.close();
                current = null;
                return false;
            }
        }
        
        @Override
        public int compareTo(RunIterator other) {
            return this.current.compareTo(other.current);
        }
    }
}
```

**Use case**: Sorting datasets larger than RAM  
**Complexity**: O(n log n) with limited memory

---

## Interview Questions

### Q1: What is the time complexity of merge sort?

**Answer**: **O(n log n)** for all cases - best, average, and worst

**Proof**:
```
Recurrence relation: T(n) = 2T(n/2) + O(n)

- Divide: 2T(n/2) - sort two halves
- Merge: O(n) - merge sorted halves

Using Master Theorem:
T(n) = 2T(n/2) + n
     = O(n log n)

Levels: log₂(n)
Work per level: n
Total: n × log n = O(n log n)
```

**Visualization**:
```
Level 0:               [n]              → n work
Level 1:         [n/2]   [n/2]          → n work
Level 2:      [n/4] [n/4] [n/4] [n/4]   → n work
...
Level log n: [1][1][1]...[1]            → n work

Total levels: log₂(n)
Total work: n log n
```

---

### Q2: Is merge sort stable?

**Answer**: **Yes**, merge sort is **stable**

**Why stable**: During merge, when elements are equal, we take from left array first:
```java
if (temp[i] <= temp[j]) {  // Note: <=
    arr[k++] = temp[i++];
} else {
    arr[k++] = temp[j++];
}
```

**Example**:
```
Input:  [(3,a), (1,b), (3,c), (2,d)]

After merge: [(1,b), (2,d), (3,a), (3,c)]

Notice: (3,a) still before (3,c) ✓
```

**Important**: Must use `<=` not `<` to maintain stability

---

### Q3: What is the space complexity of merge sort?

**Answer**: **O(n)** for arrays, **O(log n)** for linked lists

**For arrays**:
```java
int[] temp = new int[arr.length];  // O(n) auxiliary space
// Plus O(log n) recursion stack
// Total: O(n)
```

**For linked lists**:
```java
// No temp array needed - rearrange pointers
// Only recursion stack: O(log n)
```

**Bottom-up iterative**:
```java
// Still needs O(n) temp array
// But no recursion stack
// Total: O(n)
```

---

### Q4: Why is merge sort better than quicksort in some cases?

**Answer**:

| Scenario | Merge Sort Better | Reason |
|----------|------------------|---------|
| **Worst case guarantee** | ✅ | Always O(n log n), quicksort can be O(n²) |
| **Stability required** | ✅ | Merge is stable, quicksort is not |
| **Linked lists** | ✅ | O(1) space vs O(n) for quicksort |
| **External sorting** | ✅ | Sequential access, good for tape/disk |
| **Parallel processing** | ✅ | Easy to parallelize |

**Quicksort better when**:
- Cache performance important (better locality)
- In-place sorting needed (O(1) space)
- Average case performance (smaller constant factors)
- Random access available

---

### Q5: Can merge sort be done in-place?

**Answer**: **Theoretically yes, practically no**

**Problem**: In-place merge is complex and loses O(n log n) guarantee

**Attempts**:
1. **Rotation-based**: O(n²) merge → total O(n² log n)
2. **Block merge**: Complex, large constants
3. **In-place stable merge**: Research topic, very complex

**Practical verdict**: Use standard O(n) space merge sort or switch to heap sort (truly in-place O(n log n))

**Example why hard**:
```
Merge [1, 5, 9] and [2, 3, 4] in-place

Need to insert 2 between 1 and 5:
[1, 2, 5, 9, 3, 4]
      ↓ shift
[1, 2, 5, 9, 3, 4]
         ↓ shift...

Many shifts → O(n²) per merge!
```

---

### Q6: What is the difference between top-down and bottom-up merge sort?

**Answer**:

**Top-Down (Recursive)**:
```java
// Divide first, then merge
mergeSort(arr, 0, n-1)
  ├─ mergeSort(arr, 0, mid)
  └─ mergeSort(arr, mid+1, n-1)
  └─ merge(...)
```

**Bottom-Up (Iterative)**:
```java
// Start with size 1, double each time
for (size = 1; size < n; size *= 2)
  merge subarrays of size 'size'
```

**Comparison**:

| Feature | Top-Down | Bottom-Up |
|---------|----------|-----------|
| **Style** | Recursive | Iterative |
| **Recursion** | O(log n) stack | No stack |
| **Cache** | Better locality | More jumps |
| **Understanding** | More intuitive | Less intuitive |
| **Implementation** | Easier | Slightly harder |

**Both**: Same O(n log n) time, O(n) space

---

### Q7: When would you use merge sort over quicksort?

**Answer**:

**Use merge sort when**:

1. **Need guaranteed O(n log n)**
```java
// Critical systems, real-time
// Can't risk O(n²) worst case
```

2. **Stability required**
```java
// Sorting objects with multiple keys
// Preserve relative order
```

3. **Sorting linked lists**
```java
// O(1) space vs O(n) for quicksort
```

4. **External sorting**
```java
// Data doesn't fit in memory
// Sequential access pattern
```

5. **Parallel processing**
```java
// Easy to parallelize
// Each half independent
```

**Use quicksort when**:
- Average case performance (faster constant)
- In-place sorting (memory constrained)
- Cache performance critical
- Random access available

---

### Q8: How does merge sort handle duplicates?

**Answer**: **Efficiently and stably**

**Duplicates don't affect** time complexity:
```
Still O(n log n) regardless of duplicates
```

**Stability preserved**:
```java
// Using <= ensures stability
if (temp[i] <= temp[j]) {
    arr[k++] = temp[i++];
}
```

**Example**:
```
[3, 3, 3, 3, 3]

Still divides and merges: O(n log n)
Not optimized for this case

Compare to:
- Three-way quicksort: O(n) for all equal
- Counting sort: O(n) for limited range
```

**Verdict**: Not optimal for many duplicates, but handles them correctly

---

### Q9: Can merge sort be parallelized?

**Answer**: **Yes, very easily**

**Parallel approach**:
```java
public void parallelMergeSort(int[] arr, int left, int right) {
    if (left >= right) return;
    
    int mid = left + (right - left) / 2;
    
    // Sort halves in parallel
    Thread leftThread = new Thread(() -> 
        parallelMergeSort(arr, left, mid));
    Thread rightThread = new Thread(() -> 
        parallelMergeSort(arr, mid + 1, right));
    
    leftThread.start();
    rightThread.start();
    
    leftThread.join();
    rightThread.join();
    
    // Merge sequentially (can also be parallelized)
    merge(arr, left, mid, right);
}
```

**Using Fork/Join**:
```java
class MergeSortTask extends RecursiveAction {
    private int[] arr;
    private int left, right;
    
    protected void compute() {
        if (right - left < THRESHOLD) {
            Arrays.sort(arr, left, right + 1);
            return;
        }
        
        int mid = left + (right - left) / 2;
        
        invokeAll(
            new MergeSortTask(arr, left, mid),
            new MergeSortTask(arr, mid + 1, right)
        );
        
        merge(arr, left, mid, right);
    }
}
```

**Speedup**: Can achieve O(n log n / p) with p processors

---

### Q10: What are the advantages and disadvantages of merge sort?

**Answer**:

**Advantages** ✅:
1. **Guaranteed O(n log n)** - worst case same as average
2. **Stable** - maintains relative order
3. **Predictable** - no worst case degradation
4. **Parallelizable** - natural divide-and-conquer
5. **Good for linked lists** - O(1) extra space
6. **External sorting** - works with sequential access

**Disadvantages** ❌:
1. **O(n) space** - needs auxiliary array
2. **Not adaptive** - doesn't optimize for sorted data
3. **Not in-place** - can't sort with O(1) space
4. **Cache unfriendly** - lots of array copies
5. **Overhead** - slower than quicksort in practice
6. **Slower for small arrays** - recursion overhead

**Best for**:
- Stability required
- Worst-case guarantee needed
- Linked lists
- External/parallel sorting

**Avoid for**:
- Memory constrained
- Small arrays
- Already sorted data

---

## Practice Problems

### Problem 1: Sort Array (LeetCode 912)

**Description**: Sort array using merge sort.

**Solution**: (Already covered in basic implementation)

---

### Problem 2: Reverse Pairs (LeetCode 493)

**Description**: Count reverse pairs where i < j and nums[i] > 2 * nums[j].

**Solution**:
```java
public class ReversePairs {
    public int reversePairs(int[] nums) {
        return mergeSort(nums, 0, nums.length - 1);
    }
    
    private int mergeSort(int[] nums, int left, int right) {
        if (left >= right) return 0;
        
        int mid = left + (right - left) / 2;
        int count = mergeSort(nums, left, mid) + 
                   mergeSort(nums, mid + 1, right);
        
        // Count reverse pairs
        int j = mid + 1;
        for (int i = left; i <= mid; i++) {
            while (j <= right && nums[i] > 2L * nums[j]) {
                j++;
            }
            count += j - (mid + 1);
        }
        
        // Merge
        merge(nums, left, mid, right);
        
        return count;
    }
    
    private void merge(int[] nums, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;
        
        while (i <= mid && j <= right) {
            if (nums[i] <= nums[j]) {
                temp[k++] = nums[i++];
            } else {
                temp[k++] = nums[j++];
            }
        }
        
        while (i <= mid) temp[k++] = nums[i++];
        while (j <= right) temp[k++] = nums[j++];
        
        System.arraycopy(temp, 0, nums, left, temp.length);
    }
}
```

---

### Problem 3: Count of Smaller Numbers After Self (LeetCode 315)

**Solution**:
```java
public class CountSmaller {
    private static class Item {
        int val, index;
        Item(int val, int index) {
            this.val = val;
            this.index = index;
        }
    }
    
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        int[] counts = new int[n];
        Item[] items = new Item[n];
        
        for (int i = 0; i < n; i++) {
            items[i] = new Item(nums[i], i);
        }
        
        mergeSort(items, new Item[n], counts, 0, n - 1);
        
        return Arrays.stream(counts).boxed()
                     .collect(Collectors.toList());
    }
    
    private void mergeSort(Item[] items, Item[] temp, int[] counts,
                          int left, int right) {
        if (left >= right) return;
        
        int mid = left + (right - left) / 2;
        
        mergeSort(items, temp, counts, left, mid);
        mergeSort(items, temp, counts, mid + 1, right);
        merge(items, temp, counts, left, mid, right);
    }
    
    private void merge(Item[] items, Item[] temp, int[] counts,
                      int left, int mid, int right) {
        for (int i = left; i <= right; i++) {
            temp[i] = items[i];
        }
        
        int i = left, j = mid + 1, k = left;
        int rightCount = 0;
        
        while (i <= mid && j <= right) {
            if (temp[j].val < temp[i].val) {
                items[k++] = temp[j++];
                rightCount++;
            } else {
                items[k++] = temp[i];
                counts[temp[i].index] += rightCount;
                i++;
            }
        }
        
        while (i <= mid) {
            items[k++] = temp[i];
            counts[temp[i].index] += rightCount;
            i++;
        }
        
        while (j <= right) {
            items[k++] = temp[j++];
        }
    }
}
```

---

## Summary

### Key Takeaways

1. **Divide-and-conquer** - classic example of recursive algorithm
2. **O(n log n) guaranteed** - all cases, no degradation
3. **Stable** - maintains relative order
4. **O(n) space** - requires auxiliary array (arrays)
5. **Best for linked lists** - O(1) space for linked structures

### Complexity Summary

| Case | Time | Space (Array) | Space (Linked List) |
|------|------|---------------|---------------------|
| Best | O(n log n) | O(n) | O(log n) |
| Average | O(n log n) | O(n) | O(log n) |
| Worst | O(n log n) | O(n) | O(log n) |

### Comparison with Other O(n log n) Sorts

| Sort | Worst Time | Space | Stable | In-place |
|------|-----------|-------|--------|----------|
| Merge | O(n log n) | O(n) | Yes | No |
| Quick | O(n²) | O(log n) | No | Yes |
| Heap | O(n log n) | O(1) | No | Yes |

### When to Use

| Scenario | Use Merge Sort? |
|----------|----------------|
| Need stability | ✅ Yes |
| Guaranteed O(n log n) | ✅ Yes |
| Linked lists | ✅ Yes |
| External sorting | ✅ Yes |
| Memory limited | ❌ No (use heapsort) |
| Small arrays | ❌ No (use insertion) |
| Average performance | ❌ No (use quicksort) |

### Interview Tips

1. **Know recurrence**: T(n) = 2T(n/2) + O(n) = O(n log n)
2. **Explain stability**: Use `<=` in comparison
3. **Discuss space**: O(n) for arrays, O(log n) for lists
4. **Compare to quicksort**: Stable vs in-place trade-off
5. **Applications**: Counting inversions, external sorting, linked lists

---

**Next**: [6.5 Quick Sort](6.5-Quick-Sort.md) - Learn about quicksort algorithm
