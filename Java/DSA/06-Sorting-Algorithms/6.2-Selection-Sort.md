# 6.2 Selection Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Optimizations](#optimizations)
4. [Variations](#variations)
5. [Applications](#applications)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is Selection Sort?

**Selection sort** is a simple comparison-based sorting algorithm that:
- Divides array into sorted and unsorted portions
- Repeatedly finds the **minimum** element from unsorted portion
- Swaps it with the first unsorted element
- Expands sorted portion by one element

### Visual Example

```
Initial: [64, 25, 12, 22, 11]
         ↑ unsorted portion

Pass 1: Find min (11), swap with first
[11, 25, 12, 22, 64]
 ✓   ↑ unsorted portion

Pass 2: Find min (12), swap with first unsorted
[11, 12, 25, 22, 64]
 ✓   ✓   ↑ unsorted portion

Pass 3: Find min (22), swap with first unsorted
[11, 12, 22, 25, 64]
 ✓   ✓   ✓   ↑ unsorted portion

Pass 4: Find min (25), no swap needed
[11, 12, 22, 25, 64]
 ✓   ✓   ✓   ✓   ✓ sorted!
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n²)
  - Average: O(n²)
  - Worst: O(n²)
- **Space Complexity**: O(1) - in-place
- **Stability**: **Unstable** (can be made stable with modifications)
- **Swaps**: Exactly O(n) - **minimum** among comparison sorts
- **Adaptive**: No - always performs same comparisons

### When to Use

**Use Selection Sort**:
- ✅ When **minimizing swaps** is critical (swaps are expensive)
- ✅ Small datasets (n < 20)
- ✅ Memory writes are costly
- ✅ Simple implementation needed

**Avoid Selection Sort**:
- ❌ Large datasets (use quicksort, mergesort)
- ❌ When stability is required
- ❌ Nearly sorted data (insertion sort better)
- ❌ Performance-critical code

---

## Basic Implementation

### Standard Selection Sort

```java
public class SelectionSort {
    /**
     * Basic selection sort - O(n²) always
     */
    public void selectionSort(int[] arr) {
        int n = arr.length;
        
        // Expand sorted portion one element at a time
        for (int i = 0; i < n - 1; i++) {
            // Find minimum in unsorted portion
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            // Swap minimum with first unsorted element
            if (minIdx != i) {
                swap(arr, i, minIdx);
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        SelectionSort ss = new SelectionSort();
        
        int[] arr = {64, 25, 12, 22, 11};
        System.out.println("Original: " + Arrays.toString(arr));
        
        ss.selectionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [64, 25, 12, 22, 11]
Sorted: [11, 12, 22, 25, 64]
```

**Complexity**: O(n²) time, O(1) space, O(n) swaps

---

### With Detailed Steps

```java
public class SelectionSortVerbose {
    public void selectionSort(int[] arr) {
        int n = arr.length;
        int swapCount = 0;
        
        for (int i = 0; i < n - 1; i++) {
            System.out.println("\nPass " + (i + 1) + ":");
            System.out.println("  Current: " + Arrays.toString(arr));
            
            int minIdx = i;
            
            // Find minimum
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            // Swap if needed
            if (minIdx != i) {
                System.out.println("  Swap: arr[" + i + "]=" + arr[i] + 
                                 " with arr[" + minIdx + "]=" + arr[minIdx]);
                swap(arr, i, minIdx);
                swapCount++;
            } else {
                System.out.println("  No swap needed");
            }
            
            System.out.println("  Result: " + Arrays.toString(arr));
        }
        
        System.out.println("\nTotal swaps: " + swapCount);
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        SelectionSortVerbose ssv = new SelectionSortVerbose();
        
        int[] arr = {64, 25, 12, 22, 11};
        ssv.selectionSort(arr);
    }
}
```

---

## Optimizations

### Bidirectional Selection Sort

```java
public class BidirectionalSelectionSort {
    /**
     * Find both min and max in each pass
     * Reduces passes by half
     */
    public void bidirectionalSelectionSort(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int minIdx = left;
            int maxIdx = right;
            
            // Find both min and max in single pass
            for (int i = left; i <= right; i++) {
                if (arr[i] < arr[minIdx]) {
                    minIdx = i;
                }
                if (arr[i] > arr[maxIdx]) {
                    maxIdx = i;
                }
            }
            
            // Handle edge case: if max is at left position
            if (maxIdx == left) {
                maxIdx = minIdx;
            }
            
            // Place min at left
            swap(arr, left, minIdx);
            
            // Place max at right
            swap(arr, right, maxIdx);
            
            left++;
            right--;
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BidirectionalSelectionSort bss = new BidirectionalSelectionSort();
        
        int[] arr = {64, 25, 12, 22, 11, 90, 45};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bss.bidirectionalSelectionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantage**: Reduces passes from n-1 to n/2  
**Complexity**: Still O(n²) time, but ~50% fewer passes

---

### Stable Selection Sort

```java
public class StableSelectionSort {
    /**
     * Stable version using shifting instead of swapping
     */
    public void stableSelectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            // Find minimum in unsorted portion
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            // Shift elements to make room (instead of swap)
            int key = arr[minIdx];
            while (minIdx > i) {
                arr[minIdx] = arr[minIdx - 1];
                minIdx--;
            }
            arr[i] = key;
        }
    }
    
    // Test with objects to show stability
    static class Person {
        String name;
        int age;
        
        Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public void sortByAge(Person[] people) {
        int n = people.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (people[j].age < people[minIdx].age) {
                    minIdx = j;
                }
            }
            
            // Stable shift
            Person key = people[minIdx];
            while (minIdx > i) {
                people[minIdx] = people[minIdx - 1];
                minIdx--;
            }
            people[i] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        StableSelectionSort sss = new StableSelectionSort();
        
        Person[] people = {
            new Person("Alice", 25),
            new Person("Bob", 20),
            new Person("Charlie", 20)
        };
        
        System.out.println("Before: " + Arrays.toString(people));
        sss.sortByAge(people);
        System.out.println("After: " + Arrays.toString(people));
        // Bob and Charlie maintain their relative order
    }
}
```

**Note**: Stable version has O(n²) shifts instead of O(n) swaps

---

## Variations

### Descending Order

```java
public class SelectionSortDescending {
    /**
     * Sort in descending order
     */
    public void selectionSortDesc(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            // Find maximum instead of minimum
            int maxIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] > arr[maxIdx]) {
                    maxIdx = j;
                }
            }
            
            if (maxIdx != i) {
                swap(arr, i, maxIdx);
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        SelectionSortDescending ssd = new SelectionSortDescending();
        
        int[] arr = {64, 25, 12, 22, 11};
        ssd.selectionSortDesc(arr);
        System.out.println("Descending: " + Arrays.toString(arr));
        // [64, 25, 22, 12, 11]
    }
}
```

---

### Generic Selection Sort

```java
public class GenericSelectionSort {
    /**
     * Generic selection sort for any Comparable type
     */
    public <T extends Comparable<T>> void selectionSort(T[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j].compareTo(arr[minIdx]) < 0) {
                    minIdx = j;
                }
            }
            
            if (minIdx != i) {
                swap(arr, i, minIdx);
            }
        }
    }
    
    private <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        GenericSelectionSort gss = new GenericSelectionSort();
        
        String[] strings = {"banana", "apple", "cherry", "date"};
        gss.selectionSort(strings);
        System.out.println("Strings: " + Arrays.toString(strings));
        
        Double[] numbers = {3.14, 1.41, 2.71, 0.99};
        gss.selectionSort(numbers);
        System.out.println("Numbers: " + Arrays.toString(numbers));
    }
}
```

---

### Custom Comparator

```java
public class SelectionSortComparator {
    /**
     * Selection sort with custom comparator
     */
    public <T> void selectionSort(T[] arr, Comparator<T> comp) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (comp.compare(arr[j], arr[minIdx]) < 0) {
                    minIdx = j;
                }
            }
            
            if (minIdx != i) {
                swap(arr, i, minIdx);
            }
        }
    }
    
    private <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        SelectionSortComparator ssc = new SelectionSortComparator();
        
        String[] words = {"apple", "pie", "a", "cat", "zoo"};
        
        // Sort by length
        ssc.selectionSort(words, Comparator.comparingInt(String::length));
        System.out.println("By length: " + Arrays.toString(words));
        // [a, cat, pie, zoo, apple]
        
        // Sort by last character
        ssc.selectionSort(words, 
            Comparator.comparing(s -> s.charAt(s.length() - 1)));
        System.out.println("By last char: " + Arrays.toString(words));
    }
}
```

---

## Applications

### Application 1: Find K Smallest Elements

```java
public class FindKSmallest {
    /**
     * Find k smallest elements using partial selection sort
     * Only need k passes
     */
    public int[] findKSmallest(int[] arr, int k) {
        int n = arr.length;
        k = Math.min(k, n);
        
        // Only k passes needed
        for (int i = 0; i < k; i++) {
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            if (minIdx != i) {
                swap(arr, i, minIdx);
            }
        }
        
        // Return first k elements
        return Arrays.copyOfRange(arr, 0, k);
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        FindKSmallest fks = new FindKSmallest();
        
        int[] arr = {7, 10, 4, 3, 20, 15};
        int[] result = fks.findKSmallest(arr, 3);
        
        System.out.println("3 smallest: " + Arrays.toString(result));
        // [3, 4, 7]
    }
}
```

**Complexity**: O(n × k) - better than full sort when k << n

---

### Application 2: Count Minimum Swaps

```java
public class MinimumSwapsToSort {
    /**
     * Count minimum swaps needed to sort array
     * Selection sort gives minimum swaps
     */
    public int countMinSwaps(int[] arr) {
        int n = arr.length;
        int swapCount = 0;
        
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            if (minIdx != i) {
                swap(arr, i, minIdx);
                swapCount++;
            }
        }
        
        return swapCount;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        MinimumSwapsToSort msts = new MinimumSwapsToSort();
        
        int[] arr = {5, 4, 3, 2, 1};
        int swaps = msts.countMinSwaps(arr);
        
        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println("Minimum swaps: " + swaps); // 2
        
        // Compare with bubble sort: would need 10 swaps
    }
}
```

---

### Application 3: Sort by Frequency

```java
public class SortByFrequency {
    static class Element {
        int value;
        int frequency;
        
        Element(int value, int frequency) {
            this.value = value;
            this.frequency = frequency;
        }
    }
    
    /**
     * Sort array by frequency using selection sort
     */
    public void sortByFrequency(int[] arr) {
        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : arr) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        
        // Create element array
        Element[] elements = new Element[arr.length];
        for (int i = 0; i < arr.length; i++) {
            elements[i] = new Element(arr[i], freqMap.get(arr[i]));
        }
        
        // Selection sort by frequency
        for (int i = 0; i < elements.length - 1; i++) {
            int maxIdx = i;
            
            for (int j = i + 1; j < elements.length; j++) {
                if (elements[j].frequency > elements[maxIdx].frequency) {
                    maxIdx = j;
                }
            }
            
            if (maxIdx != i) {
                Element temp = elements[i];
                elements[i] = elements[maxIdx];
                elements[maxIdx] = temp;
            }
        }
        
        // Copy back
        for (int i = 0; i < arr.length; i++) {
            arr[i] = elements[i].value;
        }
    }
    
    // Test
    public static void main(String[] args) {
        SortByFrequency sbf = new SortByFrequency();
        
        int[] arr = {2, 5, 2, 8, 5, 6, 8, 8};
        sbf.sortByFrequency(arr);
        System.out.println("Sorted by frequency: " + Arrays.toString(arr));
        // [8, 8, 8, 2, 2, 5, 5, 6]
    }
}
```

---

## Interview Questions

### Q1: What is the time complexity of selection sort?

**Answer**:

**All cases: O(n²)** - best, average, and worst

**Detailed analysis**:
```
Comparisons:
Pass 1: n - 1 comparisons
Pass 2: n - 2 comparisons
...
Pass n-1: 1 comparison

Total = (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
```

**Key point**: Unlike bubble sort, selection sort **cannot detect** if array is already sorted, so it's always O(n²).

**Swaps**: O(n) - at most one swap per pass

---

### Q2: Is selection sort stable?

**Answer**: **No**, standard selection sort is **unstable**.

**Example showing instability**:
```java
Input:  [4a, 3, 4b, 2]  (subscripts show original order)

Pass 1: Find min (2), swap with 4a
        [2, 3, 4b, 4a]  ← 4a and 4b swapped order!

Result: Relative order of equal elements changed
```

**Making it stable**:
```java
// Use shifting instead of swapping
int key = arr[minIdx];
while (minIdx > i) {
    arr[minIdx] = arr[minIdx - 1];
    minIdx--;
}
arr[i] = key;
```

**Cost**: O(n²) shifts instead of O(n) swaps

---

### Q3: Why is selection sort better than bubble sort?

**Answer**:

**Selection sort advantages**:

1. **Fewer swaps**: O(n) vs O(n²) for bubble sort
```
Selection: At most n swaps
Bubble: Up to n²/2 swaps
```

2. **Predictable**: Always same number of comparisons
```
Selection: Always (n-1)(n)/2 comparisons
Bubble: Can vary based on data
```

3. **Better when swaps are expensive**: Disk writes, large objects

**Bubble sort advantages**:

1. **Stable**: Maintains relative order
2. **Adaptive**: O(n) when sorted (with optimization)
3. **Early exit**: Can stop if sorted

**Verdict**: Selection sort better for **minimizing writes**, bubble sort better for **nearly sorted** data.

---

### Q4: When should you use selection sort?

**Answer**:

**Use selection sort when**:

1. **Swaps are expensive**
```java
// Example: Writing to slow storage
// Selection: n writes
// Bubble/Insertion: Up to n² writes
```

2. **Small datasets**: n < 20
```java
// Simple implementation, acceptable performance
```

3. **Memory constraints**: Need in-place sort
```java
// O(1) extra space
```

4. **Finding k smallest**: Partial sort
```java
// Only k passes needed for k smallest
// O(n × k) instead of O(n log n)
```

**Don't use when**:

1. **Stability required**: Use insertion sort instead
2. **Large data**: Use quicksort, mergesort, heapsort
3. **Nearly sorted**: Insertion sort is O(n)
4. **Production code**: Use built-in sorts

---

### Q5: How many swaps does selection sort perform?

**Answer**: **At most n - 1 swaps** (one per pass)

**Best case**: 0 swaps (already sorted)  
**Worst case**: n - 1 swaps (every element wrong)  
**Average case**: ~n/2 swaps

**Comparison**:
```
Selection Sort: O(n) swaps
Bubble Sort: O(n²) swaps
Insertion Sort: O(n²) swaps
```

**This is the MINIMUM** possible for comparison-based sorts!

**Example**:
```java
[5, 4, 3, 2, 1]  → Worst case

Pass 1: Swap 5 and 1  → [1, 4, 3, 2, 5]
Pass 2: Swap 4 and 2  → [1, 2, 3, 4, 5]
Pass 3: No swap       → [1, 2, 3, 4, 5]
Pass 4: No swap       → [1, 2, 3, 4, 5]

Total: 2 swaps (not 4!)
```

---

### Q6: Can selection sort be adaptive?

**Answer**: **No**, standard selection sort is **not adaptive**.

**Adaptive** means performing better on partially sorted data.

**Why not adaptive**:
```java
// Always performs same comparisons
for (int i = 0; i < n - 1; i++) {
    for (int j = i + 1; j < n; j++) {
        // Always n(n-1)/2 comparisons
    }
}

// No early exit possible
```

**Comparison**:
```
Sorted array [1, 2, 3, 4, 5]:

Selection Sort: n² comparisons
Bubble Sort (optimized): n comparisons
Insertion Sort: n comparisons
```

**Verdict**: Use **insertion sort** for nearly sorted data.

---

### Q7: What's the difference between selection sort and insertion sort?

**Answer**:

| Feature | Selection Sort | Insertion Sort |
|---------|----------------|----------------|
| **Method** | Find min, swap to position | Insert element in sorted portion |
| **Swaps** | O(n) - minimum | O(n²) - many |
| **Comparisons** | O(n²) always | O(n²) worst, O(n) best |
| **Stable** | No | Yes |
| **Adaptive** | No | Yes |
| **Best case** | O(n²) | O(n) |
| **Use when** | Minimize swaps | Nearly sorted data |

**Example**:
```
Array: [5, 2, 4, 6, 1, 3]

Selection: Find 1, swap with 5 → [1, 2, 4, 6, 5, 3]
Insertion: Take 2, insert before 5 → [2, 5, 4, 6, 1, 3]
```

**Verdict**: Insertion sort generally better in practice.

---

### Q8: Can selection sort be implemented recursively?

**Answer**: **Yes**

```java
public void selectionSortRecursive(int[] arr, int start) {
    // Base case
    if (start >= arr.length - 1) return;
    
    // Find minimum in arr[start...n-1]
    int minIdx = start;
    for (int i = start + 1; i < arr.length; i++) {
        if (arr[i] < arr[minIdx]) {
            minIdx = i;
        }
    }
    
    // Swap
    if (minIdx != start) {
        swap(arr, start, minIdx);
    }
    
    // Recurse for remaining array
    selectionSortRecursive(arr, start + 1);
}
```

**Complexity**: 
- Time: O(n²) same as iterative
- Space: O(n) for recursion stack (worse than iterative O(1))

**Verdict**: Iterative version is better.

---

### Q9: How does selection sort compare to heap sort?

**Answer**:

**Similarity**: Both find minimum/maximum repeatedly

**Differences**:

| Feature | Selection Sort | Heap Sort |
|---------|----------------|-----------|
| **Data structure** | Array | Heap |
| **Find min** | Linear scan O(n) | Extract from heap O(log n) |
| **Time** | O(n²) | O(n log n) |
| **Space** | O(1) | O(1) |
| **Stable** | No | No |

**Think of heap sort** as optimized selection sort using heap instead of linear search.

**Example**:
```
Selection: [5,3,8,1,2]
  - Scan all for min (1): O(n)
  - Scan remaining for min (2): O(n-1)
  Total: O(n²)

Heap: [5,3,8,1,2]
  - Build heap: O(n)
  - Extract min n times: O(n log n)
  Total: O(n log n)
```

---

### Q10: Why is selection sort not used in practice?

**Answer**:

**Reasons to avoid**:

1. **Always O(n²)** - no best case improvement
```
Even sorted array takes O(n²) time
```

2. **Not adaptive** - can't detect sorted data
```
Can't exit early like bubble/insertion
```

3. **Not stable** - loses relative order
```
Requires modification to make stable
```

4. **Better alternatives exist**:
```
Small data: Insertion sort (faster, stable, adaptive)
Large data: Quicksort, mergesort, heapsort
Finding k smallest: Quickselect O(n) average
```

**Only advantage**: Minimum swaps
```
Use when: Swaps extremely expensive (disk writes)
Otherwise: Use better algorithm
```

**Real usage**: 
- Educational purposes
- Embedded systems with expensive writes
- Very small datasets where simplicity matters

---

## Practice Problems

### Problem 1: Selection Sort on Linked List

**Solution**:
```java
public class SelectionSortLinkedList {
    static class Node {
        int data;
        Node next;
        Node(int data) { this.data = data; }
    }
    
    public Node selectionSort(Node head) {
        if (head == null || head.next == null) return head;
        
        Node current = head;
        
        while (current != null) {
            Node min = current;
            Node r = current.next;
            
            // Find minimum in remaining list
            while (r != null) {
                if (r.data < min.data) {
                    min = r;
                }
                r = r.next;
            }
            
            // Swap data
            int temp = current.data;
            current.data = min.data;
            min.data = temp;
            
            current = current.next;
        }
        
        return head;
    }
}
```

---

### Problem 2: Pancake Sorting (LeetCode 969)

**Description**: Sort using only flip operations (like flipping pancakes).

**Solution**:
```java
public class PancakeSort {
    public List<Integer> pancakeSort(int[] arr) {
        List<Integer> result = new ArrayList<>();
        int n = arr.length;
        
        for (int size = n; size > 1; size--) {
            // Find index of maximum in arr[0...size-1]
            int maxIdx = findMax(arr, size);
            
            if (maxIdx != size - 1) {
                // Flip max to front
                if (maxIdx != 0) {
                    flip(arr, maxIdx);
                    result.add(maxIdx + 1);
                }
                
                // Flip to correct position
                flip(arr, size - 1);
                result.add(size);
            }
        }
        
        return result;
    }
    
    private int findMax(int[] arr, int size) {
        int maxIdx = 0;
        for (int i = 1; i < size; i++) {
            if (arr[i] > arr[maxIdx]) {
                maxIdx = i;
            }
        }
        return maxIdx;
    }
    
    private void flip(int[] arr, int k) {
        int left = 0, right = k;
        while (left < right) {
            int temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
```

**Pattern**: Similar to selection sort - find max, move to position

---

### Problem 3: Wiggle Sort (LeetCode 280)

**Solution**:
```java
public class WiggleSort {
    /**
     * Arrange arr[0] <= arr[1] >= arr[2] <= arr[3]...
     * Can use selection sort approach
     */
    public void wiggleSort(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            if (i % 2 == 0) {
                // Even index: should be <= next
                if (nums[i] > nums[i + 1]) {
                    swap(nums, i, i + 1);
                }
            } else {
                // Odd index: should be >= next
                if (nums[i] < nums[i + 1]) {
                    swap(nums, i, i + 1);
                }
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## Summary

### Key Takeaways

1. **Minimum swaps** - O(n) swaps, best among comparison sorts
2. **Always O(n²)** - no best case improvement
3. **Unstable** - doesn't preserve relative order
4. **Not adaptive** - always same comparisons
5. **In-place** - O(1) extra space

### Complexity Summary

| Case | Time | Swaps | Space |
|------|------|-------|-------|
| Best | O(n²) | 0 | O(1) |
| Average | O(n²) | ~n/2 | O(1) |
| Worst | O(n²) | n-1 | O(1) |

### Comparison with Other Sorts

| Sort | Time (Avg) | Swaps | Stable | Adaptive |
|------|-----------|-------|--------|----------|
| Selection | O(n²) | O(n) | No | No |
| Bubble | O(n²) | O(n²) | Yes | Yes* |
| Insertion | O(n²) | O(n²) | Yes | Yes |
| Quick | O(n log n) | Varies | No | No |

*with optimization

### When to Use

| Scenario | Use Selection Sort? |
|----------|-------------------|
| Minimize swaps | ✅ Best choice |
| Small data (n < 20) | ✅ Acceptable |
| Nearly sorted | ❌ Use insertion |
| Large data | ❌ Use quicksort |
| Need stability | ❌ Use insertion |
| Production code | ❌ Use built-in |

### Interview Tips

1. **Know swaps**: O(n) - minimum possible
2. **Know stability**: Unstable (can be made stable with shifts)
3. **Compare to insertion**: Fewer swaps, but not adaptive
4. **Use case**: When swaps are expensive
5. **Not practical**: Rarely used in production

---

**Next**: [6.3 Insertion Sort](6.3-Insertion-Sort.md) - Learn about insertion sort algorithm
