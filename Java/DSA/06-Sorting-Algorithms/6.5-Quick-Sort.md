# 6.5 Quick Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Partitioning Schemes](#partitioning-schemes)
4. [Optimizations](#optimizations)
5. [Variations](#variations)
6. [Applications](#applications)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is Quick Sort?

**Quick sort** is a highly efficient divide-and-conquer sorting algorithm that:
- **Selects** a pivot element from the array
- **Partitions** the array around the pivot (smaller left, larger right)
- **Recursively sorts** the subarrays on both sides of the pivot

### Visual Example

```
Original: [10, 7, 8, 9, 1, 5]
          (choose pivot = 5)

Partition around pivot 5:
[1, 5, 8, 9, 10, 7]
 ^  ^
 <5 =5  >5

Recursively sort left: [1]
Already sorted (single element)

Recursively sort right: [8, 9, 10, 7]
                        (choose pivot = 7)

Partition around pivot 7:
[7, 9, 10, 8]
 ^
=7  >7

Recursively sort: [9, 10, 8]
                  (choose pivot = 8)

Partition around pivot 8:
[8, 10, 9]
 ^
=8  >8

Continue...

Final: [1, 5, 7, 8, 9, 10]
```

### Partition Process (Lomuto)

```
arr = [10, 7, 8, 9, 1, 5], pivot = 5 (last element)

i = -1
       ↓
[10, 7, 8, 9, 1, 5]
 j →

Step 1: arr[j]=10 > 5, don't swap, j++
Step 2: arr[j]=7 > 5, don't swap, j++
Step 3: arr[j]=8 > 5, don't swap, j++
Step 4: arr[j]=9 > 5, don't swap, j++
Step 5: arr[j]=1 < 5, i++, swap(arr[i], arr[j])
        i=0, j=4
        [1, 7, 8, 9, 10, 5]
         ↑           ↑
         i           j

Finally: swap(arr[i+1], arr[high]) → swap pivot to correct position
        [1, 5, 8, 9, 10, 7]
            ^
         pivot at index 1
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n log n) - balanced partitions
  - Average: O(n log n)
  - Worst: O(n²) - already sorted, poor pivot choice
- **Space Complexity**: O(log n) - recursion stack (best case)
- **Stability**: **Unstable** - relative order not maintained
- **In-place**: Yes - requires O(1) extra space (excluding recursion)
- **Adaptive**: No - doesn't benefit from sorted data without optimization
- **Divide & Conquer**: Classic example

### When to Use

**Use Quick Sort**:
- ✅ **Average-case performance** critical (fastest in practice)
- ✅ In-place sorting needed (memory constrained)
- ✅ Random/unsorted data
- ✅ Cache-friendly performance important
- ✅ Partitioning problems (kth element, etc.)

**Avoid Quick Sort**:
- ❌ Worst-case O(n²) unacceptable (use merge/heap sort)
- ❌ Stability required (use merge sort)
- ❌ Already sorted data (without randomization)
- ❌ Guaranteed time bounds needed

---

## Basic Implementation

### Lomuto Partition Scheme

```java
public class QuickSort {
    /**
     * Quick sort using Lomuto partition scheme
     * Pivot is always the last element
     */
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Partition and get pivot index
            int pi = partition(arr, low, high);
            
            // Recursively sort left and right subarrays
            quickSort(arr, low, pi - 1);   // Before pivot
            quickSort(arr, pi + 1, high);  // After pivot
        }
    }
    
    /**
     * Lomuto partition scheme
     * Returns the index of pivot after partitioning
     */
    private int partition(int[] arr, int low, int high) {
        // Choose rightmost element as pivot
        int pivot = arr[high];
        
        // Index of smaller element
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            // If current element is smaller than pivot
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        // Place pivot in correct position
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        QuickSort qs = new QuickSort();
        
        int[] arr = {10, 7, 8, 9, 1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        qs.quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [10, 7, 8, 9, 1, 5]
Sorted: [1, 5, 7, 8, 9, 10]
```

**Complexity**: O(n log n) average, O(n²) worst

---

### With Detailed Steps

```java
public class QuickSortVerbose {
    private int depth = 0;
    
    public void quickSort(int[] arr) {
        System.out.println("Starting array: " + Arrays.toString(arr));
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low >= high) return;
        
        depth++;
        String indent = "  ".repeat(depth);
        
        System.out.println(indent + "Sorting: " + 
            Arrays.toString(Arrays.copyOfRange(arr, low, high + 1)) +
            " (indices " + low + "-" + high + ")");
        
        int pi = partitionVerbose(arr, low, high, indent);
        
        System.out.println(indent + "Pivot " + arr[pi] + 
            " placed at index " + pi);
        System.out.println(indent + "Array: " + Arrays.toString(arr));
        
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
        
        depth--;
    }
    
    private int partitionVerbose(int[] arr, int low, int high, String indent) {
        int pivot = arr[high];
        System.out.println(indent + "  Pivot: " + pivot);
        
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
                System.out.println(indent + "  Swap: arr[" + i + "]=" + 
                    arr[i] + " with arr[" + j + "]=" + arr[j]);
            }
        }
        
        swap(arr, i + 1, high);
        System.out.println(indent + "  Place pivot at index " + (i + 1));
        
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        QuickSortVerbose qsv = new QuickSortVerbose();
        int[] arr = {10, 7, 8, 9, 1, 5};
        qsv.quickSort(arr);
    }
}
```

---

## Partitioning Schemes

### Hoare Partition Scheme

```java
public class QuickSortHoare {
    /**
     * Quick sort using Hoare partition scheme
     * More efficient - fewer swaps than Lomuto
     */
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = hoarePartition(arr, low, high);
            
            // Note: pivot is NOT necessarily at pi
            quickSort(arr, low, pi);       // Include pi in left
            quickSort(arr, pi + 1, high);
        }
    }
    
    /**
     * Hoare partition scheme
     * Pivot is the first element
     * Returns partition index (not necessarily pivot position)
     */
    private int hoarePartition(int[] arr, int low, int high) {
        int pivot = arr[low];
        int i = low - 1;
        int j = high + 1;
        
        while (true) {
            // Move i right while arr[i] < pivot
            do {
                i++;
            } while (arr[i] < pivot);
            
            // Move j left while arr[j] > pivot
            do {
                j--;
            } while (arr[j] > pivot);
            
            // If pointers crossed, return j
            if (i >= j) {
                return j;
            }
            
            // Swap arr[i] and arr[j]
            swap(arr, i, j);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        QuickSortHoare qsh = new QuickSortHoare();
        
        int[] arr = {10, 7, 8, 9, 1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        qsh.quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantages of Hoare**:
- Performs 3x fewer swaps on average
- More efficient for equal elements
- Works better with duplicate values

---

### Three-Way Partition (Dutch National Flag)

```java
public class QuickSort3Way {
    /**
     * Three-way quick sort
     * Handles duplicates efficiently
     * Elements equal to pivot are placed in middle partition
     */
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low >= high) return;
        
        // Partition into 3 parts: <pivot, =pivot, >pivot
        int[] pivots = partition3Way(arr, low, high);
        
        // Recursively sort < and > partitions
        quickSort(arr, low, pivots[0] - 1);
        quickSort(arr, pivots[1] + 1, high);
    }
    
    /**
     * Three-way partition
     * Returns [lt, gt] where:
     *   arr[low..lt-1] < pivot
     *   arr[lt..gt] = pivot
     *   arr[gt+1..high] > pivot
     */
    private int[] partition3Way(int[] arr, int low, int high) {
        int pivot = arr[low];
        int lt = low;       // All < pivot are before lt
        int i = low + 1;    // Current element
        int gt = high;      // All > pivot are after gt
        
        while (i <= gt) {
            if (arr[i] < pivot) {
                swap(arr, lt, i);
                lt++;
                i++;
            } else if (arr[i] > pivot) {
                swap(arr, i, gt);
                gt--;
            } else {
                i++;  // arr[i] == pivot
            }
        }
        
        return new int[]{lt, gt};
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test with duplicates
    public static void main(String[] args) {
        QuickSort3Way qs3 = new QuickSort3Way();
        
        int[] arr = {5, 2, 9, 5, 8, 5, 1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        qs3.quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**When to use 3-way partition**:
- ✅ Many duplicate values
- ✅ Limited range of values
- ✅ Can reduce O(n log n) to O(n) for arrays with duplicates

---

## Optimizations

### Optimization 1: Random Pivot Selection

```java
public class QuickSortRandomized {
    private Random random = new Random();
    
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = randomizedPartition(arr, low, high);
            
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    /**
     * Choose random pivot to avoid worst case O(n²)
     * Expected time: O(n log n) even for sorted arrays
     */
    private int randomizedPartition(int[] arr, int low, int high) {
        // Random index between low and high
        int randomIndex = low + random.nextInt(high - low + 1);
        
        // Swap random element with last element
        swap(arr, randomIndex, high);
        
        // Use standard partition
        return partition(arr, low, high);
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Benefits**:
- Eliminates worst-case for sorted arrays
- Expected O(n log n) for all inputs
- Used in practice (Java's Arrays.sort for primitives uses dual-pivot variant)

---

### Optimization 2: Median-of-Three Pivot

```java
public class QuickSortMedianOfThree {
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = medianOfThreePartition(arr, low, high);
            
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    /**
     * Choose median of first, middle, and last elements as pivot
     * Better pivot selection → more balanced partitions
     */
    private int medianOfThreePartition(int[] arr, int low, int high) {
        int mid = low + (high - low) / 2;
        
        // Sort arr[low], arr[mid], arr[high]
        if (arr[low] > arr[mid]) {
            swap(arr, low, mid);
        }
        if (arr[low] > arr[high]) {
            swap(arr, low, high);
        }
        if (arr[mid] > arr[high]) {
            swap(arr, mid, high);
        }
        
        // Now arr[mid] is median, swap with high
        swap(arr, mid, high);
        
        // Use standard partition
        return partition(arr, low, high);
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Benefits**:
- Better pivot choice → more balanced partitions
- Reduces likelihood of worst case
- Only O(1) overhead

---

### Optimization 3: Hybrid with Insertion Sort

```java
public class QuickSortHybrid {
    private static final int INSERTION_THRESHOLD = 10;
    
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        // Use insertion sort for small subarrays
        if (high - low < INSERTION_THRESHOLD) {
            insertionSort(arr, low, high);
            return;
        }
        
        if (low < high) {
            int pi = partition(arr, low, high);
            
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    
    /**
     * Insertion sort for small subarrays
     * Faster than quicksort for n < 10-15
     */
    private void insertionSort(int[] arr, int low, int high) {
        for (int i = low + 1; i <= high; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= low && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Benefits**:
- 10-15% performance improvement
- Reduces recursion overhead
- Used in production implementations

---

### Optimization 4: Tail Call Elimination

```java
public class QuickSortTailRecursion {
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    /**
     * Tail call optimized quick sort
     * Guarantees O(log n) space even in worst case
     */
    private void quickSort(int[] arr, int low, int high) {
        while (low < high) {
            int pi = partition(arr, low, high);
            
            // Recur for smaller partition
            // Iterate for larger partition
            if (pi - low < high - pi) {
                // Left is smaller
                quickSort(arr, low, pi - 1);
                low = pi + 1;  // Tail recursion for right
            } else {
                // Right is smaller
                quickSort(arr, pi + 1, high);
                high = pi - 1; // Tail recursion for left
            }
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Benefits**:
- Guarantees O(log n) stack space
- Prevents stack overflow
- Important for systems programming

---

## Variations

### Dual-Pivot Quick Sort

```java
public class DualPivotQuickSort {
    /**
     * Dual-pivot quick sort
     * Used in Java's Arrays.sort() for primitives
     * Partitions array into 3 segments using 2 pivots
     */
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Choose two pivots
            if (arr[low] > arr[high]) {
                swap(arr, low, high);
            }
            
            int pivot1 = arr[low];
            int pivot2 = arr[high];
            
            int lt = low + 1;  // < pivot1
            int gt = high - 1; // > pivot2
            int i = low + 1;   // current
            
            // Partition into 3 segments:
            // [low+1..lt-1] < pivot1
            // [lt..gt] >= pivot1 && <= pivot2
            // [gt+1..high-1] > pivot2
            
            while (i <= gt) {
                if (arr[i] < pivot1) {
                    swap(arr, i, lt);
                    lt++;
                    i++;
                } else if (arr[i] > pivot2) {
                    swap(arr, i, gt);
                    gt--;
                } else {
                    i++;
                }
            }
            
            // Place pivots
            lt--;
            gt++;
            swap(arr, low, lt);
            swap(arr, high, gt);
            
            // Recursively sort 3 segments
            quickSort(arr, low, lt - 1);
            quickSort(arr, lt + 1, gt - 1);
            quickSort(arr, gt + 1, high);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        DualPivotQuickSort dpqs = new DualPivotQuickSort();
        
        int[] arr = {24, 8, 42, 75, 29, 77, 38, 57};
        System.out.println("Original: " + Arrays.toString(arr));
        
        dpqs.quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Benefits**:
- 5-10% faster than single-pivot
- Used in Java's Arrays.sort()
- Better cache performance

---

### Iterative Quick Sort

```java
public class QuickSortIterative {
    /**
     * Iterative quick sort using explicit stack
     * Avoids recursion overhead
     */
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // Create stack for storing subarray bounds
        int[] stack = new int[arr.length];
        int top = -1;
        
        // Push initial values
        stack[++top] = 0;
        stack[++top] = arr.length - 1;
        
        while (top >= 0) {
            // Pop high and low
            int high = stack[top--];
            int low = stack[top--];
            
            // Partition
            int pi = partition(arr, low, high);
            
            // Push left subarray if elements exist
            if (pi - 1 > low) {
                stack[++top] = low;
                stack[++top] = pi - 1;
            }
            
            // Push right subarray if elements exist
            if (pi + 1 < high) {
                stack[++top] = pi + 1;
                stack[++top] = high;
            }
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        QuickSortIterative qsi = new QuickSortIterative();
        
        int[] arr = {10, 7, 8, 9, 1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        qsi.quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Benefits**:
- No recursion overhead
- Explicit control over stack
- Useful for embedded systems

---

## Applications

### Application 1: Quick Select (Kth Smallest Element)

```java
public class QuickSelect {
    /**
     * Find kth smallest element in unsorted array
     * Average: O(n), Worst: O(n²)
     */
    public int findKthSmallest(int[] arr, int k) {
        if (k < 1 || k > arr.length) {
            throw new IllegalArgumentException("Invalid k");
        }
        
        return quickSelect(arr, 0, arr.length - 1, k - 1);
    }
    
    private int quickSelect(int[] arr, int low, int high, int k) {
        if (low == high) {
            return arr[low];
        }
        
        int pi = partition(arr, low, high);
        
        if (k == pi) {
            return arr[k];  // Found
        } else if (k < pi) {
            return quickSelect(arr, low, pi - 1, k);  // Search left
        } else {
            return quickSelect(arr, pi + 1, high, k); // Search right
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        QuickSelect qs = new QuickSelect();
        
        int[] arr = {7, 10, 4, 3, 20, 15};
        int k = 3;
        
        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println(k + "rd smallest: " + qs.findKthSmallest(arr, k));
    }
}
```

**Output**:
```
Array: [7, 10, 4, 3, 20, 15]
3rd smallest: 7
```

---

### Application 2: Partition Array by Condition

```java
public class PartitionProblems {
    /**
     * Partition array: negatives left, positives right
     * Uses quick sort partitioning concept
     */
    public void partitionNegativePositive(int[] arr) {
        int i = -1;
        
        for (int j = 0; j < arr.length; j++) {
            if (arr[j] < 0) {
                i++;
                swap(arr, i, j);
            }
        }
    }
    
    /**
     * Partition array: even left, odd right
     */
    public void partitionEvenOdd(int[] arr) {
        int i = -1;
        
        for (int j = 0; j < arr.length; j++) {
            if (arr[j] % 2 == 0) {
                i++;
                swap(arr, i, j);
            }
        }
    }
    
    /**
     * Dutch National Flag Problem
     * Partition array with 0s, 1s, 2s
     */
    public void sortColors(int[] nums) {
        int low = 0;    // Boundary of 0s
        int mid = 0;    // Current element
        int high = nums.length - 1;  // Boundary of 2s
        
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low, mid);
                low++;
                mid++;
            } else if (nums[mid] == 2) {
                swap(nums, mid, high);
                high--;
            } else {
                mid++;  // nums[mid] == 1
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        PartitionProblems pp = new PartitionProblems();
        
        // Test 1: Negative/Positive
        int[] arr1 = {-1, 2, -3, 4, 5, -6, 7};
        pp.partitionNegativePositive(arr1);
        System.out.println("Neg/Pos: " + Arrays.toString(arr1));
        
        // Test 2: Even/Odd
        int[] arr2 = {1, 2, 3, 4, 5, 6, 7, 8};
        pp.partitionEvenOdd(arr2);
        System.out.println("Even/Odd: " + Arrays.toString(arr2));
        
        // Test 3: Sort Colors
        int[] arr3 = {2, 0, 2, 1, 1, 0};
        pp.sortColors(arr3);
        System.out.println("Colors: " + Arrays.toString(arr3));
    }
}
```

**Output**:
```
Neg/Pos: [-1, -3, -6, 4, 5, 2, 7]
Even/Odd: [2, 4, 6, 8, 5, 1, 7, 3]
Colors: [0, 0, 1, 1, 2, 2]
```

---

### Application 3: Top K Frequent Elements

```java
public class TopKFrequent {
    /**
     * Find k most frequent elements using quick select
     * LeetCode 347
     */
    public int[] topKFrequent(int[] nums, int k) {
        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : nums) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        
        // Convert to array of unique elements
        int[] unique = new int[freqMap.size()];
        int i = 0;
        for (int num : freqMap.keySet()) {
            unique[i++] = num;
        }
        
        // Use quick select to partition by frequency
        // kth largest = (n - k)th smallest
        quickSelect(unique, 0, unique.length - 1, 
                   unique.length - k, freqMap);
        
        // Return top k
        return Arrays.copyOfRange(unique, unique.length - k, unique.length);
    }
    
    private void quickSelect(int[] arr, int low, int high, int k,
                            Map<Integer, Integer> freqMap) {
        if (low >= high) return;
        
        int pi = partition(arr, low, high, freqMap);
        
        if (k == pi) {
            return;
        } else if (k < pi) {
            quickSelect(arr, low, pi - 1, k, freqMap);
        } else {
            quickSelect(arr, pi + 1, high, k, freqMap);
        }
    }
    
    private int partition(int[] arr, int low, int high,
                         Map<Integer, Integer> freqMap) {
        int pivot = freqMap.get(arr[high]);
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (freqMap.get(arr[j]) < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        TopKFrequent tkf = new TopKFrequent();
        
        int[] nums = {1, 1, 1, 2, 2, 3};
        int k = 2;
        
        int[] result = tkf.topKFrequent(nums, k);
        System.out.println("Top " + k + " frequent: " + 
                          Arrays.toString(result));
    }
}
```

**Output**:
```
Top 2 frequent: [1, 2]
```

---

## Interview Questions

### Question 1: Nuts and Bolts Problem

**Problem**: Given a set of n nuts of different sizes and n bolts, match each nut with its corresponding bolt. You can only compare nut-bolt pairs (nut-nut or bolt-bolt comparison not allowed).

```java
public class NutsAndBolts {
    /**
     * Match nuts and bolts using quick sort partitioning
     * Time: O(n log n), Space: O(log n)
     */
    public void matchPairs(char[] nuts, char[] bolts) {
        matchPairs(nuts, bolts, 0, nuts.length - 1);
    }
    
    private void matchPairs(char[] nuts, char[] bolts, int low, int high) {
        if (low < high) {
            // Partition nuts using bolts[high] as pivot
            int pivotIndex = partition(nuts, low, high, bolts[high]);
            
            // Partition bolts using nuts[pivotIndex] as pivot
            partition(bolts, low, high, nuts[pivotIndex]);
            
            // Recursively sort left and right
            matchPairs(nuts, bolts, low, pivotIndex - 1);
            matchPairs(nuts, bolts, pivotIndex + 1, high);
        }
    }
    
    private int partition(char[] arr, int low, int high, char pivot) {
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            } else if (arr[j] == pivot) {
                // Swap pivot to end temporarily
                swap(arr, j, high);
                j--;
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        NutsAndBolts nab = new NutsAndBolts();
        
        char[] nuts = {'@', '#', '$', '%', '^', '&'};
        char[] bolts = {'$', '%', '&', '^', '@', '#'};
        
        System.out.println("Before:");
        System.out.println("Nuts:  " + Arrays.toString(nuts));
        System.out.println("Bolts: " + Arrays.toString(bolts));
        
        nab.matchPairs(nuts, bolts);
        
        System.out.println("\nAfter:");
        System.out.println("Nuts:  " + Arrays.toString(nuts));
        System.out.println("Bolts: " + Arrays.toString(bolts));
    }
}
```

---

### Question 2: Kth Largest Element in Stream

**Problem**: Design a class to find the kth largest element in a stream.

```java
public class KthLargest {
    private PriorityQueue<Integer> minHeap;
    private int k;
    
    /**
     * Initialize with k and initial array
     */
    public KthLargest(int k, int[] nums) {
        this.k = k;
        this.minHeap = new PriorityQueue<>(k);
        
        for (int num : nums) {
            add(num);
        }
    }
    
    /**
     * Add element and return kth largest
     * Using min-heap approach (more efficient for stream)
     */
    public int add(int val) {
        if (minHeap.size() < k) {
            minHeap.offer(val);
        } else if (val > minHeap.peek()) {
            minHeap.poll();
            minHeap.offer(val);
        }
        
        return minHeap.peek();
    }
    
    // Alternative: Quick select approach (for static array)
    public static int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length - 1, nums.length - k);
    }
    
    private static int quickSelect(int[] nums, int low, int high, int k) {
        if (low == high) return nums[low];
        
        int pi = partition(nums, low, high);
        
        if (k == pi) {
            return nums[k];
        } else if (k < pi) {
            return quickSelect(nums, low, pi - 1, k);
        } else {
            return quickSelect(nums, pi + 1, high, k);
        }
    }
    
    private static int partition(int[] nums, int low, int high) {
        int pivot = nums[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (nums[j] < pivot) {
                i++;
                swap(nums, i, j);
            }
        }
        
        swap(nums, i + 1, high);
        return i + 1;
    }
    
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        // Test stream approach
        KthLargest kl = new KthLargest(3, new int[]{4, 5, 8, 2});
        System.out.println(kl.add(3));  // 4
        System.out.println(kl.add(5));  // 5
        System.out.println(kl.add(10)); // 5
        System.out.println(kl.add(9));  // 8
        System.out.println(kl.add(4));  // 8
        
        // Test quick select approach
        int[] nums = {3, 2, 1, 5, 6, 4};
        System.out.println("\n2nd largest: " + findKthLargest(nums, 2));
    }
}
```

---

### Question 3: Wiggle Sort II

**Problem**: Reorder array such that nums[0] < nums[1] > nums[2] < nums[3]...

```java
public class WiggleSort {
    /**
     * Wiggle sort using partition concept
     * LeetCode 324
     */
    public void wiggleSort(int[] nums) {
        int n = nums.length;
        
        // Find median using quick select
        int median = findMedian(nums);
        
        // Three-way partition around median with virtual indexing
        // Map index: 0->1, 1->3, 2->5... (odd indices)
        //           n/2->0, n/2+1->2... (even indices)
        int left = 0, i = 0, right = n - 1;
        
        while (i <= right) {
            if (nums[newIndex(i, n)] > median) {
                swap(nums, newIndex(left++, n), newIndex(i++, n));
            } else if (nums[newIndex(i, n)] < median) {
                swap(nums, newIndex(right--, n), newIndex(i, n));
            } else {
                i++;
            }
        }
    }
    
    // Virtual index mapping for wiggle pattern
    private int newIndex(int index, int n) {
        return (1 + 2 * index) % (n | 1);
    }
    
    private int findMedian(int[] nums) {
        int[] copy = nums.clone();
        return quickSelect(copy, 0, copy.length - 1, copy.length / 2);
    }
    
    private int quickSelect(int[] nums, int low, int high, int k) {
        if (low == high) return nums[low];
        
        int pi = partition(nums, low, high);
        
        if (k == pi) {
            return nums[k];
        } else if (k < pi) {
            return quickSelect(nums, low, pi - 1, k);
        } else {
            return quickSelect(nums, pi + 1, high, k);
        }
    }
    
    private int partition(int[] nums, int low, int high) {
        int pivot = nums[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (nums[j] < pivot) {
                i++;
                swap(nums, i, j);
            }
        }
        
        swap(nums, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        WiggleSort ws = new WiggleSort();
        
        int[] nums = {1, 5, 1, 1, 6, 4};
        System.out.println("Original: " + Arrays.toString(nums));
        
        ws.wiggleSort(nums);
        System.out.println("Wiggled: " + Arrays.toString(nums));
        
        // Verify wiggle property
        boolean isWiggle = true;
        for (int i = 0; i < nums.length - 1; i++) {
            if (i % 2 == 0) {
                if (nums[i] >= nums[i + 1]) isWiggle = false;
            } else {
                if (nums[i] <= nums[i + 1]) isWiggle = false;
            }
        }
        System.out.println("Is wiggle sorted: " + isWiggle);
    }
}
```

---

## Practice Problems

### Easy Level

1. **Sort an Array** (LeetCode 912)
   - Basic quick sort implementation
   - Handle duplicates efficiently

2. **Partition Array** (LeetCode 2161)
   - Simple partitioning around value
   - Two-pointer technique

3. **Sort Colors** (LeetCode 75)
   - Dutch National Flag problem
   - Three-way partitioning

### Medium Level

4. **Kth Largest Element in Array** (LeetCode 215)
   - Quick select algorithm
   - Average O(n) solution

5. **Top K Frequent Elements** (LeetCode 347)
   - Combine hashing and quick select
   - Or use min-heap

6. **Wiggle Sort II** (LeetCode 324)
   - Advanced partitioning
   - Virtual indexing technique

7. **Sort List** (LeetCode 148)
   - Quick sort on linked list
   - Or merge sort (more common)

8. **Pancake Sorting** (LeetCode 969)
   - Simulate physical pancake flipping
   - Selection-like approach

### Hard Level

9. **Find Median from Data Stream** (LeetCode 295)
   - Two heaps approach
   - Or quick select with rebalancing

10. **Count of Range Sum** (LeetCode 327)
    - Merge sort with counting
    - Advanced application

### Implementation Challenges

```java
public class QuickSortPractice {
    /**
     * Practice 1: Sort array of 0s, 1s, and 2s
     * Dutch National Flag - O(n), O(1)
     */
    public void sortColors(int[] nums) {
        int low = 0, mid = 0, high = nums.length - 1;
        
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low++, mid++);
            } else if (nums[mid] == 2) {
                swap(nums, mid, high--);
            } else {
                mid++;
            }
        }
    }
    
    /**
     * Practice 2: Partition around range [lower, upper]
     * Elements < lower, in range, > upper
     */
    public void partitionRange(int[] arr, int lower, int upper) {
        int lt = 0;      // < lower
        int i = 0;       // current
        int gt = arr.length - 1;  // > upper
        
        while (i <= gt) {
            if (arr[i] < lower) {
                swap(arr, lt++, i++);
            } else if (arr[i] > upper) {
                swap(arr, i, gt--);
            } else {
                i++;  // in range
            }
        }
    }
    
    /**
     * Practice 3: Find kth smallest in each row of matrix
     * Apply quick select to each row
     */
    public int[] kthSmallestInRows(int[][] matrix, int k) {
        int[] result = new int[matrix.length];
        
        for (int i = 0; i < matrix.length; i++) {
            result[i] = quickSelect(matrix[i], 0, 
                                   matrix[i].length - 1, k - 1);
        }
        
        return result;
    }
    
    private int quickSelect(int[] arr, int low, int high, int k) {
        if (low == high) return arr[low];
        
        int pi = partition(arr, low, high);
        
        if (k == pi) return arr[k];
        else if (k < pi) return quickSelect(arr, low, pi - 1, k);
        else return quickSelect(arr, pi + 1, high, k);
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## Summary

### Key Takeaways

1. **Divide-and-conquer** - partition then recursively sort
2. **Fastest in practice** - O(n log n) average, cache-friendly
3. **In-place** - O(1) extra space (excluding recursion)
4. **Unstable** - doesn't maintain relative order
5. **Pivot selection matters** - randomization prevents worst case

### Complexity Summary

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best | O(n log n) | O(log n) | Balanced partitions |
| Average | O(n log n) | O(log n) | Random data |
| Worst | O(n²) | O(n) | Sorted, poor pivot |
| With randomization | O(n log n) expected | O(log n) | All inputs |

### Comparison with Other Sorts

| Sort | Avg Time | Worst Time | Space | Stable | In-place |
|------|----------|-----------|-------|--------|----------|
| Quick | O(n log n) | O(n²) | O(log n) | No | Yes |
| Merge | O(n log n) | O(n log n) | O(n) | Yes | No |
| Heap | O(n log n) | O(n log n) | O(1) | No | Yes |
| Insertion | O(n²) | O(n²) | O(1) | Yes | Yes |

### Partition Schemes Comparison

| Scheme | Swaps | Efficiency | Pivot Position |
|--------|-------|-----------|----------------|
| Lomuto | More | Simple | Last element |
| Hoare | 3x fewer | Complex | First/mid element |
| 3-Way | Optimal for dups | Medium | Handles duplicates |
| Dual-Pivot | Fewest | Most complex | Two pivots |

### When to Use

| Scenario | Use Quick Sort? |
|----------|----------------|
| Random data | ✅ Best choice |
| Nearly sorted | ❌ Use insertion or randomized |
| Many duplicates | ✅ Use 3-way partition |
| Stability needed | ❌ Use merge sort |
| Memory limited | ✅ O(1) space (in-place) |
| Guaranteed O(n log n) | ❌ Use merge/heap sort |
| Partitioning problems | ✅ Quick select |
| Small arrays | ❌ Use insertion sort |

### Optimization Checklist

- ✅ Randomize pivot selection (prevents worst case)
- ✅ Use median-of-three for pivot (better balance)
- ✅ Switch to insertion sort for small subarrays (n < 10)
- ✅ Use 3-way partition for duplicates
- ✅ Tail recursion optimization (stack space)
- ✅ Consider dual-pivot for primitives

### Interview Tips

1. **Know worst case**: O(n²) for sorted arrays without randomization
2. **Explain partition**: Lomuto (simple) vs Hoare (efficient)
3. **Discuss optimizations**: Randomization, median-of-three, hybrid
4. **Compare to merge sort**: In-place vs stable trade-off
5. **Quick select**: O(n) for kth element problems
6. **Applications**: Partitioning, selection, sorting primitives
7. **Java's implementation**: Arrays.sort() uses dual-pivot quicksort
8. **Recurrence relation**: T(n) = T(k) + T(n-k-1) + O(n)

### Common Pitfalls

❌ Not handling duplicates efficiently (use 3-way)
❌ Poor pivot choice → O(n²) (use randomization)
❌ Deep recursion → stack overflow (use tail recursion)
❌ Not optimizing for small arrays (use hybrid approach)
❌ Assuming stability (quick sort is unstable)

### Real-World Usage

- **Java**: `Arrays.sort()` for primitives (dual-pivot quicksort)
- **C++ STL**: `std::sort()` (introsort = quicksort + heapsort fallback)
- **Python**: Timsort (not quicksort, but uses insertion for small runs)
- **Unix**: `qsort()` library function

---

**Next**: [6.6 Heap Sort](6.6-Heap-Sort.md) - Learn about heap sort algorithm

**Previous**: [6.4 Merge Sort](6.4-Merge-Sort.md)
