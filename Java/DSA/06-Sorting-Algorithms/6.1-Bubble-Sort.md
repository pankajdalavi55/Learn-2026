# 6.1 Bubble Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Optimized Versions](#optimized-versions)
4. [Variations](#variations)
5. [Applications](#applications)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is Bubble Sort?

**Bubble sort** is a simple comparison-based sorting algorithm that:
- Repeatedly steps through the list
- Compares adjacent elements
- Swaps them if they're in wrong order
- "Bubbles" largest elements to the end

### Visual Example

```
Initial: [5, 3, 8, 4, 2]

Pass 1: Compare adjacent pairs
[3, 5, 8, 4, 2] → swap 5,3
[3, 5, 8, 4, 2] → no swap
[3, 5, 4, 8, 2] → swap 8,4
[3, 5, 4, 2, 8] → swap 8,2  ✓ 8 in position

Pass 2:
[3, 5, 4, 2, 8]
[3, 4, 5, 2, 8] → swap 5,4
[3, 4, 2, 5, 8] → swap 5,2  ✓ 5 in position

Pass 3:
[3, 4, 2, 5, 8]
[3, 2, 4, 5, 8] → swap 4,2  ✓ 4 in position

Pass 4:
[2, 3, 4, 5, 8] → swap 3,2  ✓ 3 in position

Sorted: [2, 3, 4, 5, 8]
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n) when already sorted
  - Average: O(n²)
  - Worst: O(n²)
- **Space Complexity**: O(1) - in-place
- **Stability**: Stable (maintains relative order of equal elements)
- **Adaptive**: Can detect sorted arrays with optimization

### When to Use

**Use Bubble Sort**:
- ✅ Educational purposes (learning sorting)
- ✅ Small datasets (n < 10)
- ✅ Nearly sorted data (with optimization)
- ✅ When simplicity is priority

**Avoid Bubble Sort**:
- ❌ Large datasets (use quicksort, mergesort)
- ❌ Performance-critical applications
- ❌ Random data (too many swaps)

---

## Basic Implementation

### Standard Bubble Sort

```java
public class BubbleSort {
    /**
     * Basic bubble sort - O(n²) always
     */
    public void bubbleSort(int[] arr) {
        int n = arr.length;
        
        // Outer loop: n-1 passes
        for (int i = 0; i < n - 1; i++) {
            // Inner loop: compare adjacent elements
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap if out of order
                    swap(arr, j, j + 1);
                }
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSort bs = new BubbleSort();
        
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bs.bubbleSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [64, 34, 25, 12, 22, 11, 90]
Sorted: [11, 12, 22, 25, 34, 64, 90]
```

**Complexity**: O(n²) time, O(1) space

---

### With Detailed Steps

```java
public class BubbleSortVerbose {
    public void bubbleSort(int[] arr) {
        int n = arr.length;
        int pass = 0;
        
        for (int i = 0; i < n - 1; i++) {
            pass++;
            System.out.println("\nPass " + pass + ":");
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    System.out.println("  Swap: " + arr[j] + " and " + arr[j + 1]);
                    swap(arr, j, j + 1);
                }
            }
            
            System.out.println("  Array: " + Arrays.toString(arr));
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSortVerbose bsv = new BubbleSortVerbose();
        
        int[] arr = {5, 3, 8, 4, 2};
        System.out.println("Initial: " + Arrays.toString(arr));
        bsv.bubbleSort(arr);
    }
}
```

---

## Optimized Versions

### Optimization 1: Early Exit

```java
public class OptimizedBubbleSort {
    /**
     * Stop if no swaps in a pass (already sorted)
     */
    public void bubbleSortOptimized(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            // If no swaps, array is sorted
            if (!swapped) {
                break;
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        OptimizedBubbleSort obs = new OptimizedBubbleSort();
        
        int[] arr1 = {1, 2, 3, 4, 5}; // Already sorted
        obs.bubbleSortOptimized(arr1);
        System.out.println("Sorted (best case): " + Arrays.toString(arr1));
        // Only 1 pass needed!
        
        int[] arr2 = {5, 4, 3, 2, 1}; // Reverse sorted
        obs.bubbleSortOptimized(arr2);
        System.out.println("Sorted (worst case): " + Arrays.toString(arr2));
    }
}
```

**Best case**: O(n) when already sorted  
**Worst case**: Still O(n²)

---

### Optimization 2: Reduce Range

```java
public class BubbleSortReducedRange {
    /**
     * Track last swap position to reduce range
     */
    public void bubbleSort(int[] arr) {
        int n = arr.length;
        int newN;
        
        do {
            newN = 0;
            for (int i = 1; i < n; i++) {
                if (arr[i - 1] > arr[i]) {
                    swap(arr, i - 1, i);
                    newN = i; // Last swap position
                }
            }
            n = newN; // Reduce range for next pass
        } while (n > 1);
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSortReducedRange bsrr = new BubbleSortReducedRange();
        
        int[] arr = {8, 1, 2, 3, 4, 5, 6, 7};
        bsrr.bubbleSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantage**: Skips already sorted portion more efficiently

---

### Optimization 3: Bidirectional (Cocktail Sort)

```java
public class CocktailSort {
    /**
     * Bubble in both directions (cocktail shaker sort)
     */
    public void cocktailSort(int[] arr) {
        boolean swapped = true;
        int start = 0;
        int end = arr.length - 1;
        
        while (swapped) {
            swapped = false;
            
            // Forward pass (bubble max to right)
            for (int i = start; i < end; i++) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    swapped = true;
                }
            }
            
            if (!swapped) break;
            
            swapped = false;
            end--;
            
            // Backward pass (bubble min to left)
            for (int i = end - 1; i >= start; i--) {
                if (arr[i] > arr[i + 1]) {
                    swap(arr, i, i + 1);
                    swapped = true;
                }
            }
            
            start++;
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        CocktailSort cs = new CocktailSort();
        
        int[] arr = {5, 1, 4, 2, 8, 0, 2};
        System.out.println("Original: " + Arrays.toString(arr));
        
        cs.cocktailSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantage**: Better for data with small values at the end  
**Complexity**: Still O(n²) average, but often faster in practice

---

## Variations

### Descending Order

```java
public class BubbleSortDescending {
    public void bubbleSortDesc(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                // Change comparison to >
                if (arr[j] < arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            if (!swapped) break;
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSortDescending bsd = new BubbleSortDescending();
        
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        bsd.bubbleSortDesc(arr);
        System.out.println("Descending: " + Arrays.toString(arr));
        // [90, 64, 34, 25, 22, 12, 11]
    }
}
```

---

### Generic Bubble Sort

```java
public class GenericBubbleSort {
    /**
     * Generic bubble sort for any Comparable type
     */
    public <T extends Comparable<T>> void bubbleSort(T[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j].compareTo(arr[j + 1]) > 0) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            if (!swapped) break;
        }
    }
    
    private <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        GenericBubbleSort gbs = new GenericBubbleSort();
        
        String[] strings = {"banana", "apple", "cherry", "date"};
        gbs.bubbleSort(strings);
        System.out.println("Strings: " + Arrays.toString(strings));
        
        Integer[] numbers = {5, 3, 8, 4, 2};
        gbs.bubbleSort(numbers);
        System.out.println("Numbers: " + Arrays.toString(numbers));
    }
}
```

---

### Custom Comparator

```java
public class BubbleSortComparator {
    /**
     * Bubble sort with custom comparator
     */
    public <T> void bubbleSort(T[] arr, Comparator<T> comp) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            for (int j = 0; j < n - 1 - i; j++) {
                if (comp.compare(arr[j], arr[j + 1]) > 0) {
                    swap(arr, j, j + 1);
                    swapped = true;
                }
            }
            
            if (!swapped) break;
        }
    }
    
    private <T> void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSortComparator bsc = new BubbleSortComparator();
        
        String[] arr = {"apple", "pie", "a", "cat"};
        
        // Sort by length
        bsc.bubbleSort(arr, Comparator.comparingInt(String::length));
        System.out.println("By length: " + Arrays.toString(arr));
        // [a, cat, pie, apple]
    }
}
```

---

## Applications

### Application 1: Sort Linked List

```java
public class BubbleSortLinkedList {
    static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    /**
     * Bubble sort on linked list
     */
    public Node bubbleSort(Node head) {
        if (head == null || head.next == null) return head;
        
        boolean swapped;
        Node ptr;
        Node lptr = null; // Last sorted node
        
        do {
            swapped = false;
            ptr = head;
            
            while (ptr.next != lptr) {
                if (ptr.data > ptr.next.data) {
                    // Swap data (easier than swapping nodes)
                    int temp = ptr.data;
                    ptr.data = ptr.next.data;
                    ptr.next.data = temp;
                    swapped = true;
                }
                ptr = ptr.next;
            }
            lptr = ptr;
            
        } while (swapped);
        
        return head;
    }
    
    // Helper methods
    private void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }
    
    // Test
    public static void main(String[] args) {
        BubbleSortLinkedList bsll = new BubbleSortLinkedList();
        
        Node head = new Node(5);
        head.next = new Node(3);
        head.next.next = new Node(8);
        head.next.next.next = new Node(1);
        
        System.out.print("Original: ");
        bsll.printList(head);
        
        head = bsll.bubbleSort(head);
        
        System.out.print("Sorted: ");
        bsll.printList(head);
    }
}
```

---

### Application 2: Count Swaps

```java
public class CountSwaps {
    /**
     * Count total swaps needed to sort array
     */
    public int countSwaps(int[] arr) {
        int n = arr.length;
        int swapCount = 0;
        
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    swapCount++;
                }
            }
        }
        
        return swapCount;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        CountSwaps cs = new CountSwaps();
        
        int[] arr = {5, 4, 3, 2, 1};
        int swaps = cs.countSwaps(arr);
        
        System.out.println("Array: " + Arrays.toString(arr));
        System.out.println("Total swaps: " + swaps); // 10
    }
}
```

---

### Application 3: Find Kth Largest (Using Partial Sort)

```java
public class KthLargestBubble {
    /**
     * Find kth largest using partial bubble sort
     * Only need k passes
     */
    public int findKthLargest(int[] arr, int k) {
        int n = arr.length;
        
        // Only k passes needed
        for (int i = 0; i < k; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
        
        // Kth largest is at position n-k
        return arr[n - k];
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        KthLargestBubble klb = new KthLargestBubble();
        
        int[] arr = {3, 2, 1, 5, 6, 4};
        System.out.println("2nd largest: " + klb.findKthLargest(arr, 2)); // 5
        
        int[] arr2 = {3, 2, 3, 1, 2, 4, 5, 5, 6};
        System.out.println("4th largest: " + klb.findKthLargest(arr2, 4)); // 4
    }
}
```

**Complexity**: O(n × k) - better than full sort for small k

---

## Interview Questions

### Q1: What is the time complexity of bubble sort?

**Answer**:

- **Best case**: O(n) - when array is already sorted (with optimization)
- **Average case**: O(n²) - random order
- **Worst case**: O(n²) - reverse sorted

**Detailed analysis**:
```
Passes: n - 1
Comparisons per pass: n - 1, n - 2, n - 3, ..., 1
Total = (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
```

**With optimization** (early exit):
```
Best case: 1 pass × n comparisons = O(n)
```

---

### Q2: Is bubble sort stable?

**Answer**: **Yes**, bubble sort is **stable**.

**Stability** means elements with equal values maintain their relative order.

**Example**:
```java
Input:  [(5,a), (3,b), (5,c), (2,d)]
Output: [(2,d), (3,b), (5,a), (5,c)]
         
Notice: (5,a) still comes before (5,c)
```

**Why stable**: Only swaps when `arr[j] > arr[j+1]`, never when equal.

---

### Q3: When should you use bubble sort?

**Answer**:

**Use bubble sort when**:
1. **Teaching/Learning** - simplest sorting algorithm
2. **Small data** - n < 10 elements
3. **Nearly sorted** - only few elements out of place
4. **Simplicity needed** - easy to implement and understand
5. **Stable sort required** - and other factors don't matter

**Don't use when**:
1. **Large datasets** - O(n²) too slow
2. **Random data** - quicksort or mergesort better
3. **Performance critical** - use built-in sort
4. **Professional code** - almost never appropriate

**Better alternatives**:
- Small data: Insertion sort (faster)
- Large data: Quicksort, mergesort, heapsort
- General: Arrays.sort() or Collections.sort()

---

### Q4: How can you optimize bubble sort?

**Answer**:

**Optimization 1: Early exit**
```java
boolean swapped = false;
// ... do pass ...
if (!swapped) break; // Already sorted
```
**Benefit**: O(n) best case instead of O(n²)

**Optimization 2: Reduce range**
```java
// After each pass, last i elements are sorted
for (int j = 0; j < n - 1 - i; j++)
```
**Benefit**: Fewer comparisons

**Optimization 3: Track last swap**
```java
int lastSwap = 0;
// ... swap at position j ...
lastSwap = j;
n = lastSwap + 1; // Reduce range
```
**Benefit**: Skip sorted portions

**Optimization 4: Bidirectional (Cocktail sort)**
```java
// Bubble both directions
```
**Benefit**: Better for certain patterns

**Note**: Even optimized, bubble sort is still O(n²) average case.

---

### Q5: What's the difference between bubble sort and selection sort?

**Answer**:

| Feature | Bubble Sort | Selection Sort |
|---------|-------------|----------------|
| **Method** | Swap adjacent if wrong order | Find min, swap to front |
| **Swaps** | Many (O(n²) worst) | Few (O(n) always) |
| **Comparisons** | O(n²) | O(n²) |
| **Stable** | Yes | No (standard version) |
| **Best case** | O(n) with optimization | O(n²) always |
| **Use when** | Nearly sorted data | Minimize swaps |

**Example**:
```
Array: [5, 3, 8, 4, 2]

Bubble sort: Compares neighbors, swaps many times
Selection sort: Finds minimum, swaps once per position
```

**Verdict**: Selection sort has fewer swaps, but both are O(n²) and rarely used in practice.

---

### Q6: Can bubble sort be implemented recursively?

**Answer**: **Yes**

```java
public void bubbleSortRecursive(int[] arr, int n) {
    // Base case
    if (n == 1) return;
    
    // One pass: bubble largest to end
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            swap(arr, i, i + 1);
        }
    }
    
    // Recurse for remaining elements
    bubbleSortRecursive(arr, n - 1);
}
```

**Complexity**: 
- Time: O(n²) same as iterative
- Space: O(n) for recursion stack (worse than iterative O(1))

**Verdict**: Iterative is better (less space).

---

### Q7: How many passes does bubble sort need?

**Answer**:

**Maximum passes**: n - 1 (for n elements)

**Why**: After k passes, largest k elements are in final positions.

**With optimization**: Can be as few as **1 pass** if already sorted.

**Example**:
```
n = 5: [5, 4, 3, 2, 1]

Pass 1: [4, 3, 2, 1, 5] ✓
Pass 2: [3, 2, 1, 4, 5] ✓
Pass 3: [2, 1, 3, 4, 5] ✓
Pass 4: [1, 2, 3, 4, 5] ✓

Total: 4 passes = n - 1
```

---

### Q8: What is the space complexity of bubble sort?

**Answer**: **O(1)** - constant space

**Explanation**:
- Sorts **in-place** (no extra array)
- Only needs one temporary variable for swapping
- No recursive calls (in iterative version)

**Comparison**:
```
Bubble sort: O(1) space ✅
Merge sort: O(n) space
Quick sort: O(log n) space (recursion)
```

---

### Q9: Is bubble sort adaptive?

**Answer**: **Yes, with optimization**

**Adaptive** means it performs better on nearly sorted data.

**Without optimization**: O(n²) always (not adaptive)

**With early exit**:
```java
if (!swapped) break;
```
- Already sorted: O(n) ✅
- Nearly sorted: Better than O(n²)

**Example**:
```
[1, 2, 3, 5, 4] → Only 1 swap needed
Without optimization: n² comparisons
With optimization: ~n comparisons
```

---

### Q10: Can bubble sort be parallelized?

**Answer**: **Difficult to parallelize effectively**

**Problems**:
1. **Dependencies**: Each comparison depends on previous swaps
2. **Sequential nature**: Must bubble in order
3. **Small operations**: Swap is too fast for parallelization overhead

**Odd-even sort** (parallel variant):
```java
// Odd phase: compare (0,1), (2,3), (4,5) in parallel
// Even phase: compare (1,2), (3,4), (5,6) in parallel
```

**Verdict**: Better to use parallel merge sort or parallel quick sort instead.

---

## Practice Problems

### Problem 1: Minimum Swaps to Sort (HackerRank)

**Description**: Count minimum swaps to sort array.

**Solution**:
```java
public class MinimumSwaps {
    public int minimumSwaps(int[] arr) {
        int swaps = 0;
        int n = arr.length;
        
        for (int i = 0; i < n; i++) {
            // If element not in correct position
            while (arr[i] != i + 1) {
                // Swap to correct position
                int correctPos = arr[i] - 1;
                int temp = arr[i];
                arr[i] = arr[correctPos];
                arr[correctPos] = temp;
                swaps++;
            }
        }
        
        return swaps;
    }
    
    // Test
    public static void main(String[] args) {
        MinimumSwaps ms = new MinimumSwaps();
        System.out.println(ms.minimumSwaps(new int[]{4, 3, 1, 2})); // 3
    }
}
```

---

### Problem 2: Sort Colors (LeetCode 75)

**Description**: Sort array of 0s, 1s, 2s in-place.

**Solution** (Dutch National Flag):
```java
public class SortColors {
    public void sortColors(int[] nums) {
        int low = 0, mid = 0, high = nums.length - 1;
        
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low++, mid++);
            } else if (nums[mid] == 1) {
                mid++;
            } else {
                swap(nums, mid, high--);
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Note**: More efficient than bubble sort (O(n) vs O(n²))

---

### Problem 3: Counting Sort Variant

**Description**: Count inversions during bubble sort.

**Solution**:
```java
public class CountInversions {
    public int countInversions(int[] arr) {
        int inversions = 0;
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr, j, j + 1);
                    inversions++; // Each swap fixes one inversion
                }
            }
        }
        
        return inversions;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## Summary

### Key Takeaways

1. **Simplest sorting algorithm** - easy to understand and implement
2. **O(n²) complexity** - inefficient for large datasets
3. **Stable sort** - maintains relative order of equal elements
4. **In-place** - O(1) extra space
5. **Adaptive** - can be optimized for nearly sorted data

### Complexity Summary

| Case | Time | Space |
|------|------|-------|
| Best (optimized) | O(n) | O(1) |
| Average | O(n²) | O(1) |
| Worst | O(n²) | O(1) |

### When to Use

| Scenario | Recommendation |
|----------|----------------|
| Learning/Teaching | ✅ Use bubble sort |
| Small data (n < 10) | ✅ Use (or insertion sort) |
| Nearly sorted | ✅ Use with optimization |
| Large data | ❌ Use quicksort/mergesort |
| Production code | ❌ Use Arrays.sort() |

### Comparison with Other O(n²) Sorts

| Sort | Swaps | Comparisons | Stable | Best Case |
|------|-------|-------------|--------|-----------|
| Bubble | Many | O(n²) | Yes | O(n) |
| Selection | O(n) | O(n²) | No | O(n²) |
| Insertion | O(n²) | O(n²) | Yes | O(n) |

### Interview Tips

1. **Know complexity**: O(n²) average, O(n) best with optimization
2. **Explain stability**: Yes, because only swaps when strictly greater
3. **Show optimization**: Early exit when no swaps
4. **Compare alternatives**: Selection sort (fewer swaps), insertion sort (faster in practice)
5. **Real usage**: Rarely used in production, mainly educational

---

**Next**: [6.2 Selection Sort](6.2-Selection-Sort.md) - Learn about selection sort algorithm
