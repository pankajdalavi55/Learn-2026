# 6.7 Counting Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Stable Counting Sort](#stable-counting-sort)
4. [Handling Negative Numbers](#handling-negative-numbers)
5. [Optimizations](#optimizations)
6. [Variations](#variations)
7. [Applications](#applications)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)
10. [Summary](#summary)

---

## Introduction

### What is Counting Sort?

**Counting sort** is a **non-comparison** based sorting algorithm that:
- **Counts** the frequency of each distinct element
- Uses **arithmetic** on array indices to determine positions
- Works only for **integers** in a known range
- Achieves **linear time** O(n + k) where k is the range

### Visual Example

```
Original: [4, 2, 2, 8, 3, 3, 1]
Range: 1 to 8

Step 1: Count frequencies
Count array for values 1-8:
Index:  0  1  2  3  4  5  6  7  8
Count: [0, 1, 2, 2, 1, 0, 0, 0, 1]
        ↑  ↑  ↑  ↑  ↑           ↑
        - 1x 2x 2x 1x          1x

Step 2: Cumulative count (for stable sort)
Index:  0  1  2  3  4  5  6  7  8
Count: [0, 1, 3, 5, 6, 6, 6, 6, 7]

Step 3: Build output array (right to left for stability)
Process [4, 2, 2, 8, 3, 3, 1] from right to left:
- 1 → position count[1]=1 → output[0]=1
- 3 → position count[3]=5 → output[4]=3
- 3 → position count[3]=4 → output[3]=3
- 8 → position count[8]=7 → output[6]=8
- 2 → position count[2]=3 → output[2]=2
- 2 → position count[2]=2 → output[1]=2
- 4 → position count[4]=6 → output[5]=4

Final: [1, 2, 2, 3, 3, 4, 8]
```

### Simple Counting (Unstable)

```
Original: [4, 2, 2, 8, 3, 3, 1]

Step 1: Count
Index:  1  2  3  4  5  6  7  8
Count: [1, 2, 2, 1, 0, 0, 0, 1]

Step 2: Output in order
For each value from 1 to 8:
  Output value count[value] times
  
1 appears 1 time  → [1]
2 appears 2 times → [1, 2, 2]
3 appears 2 times → [1, 2, 2, 3, 3]
4 appears 1 time  → [1, 2, 2, 3, 3, 4]
8 appears 1 time  → [1, 2, 2, 3, 3, 4, 8]

Final: [1, 2, 2, 3, 3, 4, 8]
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n + k)
  - Average: O(n + k)
  - Worst: O(n + k)
  - where n = elements, k = range (max - min + 1)
- **Space Complexity**: O(n + k) - count array + output
- **Stability**: Can be **stable** with proper implementation
- **Non-comparison**: Uses counting, not comparisons
- **Integer only**: Only works with integer keys
- **Linear time**: Faster than O(n log n) when k = O(n)

### When to Use

**Use Counting Sort**:
- ✅ **Small range** of integers (k ≈ n)
- ✅ **Known range** beforehand
- ✅ **Stability** required
- ✅ As part of **radix sort**
- ✅ When **O(n)** time needed

**Avoid Counting Sort**:
- ❌ Large range (k >> n) - wastes space
- ❌ Floating point numbers
- ❌ Arbitrary objects (use comparison-based)
- ❌ Unknown or dynamic range
- ❌ Sparse data (most values unused)

---

## Basic Implementation

### Simple Counting Sort (Unstable)

```java
public class CountingSort {
    /**
     * Simple counting sort - unstable version
     * Works for non-negative integers
     * Time: O(n + k), Space: O(k)
     */
    public void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // Find range
        int max = arr[0];
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
        }
        
        // Count array (0 to max)
        int[] count = new int[max + 1];
        
        // Step 1: Count frequencies
        for (int num : arr) {
            count[num]++;
        }
        
        // Step 2: Write sorted values back
        int index = 0;
        for (int i = 0; i <= max; i++) {
            while (count[i] > 0) {
                arr[index++] = i;
                count[i]--;
            }
        }
    }
    
    // Alternative: More concise
    public void countingSortConcise(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        int[] count = new int[max + 1];
        
        // Count
        for (int num : arr) {
            count[num]++;
        }
        
        // Reconstruct
        int idx = 0;
        for (int i = 0; i <= max; i++) {
            for (int j = 0; j < count[i]; j++) {
                arr[idx++] = i;
            }
        }
    }
    
    // Test
    public static void main(String[] args) {
        CountingSort cs = new CountingSort();
        
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("Original: " + Arrays.toString(arr));
        
        cs.countingSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [4, 2, 2, 8, 3, 3, 1]
Sorted: [1, 2, 2, 3, 3, 4, 8]
```

**Complexity**: O(n + k) time, O(k) space

---

### With Detailed Steps

```java
public class CountingSortVerbose {
    public void countingSort(int[] arr) {
        System.out.println("Starting array: " + Arrays.toString(arr));
        
        // Find max
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }
        System.out.println("Max value: " + max);
        
        // Create count array
        int[] count = new int[max + 1];
        System.out.println("\n=== Counting Phase ===");
        
        // Count frequencies
        for (int num : arr) {
            count[num]++;
            System.out.println("count[" + num + "] = " + count[num]);
        }
        
        System.out.println("\nCount array: " + Arrays.toString(count));
        
        // Reconstruct
        System.out.println("\n=== Reconstruction Phase ===");
        int index = 0;
        
        for (int i = 0; i <= max; i++) {
            if (count[i] > 0) {
                System.out.println("Value " + i + " appears " + 
                                 count[i] + " times");
            }
            
            while (count[i] > 0) {
                arr[index++] = i;
                count[i]--;
            }
        }
        
        System.out.println("\nFinal sorted: " + Arrays.toString(arr));
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortVerbose csv = new CountingSortVerbose();
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        csv.countingSort(arr);
    }
}
```

---

### Return New Array

```java
public class CountingSortNew {
    /**
     * Return new sorted array instead of modifying input
     * Useful when original order needed
     */
    public int[] countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        
        // Find range
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }
        
        // Count frequencies
        int[] count = new int[max + 1];
        for (int num : arr) {
            count[num]++;
        }
        
        // Build output array
        int[] output = new int[arr.length];
        int index = 0;
        
        for (int i = 0; i <= max; i++) {
            while (count[i] > 0) {
                output[index++] = i;
                count[i]--;
            }
        }
        
        return output;
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortNew csn = new CountingSortNew();
        
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("Original: " + Arrays.toString(arr));
        
        int[] sorted = csn.countingSort(arr);
        System.out.println("Sorted: " + Arrays.toString(sorted));
        System.out.println("Original unchanged: " + Arrays.toString(arr));
    }
}
```

---

## Stable Counting Sort

### Stable Version (Preserves Order)

```java
public class StableCountingSort {
    /**
     * Stable counting sort using cumulative counts
     * Preserves relative order of equal elements
     * Important for radix sort and sorting objects
     */
    public int[] countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        
        // Find range
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }
        
        // Step 1: Count frequencies
        int[] count = new int[max + 1];
        for (int num : arr) {
            count[num]++;
        }
        
        // Step 2: Cumulative count (position of last occurrence)
        for (int i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }
        
        // Step 3: Build output (traverse right to left for stability)
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int value = arr[i];
            int position = count[value] - 1;
            output[position] = value;
            count[value]--;
        }
        
        return output;
    }
    
    /**
     * Stable sort with detailed explanation
     */
    public int[] countingSortVerbose(int[] arr) {
        System.out.println("Input: " + Arrays.toString(arr));
        
        int max = Arrays.stream(arr).max().getAsInt();
        
        // Count
        int[] count = new int[max + 1];
        for (int num : arr) {
            count[num]++;
        }
        System.out.println("Count: " + Arrays.toString(count));
        
        // Cumulative
        for (int i = 1; i <= max; i++) {
            count[i] += count[i - 1];
        }
        System.out.println("Cumulative: " + Arrays.toString(count));
        
        // Build output
        int[] output = new int[arr.length];
        System.out.println("\nBuilding output (right to left):");
        
        for (int i = arr.length - 1; i >= 0; i--) {
            int value = arr[i];
            int position = count[value] - 1;
            System.out.println("  arr[" + i + "]=" + value + 
                             " → position " + position);
            output[position] = value;
            count[value]--;
        }
        
        System.out.println("Output: " + Arrays.toString(output));
        return output;
    }
    
    // Test
    public static void main(String[] args) {
        StableCountingSort scs = new StableCountingSort();
        
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        int[] sorted = scs.countingSortVerbose(arr);
    }
}
```

---

### Sorting Objects with Counting Sort

```java
public class CountingSortObjects {
    static class Student {
        String name;
        int score;
        
        Student(String name, int score) {
            this.name = name;
            this.score = score;
        }
        
        @Override
        public String toString() {
            return name + "(" + score + ")";
        }
    }
    
    /**
     * Sort objects by integer key (stable)
     * Demonstrates why stability matters
     */
    public Student[] sortByScore(Student[] students) {
        if (students == null || students.length <= 1) {
            return students;
        }
        
        // Find max score
        int maxScore = 0;
        for (Student s : students) {
            if (s.score > maxScore) {
                maxScore = s.score;
            }
        }
        
        // Count frequencies
        int[] count = new int[maxScore + 1];
        for (Student s : students) {
            count[s.score]++;
        }
        
        // Cumulative count
        for (int i = 1; i <= maxScore; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output (right to left for stability)
        Student[] output = new Student[students.length];
        for (int i = students.length - 1; i >= 0; i--) {
            int score = students[i].score;
            int position = count[score] - 1;
            output[position] = students[i];
            count[score]--;
        }
        
        return output;
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortObjects cso = new CountingSortObjects();
        
        Student[] students = {
            new Student("Alice", 85),
            new Student("Bob", 90),
            new Student("Charlie", 85),
            new Student("David", 90),
            new Student("Eve", 75)
        };
        
        System.out.println("Original:");
        System.out.println(Arrays.toString(students));
        
        Student[] sorted = cso.sortByScore(students);
        
        System.out.println("\nSorted (stable - preserves order):");
        System.out.println(Arrays.toString(sorted));
        // Eve(75), Alice(85), Charlie(85), Bob(90), David(90)
        // Alice before Charlie (both 85), Bob before David (both 90)
    }
}
```

---

## Handling Negative Numbers

### Counting Sort with Negative Numbers

```java
public class CountingSortNegative {
    /**
     * Counting sort for arrays with negative numbers
     * Shift all values by min to make them non-negative
     */
    public int[] countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        
        // Find min and max
        int min = arr[0], max = arr[0];
        for (int num : arr) {
            if (num < min) min = num;
            if (num > max) max = num;
        }
        
        // Range of values
        int range = max - min + 1;
        
        // Count array (shifted by min)
        int[] count = new int[range];
        
        // Count frequencies (shift index by min)
        for (int num : arr) {
            count[num - min]++;
        }
        
        // Cumulative count
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int value = arr[i];
            int index = value - min;
            int position = count[index] - 1;
            output[position] = value;
            count[index]--;
        }
        
        return output;
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortNegative csn = new CountingSortNegative();
        
        int[] arr = {-5, -10, 0, -3, 8, 5, -1, 10};
        System.out.println("Original: " + Arrays.toString(arr));
        
        int[] sorted = csn.countingSort(arr);
        System.out.println("Sorted: " + Arrays.toString(sorted));
    }
}
```

**Output**:
```
Original: [-5, -10, 0, -3, 8, 5, -1, 10]
Sorted: [-10, -5, -3, -1, 0, 5, 8, 10]
```

---

### With Detailed Range Calculation

```java
public class CountingSortRange {
    /**
     * Verbose version showing range calculation
     */
    public int[] countingSort(int[] arr) {
        System.out.println("Input: " + Arrays.toString(arr));
        
        // Find range
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        
        for (int num : arr) {
            if (num < min) min = num;
            if (num > max) max = num;
        }
        
        System.out.println("Min: " + min + ", Max: " + max);
        
        int range = max - min + 1;
        System.out.println("Range: " + range);
        
        // Count
        int[] count = new int[range];
        
        System.out.println("\nCounting (shifted by " + min + "):");
        for (int num : arr) {
            int index = num - min;
            count[index]++;
            System.out.println("  " + num + " → count[" + index + 
                             "] = " + count[index]);
        }
        
        // Cumulative
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int value = arr[i];
            int index = value - min;
            int position = count[index] - 1;
            output[position] = value;
            count[index]--;
        }
        
        System.out.println("\nOutput: " + Arrays.toString(output));
        return output;
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortRange csr = new CountingSortRange();
        int[] arr = {-2, 0, -3, 2, 1};
        csr.countingSort(arr);
    }
}
```

---

## Optimizations

### In-Place Counting Sort (Cycle Sort Variant)

```java
public class InPlaceCountingSort {
    /**
     * Space-optimized counting sort
     * Uses less space but modifies count array
     */
    public void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        int max = arr[0];
        for (int num : arr) {
            if (num > max) max = num;
        }
        
        int[] count = new int[max + 1];
        
        // Count
        for (int num : arr) {
            count[num]++;
        }
        
        // Reconstruct in-place
        int index = 0;
        for (int value = 0; value <= max; value++) {
            while (count[value]-- > 0) {
                arr[index++] = value;
            }
        }
    }
    
    // Test
    public static void main(String[] args) {
        InPlaceCountingSort ipcs = new InPlaceCountingSort();
        
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("Original: " + Arrays.toString(arr));
        
        ipcs.countingSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

---

### Optimized for Small Range

```java
public class OptimizedCountingSort {
    /**
     * Optimized for small range relative to n
     * Only allocate array for actual range used
     */
    public void countingSort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // Find actual range
        int min = arr[0], max = arr[0];
        for (int num : arr) {
            if (num < min) min = num;
            if (num > max) max = num;
        }
        
        // Check if range is reasonable
        int range = max - min + 1;
        
        if (range > arr.length * 10) {
            // Range too large, use comparison sort instead
            Arrays.sort(arr);
            return;
        }
        
        // Standard counting sort
        int[] count = new int[range];
        
        for (int num : arr) {
            count[num - min]++;
        }
        
        int index = 0;
        for (int i = 0; i < range; i++) {
            while (count[i] > 0) {
                arr[index++] = i + min;
                count[i]--;
            }
        }
    }
    
    // Test
    public static void main(String[] args) {
        OptimizedCountingSort ocs = new OptimizedCountingSort();
        
        // Small range - uses counting sort
        int[] arr1 = {5, 2, 9, 5, 2, 3};
        ocs.countingSort(arr1);
        System.out.println("Small range: " + Arrays.toString(arr1));
        
        // Large range - falls back to comparison sort
        int[] arr2 = {1, 1000000, 2, 999999};
        ocs.countingSort(arr2);
        System.out.println("Large range: " + Arrays.toString(arr2));
    }
}
```

---

## Variations

### Counting Sort by Digit (for Radix Sort)

```java
public class CountingSortByDigit {
    /**
     * Counting sort by specific digit
     * Used as subroutine in radix sort
     */
    public void countingSortByDigit(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10]; // Digits 0-9
        
        // Count occurrences of digits
        for (int i = 0; i < n; i++) {
            int digit = (arr[i] / exp) % 10;
            count[digit]++;
        }
        
        // Cumulative count
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output (right to left for stability)
        for (int i = n - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            int position = count[digit] - 1;
            output[position] = arr[i];
            count[digit]--;
        }
        
        // Copy to original
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    /**
     * Radix sort using counting sort
     */
    public void radixSort(int[] arr) {
        // Find max to determine number of digits
        int max = Arrays.stream(arr).max().getAsInt();
        
        // Sort by each digit (LSD to MSD)
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    // Test
    public static void main(String[] args) {
        CountingSortByDigit csbd = new CountingSortByDigit();
        
        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};
        System.out.println("Original: " + Arrays.toString(arr));
        
        csbd.radixSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

---

### Parallel Counting Sort

```java
public class ParallelCountingSort {
    /**
     * Parallel counting sort using multiple threads
     * Good for very large arrays
     */
    public int[] parallelCountingSort(int[] arr) throws InterruptedException {
        if (arr == null || arr.length <= 1) {
            return arr;
        }
        
        // Find range
        int min = arr[0], max = arr[0];
        for (int num : arr) {
            if (num < min) min = num;
            if (num > max) max = num;
        }
        
        int range = max - min + 1;
        int numThreads = Runtime.getRuntime().availableProcessors();
        
        // Parallel counting phase
        int[][] localCounts = new int[numThreads][range];
        Thread[] threads = new Thread[numThreads];
        int chunkSize = (arr.length + numThreads - 1) / numThreads;
        
        for (int t = 0; t < numThreads; t++) {
            final int threadId = t;
            final int start = t * chunkSize;
            final int end = Math.min(start + chunkSize, arr.length);
            final int minValue = min;
            
            threads[t] = new Thread(() -> {
                for (int i = start; i < end; i++) {
                    localCounts[threadId][arr[i] - minValue]++;
                }
            });
            threads[t].start();
        }
        
        // Wait for all threads
        for (Thread thread : threads) {
            thread.join();
        }
        
        // Merge counts
        int[] count = new int[range];
        for (int t = 0; t < numThreads; t++) {
            for (int i = 0; i < range; i++) {
                count[i] += localCounts[t][i];
            }
        }
        
        // Cumulative count
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            int value = arr[i];
            int index = value - min;
            int position = count[index] - 1;
            output[position] = value;
            count[index]--;
        }
        
        return output;
    }
}
```

---

## Applications

### Application 1: Sort Array by Frequency

```java
public class SortByFrequency {
    /**
     * Sort array by frequency (most frequent first)
     * If tied, smaller value first
     */
    public int[] sortByFrequency(int[] arr) {
        // Count frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int num : arr) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }
        
        // Create array of unique values
        Integer[] unique = freqMap.keySet().toArray(new Integer[0]);
        
        // Sort by frequency (descending), then by value (ascending)
        Arrays.sort(unique, (a, b) -> {
            int freqCompare = freqMap.get(b) - freqMap.get(a);
            if (freqCompare != 0) {
                return freqCompare;
            }
            return a - b;
        });
        
        // Build result
        int[] result = new int[arr.length];
        int index = 0;
        
        for (int value : unique) {
            int freq = freqMap.get(value);
            for (int i = 0; i < freq; i++) {
                result[index++] = value;
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        SortByFrequency sbf = new SortByFrequency();
        
        int[] arr = {4, 5, 6, 5, 4, 3};
        System.out.println("Original: " + Arrays.toString(arr));
        
        int[] sorted = sbf.sortByFrequency(arr);
        System.out.println("By frequency: " + Arrays.toString(sorted));
        // [4, 4, 5, 5, 3, 6] - 4 and 5 appear twice, then 3 and 6
    }
}
```

---

### Application 2: Find Duplicates in Range [1, n]

```java
public class FindDuplicates {
    /**
     * Find all duplicates in array where 1 ≤ arr[i] ≤ n
     * Using counting sort concept
     * LeetCode 442
     */
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> result = new ArrayList<>();
        
        // Use array indices as count (1-indexed values)
        // Mark visited by negating value at index
        for (int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i]) - 1;
            
            if (nums[index] < 0) {
                // Already seen - duplicate
                result.add(index + 1);
            } else {
                // Mark as seen
                nums[index] = -nums[index];
            }
        }
        
        // Restore array (optional)
        for (int i = 0; i < nums.length; i++) {
            nums[i] = Math.abs(nums[i]);
        }
        
        return result;
    }
    
    /**
     * Find all numbers disappeared in [1, n]
     * LeetCode 448
     */
    public List<Integer> findDisappearedNumbers(int[] nums) {
        // Mark present numbers
        for (int i = 0; i < nums.length; i++) {
            int index = Math.abs(nums[i]) - 1;
            if (nums[index] > 0) {
                nums[index] = -nums[index];
            }
        }
        
        // Collect unmarked indices
        List<Integer> result = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                result.add(i + 1);
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindDuplicates fd = new FindDuplicates();
        
        // Find duplicates
        int[] arr1 = {4, 3, 2, 7, 8, 2, 3, 1};
        System.out.println("Array: " + Arrays.toString(arr1));
        System.out.println("Duplicates: " + fd.findDuplicates(arr1));
        
        // Find missing
        int[] arr2 = {4, 3, 2, 7, 8, 2, 3, 1};
        System.out.println("Missing: " + fd.findDisappearedNumbers(arr2));
    }
}
```

---

### Application 3: Sort Colors (Dutch National Flag)

```java
public class SortColors {
    /**
     * Sort array of 0s, 1s, 2s
     * LeetCode 75
     * Using counting sort or three-way partition
     */
    
    // Method 1: Counting sort
    public void sortColorsCount(int[] nums) {
        int[] count = new int[3];
        
        // Count
        for (int num : nums) {
            count[num]++;
        }
        
        // Reconstruct
        int index = 0;
        for (int color = 0; color < 3; color++) {
            while (count[color]-- > 0) {
                nums[index++] = color;
            }
        }
    }
    
    // Method 2: One-pass three-way partition (Dutch National Flag)
    public void sortColorsOnePass(int[] nums) {
        int low = 0;      // Boundary of 0s
        int mid = 0;      // Current element
        int high = nums.length - 1;  // Boundary of 2s
        
        while (mid <= high) {
            if (nums[mid] == 0) {
                swap(nums, low++, mid++);
            } else if (nums[mid] == 2) {
                swap(nums, mid, high--);
            } else {
                mid++;  // nums[mid] == 1
            }
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        SortColors sc = new SortColors();
        
        int[] arr1 = {2, 0, 2, 1, 1, 0};
        sc.sortColorsCount(arr1);
        System.out.println("Counting: " + Arrays.toString(arr1));
        
        int[] arr2 = {2, 0, 2, 1, 1, 0};
        sc.sortColorsOnePass(arr2);
        System.out.println("One-pass: " + Arrays.toString(arr2));
    }
}
```

---

## Interview Questions

### Question 1: H-Index

**Problem**: Given citations array, find researcher's h-index (h papers with at least h citations each).

```java
public class HIndex {
    /**
     * H-Index using counting sort concept
     * LeetCode 274
     * Time: O(n), Space: O(n)
     */
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] count = new int[n + 1];
        
        // Count papers by citations
        // Papers with n+ citations counted in count[n]
        for (int citation : citations) {
            if (citation >= n) {
                count[n]++;
            } else {
                count[citation]++;
            }
        }
        
        // Traverse from right to find h-index
        int total = 0;
        for (int i = n; i >= 0; i--) {
            total += count[i];
            
            // If we have total papers with at least i citations
            if (total >= i) {
                return i;
            }
        }
        
        return 0;
    }
    
    // Test
    public static void main(String[] args) {
        HIndex hi = new HIndex();
        
        int[] citations1 = {3, 0, 6, 1, 5};
        System.out.println("H-Index: " + hi.hIndex(citations1)); // 3
        // 3 papers with ≥3 citations: [3, 6, 5]
        
        int[] citations2 = {1, 3, 1};
        System.out.println("H-Index: " + hi.hIndex(citations2)); // 1
    }
}
```

---

### Question 2: Maximum Gap

**Problem**: Find maximum difference between successive elements in sorted array. O(n) time required.

```java
public class MaximumGap {
    /**
     * Maximum gap using bucket sort (counting sort variant)
     * LeetCode 164
     * Time: O(n), Space: O(n)
     */
    public int maximumGap(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }
        
        int n = nums.length;
        int min = nums[0], max = nums[0];
        
        // Find range
        for (int num : nums) {
            min = Math.min(min, num);
            max = Math.max(max, num);
        }
        
        if (min == max) return 0;
        
        // Bucket size (ceiling division)
        int bucketSize = (int) Math.ceil((double) (max - min) / (n - 1));
        int bucketCount = (max - min) / bucketSize + 1;
        
        // Buckets store min and max only
        int[] bucketMin = new int[bucketCount];
        int[] bucketMax = new int[bucketCount];
        Arrays.fill(bucketMin, Integer.MAX_VALUE);
        Arrays.fill(bucketMax, Integer.MIN_VALUE);
        
        // Place numbers in buckets
        for (int num : nums) {
            int idx = (num - min) / bucketSize;
            bucketMin[idx] = Math.min(bucketMin[idx], num);
            bucketMax[idx] = Math.max(bucketMax[idx], num);
        }
        
        // Find max gap between buckets
        int maxGap = 0;
        int prevMax = min;
        
        for (int i = 0; i < bucketCount; i++) {
            if (bucketMin[i] == Integer.MAX_VALUE) {
                continue; // Empty bucket
            }
            
            maxGap = Math.max(maxGap, bucketMin[i] - prevMax);
            prevMax = bucketMax[i];
        }
        
        return maxGap;
    }
    
    // Test
    public static void main(String[] args) {
        MaximumGap mg = new MaximumGap();
        
        int[] nums1 = {3, 6, 9, 1};
        System.out.println("Max gap: " + mg.maximumGap(nums1)); // 3
        // Sorted: [1, 3, 6, 9], gaps: 2, 3, 3 → max = 3
        
        int[] nums2 = {10};
        System.out.println("Max gap: " + mg.maximumGap(nums2)); // 0
    }
}
```

---

### Question 3: First Missing Positive

**Problem**: Find smallest missing positive integer in unsorted array. O(n) time, O(1) space.

```java
public class FirstMissingPositive {
    /**
     * Find first missing positive using counting sort idea
     * LeetCode 41
     * Time: O(n), Space: O(1)
     */
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        
        // Step 1: Mark presence using array indices
        // Place each number x at index x-1 if possible
        for (int i = 0; i < n; i++) {
            while (nums[i] > 0 && nums[i] <= n && 
                   nums[nums[i] - 1] != nums[i]) {
                // Swap to correct position
                int correctIdx = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[correctIdx];
                nums[correctIdx] = temp;
            }
        }
        
        // Step 2: Find first missing
        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        
        // All 1 to n present
        return n + 1;
    }
    
    // Alternative: Using sign marking
    public int firstMissingPositiveSign(int[] nums) {
        int n = nums.length;
        
        // Replace non-positive with n+1
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0) {
                nums[i] = n + 1;
            }
        }
        
        // Mark presence by negating
        for (int i = 0; i < n; i++) {
            int val = Math.abs(nums[i]);
            if (val <= n) {
                nums[val - 1] = -Math.abs(nums[val - 1]);
            }
        }
        
        // Find first positive
        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }
        
        return n + 1;
    }
    
    // Test
    public static void main(String[] args) {
        FirstMissingPositive fmp = new FirstMissingPositive();
        
        int[] nums1 = {1, 2, 0};
        System.out.println("First missing: " + 
            fmp.firstMissingPositive(nums1)); // 3
        
        int[] nums2 = {3, 4, -1, 1};
        System.out.println("First missing: " + 
            fmp.firstMissingPositive(nums2)); // 2
        
        int[] nums3 = {7, 8, 9, 11, 12};
        System.out.println("First missing: " + 
            fmp.firstMissingPositive(nums3)); // 1
    }
}
```

---

## Practice Problems

### Easy Level

1. **Sort an Array** (LeetCode 912)
   - Use counting sort when range is small
   - Otherwise use other O(n log n) sorts

2. **Sort Colors** (LeetCode 75)
   - Classic counting sort application
   - Or Dutch National Flag

3. **Relative Sort Array** (LeetCode 1122)
   - Counting sort with custom order
   - Count frequencies, output in order

### Medium Level

4. **H-Index** (LeetCode 274)
   - Counting sort concept
   - O(n) time solution

5. **Top K Frequent Elements** (LeetCode 347)
   - Count frequencies
   - Bucket sort or heap

6. **Sort Characters by Frequency** (LeetCode 451)
   - Count character frequencies
   - Sort by count

7. **Find All Duplicates in Array** (LeetCode 442)
   - Use indices as counting mechanism
   - O(1) space solution

8. **Find All Numbers Disappeared** (LeetCode 448)
   - Similar to duplicates
   - Mark using indices

### Hard Level

9. **First Missing Positive** (LeetCode 41)
   - O(n) time, O(1) space
   - Clever use of indices

10. **Maximum Gap** (LeetCode 164)
    - Bucket sort variant
    - O(n) time required

### Implementation Challenges

```java
public class CountingSortPractice {
    /**
     * Practice 1: Count sort for characters
     */
    public String sortString(String s) {
        int[] count = new int[256]; // ASCII
        
        for (char c : s.toCharArray()) {
            count[c]++;
        }
        
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 256; i++) {
            while (count[i]-- > 0) {
                sb.append((char) i);
            }
        }
        
        return sb.toString();
    }
    
    /**
     * Practice 2: Sort array by parity (even first)
     */
    public int[] sortByParity(int[] nums) {
        int[] count = new int[2]; // 0=even, 1=odd
        
        for (int num : nums) {
            count[num % 2]++;
        }
        
        int[] result = new int[nums.length];
        int idx = 0;
        
        // Even numbers first
        for (int num : nums) {
            if (num % 2 == 0) {
                result[idx++] = num;
            }
        }
        
        // Odd numbers
        for (int num : nums) {
            if (num % 2 == 1) {
                result[idx++] = num;
            }
        }
        
        return result;
    }
    
    /**
     * Practice 3: Rank transform of array
     */
    public int[] arrayRankTransform(int[] arr) {
        int n = arr.length;
        int[] sorted = arr.clone();
        Arrays.sort(sorted);
        
        Map<Integer, Integer> rank = new HashMap<>();
        int r = 1;
        
        for (int num : sorted) {
            if (!rank.containsKey(num)) {
                rank.put(num, r++);
            }
        }
        
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            result[i] = rank.get(arr[i]);
        }
        
        return result;
    }
}
```

---

## Summary

### Key Takeaways

1. **Non-comparison** - uses counting, not comparisons
2. **Linear time** - O(n + k) when k = O(n)
3. **Integer keys only** - doesn't work for floats/objects
4. **Range dependent** - efficient only when range is small
5. **Stable version** - requires cumulative count
6. **Building block** - used in radix sort

### Complexity Summary

| Case | Time | Space | Notes |
|------|------|-------|-------|
| Best | O(n + k) | O(n + k) | k = range |
| Average | O(n + k) | O(n + k) | Same as best |
| Worst | O(n + k) | O(n + k) | No degradation |
| k = O(n) | O(n) | O(n) | Linear time |
| k >> n | O(k) | O(k) | Inefficient |

### Comparison with Other Sorts

| Sort | Time | Space | Stable | Type | Works On |
|------|------|-------|--------|------|----------|
| Counting | O(n + k) | O(n + k) | Yes | Non-comparison | Integers |
| Radix | O(d(n + k)) | O(n + k) | Yes | Non-comparison | Integers |
| Bucket | O(n + k) | O(n + k) | Yes | Non-comparison | Any |
| Quick | O(n log n) | O(log n) | No | Comparison | Any |
| Merge | O(n log n) | O(n) | Yes | Comparison | Any |

### When to Use

| Scenario | Use Counting Sort? |
|----------|-------------------|
| Range k = O(n) | ✅ Perfect - O(n) time |
| Small range (k < 1000) | ✅ Very efficient |
| Large range (k >> n) | ❌ Wastes space |
| Integers only | ✅ Designed for this |
| Need stability | ✅ Stable version available |
| As radix subroutine | ✅ Standard approach |
| Floats or objects | ❌ Doesn't work |
| Unknown range | ❌ Can't allocate array |

### Variations Summary

| Variation | Description | Use Case |
|-----------|-------------|----------|
| Simple | Direct counting | Small range, don't need stability |
| Stable | Cumulative count | Objects, radix sort |
| Negative | Offset by min | Negative numbers |
| By digit | Count single digit | Radix sort subroutine |
| In-place | Reconstruct directly | Save space |

### Interview Tips

1. **Know when applicable**: Small integer range
2. **Stability matters**: Explain cumulative count
3. **Space trade-off**: O(k) space for O(n) time
4. **Handle negatives**: Offset by minimum value
5. **Compare to radix**: Counting is building block
6. **Index tricks**: Can use array indices cleverly
7. **O(n) sorting**: One of few O(n) sorts possible
8. **Real-world**: Used in radix sort, specialized cases

### Common Pitfalls

❌ Using when range is huge (k >> n)
❌ Forgetting to handle negative numbers
❌ Not checking if stable version needed
❌ Assuming works for floats or objects
❌ Not considering space complexity O(k)
❌ Off-by-one errors with range calculation

### Real-World Usage

- **Radix Sort**: Core subroutine for digit sorting
- **Histograms**: Counting frequencies
- **Age Sorting**: Limited range (0-120)
- **Grade Sorting**: Small range (0-100)
- **Pixel Sorting**: RGB values (0-255)
- **Character Sorting**: ASCII/Unicode range

### Advantages

✅ **O(n) time** - when k = O(n)
✅ **Stable** - with proper implementation
✅ **Simple** - easy to understand and code
✅ **Predictable** - no worst case

### Disadvantages

❌ **Space O(k)** - wasteful for large ranges
❌ **Integer only** - limited data types
❌ **Range dependent** - needs known range
❌ **Not general** - specialized use cases

---

**Next**: [6.8 Radix Sort](6.8-Radix-Sort.md) - Learn about radix sort (uses counting sort)

**Previous**: [6.6 Heap Sort](6.6-Heap-Sort.md)
