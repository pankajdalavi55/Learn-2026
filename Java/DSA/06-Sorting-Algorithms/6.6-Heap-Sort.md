# 6.6 Heap Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Heap Data Structure](#heap-data-structure)
3. [Basic Implementation](#basic-implementation)
4. [Building the Heap](#building-the-heap)
5. [Optimizations](#optimizations)
6. [Variations](#variations)
7. [Applications](#applications)
8. [Interview Questions](#interview-questions)
9. [Practice Problems](#practice-problems)
10. [Summary](#summary)

---

## Introduction

### What is Heap Sort?

**Heap sort** is a comparison-based sorting algorithm that:
- Uses a **binary heap** data structure
- **Builds** a max heap from the input array
- Repeatedly **extracts** the maximum element
- Places it at the end of the array in sorted order

### Visual Example

```
Original: [4, 10, 3, 5, 1]

Step 1: Build Max Heap
        10
       /  \
      5    3
     / \
    4   1
Array: [10, 5, 3, 4, 1]

Step 2: Extract max (10), swap with last, heapify
        5
       / \
      4   3
     /
    1    [10]
Array: [5, 4, 3, 1 | 10]

Step 3: Extract max (5), swap with last, heapify
        4
       / \
      1   3
           [5, 10]
Array: [4, 1, 3 | 5, 10]

Step 4: Extract max (4), swap with last, heapify
        3
       /
      1      [4, 5, 10]
Array: [3, 1 | 4, 5, 10]

Step 5: Extract max (3), swap with last, heapify
        1      [3, 4, 5, 10]
Array: [1 | 3, 4, 5, 10]

Final: [1, 3, 4, 5, 10]
```

### Heapify Process

```
Heapify subtree rooted at index i:

        4
       / \
      10  3
     / \
    5   1

Heapify(i=0): 4 < max(10, 3) → swap with 10
        
        10
       / \
      4   3
     / \
    5   1

Heapify(i=1): 4 < max(5, 1) → swap with 5

        10
       / \
      5   3
     / \
    4   1

Done! Max heap property satisfied.
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n log n)
  - Average: O(n log n)
  - Worst: O(n log n) - **guaranteed**
- **Space Complexity**: O(1) - **in-place**
- **Stability**: **Unstable** - relative order not maintained
- **Adaptive**: No - always O(n log n)
- **Comparison-based**: Yes

### When to Use

**Use Heap Sort**:
- ✅ **Guaranteed O(n log n)** worst case
- ✅ **O(1) space** required (in-place)
- ✅ Memory constrained environments
- ✅ Embedded systems
- ✅ When stability not needed

**Avoid Heap Sort**:
- ❌ Cache performance critical (poor locality)
- ❌ Stability required (use merge sort)
- ❌ Average case performance (quicksort faster)
- ❌ Small datasets (insertion sort better)

---

## Heap Data Structure

### Binary Heap Properties

**Max Heap**: Parent ≥ Children
```
        50
       /  \
      30   20
     / \   / \
    15 10 8  16
    
Array: [50, 30, 20, 15, 10, 8, 16]
Index:  0   1   2   3   4   5  6
```

**Min Heap**: Parent ≤ Children
```
        10
       /  \
      15   20
     / \   / \
    30 40 50 60
    
Array: [10, 15, 20, 30, 40, 50, 60]
```

### Array Representation

For node at index `i`:
- **Left child**: `2*i + 1`
- **Right child**: `2*i + 2`
- **Parent**: `(i - 1) / 2`

```
Array: [50, 30, 20, 15, 10, 8, 16]
        i=0 i=1 i=2 i=3 i=4 i=5 i=6

Parent(i=4) = (4-1)/2 = 1 → arr[1] = 30
Left(i=1) = 2*1+1 = 3 → arr[3] = 15
Right(i=1) = 2*1+2 = 4 → arr[4] = 10
```

### Heap Operations

| Operation | Time Complexity | Description |
|-----------|----------------|-------------|
| Insert | O(log n) | Add element, bubble up |
| Extract Max/Min | O(log n) | Remove root, heapify down |
| Get Max/Min | O(1) | Return root |
| Heapify | O(log n) | Fix heap property |
| Build Heap | O(n) | Create heap from array |

---

## Basic Implementation

### Standard Heap Sort

```java
public class HeapSort {
    /**
     * Heap sort - O(n log n) time, O(1) space
     * In-place sorting using max heap
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // Step 1: Build max heap - O(n)
        buildMaxHeap(arr, n);
        
        // Step 2: Extract elements one by one - O(n log n)
        for (int i = n - 1; i > 0; i--) {
            // Move current root (max) to end
            swap(arr, 0, i);
            
            // Heapify the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    /**
     * Build max heap from unsorted array
     * Start from last non-leaf node and heapify each
     */
    private void buildMaxHeap(int[] arr, int n) {
        // Index of last non-leaf node = (n/2) - 1
        int startIdx = (n / 2) - 1;
        
        // Perform reverse level order traversal
        // from last non-leaf node and heapify each
        for (int i = startIdx; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    
    /**
     * Heapify subtree rooted at index i
     * n is size of heap
     */
    private void heapify(int[] arr, int n, int i) {
        int largest = i;           // Initialize largest as root
        int left = 2 * i + 1;      // Left child
        int right = 2 * i + 2;     // Right child
        
        // If left child is larger than root
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // If right child is larger than largest so far
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // If largest is not root
        if (largest != i) {
            swap(arr, i, largest);
            
            // Recursively heapify the affected subtree
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        HeapSort hs = new HeapSort();
        
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Original: " + Arrays.toString(arr));
        
        hs.heapSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [12, 11, 13, 5, 6, 7]
Sorted: [5, 6, 7, 11, 12, 13]
```

**Complexity**: O(n log n) time, O(1) space

---

### With Detailed Steps

```java
public class HeapSortVerbose {
    public void heapSort(int[] arr) {
        int n = arr.length;
        System.out.println("Starting array: " + Arrays.toString(arr));
        
        // Build max heap
        System.out.println("\n=== Building Max Heap ===");
        buildMaxHeap(arr, n);
        System.out.println("Max heap built: " + Arrays.toString(arr));
        
        // Extract elements
        System.out.println("\n=== Extracting Elements ===");
        for (int i = n - 1; i > 0; i--) {
            System.out.println("\nStep " + (n - i) + ":");
            System.out.println("  Swap max " + arr[0] + 
                             " with arr[" + i + "]=" + arr[i]);
            swap(arr, 0, i);
            
            System.out.println("  Heapify remaining " + i + " elements");
            heapify(arr, i, 0);
            System.out.println("  Array: " + Arrays.toString(arr));
            System.out.println("  Sorted portion: " + 
                Arrays.toString(Arrays.copyOfRange(arr, i, n)));
        }
        
        System.out.println("\nFinal sorted: " + Arrays.toString(arr));
    }
    
    private void buildMaxHeap(int[] arr, int n) {
        int startIdx = (n / 2) - 1;
        
        for (int i = startIdx; i >= 0; i--) {
            System.out.println("  Heapify subtree at index " + i);
            heapify(arr, n, i);
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            System.out.println("    Swap arr[" + i + "]=" + arr[i] + 
                             " with arr[" + largest + "]=" + arr[largest]);
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        HeapSortVerbose hsv = new HeapSortVerbose();
        int[] arr = {4, 10, 3, 5, 1};
        hsv.heapSort(arr);
    }
}
```

---

### Iterative Heapify

```java
public class HeapSortIterative {
    /**
     * Iterative heapify - avoids recursion overhead
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapifyIterative(arr, n, i);
        }
        
        // Extract elements
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapifyIterative(arr, i, 0);
        }
    }
    
    /**
     * Iterative heapify - no recursion
     */
    private void heapifyIterative(int[] arr, int n, int i) {
        while (true) {
            int largest = i;
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            
            if (left < n && arr[left] > arr[largest]) {
                largest = left;
            }
            
            if (right < n && arr[right] > arr[largest]) {
                largest = right;
            }
            
            if (largest == i) {
                break;  // Heap property satisfied
            }
            
            swap(arr, i, largest);
            i = largest;  // Move down to affected child
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        HeapSortIterative hsi = new HeapSortIterative();
        
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Original: " + Arrays.toString(arr));
        
        hsi.heapSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Benefits**:
- No recursion overhead
- Better for stack-limited environments
- Slightly faster in practice

---

## Building the Heap

### Why Build Heap is O(n)?

**Naive approach**: Insert n elements → O(n log n)
**Optimal approach**: Bottom-up heapify → O(n)

```java
public class HeapBuildComparison {
    /**
     * Method 1: Insert elements one by one - O(n log n)
     * Each insert is O(log n), n insertions
     */
    public int[] buildHeapByInsertion(int[] arr) {
        int[] heap = new int[arr.length];
        int heapSize = 0;
        
        for (int i = 0; i < arr.length; i++) {
            heap[heapSize] = arr[i];
            heapSize++;
            
            // Bubble up
            int current = heapSize - 1;
            while (current > 0) {
                int parent = (current - 1) / 2;
                if (heap[current] > heap[parent]) {
                    swap(heap, current, parent);
                    current = parent;
                } else {
                    break;
                }
            }
        }
        
        return heap;
    }
    
    /**
     * Method 2: Bottom-up heapify - O(n)
     * More efficient!
     */
    public int[] buildHeapByHeapify(int[] arr) {
        int n = arr.length;
        
        // Start from last non-leaf node
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        return arr;
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Proof of O(n) for bottom-up**:
```
Height 0 (leaves): n/2 nodes, 0 swaps each = 0
Height 1: n/4 nodes, ≤1 swap each = n/4
Height 2: n/8 nodes, ≤2 swaps each = 2n/8
...
Height h: 1 node, ≤h swaps = h

Total = n/4 + 2n/8 + 3n/16 + ... = O(n)
```

---

## Optimizations

### Optimization 1: Min Heap Sort (Ascending)

```java
public class MinHeapSort {
    /**
     * Sort in ascending order using min heap
     * Build min heap, extract min repeatedly
     */
    public void minHeapSort(int[] arr) {
        int n = arr.length;
        
        // Build min heap
        buildMinHeap(arr, n);
        
        // Extract min elements
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            minHeapify(arr, i, 0);
        }
        
        // Result is in descending order, reverse it
        reverse(arr);
    }
    
    private void buildMinHeap(int[] arr, int n) {
        for (int i = n / 2 - 1; i >= 0; i--) {
            minHeapify(arr, n, i);
        }
    }
    
    private void minHeapify(int[] arr, int n, int i) {
        int smallest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] < arr[smallest]) {
            smallest = left;
        }
        
        if (right < n && arr[right] < arr[smallest]) {
            smallest = right;
        }
        
        if (smallest != i) {
            swap(arr, i, smallest);
            minHeapify(arr, n, smallest);
        }
    }
    
    private void reverse(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            swap(arr, left++, right--);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

### Optimization 2: Floyd's Heap Construction

```java
public class FloydHeapConstruction {
    /**
     * Floyd's optimized heap construction
     * Reduces comparisons during build phase
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // Floyd's heap construction
        floydBuildHeap(arr, n);
        
        // Standard extraction
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    /**
     * Floyd's algorithm: push down without comparisons
     * Then bubble up once at the end
     */
    private void floydBuildHeap(int[] arr, int n) {
        for (int i = n / 2 - 1; i >= 0; i--) {
            // Push down to leaf level
            int current = i;
            while (2 * current + 1 < n) {
                int child = 2 * current + 1;
                
                // Choose larger child (no comparison with parent yet)
                if (child + 1 < n && arr[child + 1] > arr[child]) {
                    child++;
                }
                
                swap(arr, current, child);
                current = child;
            }
            
            // Bubble up to correct position
            int temp = arr[current];
            while (current > i && temp > arr[(current - 1) / 2]) {
                arr[current] = arr[(current - 1) / 2];
                current = (current - 1) / 2;
            }
            arr[current] = temp;
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

**Benefits**:
- 20-30% fewer comparisons
- Better for large datasets

---

### Optimization 3: Binary Heap with Sentinel

```java
public class HeapSortSentinel {
    /**
     * Use sentinel value to eliminate boundary checks
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // Add space for 1-based indexing (optional optimization)
        int[] heap = new int[n + 1];
        System.arraycopy(arr, 0, heap, 1, n);
        
        // Build heap (1-based indexing)
        buildHeap1Based(heap, n);
        
        // Extract elements
        for (int i = n; i > 1; i--) {
            swap(heap, 1, i);
            heapify1Based(heap, i - 1, 1);
        }
        
        // Copy back
        System.arraycopy(heap, 1, arr, 0, n);
    }
    
    /**
     * 1-based heap indexing (cleaner code)
     * Parent: i/2, Left: 2*i, Right: 2*i+1
     */
    private void buildHeap1Based(int[] heap, int n) {
        for (int i = n / 2; i >= 1; i--) {
            heapify1Based(heap, n, i);
        }
    }
    
    private void heapify1Based(int[] heap, int n, int i) {
        int largest = i;
        int left = 2 * i;
        int right = 2 * i + 1;
        
        if (left <= n && heap[left] > heap[largest]) {
            largest = left;
        }
        
        if (right <= n && heap[right] > heap[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(heap, i, largest);
            heapify1Based(heap, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## Variations

### K-Way Heap Sort

```java
public class KWayHeapSort {
    private int k; // Number of children per node
    
    public KWayHeapSort(int k) {
        this.k = k;
    }
    
    /**
     * K-way heap sort (k children per node)
     * k=2: binary heap
     * k=3: ternary heap
     * k=4: quaternary heap
     */
    public void heapSort(int[] arr) {
        int n = arr.length;
        
        // Build k-way max heap
        buildKWayHeap(arr, n);
        
        // Extract elements
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapifyKWay(arr, i, 0);
        }
    }
    
    private void buildKWayHeap(int[] arr, int n) {
        int startIdx = (n - 2) / k;  // Last non-leaf node
        
        for (int i = startIdx; i >= 0; i--) {
            heapifyKWay(arr, n, i);
        }
    }
    
    private void heapifyKWay(int[] arr, int n, int i) {
        while (true) {
            int largest = i;
            
            // Check all k children
            for (int j = 1; j <= k; j++) {
                int child = k * i + j;
                if (child < n && arr[child] > arr[largest]) {
                    largest = child;
                }
            }
            
            if (largest == i) {
                break;
            }
            
            swap(arr, i, largest);
            i = largest;
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        // Binary heap (k=2)
        KWayHeapSort binary = new KWayHeapSort(2);
        int[] arr1 = {12, 11, 13, 5, 6, 7};
        binary.heapSort(arr1);
        System.out.println("Binary heap: " + Arrays.toString(arr1));
        
        // Ternary heap (k=3)
        KWayHeapSort ternary = new KWayHeapSort(3);
        int[] arr2 = {12, 11, 13, 5, 6, 7};
        ternary.heapSort(arr2);
        System.out.println("Ternary heap: " + Arrays.toString(arr2));
    }
}
```

---

### External Heap Sort

```java
public class ExternalHeapSort {
    /**
     * External heap sort for large files
     * Only keeps k elements in memory at a time
     */
    public void externalSort(String inputFile, String outputFile, int k) {
        // Phase 1: Create sorted runs
        List<String> runFiles = createSortedRuns(inputFile, k);
        
        // Phase 2: K-way merge using min heap
        kWayMerge(runFiles, outputFile);
    }
    
    /**
     * Read k elements at a time, sort using heap sort, write to file
     */
    private List<String> createSortedRuns(String inputFile, int k) {
        List<String> runFiles = new ArrayList<>();
        
        try (BufferedReader reader = new BufferedReader(
                new FileReader(inputFile))) {
            
            int runNumber = 0;
            int[] buffer = new int[k];
            int count;
            
            while ((count = readIntegers(reader, buffer, k)) > 0) {
                // Sort this run using heap sort
                int[] run = Arrays.copyOf(buffer, count);
                heapSort(run);
                
                // Write to temporary file
                String runFile = "run_" + runNumber + ".tmp";
                writeRun(run, runFile);
                runFiles.add(runFile);
                runNumber++;
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        return runFiles;
    }
    
    /**
     * K-way merge using min heap
     */
    private void kWayMerge(List<String> runFiles, String outputFile) {
        PriorityQueue<HeapNode> minHeap = new PriorityQueue<>(
            (a, b) -> a.value - b.value
        );
        
        BufferedReader[] readers = new BufferedReader[runFiles.size()];
        
        try {
            // Open all run files
            for (int i = 0; i < runFiles.size(); i++) {
                readers[i] = new BufferedReader(
                    new FileReader(runFiles.get(i)));
                
                String line = readers[i].readLine();
                if (line != null) {
                    minHeap.offer(new HeapNode(
                        Integer.parseInt(line), i));
                }
            }
            
            // Merge
            try (PrintWriter writer = new PrintWriter(outputFile)) {
                while (!minHeap.isEmpty()) {
                    HeapNode node = minHeap.poll();
                    writer.println(node.value);
                    
                    // Read next from same file
                    String line = readers[node.fileIndex].readLine();
                    if (line != null) {
                        minHeap.offer(new HeapNode(
                            Integer.parseInt(line), node.fileIndex));
                    }
                }
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // Close all readers
            for (BufferedReader reader : readers) {
                try {
                    if (reader != null) reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    private void heapSort(int[] arr) {
        int n = arr.length;
        
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        for (int i = n - 1; i > 0; i--) {
            swap(arr, 0, i);
            heapify(arr, i, 0);
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    private int readIntegers(BufferedReader reader, int[] buffer, int k) 
            throws IOException {
        int count = 0;
        String line;
        while (count < k && (line = reader.readLine()) != null) {
            buffer[count++] = Integer.parseInt(line);
        }
        return count;
    }
    
    private void writeRun(int[] run, String filename) throws IOException {
        try (PrintWriter writer = new PrintWriter(filename)) {
            for (int value : run) {
                writer.println(value);
            }
        }
    }
    
    static class HeapNode {
        int value;
        int fileIndex;
        
        HeapNode(int value, int fileIndex) {
            this.value = value;
            this.fileIndex = fileIndex;
        }
    }
}
```

---

## Applications

### Application 1: Priority Queue Implementation

```java
public class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity];
        this.size = 0;
    }
    
    /**
     * Insert element - O(log n)
     */
    public void insert(int value) {
        if (size >= capacity) {
            throw new IllegalStateException("Heap is full");
        }
        
        // Insert at end
        heap[size] = value;
        int current = size;
        size++;
        
        // Bubble up
        while (current > 0) {
            int parent = (current - 1) / 2;
            
            if (heap[current] > heap[parent]) {
                swap(current, parent);
                current = parent;
            } else {
                break;
            }
        }
    }
    
    /**
     * Extract max - O(log n)
     */
    public int extractMax() {
        if (size == 0) {
            throw new IllegalStateException("Heap is empty");
        }
        
        int max = heap[0];
        
        // Replace root with last element
        heap[0] = heap[size - 1];
        size--;
        
        // Heapify down
        heapify(0);
        
        return max;
    }
    
    /**
     * Get max - O(1)
     */
    public int getMax() {
        if (size == 0) {
            throw new IllegalStateException("Heap is empty");
        }
        return heap[0];
    }
    
    /**
     * Increase key value - O(log n)
     */
    public void increaseKey(int index, int newValue) {
        if (newValue < heap[index]) {
            throw new IllegalArgumentException(
                "New value is smaller than current");
        }
        
        heap[index] = newValue;
        
        // Bubble up
        while (index > 0) {
            int parent = (index - 1) / 2;
            
            if (heap[index] > heap[parent]) {
                swap(index, parent);
                index = parent;
            } else {
                break;
            }
        }
    }
    
    /**
     * Delete element - O(log n)
     */
    public void delete(int index) {
        // Increase to infinity, then extract
        increaseKey(index, Integer.MAX_VALUE);
        extractMax();
    }
    
    private void heapify(int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < size && heap[left] > heap[largest]) {
            largest = left;
        }
        
        if (right < size && heap[right] > heap[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }
    
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        MaxHeap pq = new MaxHeap(10);
        
        pq.insert(3);
        pq.insert(10);
        pq.insert(12);
        pq.insert(8);
        pq.insert(2);
        pq.insert(14);
        
        System.out.println("Max: " + pq.getMax());
        System.out.println("Extract: " + pq.extractMax());
        System.out.println("Max: " + pq.getMax());
    }
}
```

---

### Application 2: Kth Largest/Smallest Element

```java
public class KthLargestHeap {
    /**
     * Find kth largest using heap sort concept
     * Method 1: Build max heap, extract k times - O(n + k log n)
     */
    public int findKthLargest(int[] nums, int k) {
        int n = nums.length;
        
        // Build max heap
        buildMaxHeap(nums, n);
        
        // Extract max k-1 times
        for (int i = 0; i < k - 1; i++) {
            swap(nums, 0, n - 1 - i);
            heapify(nums, n - 1 - i, 0);
        }
        
        // kth largest is at root
        return nums[0];
    }
    
    /**
     * Method 2: Use min heap of size k - O(n log k)
     * More efficient for small k
     */
    public int findKthLargestMinHeap(int[] nums, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        
        for (int num : nums) {
            minHeap.offer(num);
            
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        
        return minHeap.peek();
    }
    
    /**
     * Find kth smallest using max heap of size k
     */
    public int findKthSmallest(int[] nums, int k) {
        PriorityQueue<Integer> maxHeap = 
            new PriorityQueue<>((a, b) -> b - a);
        
        for (int num : nums) {
            maxHeap.offer(num);
            
            if (maxHeap.size() > k) {
                maxHeap.poll();
            }
        }
        
        return maxHeap.peek();
    }
    
    private void buildMaxHeap(int[] arr, int n) {
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    
    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            heapify(arr, n, largest);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        KthLargestHeap klh = new KthLargestHeap();
        
        int[] nums = {3, 2, 1, 5, 6, 4};
        
        System.out.println("2nd largest: " + 
            klh.findKthLargest(nums, 2));
        System.out.println("2nd smallest: " + 
            klh.findKthSmallest(nums, 2));
    }
}
```

---

### Application 3: Merge K Sorted Arrays

```java
public class MergeKSorted {
    /**
     * Merge k sorted arrays using min heap
     * Time: O(n log k) where n = total elements
     */
    public int[] mergeKArrays(int[][] arrays) {
        PriorityQueue<HeapNode> minHeap = new PriorityQueue<>(
            (a, b) -> a.value - b.value
        );
        
        int totalSize = 0;
        
        // Add first element from each array
        for (int i = 0; i < arrays.length; i++) {
            if (arrays[i].length > 0) {
                minHeap.offer(new HeapNode(arrays[i][0], i, 0));
                totalSize += arrays[i].length;
            }
        }
        
        int[] result = new int[totalSize];
        int index = 0;
        
        // Extract min and add next element from same array
        while (!minHeap.isEmpty()) {
            HeapNode node = minHeap.poll();
            result[index++] = node.value;
            
            // Add next element from same array
            if (node.elementIndex + 1 < arrays[node.arrayIndex].length) {
                minHeap.offer(new HeapNode(
                    arrays[node.arrayIndex][node.elementIndex + 1],
                    node.arrayIndex,
                    node.elementIndex + 1
                ));
            }
        }
        
        return result;
    }
    
    static class HeapNode {
        int value;
        int arrayIndex;
        int elementIndex;
        
        HeapNode(int value, int arrayIndex, int elementIndex) {
            this.value = value;
            this.arrayIndex = arrayIndex;
            this.elementIndex = elementIndex;
        }
    }
    
    // Test
    public static void main(String[] args) {
        MergeKSorted mks = new MergeKSorted();
        
        int[][] arrays = {
            {1, 3, 5, 7},
            {2, 4, 6, 8},
            {0, 9, 10, 11}
        };
        
        int[] result = mks.mergeKArrays(arrays);
        System.out.println("Merged: " + Arrays.toString(result));
    }
}
```

---

## Interview Questions

### Question 1: Nearly Sorted Array

**Problem**: Sort a k-sorted array where each element is at most k positions away from its target position.

```java
public class NearlySortedArray {
    /**
     * Sort k-sorted array using min heap
     * Time: O(n log k), Space: O(k)
     * Better than O(n log n) heap sort
     */
    public void sortNearlySorted(int[] arr, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k + 1);
        
        int index = 0;
        
        // Add first k+1 elements to heap
        for (int i = 0; i <= k && i < arr.length; i++) {
            minHeap.offer(arr[i]);
        }
        
        // Process remaining elements
        for (int i = k + 1; i < arr.length; i++) {
            arr[index++] = minHeap.poll();
            minHeap.offer(arr[i]);
        }
        
        // Extract remaining elements
        while (!minHeap.isEmpty()) {
            arr[index++] = minHeap.poll();
        }
    }
    
    // Test
    public static void main(String[] args) {
        NearlySortedArray nsa = new NearlySortedArray();
        
        int[] arr = {6, 5, 3, 2, 8, 10, 9};
        int k = 3;
        
        System.out.println("Original: " + Arrays.toString(arr));
        nsa.sortNearlySorted(arr, k);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

---

### Question 2: Connect N Ropes with Minimum Cost

**Problem**: Given n ropes of different lengths, connect them into one rope. Cost to connect two ropes is their sum. Minimize total cost.

```java
public class ConnectRopes {
    /**
     * Use min heap to always connect smallest ropes
     * Greedy approach with heap
     * Time: O(n log n)
     */
    public int minimumCost(int[] ropes) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        
        // Add all ropes to heap
        for (int rope : ropes) {
            minHeap.offer(rope);
        }
        
        int totalCost = 0;
        
        // Connect ropes until one remains
        while (minHeap.size() > 1) {
            int first = minHeap.poll();
            int second = minHeap.poll();
            
            int cost = first + second;
            totalCost += cost;
            
            minHeap.offer(cost);
        }
        
        return totalCost;
    }
    
    // Test
    public static void main(String[] args) {
        ConnectRopes cr = new ConnectRopes();
        
        int[] ropes = {4, 3, 2, 6};
        System.out.println("Minimum cost: " + cr.minimumCost(ropes));
        
        // Explanation:
        // Connect 2+3=5, cost=5
        // Connect 4+5=9, cost=5+9=14
        // Connect 6+9=15, cost=14+15=29
    }
}
```

---

### Question 3: Running Median

**Problem**: Find the median of a stream of integers.

```java
public class RunningMedian {
    private PriorityQueue<Integer> maxHeap; // Lower half
    private PriorityQueue<Integer> minHeap; // Upper half
    
    /**
     * Two heaps approach:
     * maxHeap stores smaller half (max at top)
     * minHeap stores larger half (min at top)
     * Median is at top of heaps
     */
    public RunningMedian() {
        maxHeap = new PriorityQueue<>((a, b) -> b - a);
        minHeap = new PriorityQueue<>();
    }
    
    /**
     * Add number - O(log n)
     */
    public void addNum(int num) {
        // Add to appropriate heap
        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {
            maxHeap.offer(num);
        } else {
            minHeap.offer(num);
        }
        
        // Balance heaps (sizes differ by at most 1)
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.offer(maxHeap.poll());
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.offer(minHeap.poll());
        }
    }
    
    /**
     * Find median - O(1)
     */
    public double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        } else {
            return maxHeap.peek();
        }
    }
    
    // Test
    public static void main(String[] args) {
        RunningMedian rm = new RunningMedian();
        
        rm.addNum(1);
        System.out.println("Median: " + rm.findMedian()); // 1
        
        rm.addNum(2);
        System.out.println("Median: " + rm.findMedian()); // 1.5
        
        rm.addNum(3);
        System.out.println("Median: " + rm.findMedian()); // 2
        
        rm.addNum(4);
        System.out.println("Median: " + rm.findMedian()); // 2.5
    }
}
```

---

## Practice Problems

### Easy Level

1. **Kth Largest Element in Array** (LeetCode 215)
   - Use min heap of size k
   - Or heap sort and extract k times

2. **Last Stone Weight** (LeetCode 1046)
   - Max heap, repeatedly smash heaviest stones
   - Simulation using priority queue

3. **Sort Characters by Frequency** (LeetCode 451)
   - Count frequencies, use max heap
   - Extract in order

### Medium Level

4. **Top K Frequent Elements** (LeetCode 347)
   - HashMap + min heap of size k
   - Or bucket sort

5. **Kth Smallest Element in Sorted Matrix** (LeetCode 378)
   - Min heap with matrix navigation
   - Or binary search

6. **Reorganize String** (LeetCode 767)
   - Max heap by frequency
   - Greedy placement

7. **Find Median from Data Stream** (LeetCode 295)
   - Two heaps (max + min)
   - Balance heaps on insert

8. **Merge K Sorted Lists** (LeetCode 23)
   - Min heap of list nodes
   - O(n log k) solution

### Hard Level

9. **Sliding Window Median** (LeetCode 480)
   - Two heaps with removal
   - Or balanced BST

10. **IPO** (LeetCode 502)
    - Max heap for profits
    - Min heap for capital
    - Greedy selection

### Implementation Challenges

```java
public class HeapPractice {
    /**
     * Practice 1: Is array a max heap?
     */
    public boolean isMaxHeap(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n / 2; i++) {
            int left = 2 * i + 1;
            int right = 2 * i + 2;
            
            if (left < n && arr[i] < arr[left]) {
                return false;
            }
            
            if (right < n && arr[i] < arr[right]) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Practice 2: Convert min heap to max heap
     */
    public void convertMinToMax(int[] arr) {
        int n = arr.length;
        
        // Build max heap from bottom up
        for (int i = n / 2 - 1; i >= 0; i--) {
            maxHeapify(arr, n, i);
        }
    }
    
    private void maxHeapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr, i, largest);
            maxHeapify(arr, n, largest);
        }
    }
    
    /**
     * Practice 3: K largest elements in stream
     */
    public List<Integer> kLargest(int[] arr, int k) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k);
        
        for (int num : arr) {
            minHeap.offer(num);
            
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        
        return new ArrayList<>(minHeap);
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

---

## Summary

### Key Takeaways

1. **Binary heap** - complete binary tree stored in array
2. **O(n log n) guaranteed** - no worst case degradation
3. **In-place** - O(1) extra space (best for memory)
4. **Build heap is O(n)** - bottom-up heapify
5. **Not stable** - relative order not preserved
6. **Poor cache** - random memory access pattern

### Complexity Summary

| Operation | Time | Space | Notes |
|-----------|------|-------|-------|
| Build Heap | O(n) | O(1) | Bottom-up heapify |
| Heapify | O(log n) | O(1) | Single node fix |
| Extract Max/Min | O(log n) | O(1) | Remove root |
| Insert | O(log n) | O(1) | Add and bubble up |
| Heap Sort | O(n log n) | O(1) | All cases |

### Comparison with Other O(n log n) Sorts

| Sort | Worst Time | Space | Stable | Cache | In-place |
|------|-----------|-------|--------|-------|----------|
| Heap | O(n log n) | O(1) | No | Poor | Yes |
| Merge | O(n log n) | O(n) | Yes | Good | No |
| Quick | O(n²) | O(log n) | No | Good | Yes |

### Heap Variations

| Type | Children per Node | Height | Use Case |
|------|------------------|--------|----------|
| Binary | 2 | log₂ n | Standard |
| Ternary | 3 | log₃ n | Faster decrease-key |
| d-ary | d | logₐ n | Trade-off tuning |
| Fibonacci | Variable | O(log n) amortized | Dijkstra |

### When to Use

| Scenario | Use Heap Sort? |
|----------|----------------|
| Memory limited | ✅ O(1) space |
| Guaranteed O(n log n) | ✅ No worst case |
| Stability needed | ❌ Use merge sort |
| Cache performance | ❌ Use quicksort |
| Priority queue | ✅ Perfect fit |
| External sorting | ✅ K-way merge |
| Nearly sorted | ❌ Use insertion |

### Interview Tips

1. **Know heap property**: Parent ≥ children (max heap)
2. **Array indexing**: Parent=(i-1)/2, Left=2i+1, Right=2i+2
3. **Build heap is O(n)**: Not O(n log n), use bottom-up
4. **Two heaps pattern**: Running median, sliding window
5. **Min heap for k largest**: Counter-intuitive but correct
6. **Heapify vs build**: Heapify is O(log n), build is O(n)
7. **Applications**: Priority queue, k-way merge, top-k problems
8. **Not stable**: Can't maintain relative order

### Common Pitfalls

❌ Thinking build heap is O(n log n) (it's O(n))
❌ Using max heap for k largest (use min heap)
❌ Forgetting heap is 0-indexed in arrays
❌ Not handling edge cases (empty heap, single element)
❌ Assuming stability (heap sort is unstable)
❌ Poor cache performance (not cache-friendly)

### Real-World Usage

- **Priority Queues**: Task scheduling, event simulation
- **Dijkstra's Algorithm**: Shortest path with priority queue
- **Huffman Coding**: Data compression
- **Operating Systems**: Process scheduling
- **K-way Merge**: External sorting, merge sorted files
- **Top-K Problems**: Find k largest/smallest efficiently

### Advantages

✅ **Guaranteed O(n log n)** - no worst case like quicksort
✅ **O(1) space** - truly in-place sorting
✅ **No recursion** - can use iterative heapify
✅ **Priority queue** - natural data structure

### Disadvantages

❌ **Poor cache locality** - random access pattern
❌ **Not stable** - can't preserve order
❌ **Slower than quicksort** - higher constants in practice
❌ **More swaps** - more writes than merge sort

---

**Next**: [6.7 Counting Sort](6.7-Counting-Sort.md) - Learn about non-comparison sorting

**Previous**: [6.5 Quick Sort](6.5-Quick-Sort.md)
