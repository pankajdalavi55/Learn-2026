# Sorting Algorithms - Quick Reference Cheat Sheet

## Table of Contents
1. [Complexity Comparison Table](#complexity-comparison-table)
2. [Algorithm Quick Reference](#algorithm-quick-reference)
3. [When to Use Which Algorithm](#when-to-use-which-algorithm)
4. [Code Templates](#code-templates)
5. [Interview Cheat Sheet](#interview-cheat-sheet)
6. [Common Patterns](#common-patterns)

---

## Complexity Comparison Table

### Time & Space Complexity

| Algorithm | Best | Average | Worst | Space | Stable | In-Place |
|-----------|------|---------|-------|-------|--------|----------|
| **Bubble Sort** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… Yes | âœ… Yes |
| **Selection Sort** | O(nÂ²) | O(nÂ²) | O(nÂ²) | O(1) | âŒ No | âœ… Yes |
| **Insertion Sort** | O(n) | O(nÂ²) | O(nÂ²) | O(1) | âœ… Yes | âœ… Yes |
| **Merge Sort** | O(n log n) | O(n log n) | O(n log n) | O(n) | âœ… Yes | âŒ No |
| **Quick Sort** | O(n log n) | O(n log n) | O(nÂ²) | O(log n) | âŒ No | âœ… Yes |
| **Heap Sort** | O(n log n) | O(n log n) | O(n log n) | O(1) | âŒ No | âœ… Yes |
| **Counting Sort** | O(n + k) | O(n + k) | O(n + k) | O(k) | âœ… Yes | âŒ No |
| **Radix Sort** | O(dÂ·n) | O(dÂ·n) | O(dÂ·n) | O(n + k) | âœ… Yes | âŒ No |

**Legend**: 
- k = range of input values
- d = number of digits
- n = number of elements

---

## Algorithm Quick Reference

### 1. Bubble Sort ğŸ«§

**Concept**: Repeatedly swap adjacent elements if they're in wrong order

```java
// Optimized version
for (int i = 0; i < n - 1; i++) {
    boolean swapped = false;
    for (int j = 0; j < n - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr, j, j + 1);
            swapped = true;
        }
    }
    if (!swapped) break; // Already sorted
}
```

**Key Points**:
- âœ… Simple, easy to understand
- âœ… Adaptive with optimization (detects sorted)
- âœ… Stable
- âŒ O(nÂ²) - too slow for large data
- **Use when**: Teaching, n < 10, nearly sorted

---

### 2. Selection Sort ğŸ¯

**Concept**: Find minimum element, swap with first unsorted position

```java
for (int i = 0; i < n - 1; i++) {
    int minIdx = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIdx]) {
            minIdx = j;
        }
    }
    swap(arr, i, minIdx);
}
```

**Key Points**:
- âœ… **Minimum swaps** - exactly n-1 swaps
- âœ… O(1) space
- âŒ Not stable
- âŒ Always O(nÂ²) - no best case
- **Use when**: Swaps are expensive, n < 20

---

### 3. Insertion Sort ğŸ“¥

**Concept**: Build sorted array one element at a time

```java
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

**Key Points**:
- âœ… **Best for nearly sorted** - O(n) when sorted
- âœ… Stable, in-place, online algorithm
- âœ… Adaptive - performs well on partially sorted
- âŒ O(nÂ²) for random data
- **Use when**: Small arrays (n < 50), nearly sorted, online data

---

### 4. Merge Sort ğŸ”€

**Concept**: Divide array, recursively sort halves, merge

```java
void mergeSort(int[] arr, int left, int right) {
    if (left >= right) return;
    int mid = left + (right - left) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

**Key Points**:
- âœ… **Guaranteed O(n log n)** - no worst case
- âœ… Stable
- âœ… **Best for linked lists** - O(1) space on lists
- âœ… Good for external sorting
- âŒ O(n) space for arrays
- **Use when**: Stability needed, guaranteed performance, linked lists

---

### 5. Quick Sort âš¡

**Concept**: Pick pivot, partition around it, recursively sort

```java
void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

**Key Points**:
- âœ… **Fastest in practice** - O(n log n) average
- âœ… In-place (O(1) extra space)
- âœ… Cache-friendly
- âŒ **Worst case O(nÂ²)** - sorted arrays without randomization
- âŒ Not stable
- **Use when**: Average performance critical, memory limited

**Partitioning**:
- **Lomuto**: Simple, pivot = last element
- **Hoare**: 3x fewer swaps, more efficient
- **3-Way**: Best for duplicates

---

### 6. Heap Sort ğŸ”ï¸

**Concept**: Build max heap, repeatedly extract maximum

```java
void heapSort(int[] arr) {
    // Build heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    // Extract elements
    for (int i = n - 1; i > 0; i--) {
        swap(arr, 0, i);
        heapify(arr, i, 0);
    }
}
```

**Key Points**:
- âœ… **Guaranteed O(n log n)** + **O(1) space**
- âœ… No recursion needed (can use iterative)
- âŒ Not stable
- âŒ Poor cache locality
- **Use when**: Memory constrained, guaranteed performance needed

**Heap Property**: Parent â‰¥ Children (max heap)

---

### 7. Counting Sort ğŸ”¢

**Concept**: Count occurrences, calculate positions

```java
void countingSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    int[] count = new int[max + 1];
    
    // Count
    for (int num : arr) count[num]++;
    
    // Reconstruct
    int idx = 0;
    for (int i = 0; i <= max; i++) {
        while (count[i]-- > 0) arr[idx++] = i;
    }
}
```

**Key Points**:
- âœ… **Linear time O(n + k)** when k â‰ˆ n
- âœ… Stable (with cumulative count)
- âœ… Non-comparison based
- âŒ Only for **integers** in small range
- âŒ O(k) space - wasteful if k >> n
- **Use when**: Small integer range, k = O(n)

---

### 8. Radix Sort ğŸ“Š

**Concept**: Sort by individual digits (LSD to MSD)

```java
void radixSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    for (int exp = 1; max / exp > 0; exp *= 10) {
        countingSortByDigit(arr, exp);
    }
}
```

**Key Points**:
- âœ… **O(dÂ·n) time** - linear when d is constant
- âœ… Stable (uses stable counting sort)
- âœ… Good for **fixed-length** data (dates, phone numbers)
- âŒ Only for integers or fixed-length strings
- âŒ Space overhead O(n)
- **Use when**: Integers with few digits, fixed-length strings

**Variants**:
- **LSD**: Process right to left (simpler)
- **MSD**: Process left to right (can optimize early)

---

## When to Use Which Algorithm

### Decision Tree

```
Is data small (n < 10)?
â”œâ”€ YES â†’ Insertion Sort
â””â”€ NO
    â”œâ”€ Is data nearly sorted?
    â”‚   â””â”€ YES â†’ Insertion Sort
    â”‚
    â”œâ”€ Are integers in small range?
    â”‚   â””â”€ YES â†’ Counting Sort
    â”‚
    â”œâ”€ Are integers with few digits?
    â”‚   â””â”€ YES â†’ Radix Sort
    â”‚
    â”œâ”€ Is stability required?
    â”‚   â””â”€ YES â†’ Merge Sort
    â”‚
    â”œâ”€ Is memory severely limited?
    â”‚   â””â”€ YES â†’ Heap Sort
    â”‚
    â”œâ”€ Need guaranteed O(n log n)?
    â”‚   â””â”€ YES â†’ Merge Sort or Heap Sort
    â”‚
    â””â”€ General purpose?
        â””â”€ YES â†’ Quick Sort (with randomization)
```

### By Use Case

| Use Case | Algorithm | Reason |
|----------|-----------|--------|
| **Small arrays (n < 50)** | Insertion Sort | Simple, low overhead |
| **Nearly sorted** | Insertion Sort | O(n) best case, adaptive |
| **Need stability** | Merge Sort | Stable O(n log n) |
| **Memory limited** | Heap Sort | O(1) space, O(n log n) |
| **Average performance** | Quick Sort | Fastest in practice |
| **Linked lists** | Merge Sort | O(1) space on lists |
| **Guaranteed O(n log n)** | Merge/Heap Sort | No worst case |
| **Small integer range** | Counting Sort | O(n) time |
| **Fixed-length data** | Radix Sort | O(dÂ·n) time |
| **External sorting** | Merge Sort | Sequential access |
| **Minimize swaps** | Selection Sort | Only n-1 swaps |

---

## Code Templates

### Template 1: Comparison-Based In-Place

```java
public class SortTemplate {
    public void sort(int[] arr) {
        for (int i = 0; i < arr.length - 1; i++) {
            // Find/select element for position i
            int targetIdx = findTarget(arr, i);
            
            // Place element at position i
            swap(arr, i, targetIdx);
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### Template 2: Divide & Conquer

```java
public class DivideConquerSort {
    public void sort(int[] arr, int left, int right) {
        if (left >= right) return; // Base case
        
        // Divide
        int mid = partition(arr, left, right);
        
        // Conquer
        sort(arr, left, mid);
        sort(arr, mid + 1, right);
        
        // Combine (optional - merge sort needs this)
        merge(arr, left, mid, right);
    }
}
```

### Template 3: Non-Comparison (Counting)

```java
public class CountingTemplate {
    public void sort(int[] arr) {
        int max = findMax(arr);
        int[] count = new int[max + 1];
        
        // Count frequencies
        for (int num : arr) {
            count[num]++;
        }
        
        // Reconstruct sorted array
        int idx = 0;
        for (int val = 0; val <= max; val++) {
            while (count[val]-- > 0) {
                arr[idx++] = val;
            }
        }
    }
}
```

---

## Interview Cheat Sheet

### Must-Know Facts

**Stability**:
- **Stable**: Bubble, Insertion, Merge, Counting, Radix
- **Unstable**: Selection, Quick, Heap
- **Why it matters**: Sorting objects with multiple keys, radix sort requires stable subroutine

**In-Place**:
- **In-Place**: Bubble, Selection, Insertion, Quick, Heap
- **Not In-Place**: Merge, Counting, Radix
- **Why it matters**: Memory constraints, embedded systems

**Adaptive**:
- **Adaptive**: Bubble (with flag), Insertion
- **Non-Adaptive**: Selection, Merge, Heap, Quick (standard), Counting, Radix
- **Why it matters**: Performance on nearly sorted data

### Time Complexity Quick Facts

```
O(nÂ²) Algorithms:
- Bubble Sort: n(n-1)/2 comparisons worst case
- Selection Sort: Always n(n-1)/2 comparisons
- Insertion Sort: n(n-1)/2 comparisons worst, O(n) best

O(n log n) Algorithms:
- Merge Sort: Always O(n log n), T(n) = 2T(n/2) + n
- Quick Sort: Average O(n log n), worst O(nÂ²)
- Heap Sort: Always O(n log n)

O(n) Algorithms:
- Counting Sort: O(n + k) where k = range
- Radix Sort: O(dÂ·n) where d = digits
- Bucket Sort: O(n) average for uniform distribution
```

### Space Complexity Quick Facts

```
O(1) Extra Space:
- Bubble, Selection, Insertion, Heap

O(log n) Space (recursion):
- Quick Sort (best case, tail recursion)

O(n) Space:
- Merge Sort (array), Quick Sort (worst case)
- Counting Sort O(k), Radix Sort O(n + k)
```

### Algorithm Selection Flowchart

```
INPUT: Array to sort

1. Check constraints:
   - n < 50? â†’ Use Insertion Sort
   - Nearly sorted? â†’ Use Insertion Sort
   
2. Check data type:
   - Integers in range [0, k] where k â‰ˆ n? â†’ Counting Sort
   - Integers with d digits where d is small? â†’ Radix Sort
   
3. Check requirements:
   - Need stability? â†’ Merge Sort
   - Memory limited (O(1) space)? â†’ Heap Sort
   - Guaranteed O(n log n)? â†’ Merge/Heap Sort
   
4. Default:
   - Use Quick Sort (with randomization)
```

---

## Common Patterns

### Pattern 1: Two Pointers (Partitioning)

Used in: Quick Sort, Dutch National Flag

```java
// Partition pattern
int i = low - 1;
for (int j = low; j < high; j++) {
    if (arr[j] < pivot) {
        i++;
        swap(arr, i, j);
    }
}
swap(arr, i + 1, high);
```

### Pattern 2: Divide & Conquer

Used in: Merge Sort, Quick Sort

```java
// Divide & Conquer pattern
void sort(int[] arr, int left, int right) {
    if (left >= right) return;
    
    int mid = divide(arr, left, right);
    sort(arr, left, mid);
    sort(arr, mid + 1, right);
    conquer(arr, left, mid, right);
}
```

### Pattern 3: Counting/Bucketing

Used in: Counting Sort, Radix Sort, Bucket Sort

```java
// Counting pattern
int[] count = new int[range];
for (int num : arr) count[num]++;

// Cumulative for stable sort
for (int i = 1; i < range; i++) {
    count[i] += count[i - 1];
}

// Place elements
for (int i = n - 1; i >= 0; i--) {
    output[--count[arr[i]]] = arr[i];
}
```

### Pattern 4: Heap Operations

Used in: Heap Sort, Priority Queue

```java
// Heapify pattern
void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;
        
    if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, n, largest);
    }
}
```

---

## Interview Questions by Algorithm

### Bubble/Selection/Insertion Sort
- âœ“ Sort small arrays
- âœ“ Detect if array is already sorted
- âœ“ Minimum swaps to sort array

### Merge Sort
- âœ“ Count inversions (LeetCode 493)
- âœ“ Reverse pairs (LeetCode 493)
- âœ“ Sort linked list (LeetCode 148)
- âœ“ Count of smaller numbers after self (LeetCode 315)

### Quick Sort
- âœ“ Kth largest element (LeetCode 215)
- âœ“ Top K frequent elements (LeetCode 347)
- âœ“ Wiggle sort II (LeetCode 324)
- âœ“ Sort colors (LeetCode 75)
- âœ“ Nuts and bolts problem

### Heap Sort
- âœ“ Kth largest in stream (LeetCode 703)
- âœ“ Merge K sorted arrays/lists (LeetCode 23)
- âœ“ Find median from data stream (LeetCode 295)
- âœ“ Top K frequent (LeetCode 347)

### Counting Sort
- âœ“ Sort colors (LeetCode 75)
- âœ“ H-Index (LeetCode 274)
- âœ“ Find duplicates in [1,n] (LeetCode 442)
- âœ“ First missing positive (LeetCode 41)

### Radix Sort
- âœ“ Maximum gap (LeetCode 164)
- âœ“ Sort by frequency (LeetCode 1636)
- âœ“ Sort by number of 1 bits (LeetCode 1356)

---

## Key Interview Tips

### 1. Always Ask Clarifying Questions
- What's the size of input? (affects algorithm choice)
- What's the range of values?
- Is stability required?
- Is data nearly sorted?
- Memory constraints?
- Can we modify input array?

### 2. Complexity Analysis
- State time complexity: best, average, worst
- State space complexity: auxiliary + recursion
- Explain why (e.g., "O(nÂ²) because nested loops")

### 3. Optimization Opportunities
- **Quick Sort**: Randomize pivot, median-of-three, hybrid with insertion
- **Merge Sort**: Switch to insertion for small subarrays
- **Bubble Sort**: Early termination with swap flag
- **All**: Check if already sorted first

### 4. Edge Cases to Mention
- Empty array or single element
- Already sorted (best case for some)
- Reverse sorted (worst case for some)
- All duplicates
- Negative numbers (for counting/radix)

### 5. Real-World Usage
- **Java**: Arrays.sort() uses dual-pivot quicksort (primitives), TimSort (objects)
- **Python**: Timsort (hybrid of merge + insertion)
- **C++ STL**: Introsort (quicksort + heapsort fallback)

---

## Sorting Algorithm Trade-offs

| Priority | Choose | Trade-off |
|----------|--------|-----------|
| **Speed (average)** | Quick Sort | Risk O(nÂ²) worst case |
| **Guaranteed O(n log n)** | Merge/Heap | Extra space or poor cache |
| **Stability** | Merge Sort | Extra O(n) space |
| **Memory O(1)** | Heap Sort | Not stable, slower than quick |
| **Nearly sorted** | Insertion | O(nÂ²) for random data |
| **Small range** | Counting | O(k) space, integers only |
| **Few digits** | Radix | Integers only, O(dÂ·n) |

---

## Quick Comparison Grid

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Algorithm   â”‚ Fast?    â”‚ Stable?  â”‚ Space  â”‚ Simple?â”‚ Use When â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Bubble      â”‚ âŒ Slow  â”‚ âœ… Yes   â”‚ âœ… O(1)â”‚ âœ… Yes â”‚ Learning â”‚
â”‚ Selection   â”‚ âŒ Slow  â”‚ âŒ No    â”‚ âœ… O(1)â”‚ âœ… Yes â”‚ Min swapsâ”‚
â”‚ Insertion   â”‚ âš ï¸ OK    â”‚ âœ… Yes   â”‚ âœ… O(1)â”‚ âœ… Yes â”‚ Small/sortedâ”‚
â”‚ Merge       â”‚ âœ… Fast  â”‚ âœ… Yes   â”‚ âŒ O(n)â”‚ âš ï¸ Med â”‚ Stabilityâ”‚
â”‚ Quick       â”‚ âœ… Fastestâ”‚âŒ No    â”‚ âœ… O(1)â”‚ âš ï¸ Med â”‚ General  â”‚
â”‚ Heap        â”‚ âœ… Fast  â”‚ âŒ No    â”‚ âœ… O(1)â”‚ âš ï¸ Med â”‚ Memory   â”‚
â”‚ Counting    â”‚ âœ… Linearâ”‚ âœ… Yes   â”‚ âŒ O(k)â”‚ âœ… Yes â”‚ Small rangeâ”‚
â”‚ Radix       â”‚ âœ… Linearâ”‚ âœ… Yes   â”‚ âŒ O(n)â”‚ âš ï¸ Med â”‚ Integers â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Summary Cards

### ğŸ”µ O(nÂ²) Sorts (Simple)
```
Bubble Sort:    Swap adjacent if wrong order
Selection Sort: Find min, place at front
Insertion Sort: Insert into sorted portion

Use: Small arrays, learning, nearly sorted (insertion)
```

### ğŸŸ¢ O(n log n) Sorts (Efficient)
```
Merge Sort: Divide, sort, merge - stable, O(n) space
Quick Sort: Partition, recurse - fastest, unstable
Heap Sort:  Heapify, extract max - O(1) space

Use: General purpose, large datasets
```

### ğŸŸ¡ O(n) Sorts (Special Cases)
```
Counting Sort: Count frequencies - small integer range
Radix Sort:    Sort by digits - fixed-length integers

Use: Specialized constraints (integers, known range)
```

---

**Remember**: 
- No single "best" algorithm - depends on constraints
- In practice: Quick Sort for most cases, Merge for stability, Insertion for small
- Know time/space complexity and can code at least 3-4 algorithms
- Understand when O(n log n) barrier can be broken (counting, radix)

**Master Mantra**: "Small â†’ Insertion, Stable â†’ Merge, Fast â†’ Quick, Memory â†’ Heap, Range â†’ Counting"
