# 6.3 Insertion Sort

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Optimizations](#optimizations)
4. [Variations](#variations)
5. [Applications](#applications)
6. [Interview Questions](#interview-questions)
7. [Practice Problems](#practice-problems)
8. [Summary](#summary)

---

## Introduction

### What is Insertion Sort?

**Insertion sort** builds the sorted array one element at a time by:
- Picking elements from unsorted portion
- Finding correct position in sorted portion
- **Inserting** element by shifting others right
- Similar to sorting playing cards in hand

### Visual Example

```
Initial: [5, 2, 4, 6, 1, 3]
         ✓  ← sorted portion

Step 1: Insert 2 into sorted portion
[5, 2, 4, 6, 1, 3]
    ↑ pick
[2, 5, 4, 6, 1, 3]  Shift 5 right, insert 2
 ✓  ✓

Step 2: Insert 4
[2, 5, 4, 6, 1, 3]
       ↑ pick
[2, 4, 5, 6, 1, 3]  Shift 5 right, insert 4
 ✓  ✓  ✓

Step 3: Insert 6 (already in place)
[2, 4, 5, 6, 1, 3]
 ✓  ✓  ✓  ✓

Step 4: Insert 1
[2, 4, 5, 6, 1, 3]
             ↑ pick
[1, 2, 4, 5, 6, 3]  Shift all right, insert 1
 ✓  ✓  ✓  ✓  ✓

Step 5: Insert 3
[1, 2, 4, 5, 6, 3]
                ↑ pick
[1, 2, 3, 4, 5, 6]  Shift 4,5,6 right, insert 3
 ✓  ✓  ✓  ✓  ✓  ✓ sorted!
```

### Key Characteristics

- **Time Complexity**: 
  - Best: O(n) when already sorted
  - Average: O(n²)
  - Worst: O(n²) when reverse sorted
- **Space Complexity**: O(1) - in-place
- **Stability**: Stable - preserves relative order
- **Adaptive**: Yes - efficient for nearly sorted data
- **Online**: Can sort data as it arrives

### When to Use

**Use Insertion Sort**:
- ✅ **Small datasets** (n < 50)
- ✅ **Nearly sorted data** (very efficient!)
- ✅ **Online sorting** (process elements as they arrive)
- ✅ **Stable sort required**
- ✅ **Simple implementation** needed

**Avoid Insertion Sort**:
- ❌ Large random datasets (use quicksort, mergesort)
- ❌ Reverse sorted data (worst case O(n²))
- ❌ Performance-critical large data

---

## Basic Implementation

### Standard Insertion Sort

```java
public class InsertionSort {
    /**
     * Basic insertion sort
     * Best: O(n), Average/Worst: O(n²)
     */
    public void insertionSort(int[] arr) {
        int n = arr.length;
        
        // Start from second element (first is "sorted")
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // Element to insert
            int j = i - 1;
            
            // Shift elements greater than key to the right
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            // Insert key at correct position
            arr[j + 1] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSort is = new InsertionSort();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        System.out.println("Original: " + Arrays.toString(arr));
        
        is.insertionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Output**:
```
Original: [5, 2, 4, 6, 1, 3]
Sorted: [1, 2, 3, 4, 5, 6]
```

**Complexity**: O(n²) time average, O(1) space

---

### With Detailed Steps

```java
public class InsertionSortVerbose {
    public void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            System.out.println("\nStep " + i + ": Insert " + key);
            System.out.println("  Before: " + Arrays.toString(arr));
            
            int j = i - 1;
            int shifts = 0;
            
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                shifts++;
                j--;
            }
            
            arr[j + 1] = key;
            
            System.out.println("  Shifts: " + shifts);
            System.out.println("  After:  " + Arrays.toString(arr));
        }
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSortVerbose isv = new InsertionSortVerbose();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        System.out.println("Initial: " + Arrays.toString(arr));
        isv.insertionSort(arr);
    }
}
```

---

### Alternative: Using Swaps

```java
public class InsertionSortSwap {
    /**
     * Insertion sort using swaps instead of shifts
     * Less efficient but easier to understand
     */
    public void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            // Bubble current element to its position
            for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
                swap(arr, j, j - 1);
            }
        }
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSortSwap iss = new InsertionSortSwap();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        iss.insertionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Note**: Swap version is slower (more assignments) but conceptually simpler.

---

## Optimizations

### Binary Insertion Sort

```java
public class BinaryInsertionSort {
    /**
     * Use binary search to find insertion position
     * Reduces comparisons from O(n) to O(log n) per element
     */
    public void binaryInsertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            
            // Binary search for insertion position
            int pos = binarySearch(arr, 0, i - 1, key);
            
            // Shift elements to make room
            for (int j = i - 1; j >= pos; j--) {
                arr[j + 1] = arr[j];
            }
            
            // Insert key
            arr[pos] = key;
        }
    }
    
    private int binarySearch(int[] arr, int left, int right, int key) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == key) {
                return mid + 1; // Insert after equal element (stable)
            } else if (arr[mid] < key) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left; // Insertion position
    }
    
    // Test
    public static void main(String[] args) {
        BinaryInsertionSort bis = new BinaryInsertionSort();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bis.binaryInsertionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Improvement**: 
- Comparisons: O(n log n) instead of O(n²)
- Shifts: Still O(n²)
- Overall: Still O(n²) but faster in practice

---

### Sentinel Insertion Sort

```java
public class SentinelInsertionSort {
    /**
     * Use sentinel to eliminate boundary check
     * Slightly faster due to fewer comparisons per iteration
     */
    public void sentinelInsertionSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        
        int n = arr.length;
        
        // Find minimum and move to first position (sentinel)
        int minIdx = 0;
        for (int i = 1; i < n; i++) {
            if (arr[i] < arr[minIdx]) {
                minIdx = i;
            }
        }
        
        // Swap minimum to position 0
        int temp = arr[0];
        arr[0] = arr[minIdx];
        arr[minIdx] = temp;
        
        // Now arr[0] is sentinel (smallest), no need for j >= 0 check
        for (int i = 2; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // No boundary check needed (sentinel stops it)
            while (arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        SentinelInsertionSort sis = new SentinelInsertionSort();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        sis.sentinelInsertionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Advantage**: Removes one comparison per inner loop iteration

---

## Variations

### Descending Order

```java
public class InsertionSortDescending {
    public void insertionSortDesc(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // Change comparison: shift smaller elements right
            while (j >= 0 && arr[j] < key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSortDescending isd = new InsertionSortDescending();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        isd.insertionSortDesc(arr);
        System.out.println("Descending: " + Arrays.toString(arr));
        // [6, 5, 4, 3, 2, 1]
    }
}
```

---

### Generic Insertion Sort

```java
public class GenericInsertionSort {
    /**
     * Generic insertion sort for any Comparable type
     */
    public <T extends Comparable<T>> void insertionSort(T[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            T key = arr[i];
            int j = i - 1;
            
            while (j >= 0 && arr[j].compareTo(key) > 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        GenericInsertionSort gis = new GenericInsertionSort();
        
        String[] strings = {"banana", "apple", "cherry", "date"};
        gis.insertionSort(strings);
        System.out.println("Strings: " + Arrays.toString(strings));
        
        Integer[] numbers = {5, 2, 4, 6, 1, 3};
        gis.insertionSort(numbers);
        System.out.println("Numbers: " + Arrays.toString(numbers));
    }
}
```

---

### Custom Comparator

```java
public class InsertionSortComparator {
    /**
     * Insertion sort with custom comparator
     */
    public <T> void insertionSort(T[] arr, Comparator<T> comp) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            T key = arr[i];
            int j = i - 1;
            
            while (j >= 0 && comp.compare(arr[j], key) > 0) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSortComparator isc = new InsertionSortComparator();
        
        String[] words = {"apple", "pie", "a", "cat", "zoo"};
        
        // Sort by length
        isc.insertionSort(words, Comparator.comparingInt(String::length));
        System.out.println("By length: " + Arrays.toString(words));
        // [a, cat, pie, zoo, apple]
        
        // Sort reverse alphabetically
        isc.insertionSort(words, Comparator.reverseOrder());
        System.out.println("Reverse: " + Arrays.toString(words));
    }
}
```

---

### Recursive Insertion Sort

```java
public class RecursiveInsertionSort {
    /**
     * Recursive implementation of insertion sort
     */
    public void insertionSortRecursive(int[] arr, int n) {
        // Base case
        if (n <= 1) return;
        
        // Sort first n-1 elements
        insertionSortRecursive(arr, n - 1);
        
        // Insert last element at correct position
        int key = arr[n - 1];
        int j = n - 2;
        
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
    
    // Test
    public static void main(String[] args) {
        RecursiveInsertionSort ris = new RecursiveInsertionSort();
        
        int[] arr = {5, 2, 4, 6, 1, 3};
        ris.insertionSortRecursive(arr, arr.length);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Complexity**: O(n²) time, O(n) space for recursion stack

---

## Applications

### Application 1: Sort Linked List

```java
public class InsertionSortLinkedList {
    static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
        }
    }
    
    /**
     * Insertion sort for linked list
     * More efficient than for arrays (no shifting needed)
     */
    public Node insertionSort(Node head) {
        if (head == null || head.next == null) return head;
        
        Node sorted = null; // Head of sorted list
        Node current = head;
        
        while (current != null) {
            Node next = current.next;
            
            // Insert current into sorted list
            sorted = sortedInsert(sorted, current);
            
            current = next;
        }
        
        return sorted;
    }
    
    private Node sortedInsert(Node sorted, Node newNode) {
        // Insert at beginning
        if (sorted == null || newNode.data <= sorted.data) {
            newNode.next = sorted;
            return newNode;
        }
        
        // Find insertion point
        Node current = sorted;
        while (current.next != null && current.next.data < newNode.data) {
            current = current.next;
        }
        
        // Insert
        newNode.next = current.next;
        current.next = newNode;
        
        return sorted;
    }
    
    // Helper methods
    private void printList(Node head) {
        Node curr = head;
        while (curr != null) {
            System.out.print(curr.data + " ");
            curr = curr.next;
        }
        System.out.println();
    }
    
    // Test
    public static void main(String[] args) {
        InsertionSortLinkedList isll = new InsertionSortLinkedList();
        
        Node head = new Node(5);
        head.next = new Node(2);
        head.next.next = new Node(4);
        head.next.next.next = new Node(1);
        
        System.out.print("Original: ");
        isll.printList(head);
        
        head = isll.insertionSort(head);
        
        System.out.print("Sorted: ");
        isll.printList(head);
    }
}
```

**Advantage**: O(1) space for linked list (vs O(n log n) for merge sort)

---

### Application 2: Online Sorting

```java
public class OnlineInsertion {
    private List<Integer> sorted;
    
    public OnlineInsertion() {
        sorted = new ArrayList<>();
    }
    
    /**
     * Add element and maintain sorted order
     * O(n) per insertion
     */
    public void insert(int value) {
        // Binary search for position
        int pos = Collections.binarySearch(sorted, value);
        
        if (pos < 0) {
            pos = -(pos + 1); // Convert to insertion point
        }
        
        sorted.add(pos, value);
    }
    
    public List<Integer> getSorted() {
        return new ArrayList<>(sorted);
    }
    
    // Test
    public static void main(String[] args) {
        OnlineInsertion oi = new OnlineInsertion();
        
        int[] stream = {5, 2, 8, 1, 9, 3};
        
        for (int num : stream) {
            oi.insert(num);
            System.out.println("After inserting " + num + ": " + oi.getSorted());
        }
    }
}
```

**Use case**: Processing streaming data that needs to stay sorted

---

### Application 3: Shell Sort (Gap Insertion Sort)

```java
public class ShellSort {
    /**
     * Shell sort: insertion sort with decreasing gaps
     * More efficient than standard insertion sort
     */
    public void shellSort(int[] arr) {
        int n = arr.length;
        
        // Start with large gap, reduce by half each time
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // Insertion sort with gap
            for (int i = gap; i < n; i++) {
                int key = arr[i];
                int j = i;
                
                while (j >= gap && arr[j - gap] > key) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                
                arr[j] = key;
            }
        }
    }
    
    // Test
    public static void main(String[] args) {
        ShellSort ss = new ShellSort();
        
        int[] arr = {12, 34, 54, 2, 3};
        System.out.println("Original: " + Arrays.toString(arr));
        
        ss.shellSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}
```

**Complexity**: O(n log²n) to O(n^1.5) depending on gap sequence  
**Advantage**: Much faster than O(n²) insertion sort on large arrays

---

## Interview Questions

### Q1: What is the time complexity of insertion sort?

**Answer**:

- **Best case**: O(n) - when array is already sorted
- **Average case**: O(n²)
- **Worst case**: O(n²) - when array is reverse sorted

**Detailed analysis**:

**Best case** (sorted array):
```
[1, 2, 3, 4, 5]
Each element: 1 comparison, 0 shifts
Total: n comparisons = O(n)
```

**Worst case** (reverse sorted):
```
[5, 4, 3, 2, 1]
Element i needs i comparisons and shifts
Total: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2 = O(n²)
```

**Average case**: O(n²) - about half of worst case

---

### Q2: Why is insertion sort good for nearly sorted data?

**Answer**: **Adaptive** - performs fewer operations when data is nearly sorted.

**Example**:
```java
Already sorted: [1, 2, 3, 4, 5]
Complexity: O(n) - each element only compared once

Nearly sorted: [1, 2, 4, 3, 5]
               Only 3 needs to move (2 operations)
Complexity: O(n + k) where k = inversions
```

**Practical measurement**:
```java
public int countOperations(int[] arr) {
    int operations = 0;
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
            operations++; // Count shift
        }
        arr[j + 1] = key;
    }
    return operations;
}

// Nearly sorted: operations ≈ O(n)
// Random: operations ≈ O(n²)
```

**This is why** many hybrid sorts (like Timsort) use insertion sort for small/nearly sorted subarrays.

---

### Q3: Is insertion sort stable?

**Answer**: **Yes**, insertion sort is **stable**.

**Stability** maintained by:
```java
while (j >= 0 && arr[j] > key) {  // Note: strictly greater
    arr[j + 1] = arr[j];
    j--;
}
```

**Example**:
```
Input:  [5a, 3, 5b, 2]

Step 1: Insert 3 → [3, 5a, 5b, 2]
Step 2: 5b stays after 5a → [3, 5a, 5b, 2]
Step 3: Insert 2 → [2, 3, 5a, 5b]

Result: 5a still before 5b ✓
```

**Key**: Using `>` (not `>=`) ensures equal elements maintain order.

---

### Q4: When is insertion sort better than quicksort?

**Answer**:

**Insertion sort better when**:

1. **Small arrays** (n < 10-50)
```
Insertion: O(n²) but low constant factor
Quicksort: O(n log n) but high constant + recursion overhead
```

2. **Nearly sorted data**
```
Insertion: O(n) best case
Quicksort: O(n log n) always
```

3. **Online sorting**
```
Insertion: Can insert elements one at a time
Quicksort: Needs all data upfront
```

4. **Linked lists**
```
Insertion: O(n²) time, O(1) space
Quicksort: Difficult to implement efficiently
```

**Real usage**: Many optimized sorts use **hybrid approach**:
```java
// Quicksort implementation
if (right - left < 10) {
    insertionSort(arr, left, right); // Switch to insertion
} else {
    quicksort(arr, left, right);
}
```

**Examples**: Java's Arrays.sort(), Python's Timsort

---

### Q5: What's the difference between insertion sort and selection sort?

**Answer**:

| Feature | Insertion Sort | Selection Sort |
|---------|----------------|----------------|
| **Method** | Insert into sorted portion | Find min, place at end of sorted |
| **Comparisons** | O(n) to O(n²) | Always O(n²) |
| **Shifts/Swaps** | O(n²) shifts | O(n) swaps |
| **Best case** | O(n) | O(n²) |
| **Adaptive** | Yes | No |
| **Stable** | Yes | No |
| **Online** | Yes | No |

**Visual comparison**:
```
Array: [5, 2, 4, 1, 3]

Insertion: Pick 2, insert in sorted portion [2, 5]
Selection: Find min (1), swap with first [1, 2, 4, 5, 3]
```

**Verdict**: 
- Insertion better for: nearly sorted, small data, online
- Selection better for: minimize swaps (expensive writes)
- **Generally**: Insertion sort preferred

---

### Q6: Can insertion sort be implemented iteratively and recursively?

**Answer**: **Yes**, both ways.

**Iterative** (standard):
```java
public void insertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

**Recursive**:
```java
public void insertionSortRec(int[] arr, int n) {
    if (n <= 1) return;
    
    insertionSortRec(arr, n - 1); // Sort first n-1
    
    // Insert nth element
    int key = arr[n - 1];
    int j = n - 2;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

**Comparison**:
- Iterative: O(1) space ✅
- Recursive: O(n) space for call stack
- **Iterative preferred** - less overhead

---

### Q7: What is binary insertion sort?

**Answer**: **Optimization** using binary search to find insertion position.

**Standard insertion**: Linear search for position - O(n) comparisons per element

**Binary insertion**: Binary search for position - O(log n) comparisons per element

```java
public void binaryInsertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        
        // Binary search for position
        int pos = binarySearch(arr, 0, i - 1, key);
        
        // Shift elements (still O(n) per element)
        for (int j = i - 1; j >= pos; j--) {
            arr[j + 1] = arr[j];
        }
        
        arr[pos] = key;
    }
}
```

**Complexity**:
- Comparisons: O(n log n) ✅ Better
- Shifts: O(n²) ❌ Same
- **Overall**: Still O(n²) but faster in practice

**When useful**: When comparisons are expensive (complex objects)

---

### Q8: Is insertion sort in-place?

**Answer**: **Yes**, insertion sort is **in-place**.

**Space complexity**: O(1) - only uses constant extra space

**Why**:
```java
public void insertionSort(int[] arr) {
    // Only extra variables:
    int key;  // O(1)
    int j;    // O(1)
    
    // No auxiliary arrays created
    // Sorting happens within input array
}
```

**Comparison**:
```
In-place (O(1) space):
  - Insertion sort ✅
  - Selection sort ✅
  - Bubble sort ✅
  - Heap sort ✅

Not in-place:
  - Merge sort: O(n)
  - Counting sort: O(k)
```

---

### Q9: What is the best case scenario for insertion sort?

**Answer**: **Already sorted array** - O(n) time

**Why**:
```java
Array: [1, 2, 3, 4, 5]

For each element:
  - One comparison: arr[j] > key? No
  - Zero shifts
  - Move to next element

Total: n - 1 comparisons = O(n)
```

**Code path**:
```java
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    
    // This condition immediately false for sorted array
    while (j >= 0 && arr[j] > key) {  
        // Never enters loop
    }
    
    arr[j + 1] = key; // Just reassigns same position
}
```

**This makes insertion sort excellent** for maintaining sorted lists or sorting nearly sorted data.

---

### Q10: How does insertion sort handle duplicates?

**Answer**: **Correctly and stably** handles duplicates.

**Behavior**:
```java
Input: [5, 2, 5, 1, 5]

Step by step:
[5a, 2, 5b, 1, 5c]
[2, 5a, 5b, 1, 5c]  ← 2 inserted before all 5s
[2, 5a, 5b, 1, 5c]  ← 5b stays after 5a
[1, 2, 5a, 5b, 5c]  ← 1 inserted at start
[1, 2, 5a, 5b, 5c]  ← 5c stays after 5a and 5b

Result: All duplicates maintain relative order
```

**Key code**:
```java
while (j >= 0 && arr[j] > key) {  // Strictly greater
    // Equal elements not shifted
}
```

**Because `>` not `>=`**, equal elements stay in place - guaranteeing **stability**.

---

## Practice Problems

### Problem 1: Insertion Sort List (LeetCode 147)

**Description**: Sort a linked list using insertion sort.

**Solution**:
```java
public class InsertionSortList {
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int val) { this.val = val; }
    }
    
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) return head;
        
        ListNode dummy = new ListNode(0);
        ListNode curr = head;
        
        while (curr != null) {
            ListNode next = curr.next;
            ListNode prev = dummy;
            
            // Find insertion position
            while (prev.next != null && prev.next.val < curr.val) {
                prev = prev.next;
            }
            
            // Insert current
            curr.next = prev.next;
            prev.next = curr;
            
            curr = next;
        }
        
        return dummy.next;
    }
}
```

**Complexity**: O(n²) time, O(1) space

---

### Problem 2: Sort Array By Parity (LeetCode 905)

**Description**: Move all even numbers before odd numbers.

**Solution**:
```java
public class SortArrayByParity {
    /**
     * Two-pointer approach (more efficient than insertion sort)
     */
    public int[] sortArrayByParity(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            if (nums[left] % 2 > nums[right] % 2) {
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
            
            if (nums[left] % 2 == 0) left++;
            if (nums[right] % 2 == 1) right--;
        }
        
        return nums;
    }
}
```

---

### Problem 3: Merge Sorted Array (LeetCode 88)

**Description**: Merge two sorted arrays in-place.

**Solution**:
```java
public class MergeSortedArray {
    /**
     * Merge from back to avoid overwriting
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;      // Last element in nums1
        int j = n - 1;      // Last element in nums2
        int k = m + n - 1;  // Last position
        
        while (j >= 0) {
            if (i >= 0 && nums1[i] > nums2[j]) {
                nums1[k--] = nums1[i--];
            } else {
                nums1[k--] = nums2[j--];
            }
        }
    }
}
```

**Complexity**: O(m + n) time, O(1) space

---

## Summary

### Key Takeaways

1. **Adaptive** - O(n) on sorted data, O(n²) on random
2. **Stable** - preserves relative order of equal elements
3. **Online** - can sort data as it arrives
4. **In-place** - O(1) extra space
5. **Simple** - easy to implement and understand

### Complexity Summary

| Case | Time | Space |
|------|------|-------|
| Best (sorted) | O(n) | O(1) |
| Average | O(n²) | O(1) |
| Worst (reverse) | O(n²) | O(1) |

### Comparison with Other Sorts

| Sort | Best | Average | Stable | Adaptive | Online |
|------|------|---------|--------|----------|--------|
| Insertion | O(n) | O(n²) | Yes | Yes | Yes |
| Selection | O(n²) | O(n²) | No | No | No |
| Bubble | O(n)* | O(n²) | Yes | Yes* | No |
| Quick | O(n log n) | O(n log n) | No | No | No |
| Merge | O(n log n) | O(n log n) | Yes | No | No |

*with optimization

### When to Use

| Scenario | Use Insertion Sort? |
|----------|-------------------|
| Small data (n < 50) | ✅ Best choice |
| Nearly sorted | ✅ Excellent (O(n)) |
| Online sorting | ✅ Only option |
| Linked lists | ✅ Simple & efficient |
| Large random data | ❌ Use quicksort |
| Guaranteed O(n log n) | ❌ Use mergesort |

### Real-World Usage

1. **Hybrid sorts**: Used in Timsort (Python), Java Arrays.sort() for small subarrays
2. **Online algorithms**: Maintaining sorted streams
3. **Embedded systems**: Simple, predictable, low memory
4. **Teaching**: Best for learning sorting concepts

### Interview Tips

1. **Know best case**: O(n) for sorted data (unique among simple sorts)
2. **Explain adaptivity**: Efficient for nearly sorted data
3. **Show stability**: Maintains order with `>` not `>=`
4. **Compare to selection**: Better in most cases
5. **Mention optimizations**: Binary insertion, shell sort

---

**Next**: [6.4 Merge Sort](6.4-Merge-Sort.md) - Learn about divide-and-conquer sorting
