# 5.5 Searching Algorithms - Practice Problems

## Table of Contents
1. [Easy Problems](#easy-problems)
2. [Medium Problems](#medium-problems)
3. [Hard Problems](#hard-problems)
4. [Company-Specific Problems](#company-specific-problems)
5. [Quick Reference](#quick-reference)

---

## Easy Problems

### Problem 1: First Bad Version (LeetCode 278)

**Description**: Find first bad version using binary search API.

**Solution**:
```java
public class FirstBadVersion {
    // API provided
    boolean isBadVersion(int version) {
        // Simulated implementation
        return version >= 4;
    }
    
    public int firstBadVersion(int n) {
        int left = 1, right = n;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (isBadVersion(mid)) {
                right = mid; // First bad is at or before mid
            } else {
                left = mid + 1; // First bad is after mid
            }
        }
        
        return left;
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Pattern**: Lower bound binary search

---

### Problem 2: Search Insert Position (LeetCode 35)

**Description**: Find index to insert target in sorted array.

**Solution**:
```java
public class SearchInsert {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Pattern**: Lower bound (first position >= target)

---

### Problem 3: Valid Perfect Square (LeetCode 367)

**Description**: Check if number is perfect square without sqrt().

**Solution**:
```java
public class ValidPerfectSquare {
    public boolean isPerfectSquare(int num) {
        if (num < 2) return true;
        
        long left = 2, right = num / 2;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;
            
            if (square == num) return true;
            else if (square < num) left = mid + 1;
            else right = mid - 1;
        }
        
        return false;
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Pattern**: Binary search with overflow handling

---

### Problem 4: Sqrt(x) (LeetCode 69)

**Description**: Compute integer square root.

**Solution**:
```java
public class Sqrt {
    public int mySqrt(int x) {
        if (x < 2) return x;
        
        long left = 1, right = x / 2;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;
            
            if (square == x) return (int)mid;
            else if (square < x) left = mid + 1;
            else right = mid - 1;
        }
        
        return (int)right;
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 5: Peak Index in Mountain Array (LeetCode 852)

**Description**: Find peak in mountain array (guaranteed single peak).

**Solution**:
```java
public class PeakIndexMountain {
    public int peakIndexInMountainArray(int[] arr) {
        int left = 0, right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < arr[mid + 1]) {
                left = mid + 1; // Peak is on right
            } else {
                right = mid; // Peak is at or left of mid
            }
        }
        
        return left;
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

## Medium Problems

### Problem 6: Find First and Last Position (LeetCode 34)

**Description**: Find start and end positions of target in sorted array.

**Solution**:
```java
public class FindRange {
    public int[] searchRange(int[] nums, int target) {
        int first = findFirst(nums, target);
        if (first == -1) return new int[]{-1, -1};
        
        int last = findLast(nums, target);
        return new int[]{first, last};
    }
    
    private int findFirst(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                result = mid;
                right = mid - 1; // Continue searching left
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    private int findLast(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                result = mid;
                left = mid + 1; // Continue searching right
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Pattern**: Binary search with continuation

---

### Problem 7: Search in Rotated Sorted Array (LeetCode 33)

**Description**: Search in rotated sorted array (no duplicates).

**Solution**:
```java
public class SearchRotated {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) return mid;
            
            // Determine which half is sorted
            if (nums[left] <= nums[mid]) {
                // Left half is sorted
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // Right half is sorted
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Pattern**: Modified binary search for rotated array

---

### Problem 8: Find Minimum in Rotated Sorted Array (LeetCode 153)

**Description**: Find minimum in rotated sorted array.

**Solution**:
```java
public class FindMinRotated {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[right]) {
                // Minimum is in right half
                left = mid + 1;
            } else {
                // Minimum is in left half (including mid)
                right = mid;
            }
        }
        
        return nums[left];
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 9: Capacity To Ship Packages (LeetCode 1011)

**Description**: Find minimum capacity to ship within D days.

**Solution**:
```java
public class ShipPackages {
    public int shipWithinDays(int[] weights, int days) {
        int left = 0, right = 0;
        
        for (int w : weights) {
            left = Math.max(left, w);
            right += w;
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canShip(weights, days, mid)) {
                right = mid; // Try smaller capacity
            } else {
                left = mid + 1; // Need larger capacity
            }
        }
        
        return left;
    }
    
    private boolean canShip(int[] weights, int days, int capacity) {
        int daysNeeded = 1, currentLoad = 0;
        
        for (int w : weights) {
            if (currentLoad + w > capacity) {
                daysNeeded++;
                currentLoad = w;
                if (daysNeeded > days) return false;
            } else {
                currentLoad += w;
            }
        }
        
        return true;
    }
}
```

**Complexity**: O(n × log(sum)) time, O(1) space  
**Pattern**: Binary search on answer

---

### Problem 10: Koko Eating Bananas (LeetCode 875)

**Description**: Find minimum eating speed to finish bananas in H hours.

**Solution**:
```java
public class KokoEatingBananas {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1, right = 0;
        
        for (int pile : piles) {
            right = Math.max(right, pile);
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canEatAll(piles, h, mid)) {
                right = mid; // Try slower speed
            } else {
                left = mid + 1; // Need faster speed
            }
        }
        
        return left;
    }
    
    private boolean canEatAll(int[] piles, int h, int speed) {
        long hours = 0;
        
        for (int pile : piles) {
            hours += (pile + speed - 1) / speed; // Ceiling division
            if (hours > h) return false;
        }
        
        return true;
    }
}
```

**Complexity**: O(n × log(max)) time, O(1) space  
**Pattern**: Binary search on answer

---

### Problem 11: Find Peak Element (LeetCode 162)

**Description**: Find any peak element (nums[i] > neighbors).

**Solution**:
```java
public class FindPeakElement {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1; // Peak is on right
            } else {
                right = mid; // Peak is at or left of mid
            }
        }
        
        return left;
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 12: Search a 2D Matrix (LeetCode 74)

**Description**: Search in matrix where each row is sorted and first element > last of previous row.

**Solution**:
```java
public class Search2DMatrix {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0) return false;
        
        int m = matrix.length, n = matrix[0].length;
        int left = 0, right = m * n - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int midVal = matrix[mid / n][mid % n];
            
            if (midVal == target) return true;
            else if (midVal < target) left = mid + 1;
            else right = mid - 1;
        }
        
        return false;
    }
}
```

**Complexity**: O(log(m×n)) time, O(1) space  
**Pattern**: Treat 2D as 1D array

---

## Hard Problems

### Problem 13: Median of Two Sorted Arrays (LeetCode 4)

**Description**: Find median of two sorted arrays in O(log(min(m,n))).

**Solution**:
```java
public class MedianTwoArrays {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return findMedianSortedArrays(nums2, nums1);
        }
        
        int m = nums1.length, n = nums2.length;
        int left = 0, right = m;
        
        while (left <= right) {
            int i = left + (right - left) / 2;
            int j = (m + n + 1) / 2 - i;
            
            int maxLeft1 = (i == 0) ? Integer.MIN_VALUE : nums1[i - 1];
            int minRight1 = (i == m) ? Integer.MAX_VALUE : nums1[i];
            int maxLeft2 = (j == 0) ? Integer.MIN_VALUE : nums2[j - 1];
            int minRight2 = (j == n) ? Integer.MAX_VALUE : nums2[j];
            
            if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1) {
                if ((m + n) % 2 == 0) {
                    return (Math.max(maxLeft1, maxLeft2) + 
                           Math.min(minRight1, minRight2)) / 2.0;
                } else {
                    return Math.max(maxLeft1, maxLeft2);
                }
            } else if (maxLeft1 > minRight2) {
                right = i - 1;
            } else {
                left = i + 1;
            }
        }
        
        return 0.0;
    }
}
```

**Complexity**: O(log(min(m,n))) time, O(1) space  
**Pattern**: Binary search on partition point

---

### Problem 14: Split Array Largest Sum (LeetCode 410)

**Description**: Minimize the largest sum among m subarrays.

**Solution**:
```java
public class SplitArrayLargestSum {
    public int splitArray(int[] nums, int m) {
        int left = 0, right = 0;
        
        for (int num : nums) {
            left = Math.max(left, num);
            right += num;
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canSplit(nums, m, mid)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        
        return left;
    }
    
    private boolean canSplit(int[] nums, int m, int maxSum) {
        int subarrays = 1, currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                subarrays++;
                currentSum = num;
                if (subarrays > m) return false;
            } else {
                currentSum += num;
            }
        }
        
        return true;
    }
}
```

**Complexity**: O(n × log(sum)) time, O(1) space  
**Pattern**: Minimize maximum with binary search

---

### Problem 15: Find K-th Smallest Pair Distance (LeetCode 719)

**Description**: Find kth smallest distance among all pairs.

**Solution**:
```java
public class KthSmallestPairDistance {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        
        int left = 0;
        int right = nums[nums.length - 1] - nums[0];
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (countPairs(nums, mid) < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    private int countPairs(int[] nums, int distance) {
        int count = 0, j = 0;
        
        for (int i = 0; i < nums.length; i++) {
            while (j < nums.length && nums[j] - nums[i] <= distance) {
                j++;
            }
            count += j - i - 1;
        }
        
        return count;
    }
}
```

**Complexity**: O(n log n + n log(max_dist)) time, O(1) space  
**Pattern**: Binary search on answer with sliding window

---

## Company-Specific Problems

### Google: Find in Mountain Array (LeetCode 1095)

**Solution**:
```java
public class FindInMountainArray {
    interface MountainArray {
        int get(int index);
        int length();
    }
    
    public int findInMountainArray(int target, MountainArray arr) {
        int peak = findPeak(arr);
        
        // Search in ascending part
        int idx = binarySearch(arr, target, 0, peak, true);
        if (idx != -1) return idx;
        
        // Search in descending part
        return binarySearch(arr, target, peak + 1, arr.length() - 1, false);
    }
    
    private int findPeak(MountainArray arr) {
        int left = 0, right = arr.length() - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr.get(mid) < arr.get(mid + 1)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    private int binarySearch(MountainArray arr, int target, 
                            int left, int right, boolean ascending) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            int val = arr.get(mid);
            
            if (val == target) return mid;
            
            if (ascending) {
                if (val < target) left = mid + 1;
                else right = mid - 1;
            } else {
                if (val > target) left = mid + 1;
                else right = mid - 1;
            }
        }
        
        return -1;
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Amazon: Time Based Key-Value Store (LeetCode 981)

**Solution**:
```java
public class TimeMap {
    private Map<String, List<Pair>> map;
    
    static class Pair {
        int timestamp;
        String value;
        
        Pair(int t, String v) {
            timestamp = t;
            value = v;
        }
    }
    
    public TimeMap() {
        map = new HashMap<>();
    }
    
    public void set(String key, String value, int timestamp) {
        map.putIfAbsent(key, new ArrayList<>());
        map.get(key).add(new Pair(timestamp, value));
    }
    
    public String get(String key, int timestamp) {
        if (!map.containsKey(key)) return "";
        
        List<Pair> list = map.get(key);
        return binarySearch(list, timestamp);
    }
    
    private String binarySearch(List<Pair> list, int time) {
        int left = 0, right = list.size() - 1;
        String result = "";
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (list.get(mid).timestamp <= time) {
                result = list.get(mid).value;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
}
```

**Complexity**: set() O(1), get() O(log n)

---

### Facebook: Single Element in Sorted Array (LeetCode 540)

**Solution**:
```java
public class SingleElement {
    public int singleNonDuplicate(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Make mid even
            if (mid % 2 == 1) mid--;
            
            if (nums[mid] == nums[mid + 1]) {
                left = mid + 2; // Single is on right
            } else {
                right = mid; // Single is on left or at mid
            }
        }
        
        return nums[left];
    }
}
```

**Complexity**: O(log n) time, O(1) space  
**Key**: Pairs start at even indices before single element

---

## Quick Reference

### Pattern Recognition

| Problem Type | Pattern | Template |
|-------------|---------|----------|
| Find exact element | Standard binary | `while (left <= right)` |
| Find boundary | Lower/upper bound | `while (left < right)` |
| Minimize maximum | Binary on answer | Check if value works |
| Maximize minimum | Binary on answer | Check if value works |
| Rotated array | Modified binary | Check sorted half |
| 2D matrix | Treat as 1D | `mid/n, mid%n` |
| Peak element | Compare neighbors | Move toward larger |

### Common Mistakes

1. **Overflow**: Use `left + (right - left) / 2` not `(left + right) / 2`
2. **Infinite loop**: Ensure `left` or `right` changes each iteration
3. **Wrong boundary**: `left <= right` vs `left < right`
4. **Off-by-one**: `mid + 1` vs `mid - 1`
5. **Unsorted array**: Verify array is sorted or has structure

### Complexity Guide

| Algorithm | Time | Space | Use Case |
|-----------|------|-------|----------|
| Linear search | O(n) | O(1) | Unsorted, small data |
| Binary search | O(log n) | O(1) | Sorted data |
| Binary on answer | O(n log k) | O(1) | Optimization problems |
| Ternary search | O(log n) | O(1) | Unimodal functions |

### Interview Strategy

1. **Clarify**: Sorted? Duplicates? Range?
2. **Identify pattern**: Exact match, boundary, or optimization?
3. **Choose template**: Template 1, 2, or 3
4. **Handle edge cases**: Empty, single element, boundaries
5. **Test**: Small arrays, boundaries, not found

---

**Completed**: Searching Algorithms section with Linear Search, Binary Search, Variations, Ternary Search, and Practice Problems.
