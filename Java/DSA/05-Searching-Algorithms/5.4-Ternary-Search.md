# 5.4 Ternary Search

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Ternary Search](#basic-ternary-search)
3. [Finding Maximum/Minimum](#finding-maximumminimum)
4. [Discrete Ternary Search](#discrete-ternary-search)
5. [Applications](#applications)
6. [Ternary vs Binary Search](#ternary-vs-binary-search)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is Ternary Search?

**Ternary search** is a divide-and-conquer algorithm that:
- Divides the search space into **three parts** (not two like binary search)
- Works on **unimodal functions** (functions with a single maximum or minimum)
- Finds the maximum or minimum value efficiently

### Visual Example

```
Unimodal function (single peak):

      ^
      |       *
      |     *   *
      |   *       *
      | *           *
      |_______________>
     m1    m2
```

**Algorithm**:
- Split range into 3 parts using two midpoints `m1` and `m2`
- Compare `f(m1)` and `f(m2)`
- Eliminate 1/3 of the search space
- Repeat until range is small enough

### When to Use Ternary Search

**Use when**:
- Function is **unimodal** (single peak or valley)
- Need to find **maximum or minimum** value
- Function evaluation is expensive but feasible
- Derivative is unavailable or complex

**Don't use when**:
- Function has multiple peaks (multimodal)
- Function is monotonic (use binary search instead)
- Need to find specific value (not extremum)
- Function is not continuous

### Key Properties

**Unimodal function requirements**:
1. **Single extremum**: Only one maximum (or minimum)
2. **Strictly increasing then decreasing**: Or vice versa
3. **No plateaus**: At the extremum

**Examples**:
- ✅ f(x) = -(x - 5)² + 10 (parabola with peak at x=5)
- ✅ f(x) = -|x - 5| + 10 (V-shape with peak at x=5)
- ❌ f(x) = sin(x) (multiple peaks - multimodal)
- ❌ f(x) = x (monotonic - use binary search)

### Complexity

- **Time**: O(log₃ n) for discrete, O(log((b-a)/ε)) for continuous
- **Space**: O(1) iterative, O(log n) recursive
- **Comparisons**: ~2 per iteration (vs 1 for binary search)

---

## Basic Ternary Search

### Continuous Ternary Search (Finding Maximum)

```java
public class ContinuousTernarySearch {
    /**
     * Find maximum of unimodal function in range [left, right]
     * @param epsilon precision threshold
     */
    public double findMaximum(double left, double right, double epsilon) {
        while (right - left > epsilon) {
            // Two midpoints dividing range into thirds
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            if (function(m1) < function(m2)) {
                // Maximum is in [m1, right]
                left = m1;
            } else {
                // Maximum is in [left, m2]
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    /**
     * Example: f(x) = -(x - 5)^2 + 25
     * Maximum at x = 5, f(5) = 25
     */
    private double function(double x) {
        return -(x - 5) * (x - 5) + 25;
    }
    
    /**
     * Get function value at maximum
     */
    public double getMaxValue(double left, double right, double epsilon) {
        double maxX = findMaximum(left, right, epsilon);
        return function(maxX);
    }
    
    // Test
    public static void main(String[] args) {
        ContinuousTernarySearch cts = new ContinuousTernarySearch();
        
        double maxX = cts.findMaximum(0, 10, 1e-6);
        double maxValue = cts.function(maxX);
        
        System.out.printf("Maximum at x = %.6f%n", maxX);     // 5.000000
        System.out.printf("Maximum value = %.6f%n", maxValue); // 25.000000
    }
}
```

**Key points**:
- Use `m1 = left + (right - left) / 3`
- Use `m2 = right - (right - left) / 3`
- Eliminate 1/3 of search space each iteration
- Continue until `right - left < epsilon`

**Complexity**: O(log₃((right - left) / epsilon)) iterations

---

### Continuous Ternary Search (Finding Minimum)

```java
public class FindMinimum {
    /**
     * Find minimum of unimodal function (valley)
     */
    public double findMinimum(double left, double right, double epsilon) {
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            // For minimum: opposite comparison
            if (function(m1) > function(m2)) {
                // Minimum is in [m1, right]
                left = m1;
            } else {
                // Minimum is in [left, m2]
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    /**
     * Example: f(x) = (x - 3)^2 + 2
     * Minimum at x = 3, f(3) = 2
     */
    private double function(double x) {
        return (x - 3) * (x - 3) + 2;
    }
    
    // Test
    public static void main(String[] args) {
        FindMinimum fm = new FindMinimum();
        
        double minX = fm.findMinimum(0, 10, 1e-6);
        double minValue = fm.function(minX);
        
        System.out.printf("Minimum at x = %.6f%n", minX);     // 3.000000
        System.out.printf("Minimum value = %.6f%n", minValue); // 2.000000
    }
}
```

**Difference**: Only the comparison is flipped (`>` instead of `<`).

---

### Recursive Implementation

```java
public class RecursiveTernarySearch {
    private static final double EPSILON = 1e-9;
    
    /**
     * Recursive ternary search for maximum
     */
    public double findMaximumRecursive(double left, double right) {
        if (right - left < EPSILON) {
            return (left + right) / 2;
        }
        
        double m1 = left + (right - left) / 3;
        double m2 = right - (right - left) / 3;
        
        if (function(m1) < function(m2)) {
            return findMaximumRecursive(m1, right);
        } else {
            return findMaximumRecursive(left, m2);
        }
    }
    
    private double function(double x) {
        return -(x - 7) * (x - 7) + 50;
    }
    
    // Test
    public static void main(String[] args) {
        RecursiveTernarySearch rts = new RecursiveTernarySearch();
        
        double maxX = rts.findMaximumRecursive(0, 15);
        System.out.printf("Maximum at x = %.6f%n", maxX); // 7.000000
    }
}
```

**Complexity**: O(log₃ n) time, O(log₃ n) space for recursion stack

---

## Finding Maximum/Minimum

### Polynomial Functions

```java
public class PolynomialOptimization {
    /**
     * Find maximum of cubic polynomial
     * f(x) = -x^3 + 6x^2 - 9x + 4
     */
    public double findPolynomialMax(double left, double right) {
        double epsilon = 1e-9;
        
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            if (polynomial(m1) < polynomial(m2)) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    private double polynomial(double x) {
        return -x * x * x + 6 * x * x - 9 * x + 4;
    }
    
    // Test
    public static void main(String[] args) {
        PolynomialOptimization po = new PolynomialOptimization();
        
        double maxX = po.findPolynomialMax(0, 5);
        double maxValue = po.polynomial(maxX);
        
        System.out.printf("Maximum at x = %.6f%n", maxX);     // ~1.0
        System.out.printf("Maximum value = %.6f%n", maxValue); // ~2.0
    }
}
```

---

### Absolute Value Functions

```java
public class AbsoluteValueOptimization {
    /**
     * Find maximum of f(x) = -|x - 4| - |x - 8| + 10
     */
    public double findMaximum(double left, double right) {
        double epsilon = 1e-9;
        
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            if (absFunction(m1) < absFunction(m2)) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    private double absFunction(double x) {
        return -Math.abs(x - 4) - Math.abs(x - 8) + 10;
    }
    
    // Test
    public static void main(String[] args) {
        AbsoluteValueOptimization avo = new AbsoluteValueOptimization();
        
        double maxX = avo.findMaximum(0, 15);
        double maxValue = avo.absFunction(maxX);
        
        System.out.printf("Maximum at x = %.6f%n", maxX);     // ~6.0
        System.out.printf("Maximum value = %.6f%n", maxValue); // ~6.0
    }
}
```

---

### Trigonometric Functions

```java
public class TrigonometricOptimization {
    /**
     * Find maximum of f(x) = sin(x) + cos(x) in [0, 2π]
     * Has single maximum in this range
     */
    public double findMaximum() {
        double left = 0;
        double right = 2 * Math.PI;
        double epsilon = 1e-9;
        
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            if (trigFunction(m1) < trigFunction(m2)) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    private double trigFunction(double x) {
        return Math.sin(x) + Math.cos(x);
    }
    
    // Test
    public static void main(String[] args) {
        TrigonometricOptimization to = new TrigonometricOptimization();
        
        double maxX = to.findMaximum();
        double maxValue = to.trigFunction(maxX);
        
        System.out.printf("Maximum at x = %.6f (%.2f degrees)%n", 
                         maxX, Math.toDegrees(maxX));  // ~0.785398 (45 degrees)
        System.out.printf("Maximum value = %.6f%n", maxValue); // ~1.414214 (√2)
    }
}
```

---

## Discrete Ternary Search

### Integer Array Maximum

```java
public class DiscreteArraySearch {
    /**
     * Find index of maximum element in unimodal array
     * Array increases then decreases (mountain array)
     */
    public int findPeakElement(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (right - left > 2) {
            int m1 = left + (right - left) / 3;
            int m2 = right - (right - left) / 3;
            
            if (arr[m1] < arr[m2]) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        // Check remaining elements
        int maxIdx = left;
        for (int i = left + 1; i <= right; i++) {
            if (arr[i] > arr[maxIdx]) {
                maxIdx = i;
            }
        }
        
        return maxIdx;
    }
    
    // Test
    public static void main(String[] args) {
        DiscreteArraySearch das = new DiscreteArraySearch();
        
        int[] arr1 = {1, 3, 8, 12, 15, 13, 10, 7, 4, 2};
        System.out.println("Peak at index: " + das.findPeakElement(arr1)); // 4
        System.out.println("Peak value: " + arr1[das.findPeakElement(arr1)]); // 15
        
        int[] arr2 = {5, 10, 20, 15, 7, 3};
        System.out.println("Peak at index: " + das.findPeakElement(arr2)); // 2
    }
}
```

**Note**: For discrete case, post-process remaining elements when range is small.

---

### Binary Search Alternative for Discrete

```java
public class BinarySearchPeak {
    /**
     * Binary search can also find peak in O(log n)
     * More efficient than ternary for discrete case
     */
    public int findPeakElementBinary(int[] arr) {
        int left = 0;
        int right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < arr[mid + 1]) {
                // Peak is on the right
                left = mid + 1;
            } else {
                // Peak is on the left (or at mid)
                right = mid;
            }
        }
        
        return left;
    }
    
    // Test
    public static void main(String[] args) {
        BinarySearchPeak bsp = new BinarySearchPeak();
        
        int[] arr = {1, 3, 8, 12, 15, 13, 10, 7, 4, 2};
        System.out.println("Peak at index: " + bsp.findPeakElementBinary(arr)); // 4
    }
}
```

**Important**: For discrete/integer arrays, **binary search is more efficient** than ternary search.

---

## Applications

### Application 1: Minimum Time to Complete Tasks

```java
public class MinimumTimeAllocation {
    /**
     * Find optimal distribution point to minimize maximum time
     * 
     * Example: Two workers, n tasks with times[i]
     * Assign tasks 0..k to worker1, k+1..n-1 to worker2
     * Minimize max(sum1, sum2)
     */
    public int minimizeMaxTime(int[] tasks) {
        int n = tasks.length;
        int minTime = Integer.MAX_VALUE;
        int bestSplit = 0;
        
        // Compute prefix sums
        int[] prefix = new int[n + 1];
        for (int i = 0; i < n; i++) {
            prefix[i + 1] = prefix[i] + tasks[i];
        }
        
        int total = prefix[n];
        
        // Ternary search on split point
        int left = 0, right = n - 1;
        
        while (right - left > 2) {
            int m1 = left + (right - left) / 3;
            int m2 = right - (right - left) / 3;
            
            int time1 = calculateMaxTime(prefix, total, m1);
            int time2 = calculateMaxTime(prefix, total, m2);
            
            if (time1 > time2) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        // Check remaining positions
        for (int i = left; i <= right; i++) {
            int time = calculateMaxTime(prefix, total, i);
            if (time < minTime) {
                minTime = time;
                bestSplit = i;
            }
        }
        
        return minTime;
    }
    
    private int calculateMaxTime(int[] prefix, int total, int split) {
        int sum1 = prefix[split + 1];
        int sum2 = total - sum1;
        return Math.max(sum1, sum2);
    }
    
    // Test
    public static void main(String[] args) {
        MinimumTimeAllocation mta = new MinimumTimeAllocation();
        
        int[] tasks = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        System.out.println("Minimum max time: " + mta.minimizeMaxTime(tasks)); // 25
    }
}
```

---

### Application 2: Optimal Meeting Point

```java
public class OptimalMeetingPoint {
    /**
     * Find point on line that minimizes sum of squared distances
     * People at positions array, find x to minimize Σ(x - positions[i])^2
     */
    public double findOptimalPoint(double[] positions) {
        double left = Double.MAX_VALUE;
        double right = -Double.MAX_VALUE;
        
        for (double pos : positions) {
            left = Math.min(left, pos);
            right = Math.max(right, pos);
        }
        
        double epsilon = 1e-9;
        
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            if (totalDistance(positions, m1) > totalDistance(positions, m2)) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        return (left + right) / 2;
    }
    
    private double totalDistance(double[] positions, double point) {
        double sum = 0;
        for (double pos : positions) {
            double diff = pos - point;
            sum += diff * diff;
        }
        return sum;
    }
    
    // Test
    public static void main(String[] args) {
        OptimalMeetingPoint omp = new OptimalMeetingPoint();
        
        double[] positions = {1.0, 3.0, 5.0, 7.0, 9.0};
        double optimal = omp.findOptimalPoint(positions);
        
        System.out.printf("Optimal meeting point: %.6f%n", optimal); // 5.0 (mean)
    }
}
```

**Note**: For sum of squared distances, optimal point is the **mean**. This demonstrates ternary search working correctly.

---

### Application 3: Wooden Stick Cutting (LeetCode 1552 variant)

```java
public class WoodenStickCutting {
    /**
     * Cut wooden sticks to maximize minimum distance between cuts
     * Similar to aggressive cows but with ternary search approach
     */
    public double maxMinDistance(double length, int numCuts) {
        double left = 0;
        double right = length / (numCuts + 1);
        double epsilon = 1e-9;
        
        // Binary search is better here, but showing ternary for education
        while (right - left > epsilon) {
            double m1 = left + (right - left) / 3;
            double m2 = right - (right - left) / 3;
            
            // This is actually not unimodal - binary search is better
            // Showing for comparison
            if (canCut(length, numCuts, m1)) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        return left;
    }
    
    private boolean canCut(double length, int numCuts, double minDist) {
        int cuts = 0;
        double position = minDist;
        
        while (position <= length - minDist) {
            cuts++;
            position += minDist;
        }
        
        return cuts >= numCuts;
    }
    
    // Test
    public static void main(String[] args) {
        WoodenStickCutting wsc = new WoodenStickCutting();
        
        double result = wsc.maxMinDistance(100, 3);
        System.out.printf("Max min distance: %.6f%n", result); // ~25.0
    }
}
```

**Note**: Binary search is more appropriate here. Ternary search is for **optimization**, not feasibility checking.

---

### Application 4: Delivery Route Optimization

```java
public class DeliveryOptimization {
    /**
     * Find speed that minimizes total time
     * Time = distance/speed + waitTime(speed)
     * Unimodal function: too slow = long travel, too fast = long wait
     */
    public double findOptimalSpeed(double distance, double minSpeed, 
                                   double maxSpeed) {
        double epsilon = 1e-6;
        
        while (maxSpeed - minSpeed > epsilon) {
            double s1 = minSpeed + (maxSpeed - minSpeed) / 3;
            double s2 = maxSpeed - (maxSpeed - minSpeed) / 3;
            
            if (totalTime(distance, s1) > totalTime(distance, s2)) {
                minSpeed = s1;
            } else {
                maxSpeed = s2;
            }
        }
        
        return (minSpeed + maxSpeed) / 2;
    }
    
    /**
     * Total time = travel time + wait time
     * Wait time increases with speed (e.g., traffic lights, congestion)
     */
    private double totalTime(double distance, double speed) {
        double travelTime = distance / speed;
        double waitTime = 0.1 * speed; // Wait increases with speed
        return travelTime + waitTime;
    }
    
    // Test
    public static void main(String[] args) {
        DeliveryOptimization dopt = new DeliveryOptimization();
        
        double optimalSpeed = dopt.findOptimalSpeed(100, 10, 100);
        System.out.printf("Optimal speed: %.2f%n", optimalSpeed); // ~31.62
        System.out.printf("Total time: %.2f%n", 
                         dopt.totalTime(100, optimalSpeed)); // ~6.32
    }
}
```

---

## Ternary vs Binary Search

### Comparison Table

| Feature | Binary Search | Ternary Search |
|---------|--------------|----------------|
| **Purpose** | Find exact element | Find maximum/minimum |
| **Requirement** | Sorted array/monotonic | Unimodal function |
| **Division** | 2 parts | 3 parts |
| **Comparisons/iteration** | 1 | 2 |
| **Reduction rate** | 1/2 | 1/3 |
| **Time complexity** | O(log₂ n) | O(log₃ n) |
| **Constant factor** | Better | Worse (2× comparisons) |
| **Use for discrete** | Yes, preferred | Use binary instead |
| **Use for continuous** | Feasibility check | Optimization |

### When Each is Better

**Binary Search better**:
- Discrete/integer problems
- Finding exact values
- Feasibility checking ("Can we achieve X?")
- Monotonic functions
- When comparisons are expensive

**Ternary Search better**:
- Continuous optimization
- Unimodal functions
- When derivative is complex
- Finding extremum (not specific value)
- When function evaluation is not too expensive

### Iterations Comparison

For n = 1,000,000:
- **Binary**: log₂(1,000,000) ≈ **20 iterations**
- **Ternary**: log₃(1,000,000) ≈ **13 iterations**

But ternary does **2 comparisons** per iteration:
- Binary: 20 comparisons total
- Ternary: 26 comparisons total

**Conclusion**: Binary search is more efficient when applicable.

---

### Code Comparison: Peak Element

```java
public class PeakElementComparison {
    /**
     * Binary search - MORE EFFICIENT
     */
    public int findPeakBinary(int[] arr) {
        int left = 0, right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < arr[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    /**
     * Ternary search - LESS EFFICIENT for discrete
     */
    public int findPeakTernary(int[] arr) {
        int left = 0, right = arr.length - 1;
        
        while (right - left > 2) {
            int m1 = left + (right - left) / 3;
            int m2 = right - (right - left) / 3;
            
            if (arr[m1] < arr[m2]) {
                left = m1;
            } else {
                right = m2;
            }
        }
        
        int maxIdx = left;
        for (int i = left + 1; i <= right; i++) {
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        }
        
        return maxIdx;
    }
    
    // Test
    public static void main(String[] args) {
        PeakElementComparison pec = new PeakElementComparison();
        int[] arr = {1, 3, 8, 12, 15, 13, 10, 7, 4, 2};
        
        System.out.println("Binary: " + pec.findPeakBinary(arr));   // 4
        System.out.println("Ternary: " + pec.findPeakTernary(arr)); // 4
        
        // Binary is preferred for discrete arrays
    }
}
```

**Recommendation**: Use **binary search** for discrete arrays/peak finding.

---

## Interview Questions

### Q1: What is the difference between binary and ternary search?

**Answer**:

| Aspect | Binary Search | Ternary Search |
|--------|---------------|----------------|
| **Purpose** | Find element in sorted array | Find extremum in unimodal function |
| **Works on** | Monotonic/sorted data | Unimodal functions |
| **Division** | 2 regions (left, right) | 3 regions (left, mid, right) |
| **Midpoints** | 1 (mid) | 2 (m1, m2) |
| **Comparisons** | 1 per iteration | 2 per iteration |
| **Returns** | Index or -1 | Optimal value/position |
| **Efficiency** | Better (fewer comparisons) | Worse (2× comparisons) |

**Example**:
```
Binary: [1,2,3,4,5] find 3 → compares with mid
Ternary: f(x) = -x² + 10 → finds x where f(x) is maximum
```

**Key**: Binary finds **exact value**, ternary finds **extremum**.

---

### Q2: When should you use ternary search over binary search?

**Answer**:

**Use ternary search when**:

1. **Finding extremum** (max/min) not exact value
2. **Unimodal function** with single peak/valley
3. **Continuous optimization** problems
4. **Derivative unavailable** or too complex

**Use binary search when**:

1. **Finding exact element** in sorted data
2. **Monotonic function** (always increasing/decreasing)
3. **Discrete/integer** problems
4. **Feasibility checking** ("Can we achieve X?")

**Example decisions**:

```java
// Ternary search ✅
"Find speed that minimizes time" → unimodal optimization

// Binary search ✅
"Find minimum capacity to ship within D days" → feasibility check

// Binary search ✅ (even for peak)
"Find peak in mountain array" → discrete, binary is more efficient

// Ternary search ✅
"Find x where f(x) = -x² + 5x is maximum" → continuous optimization
```

**Rule of thumb**: If you can phrase as "Does value X work?", use binary. If "What value optimizes Y?", consider ternary.

---

### Q3: What is a unimodal function?

**Answer**:

A **unimodal function** has exactly **one local extremum** (maximum or minimum).

**Formal definition**:
- **Strictly increasing** then **strictly decreasing** (for maximum)
- **Strictly decreasing** then **strictly increasing** (for minimum)

**Examples**:

**Unimodal ✅**:
```java
f(x) = -(x - 5)² + 10     // Parabola, peak at x=5
f(x) = -|x - 3| + 7       // V-shape, peak at x=3
f(x) = x(10 - x)          // Quadratic, peak at x=5
```

**NOT unimodal ❌**:
```java
f(x) = sin(x)             // Multiple peaks (multimodal)
f(x) = x³                 // No peak (monotonic)
f(x) = |x - 2| + |x - 8|  // Two valleys (bimodal)
```

**Testing for unimodality**:
```java
// Check if function is unimodal in range
public boolean isUnimodal(double left, double right) {
    double step = (right - left) / 1000;
    boolean increasing = true;
    boolean foundPeak = false;
    
    for (double x = left; x < right; x += step) {
        double curr = f(x);
        double next = f(x + step);
        
        if (increasing && next < curr) {
            increasing = false;
            foundPeak = true;
        } else if (!increasing && next > curr) {
            return false; // Going up after peak
        }
    }
    
    return foundPeak;
}
```

---

### Q4: Can ternary search handle multiple peaks?

**Answer**: **No**, ternary search **only works** for unimodal functions (single peak).

**Why it fails**:

For function with multiple peaks:
```
      *         *
    *   *     *   *
  *       * *       *
```

Ternary search might:
1. Find a **local maximum** instead of **global maximum**
2. Get stuck in wrong region
3. Give incorrect results

**Example failure**:
```java
// Bimodal function: f(x) = -|x - 2| - |x - 8| + 10
// Has two peaks at x=2 and x=8

double result = ternarySearch(0, 10);
// Might find x=2 or x=8 depending on initial range
// Cannot guarantee global maximum
```

**Solutions for multimodal**:

1. **Grid search**: Evaluate at many points
```java
double max = Double.MIN_VALUE;
for (double x = left; x <= right; x += step) {
    max = Math.max(max, f(x));
}
```

2. **Divide into unimodal regions**: If you know peak locations
```java
// Search [left, peak1], [peak1, peak2], etc.
```

3. **Random sampling + local search**: Monte Carlo methods

4. **Gradient descent/ascent**: For smooth functions

**Key**: Ternary search assumes **single extremum**. Verify function is unimodal first.

---

### Q5: Why does ternary search do 2 comparisons per iteration?

**Answer**:

**Reason**: Need to compare **two midpoints** to decide which third to eliminate.

**Process**:
```
Range: [left, ............., right]
Divide: [left, m1, m2, right]
          ^^^   ^^^
          Compare f(m1) and f(m2)
```

**Decision logic**:
```java
if (f(m1) < f(m2)) {
    // Maximum is in [m1, right]
    // Eliminate [left, m1)
} else {
    // Maximum is in [left, m2]
    // Eliminate (m2, right]
}
```

**Why not 1 comparison?**

With only 1 midpoint, you can't decide:
```
If f(mid) is large, is peak left or right? Unknown!
Need second point for comparison.
```

**Comparison with binary**:

**Binary** (1 comparison):
```java
if (arr[mid] == target) return mid;
else if (arr[mid] < target) left = mid + 1;  // ✅ Know direction
else right = mid - 1;                        // ✅ Know direction
```

**Ternary** (2 comparisons):
```java
if (f(m1) < f(m2)) left = m1;   // Need both f(m1) AND f(m2)
else right = m2;
```

**Total cost**:
- Binary: log₂(n) iterations × 1 comparison = **log₂(n) comparisons**
- Ternary: log₃(n) iterations × 2 comparisons ≈ **1.26 × log₂(n) comparisons**

**Result**: Ternary is **26% slower** than binary when both are applicable.

---

### Q6: How do you choose epsilon for continuous ternary search?

**Answer**:

**Epsilon (ε)** is the precision threshold: stop when `right - left < ε`.

**Factors to consider**:

1. **Required precision**:
```java
// Financial: high precision
double epsilon = 1e-9;

// Engineering: moderate precision
double epsilon = 1e-6;

// Display: low precision
double epsilon = 1e-3;
```

2. **Problem constraints**:
```java
// If answer must be within 0.01
double epsilon = 0.001; // Slightly smaller for safety
```

3. **Function evaluation cost**:
```java
// Expensive function: larger epsilon (fewer iterations)
double epsilon = 1e-4;

// Cheap function: smaller epsilon (more precision)
double epsilon = 1e-9;
```

4. **Floating-point precision**:
```java
// Don't go below machine epsilon
double epsilon = 1e-15; // ❌ Too small, rounding errors
double epsilon = 1e-9;  // ✅ Safe for double
```

**Iterations vs epsilon**:
```
Range = 100, epsilon = 1e-6
Iterations = log₃(100 / 1e-6) = log₃(10⁸) ≈ 16.8 ≈ 17
```

**Default recommendation**: `1e-6` or `1e-9` for most problems.

**Adaptive epsilon**:
```java
// Scale with problem size
double epsilon = (right - left) * 1e-9;
```

---

### Q7: Can you use ternary search on discrete arrays?

**Answer**: **Yes, but binary search is better** for discrete cases.

**Discrete ternary search**:
```java
public int ternarySearchDiscrete(int[] arr) {
    int left = 0, right = arr.length - 1;
    
    while (right - left > 2) {
        int m1 = left + (right - left) / 3;
        int m2 = right - (right - left) / 3;
        
        if (arr[m1] < arr[m2]) {
            left = m1;
        } else {
            right = m2;
        }
    }
    
    // Post-process remaining elements
    int maxIdx = left;
    for (int i = left + 1; i <= right; i++) {
        if (arr[i] > arr[maxIdx]) maxIdx = i;
    }
    
    return maxIdx;
}
```

**Problems with discrete ternary**:

1. **More comparisons**: 2 per iteration vs 1 for binary
2. **Post-processing**: Need to check remaining elements
3. **Less elegant**: Binary search is cleaner

**Binary search alternative**:
```java
public int binarySearchDiscrete(int[] arr) {
    int left = 0, right = arr.length - 1;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < arr[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left; // No post-processing
}
```

**Verdict**: Use **binary search** for discrete arrays (peak finding, mountain array).

**Use ternary** only for:
- Continuous functions
- Real number optimization
- When binary search doesn't apply

---

### Q8: What are the common pitfalls in ternary search?

**Answer**:

**Top 7 pitfalls**:

**1. Using on multimodal function**:
```java
// ❌ WRONG: sin(x) has multiple peaks
double result = ternarySearch(0, 10, x -> Math.sin(x));

// ✅ CORRECT: Restrict to unimodal region
double result = ternarySearch(0, Math.PI/2, x -> Math.sin(x));
```

**2. Wrong midpoint calculation**:
```java
// ❌ WRONG
double m1 = (left + right) / 3;
double m2 = (left + right) * 2 / 3;

// ✅ CORRECT
double m1 = left + (right - left) / 3;
double m2 = right - (right - left) / 3;
```

**3. Swapping comparison for min/max**:
```java
// For MAXIMUM
if (f(m1) < f(m2)) left = m1;  // ✅

// For MINIMUM
if (f(m1) > f(m2)) left = m1;  // ✅
// Note the flipped comparison
```

**4. Infinite loop with integers**:
```java
// ❌ Can loop forever with integers
while (right > left) {
    int m1 = left + (right - left) / 3;
    int m2 = right - (right - left) / 3;
    // If right - left = 2, m1 = m2
}

// ✅ Add termination condition
while (right - left > 2) { ... }
```

**5. Wrong epsilon**:
```java
// ❌ Too large: imprecise
double epsilon = 1;

// ❌ Too small: infinite loop or rounding errors
double epsilon = 1e-20;

// ✅ Reasonable
double epsilon = 1e-6;
```

**6. Not handling edge cases**:
```java
// ❌ Peak at boundary
double result = ternarySearch(0, 10, x -> -x); // Peak at x=0
// Might miss boundary

// ✅ Check boundaries separately
double result = ternarySearch(eps, 10 - eps, f);
result = Math.max(result, f(0), f(10));
```

**7. Using for feasibility instead of optimization**:
```java
// ❌ WRONG: Binary search problem
"Can we achieve capacity X?" → Use binary search

// ✅ CORRECT: Optimization problem  
"What capacity minimizes cost?" → Use ternary search
```

---

### Q9: How do you prove a function is unimodal?

**Answer**:

**Method 1: Derivative test** (for differentiable functions)

A function is unimodal if:
1. f'(x) > 0 for x < x*, f'(x) < 0 for x > x* (maximum at x*)
2. f'(x) changes sign exactly once

Example:
```
f(x) = -x² + 4x + 1
f'(x) = -2x + 4
f'(x) = 0 at x = 2

f'(x) > 0 for x < 2 (increasing)
f'(x) < 0 for x > 2 (decreasing)
→ Unimodal with maximum at x = 2
```

**Method 2: Second derivative test**

For concave function (f''(x) < 0 everywhere):
- Has at most one maximum
- Is unimodal

Example:
```
f(x) = -x² + 4x
f''(x) = -2 < 0 (concave)
→ Unimodal
```

**Method 3: Empirical sampling**

```java
public boolean isUnimodal(Function f, double left, double right) {
    int samples = 1000;
    double step = (right - left) / samples;
    
    boolean increasing = true;
    boolean foundPeak = false;
    double prev = f.apply(left);
    
    for (int i = 1; i <= samples; i++) {
        double x = left + i * step;
        double curr = f.apply(x);
        
        if (increasing && curr < prev) {
            increasing = false;
            foundPeak = true;
        } else if (!increasing && curr > prev) {
            return false; // Going up after going down
        }
        
        prev = curr;
    }
    
    return foundPeak;
}
```

**Method 4: Mathematical properties**

Known unimodal functions:
- f(x) = -ax² + bx + c (a > 0)
- f(x) = a / (1 + (x - b)²)
- f(x) = -|x - a|

**In interviews**: State assumption that function is unimodal, or verify with sampling if uncertain.

---

### Q10: What's the time complexity of ternary search?

**Answer**:

**Continuous case**:
```
T(n) = O(log₃((right - left) / epsilon))
```

Where:
- `right - left` = initial range
- `epsilon` = precision threshold

**Example**:
```
Range = 1000, epsilon = 0.001
Iterations = log₃(1000 / 0.001) = log₃(10⁶) ≈ 12.6 ≈ 13
```

**Discrete case**:
```
T(n) = O(log₃ n)
```

Where n = array length.

**With function complexity**:

If function f(x) takes O(F) time:
```
Total = O(F × log₃(range / epsilon))
```

**Comparison with binary**:

Converting base:
```
log₃(n) = log₂(n) / log₂(3) ≈ 0.63 × log₂(n)
```

So ternary search does **63% of iterations** but **2× comparisons per iteration**:
```
Total comparisons = 0.63 × 2 × log₂(n) ≈ 1.26 × log₂(n)
```

**Result**: Ternary is **26% slower** than binary (when both apply).

**Space complexity**:
- Iterative: O(1)
- Recursive: O(log₃ n)

---

## Practice Problems

### Problem 1: Minimize Maximum Distance to Gas Station (LeetCode 774)

**Description**: Add K gas stations to minimize maximum distance between consecutive stations.

**Solution**:
```java
public class MinimizeMaxDistance {
    /**
     * Binary search on answer is more appropriate than ternary
     * But showing for comparison
     */
    public double minmaxGasDist(int[] stations, int K) {
        double left = 0;
        double right = stations[stations.length - 1] - stations[0];
        double epsilon = 1e-6;
        
        while (right - left > epsilon) {
            double mid = left + (right - left) / 2;
            
            if (canAchieve(stations, K, mid)) {
                right = mid; // Can achieve smaller
            } else {
                left = mid; // Need larger
            }
        }
        
        return left;
    }
    
    private boolean canAchieve(int[] stations, int K, double maxDist) {
        int needed = 0;
        
        for (int i = 1; i < stations.length; i++) {
            double dist = stations[i] - stations[i - 1];
            needed += (int)(dist / maxDist);
        }
        
        return needed <= K;
    }
    
    // Test
    public static void main(String[] args) {
        MinimizeMaxDistance mmd = new MinimizeMaxDistance();
        
        int[] stations = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.printf("%.6f%n", mmd.minmaxGasDist(stations, 9)); // 0.500000
    }
}
```

**Note**: This is actually a **binary search** problem (feasibility), not ternary (optimization).

---

### Problem 2: Allocate Mailboxes (LeetCode 1478)

**Description**: Place k mailboxes to minimize sum of distances.

**Solution**:
```java
public class AllocateMailboxes {
    /**
     * Find optimal mailbox positions using ternary search
     * For single mailbox in range [i, j], optimal position is median
     */
    public int minDistance(int[] houses, int k) {
        Arrays.sort(houses);
        int n = houses.length;
        
        // dp[i][j] = min cost to allocate j mailboxes to first i houses
        int[][] dp = new int[n + 1][k + 1];
        
        // cost[i][j] = cost of one mailbox for houses[i..j]
        int[][] cost = new int[n][n];
        
        // Precompute costs
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                int median = houses[(i + j) / 2];
                for (int t = i; t <= j; t++) {
                    cost[i][j] += Math.abs(houses[t] - median);
                }
            }
        }
        
        // Initialize
        for (int i = 0; i <= n; i++) {
            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);
        }
        dp[0][0] = 0;
        
        // DP
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, k); j++) {
                for (int t = j - 1; t < i; t++) {
                    dp[i][j] = Math.min(dp[i][j], 
                                       dp[t][j - 1] + cost[t][i - 1]);
                }
            }
        }
        
        return dp[n][k];
    }
    
    // Test
    public static void main(String[] args) {
        AllocateMailboxes am = new AllocateMailboxes();
        
        System.out.println(am.minDistance(new int[]{1, 4, 8, 10, 20}, 3)); // 5
    }
}
```

**Note**: Uses **median** (from ternary search principle) but implemented with DP.

---

### Problem 3: Find Peak Element II (LeetCode 1901)

**Description**: Find peak in 2D matrix.

**Solution**:
```java
public class FindPeakElement2D {
    /**
     * Binary search on columns, ternary concept on rows
     */
    public int[] findPeakGrid(int[][] mat) {
        int left = 0, right = mat[0].length - 1;
        
        while (left <= right) {
            int midCol = left + (right - left) / 2;
            int maxRow = findMaxInColumn(mat, midCol);
            
            int midVal = mat[maxRow][midCol];
            int leftVal = midCol > 0 ? mat[maxRow][midCol - 1] : -1;
            int rightVal = midCol < mat[0].length - 1 ? 
                          mat[maxRow][midCol + 1] : -1;
            
            if (midVal > leftVal && midVal > rightVal) {
                return new int[]{maxRow, midCol};
            } else if (midVal < leftVal) {
                right = midCol - 1;
            } else {
                left = midCol + 1;
            }
        }
        
        return new int[]{-1, -1};
    }
    
    private int findMaxInColumn(int[][] mat, int col) {
        int maxRow = 0;
        for (int i = 1; i < mat.length; i++) {
            if (mat[i][col] > mat[maxRow][col]) {
                maxRow = i;
            }
        }
        return maxRow;
    }
    
    // Test
    public static void main(String[] args) {
        FindPeakElement2D fpe = new FindPeakElement2D();
        
        int[][] mat = {{1, 4}, {3, 2}};
        System.out.println(Arrays.toString(fpe.findPeakGrid(mat))); // [0, 1]
    }
}
```

---

### Problem 4: Maximum Average Subarray II (LeetCode 644)

**Description**: Find maximum average of subarray with length >= k.

**Solution**:
```java
public class MaximumAverageSubarray {
    /**
     * Binary search on average value
     */
    public double findMaxAverage(int[] nums, int k) {
        double left = Integer.MAX_VALUE;
        double right = Integer.MIN_VALUE;
        
        for (int num : nums) {
            left = Math.min(left, num);
            right = Math.max(right, num);
        }
        
        double epsilon = 1e-5;
        
        while (right - left > epsilon) {
            double mid = left + (right - left) / 2;
            
            if (canAchieveAverage(nums, k, mid)) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    private boolean canAchieveAverage(int[] nums, int k, double avg) {
        double[] diffs = new double[nums.length];
        for (int i = 0; i < nums.length; i++) {
            diffs[i] = nums[i] - avg;
        }
        
        double sum = 0;
        for (int i = 0; i < k; i++) {
            sum += diffs[i];
        }
        
        if (sum >= 0) return true;
        
        double prevSum = 0, minPrevSum = 0;
        
        for (int i = k; i < nums.length; i++) {
            sum += diffs[i];
            prevSum += diffs[i - k];
            minPrevSum = Math.min(minPrevSum, prevSum);
            
            if (sum - minPrevSum >= 0) return true;
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        MaximumAverageSubarray mas = new MaximumAverageSubarray();
        
        System.out.printf("%.5f%n", 
            mas.findMaxAverage(new int[]{1, 12, -5, -6, 50, 3}, 4)); // 12.75
    }
}
```

---

### Problem 5: Maximize Profit (Custom Problem)

**Description**: Sell product with price-demand curve: demand = a - b × price. Maximize revenue.

**Solution**:
```java
public class MaximizeRevenue {
    private double a; // Max demand (when price = 0)
    private double b; // Demand decrease rate
    
    public MaximizeRevenue(double a, double b) {
        this.a = a;
        this.b = b;
    }
    
    /**
     * Revenue = price × demand = p × (a - b × p)
     * This is a quadratic, unimodal function
     */
    public double findOptimalPrice() {
        double left = 0;
        double right = a / b; // Max price (demand = 0)
        double epsilon = 1e-6;
        
        while (right - left > epsilon) {
            double p1 = left + (right - left) / 3;
            double p2 = right - (right - left) / 3;
            
            if (revenue(p1) < revenue(p2)) {
                left = p1;
            } else {
                right = p2;
            }
        }
        
        return (left + right) / 2;
    }
    
    private double revenue(double price) {
        double demand = a - b * price;
        if (demand < 0) return 0;
        return price * demand;
    }
    
    // Test
    public static void main(String[] args) {
        MaximizeRevenue mr = new MaximizeRevenue(100, 2);
        
        double optimalPrice = mr.findOptimalPrice();
        double maxRevenue = mr.revenue(optimalPrice);
        
        System.out.printf("Optimal price: $%.2f%n", optimalPrice);   // $25.00
        System.out.printf("Maximum revenue: $%.2f%n", maxRevenue);   // $1250.00
        
        // Verification: Revenue = p(100 - 2p) = -2p² + 100p
        // Maximum at p = -100 / (2 × -2) = 25
    }
}
```

---

## Summary

### Key Takeaways

1. **Ternary search** finds extremum in unimodal functions
2. **Three-way division** using two midpoints m1 and m2
3. **2 comparisons** per iteration vs 1 for binary search
4. **Use for continuous optimization**, not discrete arrays
5. **Verify unimodality** before applying

### When to Use Ternary Search

| Use Ternary ✅ | Use Binary Instead ✅ |
|---------------|---------------------|
| Finding maximum/minimum | Finding exact element |
| Unimodal function | Monotonic function |
| Continuous optimization | Discrete array |
| Derivative complex | Feasibility checking |
| Real number search | Peak in array (more efficient) |

### Algorithm Template

```java
// Continuous optimization
double left = min, right = max;
while (right - left > epsilon) {
    double m1 = left + (right - left) / 3;
    double m2 = right - (right - left) / 3;
    
    if (f(m1) < f(m2)) {  // For maximum
        left = m1;
    } else {
        right = m2;
    }
}
return (left + right) / 2;
```

### Complexity Summary

| Aspect | Complexity |
|--------|------------|
| Time (continuous) | O(log₃(range/ε)) |
| Time (discrete) | O(log₃ n) |
| Space (iterative) | O(1) |
| Space (recursive) | O(log₃ n) |
| Comparisons | ~2 per iteration |

### Common Patterns

1. **Polynomial optimization**: Finding max/min of f(x) = ax² + bx + c
2. **Revenue maximization**: price × demand curves
3. **Meeting point**: Minimize sum of distances
4. **Speed optimization**: Balance multiple factors
5. **Resource allocation**: Optimize distribution

### Interview Tips

1. **Verify unimodal**: Check function has single peak/valley
2. **Choose epsilon**: Based on precision requirements (usually 1e-6 or 1e-9)
3. **Consider binary**: For discrete problems, binary search is better
4. **Test boundaries**: Peak might be at edges
5. **Explain trade-offs**: More iterations than binary, but works on different problems

---

**Next**: [5.5 Exponential Search](5.5-Exponential-Search.md) - Learn searching in unbounded/infinite arrays
