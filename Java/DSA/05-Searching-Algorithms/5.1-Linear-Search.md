# 5.1 Linear Search

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Variations](#variations)
4. [Common Patterns](#common-patterns)
5. [Applications](#applications)
6. [Optimizations](#optimizations)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is Linear Search?

Linear search (also called sequential search) is the simplest searching algorithm that sequentially checks each element in a collection until the target is found or the end is reached.

**Key Characteristics**:
- Simple and intuitive
- Works on unsorted data
- No preprocessing required
- O(n) time complexity in worst case
- Best for small datasets or single searches

### When to Use Linear Search?

✅ **Use Linear Search when**:
- Data is unsorted
- Dataset is small (n < 100)
- Searching only once (no multiple queries)
- Simplicity is more important than efficiency
- Need to find all occurrences

❌ **Avoid when**:
- Data is sorted (use Binary Search instead - O(log n))
- Multiple searches needed (consider preprocessing with HashMap)
- Dataset is very large (n > 10⁶)

### Complexity Analysis

| Case | Time | Space |
|------|------|-------|
| **Best** | O(1) | O(1) |
| **Average** | O(n) | O(1) |
| **Worst** | O(n) | O(1) |

- **Best Case**: Element at first position
- **Average Case**: Element at middle (n/2 comparisons)
- **Worst Case**: Element at last position or not present

---

## Basic Implementation

### Template 1: Find First Occurrence (Returns Index)

```java
public class LinearSearch {
    /**
     * Find first occurrence of target in array
     * @return index if found, -1 otherwise
     */
    public int linearSearch(int[] arr, int target) {
        // Edge case: null or empty array
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        // Sequential search
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Found at index i
            }
        }
        
        return -1; // Not found
    }
    
    // Test
    public static void main(String[] args) {
        LinearSearch ls = new LinearSearch();
        
        int[] arr = {10, 25, 30, 45, 50, 25, 60};
        
        System.out.println(ls.linearSearch(arr, 45));  // Output: 3
        System.out.println(ls.linearSearch(arr, 25));  // Output: 1 (first occurrence)
        System.out.println(ls.linearSearch(arr, 100)); // Output: -1
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Template 2: Find Using Enhanced For Loop

```java
public class LinearSearchEnhanced {
    /**
     * Check if target exists in array
     * @return true if found, false otherwise
     */
    public boolean contains(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return false;
        }
        
        for (int num : arr) {
            if (num == target) {
                return true;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        LinearSearchEnhanced lse = new LinearSearchEnhanced();
        
        int[] arr = {10, 25, 30, 45, 50};
        
        System.out.println(lse.contains(arr, 30));  // true
        System.out.println(lse.contains(arr, 100)); // false
    }
}
```

**When to use**: When you only need to check existence, not the index.

---

### Template 3: Generic Linear Search

```java
public class GenericLinearSearch {
    /**
     * Generic linear search for any comparable type
     */
    public static <T> int search(T[] arr, T target) {
        if (arr == null || arr.length == 0 || target == null) {
            return -1;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].equals(target)) {
                return i;
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        // Integer array
        Integer[] nums = {10, 25, 30, 45, 50};
        System.out.println(search(nums, 30)); // 2
        
        // String array
        String[] names = {"Alice", "Bob", "Charlie", "David"};
        System.out.println(search(names, "Charlie")); // 2
        
        // Custom objects
        Person[] people = {
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 28)
        };
        System.out.println(search(people, new Person("Bob", 30))); // 1
    }
}

class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }
}
```

**Complexity**: O(n) time, O(1) space

---

## Variations

### Variation 1: Find Last Occurrence

```java
public class FindLastOccurrence {
    /**
     * Find last occurrence of target
     * @return last index if found, -1 otherwise
     */
    public int findLast(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int lastIndex = -1;
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                lastIndex = i; // Update last found index
            }
        }
        
        return lastIndex;
    }
    
    // Alternative: Search from right to left
    public int findLastReverse(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        for (int i = arr.length - 1; i >= 0; i--) {
            if (arr[i] == target) {
                return i; // First match from right = last occurrence
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        FindLastOccurrence flo = new FindLastOccurrence();
        
        int[] arr = {10, 25, 30, 45, 25, 50, 25};
        
        System.out.println(flo.findLast(arr, 25));        // 6
        System.out.println(flo.findLastReverse(arr, 25)); // 6
        System.out.println(flo.findLast(arr, 100));       // -1
    }
}
```

**Optimization**: Use reverse search to exit early when last occurrence is near the end.

**Complexity**: O(n) time, O(1) space

---

### Variation 2: Find All Occurrences

```java
import java.util.*;

public class FindAllOccurrences {
    /**
     * Find all indices where target appears
     * @return list of indices (empty if not found)
     */
    public List<Integer> findAll(int[] arr, int target) {
        List<Integer> indices = new ArrayList<>();
        
        if (arr == null || arr.length == 0) {
            return indices;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                indices.add(i);
            }
        }
        
        return indices;
    }
    
    // Test
    public static void main(String[] args) {
        FindAllOccurrences fao = new FindAllOccurrences();
        
        int[] arr = {10, 25, 30, 25, 50, 25, 60};
        
        System.out.println(fao.findAll(arr, 25));  // [1, 3, 5]
        System.out.println(fao.findAll(arr, 100)); // []
    }
}
```

**Use Case**: When you need positions of all duplicates.

**Complexity**: O(n) time, O(k) space where k = number of occurrences

---

### Variation 3: Count Occurrences

```java
public class CountOccurrences {
    /**
     * Count how many times target appears
     * @return count (0 if not found)
     */
    public int count(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        
        int count = 0;
        
        for (int num : arr) {
            if (num == target) {
                count++;
            }
        }
        
        return count;
    }
    
    // Test
    public static void main(String[] args) {
        CountOccurrences co = new CountOccurrences();
        
        int[] arr = {10, 25, 30, 25, 50, 25, 60};
        
        System.out.println(co.count(arr, 25));  // 3
        System.out.println(co.count(arr, 100)); // 0
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Variation 4: Search in 2D Array

```java
public class LinearSearch2D {
    /**
     * Find target in 2D array (not necessarily sorted)
     * @return int[] {row, col} if found, {-1, -1} otherwise
     */
    public int[] search2D(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return new int[]{-1, -1};
        }
        
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        
        return new int[]{-1, -1};
    }
    
    // Alternative: Return as soon as found
    public boolean exists2D(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        
        for (int[] row : matrix) {
            for (int num : row) {
                if (num == target) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        LinearSearch2D ls2d = new LinearSearch2D();
        
        int[][] matrix = {
            {10, 25, 30},
            {45, 50, 60},
            {75, 80, 90}
        };
        
        int[] result = ls2d.search2D(matrix, 50);
        System.out.println(Arrays.toString(result)); // [1, 1]
        
        System.out.println(ls2d.exists2D(matrix, 80)); // true
        System.out.println(ls2d.exists2D(matrix, 100)); // false
    }
}
```

**Complexity**: O(m × n) time, O(1) space

---

### Variation 5: Search with Condition

```java
public class ConditionalSearch {
    /**
     * Find first element satisfying a condition
     */
    public int findFirst(int[] arr, Predicate<Integer> condition) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        for (int i = 0; i < arr.length; i++) {
            if (condition.test(arr[i])) {
                return i;
            }
        }
        
        return -1;
    }
    
    // Without lambda (for competitive programming)
    public int findFirstEven(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] % 2 == 0) {
                return i;
            }
        }
        return -1;
    }
    
    public int findFirstGreaterThan(int[] arr, int threshold) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > threshold) {
                return i;
            }
        }
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        ConditionalSearch cs = new ConditionalSearch();
        
        int[] arr = {1, 3, 5, 8, 10, 12, 15};
        
        // Using lambda
        System.out.println(cs.findFirst(arr, x -> x % 2 == 0));  // 3 (index of 8)
        System.out.println(cs.findFirst(arr, x -> x > 10));      // 4 (index of 12)
        
        // Without lambda
        System.out.println(cs.findFirstEven(arr));                // 3
        System.out.println(cs.findFirstGreaterThan(arr, 10));     // 4
    }
}
```

**Use Case**: Finding elements based on custom conditions.

**Complexity**: O(n) time, O(1) space

---

## Common Patterns

### Pattern 1: Find Minimum/Maximum

```java
public class FindMinMax {
    /**
     * Find minimum element in array
     */
    public int findMin(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        int min = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < min) {
                min = arr[i];
            }
        }
        
        return min;
    }
    
    /**
     * Find maximum element in array
     */
    public int findMax(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        int max = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        
        return max;
    }
    
    /**
     * Find both min and max in single pass
     */
    public int[] findMinMax(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        int min = arr[0], max = arr[0];
        
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] < min) min = arr[i];
            if (arr[i] > max) max = arr[i];
        }
        
        return new int[]{min, max};
    }
    
    // Test
    public static void main(String[] args) {
        FindMinMax fmm = new FindMinMax();
        
        int[] arr = {45, 10, 80, 25, 60, 5, 90};
        
        System.out.println(fmm.findMin(arr)); // 5
        System.out.println(fmm.findMax(arr)); // 90
        System.out.println(Arrays.toString(fmm.findMinMax(arr))); // [5, 90]
    }
}
```

**Optimization**: Single pass for both min and max reduces constants.

**Complexity**: O(n) time, O(1) space

---

### Pattern 2: Find Second Largest/Smallest

```java
public class FindSecondLargest {
    /**
     * Find second largest element
     */
    public int findSecondLargest(int[] arr) {
        if (arr == null || arr.length < 2) {
            throw new IllegalArgumentException("Array must have at least 2 elements");
        }
        
        int largest = Integer.MIN_VALUE;
        int secondLargest = Integer.MIN_VALUE;
        
        for (int num : arr) {
            if (num > largest) {
                secondLargest = largest;
                largest = num;
            } else if (num > secondLargest && num != largest) {
                secondLargest = num;
            }
        }
        
        if (secondLargest == Integer.MIN_VALUE) {
            throw new IllegalArgumentException("No second largest element found");
        }
        
        return secondLargest;
    }
    
    /**
     * Find second smallest element
     */
    public int findSecondSmallest(int[] arr) {
        if (arr == null || arr.length < 2) {
            throw new IllegalArgumentException("Array must have at least 2 elements");
        }
        
        int smallest = Integer.MAX_VALUE;
        int secondSmallest = Integer.MAX_VALUE;
        
        for (int num : arr) {
            if (num < smallest) {
                secondSmallest = smallest;
                smallest = num;
            } else if (num < secondSmallest && num != smallest) {
                secondSmallest = num;
            }
        }
        
        if (secondSmallest == Integer.MAX_VALUE) {
            throw new IllegalArgumentException("No second smallest element found");
        }
        
        return secondSmallest;
    }
    
    // Test
    public static void main(String[] args) {
        FindSecondLargest fsl = new FindSecondLargest();
        
        int[] arr = {12, 35, 1, 10, 34, 1};
        
        System.out.println(fsl.findSecondLargest(arr));  // 34
        System.out.println(fsl.findSecondSmallest(arr)); // 10
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Pattern 3: Search in Rotated Array (Unsorted)

```java
public class SearchRotated {
    /**
     * Search in rotated array (linear approach)
     * Note: For sorted rotated arrays, use binary search
     */
    public int searchRotated(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        // Linear search works for any rotation
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        
        return -1;
    }
    
    /**
     * Find rotation point (where array was rotated)
     */
    public int findRotationPoint(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return i + 1; // Rotation point
            }
        }
        
        return 0; // Not rotated
    }
    
    // Test
    public static void main(String[] args) {
        SearchRotated sr = new SearchRotated();
        
        int[] arr = {4, 5, 6, 7, 0, 1, 2};
        
        System.out.println(sr.searchRotated(arr, 0)); // 4
        System.out.println(sr.findRotationPoint(arr)); // 4
    }
}
```

**Note**: For sorted rotated arrays, binary search is O(log n) - more efficient.

**Complexity**: O(n) time, O(1) space

---

### Pattern 4: Missing Number

```java
public class MissingNumber {
    /**
     * Find missing number in array [0, n]
     * Using linear search approach
     */
    public int findMissing(int[] arr) {
        int n = arr.length;
        
        // Expected sum: 0 + 1 + 2 + ... + n = n * (n + 1) / 2
        int expectedSum = n * (n + 1) / 2;
        
        // Actual sum
        int actualSum = 0;
        for (int num : arr) {
            actualSum += num;
        }
        
        return expectedSum - actualSum;
    }
    
    /**
     * Alternative: Using XOR (more robust against overflow)
     */
    public int findMissingXOR(int[] arr) {
        int n = arr.length;
        int xor = 0;
        
        // XOR with [0, n]
        for (int i = 0; i <= n; i++) {
            xor ^= i;
        }
        
        // XOR with array elements
        for (int num : arr) {
            xor ^= num;
        }
        
        return xor; // Missing number
    }
    
    // Test
    public static void main(String[] args) {
        MissingNumber mn = new MissingNumber();
        
        int[] arr = {3, 0, 1}; // Missing: 2
        System.out.println(mn.findMissing(arr));    // 2
        System.out.println(mn.findMissingXOR(arr)); // 2
        
        int[] arr2 = {9, 6, 4, 2, 3, 5, 7, 0, 1}; // Missing: 8
        System.out.println(mn.findMissing(arr2));   // 8
    }
}
```

**Complexity**: O(n) time, O(1) space

---

## Applications

### Application 1: Search in String

```java
public class LinearSearchString {
    /**
     * Find first occurrence of character in string
     */
    public int findChar(String str, char target) {
        if (str == null || str.isEmpty()) {
            return -1;
        }
        
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == target) {
                return i;
            }
        }
        
        return -1;
    }
    
    /**
     * Find substring using linear search
     */
    public int findSubstring(String text, String pattern) {
        if (text == null || pattern == null || pattern.length() > text.length()) {
            return -1;
        }
        
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j;
            for (j = 0; j < m; j++) {
                if (text.charAt(i + j) != pattern.charAt(j)) {
                    break;
                }
            }
            if (j == m) {
                return i; // Pattern found at index i
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        LinearSearchString lss = new LinearSearchString();
        
        System.out.println(lss.findChar("hello", 'l'));        // 2
        System.out.println(lss.findSubstring("hello", "ll"));  // 2
        System.out.println(lss.findSubstring("hello", "world")); // -1
    }
}
```

**Note**: Java's `indexOf()` uses optimized native implementation.

**Complexity**: 
- Find char: O(n) time
- Find substring: O(n × m) time

---

### Application 2: Search in Linked List

```java
public class LinearSearchLinkedList {
    static class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    /**
     * Search in linked list
     */
    public int search(Node head, int target) {
        Node current = head;
        int index = 0;
        
        while (current != null) {
            if (current.data == target) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1; // Not found
    }
    
    /**
     * Check if element exists
     */
    public boolean contains(Node head, int target) {
        Node current = head;
        
        while (current != null) {
            if (current.data == target) {
                return true;
            }
            current = current.next;
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        LinearSearchLinkedList lsll = new LinearSearchLinkedList();
        
        // Create linked list: 10 -> 25 -> 30 -> 45
        Node head = new Node(10);
        head.next = new Node(25);
        head.next.next = new Node(30);
        head.next.next.next = new Node(45);
        
        System.out.println(lsll.search(head, 30));    // 2
        System.out.println(lsll.contains(head, 45));  // true
        System.out.println(lsll.contains(head, 100)); // false
    }
}
```

**Note**: Linear search is the ONLY option for unsorted linked lists (can't use binary search - no random access).

**Complexity**: O(n) time, O(1) space

---

### Application 3: Sentinel Linear Search

```java
public class SentinelLinearSearch {
    /**
     * Sentinel linear search - Reduces comparisons by half
     * Avoids boundary checking in loop
     */
    public int sentinelSearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int n = arr.length;
        int last = arr[n - 1]; // Save last element
        
        arr[n - 1] = target; // Place sentinel
        
        int i = 0;
        while (arr[i] != target) {
            i++;
        }
        
        arr[n - 1] = last; // Restore last element
        
        // Check if found before sentinel or at original position
        if (i < n - 1 || arr[n - 1] == target) {
            return i;
        }
        
        return -1; // Not found
    }
    
    // Test
    public static void main(String[] args) {
        SentinelLinearSearch sls = new SentinelLinearSearch();
        
        int[] arr = {10, 25, 30, 45, 50};
        
        System.out.println(sls.sentinelSearch(arr, 30));  // 2
        System.out.println(sls.sentinelSearch(arr, 100)); // -1
    }
}
```

**Optimization**: Reduces number of comparisons from 2n to n (no boundary check in loop).

**Use Case**: Performance-critical code in low-level systems.

**Complexity**: O(n) time, O(1) space

---

## Optimizations

### Optimization 1: Early Exit

```java
public class EarlyExit {
    /**
     * Stop searching as soon as found
     * Already implemented in basic template
     */
    public int search(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Early exit - don't continue
            }
        }
        return -1;
    }
}
```

**Benefit**: Best case O(1) when element is at beginning.

---

### Optimization 2: Sorted Array with Early Exit

```java
public class SortedLinearSearch {
    /**
     * Linear search on sorted array - can exit early
     */
    public int searchSorted(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
            if (arr[i] > target) {
                return -1; // Won't find it further - early exit
            }
        }
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        SortedLinearSearch sls = new SortedLinearSearch();
        
        int[] arr = {10, 20, 30, 40, 50};
        
        System.out.println(sls.searchSorted(arr, 30));  // 2
        System.out.println(sls.searchSorted(arr, 25));  // -1 (exits at index 2)
    }
}
```

**Note**: If array is sorted, binary search O(log n) is much better than this O(n) approach.

---

### Optimization 3: Move-to-Front

```java
public class MoveToFront {
    /**
     * Self-organizing linear search
     * Move found element to front for faster future searches
     */
    public int searchAndMove(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                // Move to front if not already there
                if (i > 0) {
                    int temp = arr[i];
                    // Shift elements
                    for (int j = i; j > 0; j--) {
                        arr[j] = arr[j - 1];
                    }
                    arr[0] = temp;
                }
                return 0; // Now at index 0
            }
        }
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        MoveToFront mtf = new MoveToFront();
        
        int[] arr = {10, 25, 30, 45, 50};
        
        System.out.println(mtf.searchAndMove(arr, 45));  // 0 (moved to front)
        System.out.println(Arrays.toString(arr));        // [45, 10, 25, 30, 50]
        
        System.out.println(mtf.searchAndMove(arr, 45));  // 0 (already at front)
    }
}
```

**Use Case**: When some elements are accessed more frequently.

**Complexity**: O(n) time per search, but improves over multiple searches for hot elements.

---

### Optimization 4: Transpose

```java
public class Transpose {
    /**
     * Swap found element with predecessor
     * Gradually moves frequently accessed elements forward
     */
    public int searchAndTranspose(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                // Swap with previous element (if not first)
                if (i > 0) {
                    int temp = arr[i];
                    arr[i] = arr[i - 1];
                    arr[i - 1] = temp;
                    return i - 1;
                }
                return i;
            }
        }
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        Transpose t = new Transpose();
        
        int[] arr = {10, 25, 30, 45, 50};
        
        System.out.println(t.searchAndTranspose(arr, 45));  // 2
        System.out.println(Arrays.toString(arr));           // [10, 25, 45, 30, 50]
        
        System.out.println(t.searchAndTranspose(arr, 45));  // 1
        System.out.println(Arrays.toString(arr));           // [10, 45, 25, 30, 50]
    }
}
```

**Use Case**: More conservative than move-to-front; adapts gradually.

---

## Interview Questions

### Q1: What is the time complexity of linear search?

**Answer**: 
- **Best case**: O(1) - element at first position
- **Average case**: O(n/2) = O(n) - element in middle
- **Worst case**: O(n) - element at last position or not present
- **Space**: O(1) - no extra space needed

---

### Q2: When should you use linear search instead of binary search?

**Answer**:
Use linear search when:
1. **Data is unsorted** (binary search requires sorted data)
2. **Small dataset** (n < 100) - overhead of sorting not worth it
3. **Single search** - no benefit from sorting for one search
4. **Linked list** - no random access for binary search
5. **Simplicity matters** - easier to implement and understand

Use binary search when:
- Data is already sorted
- Multiple searches on same data
- Large dataset (n > 1000)
- O(log n) improvement is significant

---

### Q3: Can linear search be faster than binary search?

**Answer**: Yes, in these scenarios:

1. **Best case**: O(1) if element is at start vs O(log n) for binary search
2. **Small arrays**: For n < 10, linear search has less overhead
3. **Unsorted data**: Linear search O(n) vs sort + binary search O(n log n + log n)
4. **Single search**: No amortization benefit from sorting

**Example**:
```java
int[] arr = {5, 2, 8, 1, 9}; // Small, unsorted
// Linear search: O(n) = 5 comparisons
// Binary search: O(n log n) sorting + O(log n) search = ~15 operations
```

---

### Q4: What is sentinel linear search and why use it?

**Answer**:

**Sentinel linear search** places the search key at the end of array to eliminate boundary checking in the loop.

**Normal linear search**:
```java
for (int i = 0; i < n; i++) {  // 2 comparisons per iteration
    if (arr[i] == target) return i;
}
```

**Sentinel linear search**:
```java
last = arr[n-1];
arr[n-1] = target;
i = 0;
while (arr[i] != target) i++;  // 1 comparison per iteration
arr[n-1] = last;
```

**Benefits**:
- Reduces comparisons from 2n to n
- 10-20% performance improvement
- Useful in embedded/real-time systems

**Drawback**: Modifies array temporarily

---

### Q5: How do you search in a 2D array?

**Answer**:

**Approach 1: Row-by-row linear search** (unsorted 2D array)
```java
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        if (matrix[i][j] == target) return true;
    }
}
```
**Complexity**: O(m × n)

**Approach 2**: If sorted row-wise and column-wise, start from top-right or bottom-left:
```java
int i = 0, j = cols - 1;
while (i < rows && j >= 0) {
    if (matrix[i][j] == target) return true;
    if (matrix[i][j] > target) j--;
    else i++;
}
```
**Complexity**: O(m + n)

---

### Q6: What are advantages and disadvantages of linear search?

**Advantages**:
✅ Simple to implement
✅ Works on unsorted data
✅ No preprocessing needed
✅ Works with any data structure (array, linked list)
✅ Best for small datasets
✅ O(1) space complexity

**Disadvantages**:
❌ Slow for large datasets - O(n)
❌ Inefficient for multiple searches
❌ Not suitable for sorted data (binary search better)
❌ Cannot be parallelized easily

---

### Q7: How to optimize linear search for frequently accessed elements?

**Answer**:

**Technique 1: Move-to-Front**
- Move accessed element to front
- Best for highly skewed access patterns
- O(n) per search, but O(1) for hot elements

**Technique 2: Transpose**
- Swap with predecessor
- Gradual adaptation
- More stable than move-to-front

**Technique 3: Frequency Count**
- Maintain access count
- Periodically sort by frequency
- Balance between search and reorganization

**Example**:
```java
// Move-to-front for hot element
int[] arr = {10, 25, 30, 45, 50};
// After searching 45 multiple times: [45, 10, 25, 30, 50]
// Future searches for 45: O(1) instead of O(n)
```

---

### Q8: Can you parallelize linear search?

**Answer**: Yes, but with limited benefit:

**Approach**:
```java
// Divide array into chunks
// Search each chunk in parallel
// Return first match found
```

**Implementation** (simplified):
```java
ExecutorService executor = Executors.newFixedThreadPool(4);
int chunkSize = arr.length / 4;
// Submit 4 tasks, each searching arr[i*chunkSize to (i+1)*chunkSize]
```

**Limitations**:
- Overhead of thread creation
- Only beneficial for very large arrays (n > 10⁶)
- Early exit difficult to implement
- Not suitable for competitive programming

**Better alternative**: Use data structures (HashMap for O(1) lookup)

---

### Q9: How does linear search compare to HashMap lookup?

**Answer**:

| Aspect | Linear Search | HashMap |
|--------|---------------|---------|
| **Search time** | O(n) | O(1) average |
| **Space** | O(1) | O(n) |
| **Preprocessing** | None | Build HashMap O(n) |
| **Best for** | Single search | Multiple searches |
| **Modification** | Easy | Rebuild HashMap |

**Decision**:
```java
// Single search on array
if (searches == 1) use linear search;

// Multiple searches
if (searches > 1) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < arr.length; i++) {
        map.put(arr[i], i);
    }
    // Now searches are O(1)
}
```

---

### Q10: What is the difference between linear search and binary search?

**Answer**:

| Feature | Linear Search | Binary Search |
|---------|--------------|---------------|
| **Requirement** | Any array | Sorted array |
| **Time (worst)** | O(n) | O(log n) |
| **Time (best)** | O(1) | O(1) |
| **Time (avg)** | O(n) | O(log n) |
| **Space** | O(1) | O(1) iterative, O(log n) recursive |
| **Complexity** | Simple | Moderate |
| **Data structure** | Any (array, list) | Array only (needs random access) |

**Example** (n = 1000):
- Linear search: up to 1000 comparisons
- Binary search: up to 10 comparisons (log₂(1000) ≈ 10)

**When to use each**:
- Unsorted or small data → Linear search
- Sorted and large data → Binary search

---

## Practice Problems

### Problem 1: First Bad Version (LeetCode 278 variant)

**Description**: You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version is bad. Given an array of version status, find the first bad version.

**Linear Search Solution**:
```java
public class FirstBadVersion {
    /**
     * Linear search approach (not optimal, but demonstrates concept)
     */
    public int firstBadVersion(boolean[] versions) {
        for (int i = 0; i < versions.length; i++) {
            if (versions[i]) { // true = bad
                return i;
            }
        }
        return -1; // All good
    }
    
    // Test
    public static void main(String[] args) {
        FirstBadVersion fbv = new FirstBadVersion();
        
        boolean[] versions = {false, false, false, true, true};
        System.out.println(fbv.firstBadVersion(versions)); // 3
    }
}
```

**Note**: Binary search is optimal O(log n) solution for this problem.

**Complexity**: O(n) time, O(1) space

---

### Problem 2: Peak Element (LeetCode 162 variant)

**Description**: Find a peak element in array (element greater than neighbors).

**Linear Search Solution**:
```java
public class PeakElement {
    /**
     * Linear search for peak
     */
    public int findPeakElement(int[] arr) {
        if (arr == null || arr.length == 0) return -1;
        if (arr.length == 1) return 0;
        
        // Check first element
        if (arr[0] > arr[1]) return 0;
        
        // Check middle elements
        for (int i = 1; i < arr.length - 1; i++) {
            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
                return i;
            }
        }
        
        // Check last element
        if (arr[arr.length - 1] > arr[arr.length - 2]) {
            return arr.length - 1;
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        PeakElement pe = new PeakElement();
        
        int[] arr1 = {1, 2, 3, 1};
        System.out.println(pe.findPeakElement(arr1)); // 2 (element 3)
        
        int[] arr2 = {1, 2, 1, 3, 5, 6, 4};
        System.out.println(pe.findPeakElement(arr2)); // 1 or 5
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 3: Check if Array is Sorted

**Description**: Determine if array is sorted in ascending order.

**Solution**:
```java
public class CheckSorted {
    /**
     * Check if array is sorted
     */
    public boolean isSorted(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return true;
        }
        
        for (int i = 0; i < arr.length - 1; i++) {
            if (arr[i] > arr[i + 1]) {
                return false; // Found decreasing pair
            }
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        CheckSorted cs = new CheckSorted();
        
        System.out.println(cs.isSorted(new int[]{1, 2, 3, 4, 5})); // true
        System.out.println(cs.isSorted(new int[]{1, 3, 2, 4, 5})); // false
        System.out.println(cs.isSorted(new int[]{5, 5, 5}));       // true
    }
}
```

**Complexity**: O(n) time, O(1) space

---

### Problem 4: Find Majority Element (LeetCode 169)

**Description**: Find element that appears more than ⌊n/2⌋ times.

**Linear Search with Counting**:
```java
import java.util.*;

public class MajorityElement {
    /**
     * Approach 1: HashMap (simple)
     */
    public int majorityElement(int[] arr) {
        Map<Integer, Integer> count = new HashMap<>();
        int n = arr.length;
        
        for (int num : arr) {
            count.put(num, count.getOrDefault(num, 0) + 1);
            if (count.get(num) > n / 2) {
                return num;
            }
        }
        
        return -1;
    }
    
    /**
     * Approach 2: Boyer-Moore Voting (O(1) space)
     */
    public int majorityElementOptimal(int[] arr) {
        int candidate = arr[0];
        int count = 1;
        
        // Find candidate
        for (int i = 1; i < arr.length; i++) {
            if (count == 0) {
                candidate = arr[i];
                count = 1;
            } else if (arr[i] == candidate) {
                count++;
            } else {
                count--;
            }
        }
        
        return candidate; // Assumes majority element always exists
    }
    
    // Test
    public static void main(String[] args) {
        MajorityElement me = new MajorityElement();
        
        int[] arr1 = {3, 2, 3};
        System.out.println(me.majorityElement(arr1)); // 3
        
        int[] arr2 = {2, 2, 1, 1, 1, 2, 2};
        System.out.println(me.majorityElementOptimal(arr2)); // 2
    }
}
```

**Complexity**: 
- HashMap: O(n) time, O(n) space
- Boyer-Moore: O(n) time, O(1) space

---

### Problem 5: Find Element in Infinite Array

**Description**: Find target in sorted infinite array (you can't get length).

**Solution**:
```java
public class InfiniteArray {
    /**
     * Simulated infinite array
     */
    static class ArrayReader {
        private int[] arr;
        
        ArrayReader(int[] arr) {
            this.arr = arr;
        }
        
        int get(int index) {
            if (index >= arr.length) {
                return Integer.MAX_VALUE; // Represents infinity
            }
            return arr[index];
        }
    }
    
    /**
     * Find target using exponential search + linear
     */
    public int search(ArrayReader reader, int target) {
        // Find range using exponential search
        int left = 0, right = 1;
        
        while (reader.get(right) < target) {
            left = right;
            right *= 2; // Exponential jump
        }
        
        // Linear search in range [left, right]
        for (int i = left; i <= right; i++) {
            int val = reader.get(i);
            if (val == target) return i;
            if (val > target) return -1;
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        InfiniteArray ia = new InfiniteArray();
        
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
        ArrayReader reader = new ArrayReader(arr);
        
        System.out.println(ia.search(reader, 9));  // 4
        System.out.println(ia.search(reader, 100)); // -1
    }
}
```

**Note**: Binary search in range would be optimal O(log n).

**Complexity**: O(log n) to find range + O(right - left) for linear = O(log n) for range finding

---

## Summary

### Key Takeaways

1. **Simple but important**: Linear search is fundamental - master it first
2. **Best for unsorted data**: Only option when data isn't sorted
3. **O(n) complexity**: Understand when this is acceptable vs when to optimize
4. **Many variations**: First/last occurrence, count, 2D search, conditional search
5. **Foundation for optimization**: Learn self-organizing techniques

### When to Use Linear Search

```
Use Linear Search:
✓ Unsorted data
✓ Small arrays (n < 100)
✓ Single search
✓ Linked lists
✓ Simplicity is priority

Use Alternatives:
✗ Sorted data → Binary Search O(log n)
✗ Multiple searches → HashMap O(1)
✗ Large data → Indexing/preprocessing
```

### Complexity Summary

| Operation | Time | Space |
|-----------|------|-------|
| Basic search | O(n) | O(1) |
| Find all | O(n) | O(k) |
| 2D search | O(m×n) | O(1) |
| Linked list | O(n) | O(1) |
| With move-to-front | O(n) worst, O(1) for hot items | O(1) |

### Common Patterns Checklist

- [ ] Find first/last occurrence
- [ ] Count occurrences
- [ ] Find min/max
- [ ] Search with condition
- [ ] 2D array search
- [ ] Linked list search
- [ ] Self-organizing search

### Interview Tips

1. **Always clarify**: Is data sorted? Single or multiple searches?
2. **Start with linear search**: Then optimize if needed
3. **Mention alternatives**: "Binary search would be O(log n) if sorted"
4. **Handle edge cases**: null, empty, single element
5. **Optimize when asked**: Sentinel, move-to-front, transpose

---

**Next**: [5.2 Binary Search](5.2-Binary-Search.md) - Learn O(log n) searching for sorted data
