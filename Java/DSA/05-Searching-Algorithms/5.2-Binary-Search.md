# 5.2 Binary Search

## Table of Contents
1. [Introduction](#introduction)
2. [Basic Implementation](#basic-implementation)
3. [Variations](#variations)
4. [Common Patterns](#common-patterns)
5. [Advanced Applications](#advanced-applications)
6. [Common Pitfalls](#common-pitfalls)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### What is Binary Search?

Binary search is a **divide-and-conquer** algorithm that finds the position of a target value within a **sorted array** by repeatedly dividing the search interval in half.

**Key Characteristics**:
- Works only on **sorted** data
- O(log n) time complexity
- Efficient for large datasets
- Can be iterative or recursive
- Foundation for many optimization problems

### How Binary Search Works

```
Array: [1, 3, 5, 7, 9, 11, 13, 15]  Target: 7

Step 1: mid = (0 + 7) / 2 = 3, arr[3] = 7  ✓ Found!

If target was 11:
Step 1: mid = 3, arr[3] = 7 < 11  → search right half [9,11,13,15]
Step 2: mid = 5, arr[5] = 11      ✓ Found!
```

### When to Use Binary Search?

✅ **Use Binary Search when**:
- Array is **sorted** (ascending or descending)
- Need O(log n) performance
- Large dataset (n > 1000)
- Multiple searches on same data
- Finding bounds/ranges

❌ **Don't use when**:
- Data is unsorted (use linear search or sort first)
- Very small arrays (n < 10) - linear search simpler
- Need to find all occurrences in one pass

### Complexity Analysis

| Case | Time | Space |
|------|------|-------|
| **Best** | O(1) | O(1) iterative, O(log n) recursive |
| **Average** | O(log n) | O(1) iterative, O(log n) recursive |
| **Worst** | O(log n) | O(1) iterative, O(log n) recursive |

**Example**: For n = 1,000,000
- Binary search: ~20 comparisons (log₂(1,000,000) ≈ 20)
- Linear search: up to 1,000,000 comparisons

---

## Basic Implementation

### Template 1: Iterative Binary Search (Most Common)

```java
public class BinarySearch {
    /**
     * Standard iterative binary search
     * @return index if found, -1 otherwise
     */
    public int binarySearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0;
        int right = arr.length - 1;
        
        while (left <= right) {
            // Avoid overflow: mid = (left + right) / 2
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid; // Found
            } else if (arr[mid] < target) {
                left = mid + 1; // Search right half
            } else {
                right = mid - 1; // Search left half
            }
        }
        
        return -1; // Not found
    }
    
    // Test
    public static void main(String[] args) {
        BinarySearch bs = new BinarySearch();
        
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        
        System.out.println(bs.binarySearch(arr, 7));   // 3
        System.out.println(bs.binarySearch(arr, 11));  // 5
        System.out.println(bs.binarySearch(arr, 100)); // -1
    }
}
```

**Why `left + (right - left) / 2`?**
- Avoids integer overflow when left + right > Integer.MAX_VALUE
- Equivalent to `(left + right) / 2` but safer

**Complexity**: O(log n) time, O(1) space

---

### Template 2: Recursive Binary Search

```java
public class RecursiveBinarySearch {
    /**
     * Recursive binary search
     */
    public int binarySearch(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        return binarySearchHelper(arr, target, 0, arr.length - 1);
    }
    
    private int binarySearchHelper(int[] arr, int target, int left, int right) {
        // Base case: not found
        if (left > right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid; // Found
        } else if (arr[mid] < target) {
            return binarySearchHelper(arr, target, mid + 1, right); // Search right
        } else {
            return binarySearchHelper(arr, target, left, mid - 1); // Search left
        }
    }
    
    // Test
    public static void main(String[] args) {
        RecursiveBinarySearch rbs = new RecursiveBinarySearch();
        
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        
        System.out.println(rbs.binarySearch(arr, 7));   // 3
        System.out.println(rbs.binarySearch(arr, 100)); // -1
    }
}
```

**Note**: Recursive uses O(log n) call stack space. Prefer iterative in competitive programming.

**Complexity**: O(log n) time, O(log n) space

---

### Template 3: Java Built-in Binary Search

```java
import java.util.Arrays;

public class BuiltInBinarySearch {
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        
        // Arrays.binarySearch() returns:
        // - index if found (>= 0)
        // - (-(insertion point) - 1) if not found (< 0)
        
        int index1 = Arrays.binarySearch(arr, 7);
        System.out.println(index1); // 3
        
        int index2 = Arrays.binarySearch(arr, 6);
        System.out.println(index2); // -4 (insertion point would be index 3)
        
        // To get insertion point from negative result:
        if (index2 < 0) {
            int insertionPoint = -(index2 + 1);
            System.out.println("Insertion point: " + insertionPoint); // 3
        }
    }
}
```

**Use Cases**:
- Quick implementation in contests
- Supports various data types
- Can search in range: `Arrays.binarySearch(arr, fromIndex, toIndex, key)`

---

## Variations

### Variation 1: Find First Occurrence (Lower Bound)

```java
public class FindFirstOccurrence {
    /**
     * Find first (leftmost) occurrence of target
     * Also known as lower_bound in C++
     */
    public int findFirst(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0, right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;         // Found, but keep searching left
                right = mid - 1;      // Continue in left half
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindFirstOccurrence ffo = new FindFirstOccurrence();
        
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        
        System.out.println(ffo.findFirst(arr, 2)); // 1 (first occurrence of 2)
        System.out.println(ffo.findFirst(arr, 6)); // -1
    }
}
```

**Use Case**: Finding the start of a range of duplicates.

**Complexity**: O(log n) time, O(1) space

---

### Variation 2: Find Last Occurrence (Upper Bound)

```java
public class FindLastOccurrence {
    /**
     * Find last (rightmost) occurrence of target
     */
    public int findLast(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0, right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;         // Found, but keep searching right
                left = mid + 1;       // Continue in right half
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindLastOccurrence flo = new FindLastOccurrence();
        
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        
        System.out.println(flo.findLast(arr, 2)); // 3 (last occurrence of 2)
        System.out.println(flo.findLast(arr, 6)); // -1
    }
}
```

**Use Case**: Finding the end of a range of duplicates.

**Complexity**: O(log n) time, O(1) space

---

### Variation 3: Count Occurrences

```java
public class CountOccurrences {
    /**
     * Count occurrences of target using binary search
     */
    public int countOccurrences(int[] arr, int target) {
        int first = findFirst(arr, target);
        
        if (first == -1) {
            return 0; // Not found
        }
        
        int last = findLast(arr, target);
        
        return last - first + 1;
    }
    
    private int findFirst(int[] arr, int target) {
        int left = 0, right = arr.length - 1, result = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                result = mid;
                right = mid - 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
    
    private int findLast(int[] arr, int target) {
        int left = 0, right = arr.length - 1, result = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                result = mid;
                left = mid + 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        CountOccurrences co = new CountOccurrences();
        
        int[] arr = {1, 2, 2, 2, 2, 3, 4, 5};
        
        System.out.println(co.countOccurrences(arr, 2)); // 4
        System.out.println(co.countOccurrences(arr, 5)); // 1
        System.out.println(co.countOccurrences(arr, 6)); // 0
    }
}
```

**Complexity**: O(log n) time (two binary searches), O(1) space

---

### Variation 4: Search in Descending Array

```java
public class SearchDescending {
    /**
     * Binary search in descending sorted array
     */
    public int binarySearchDesc(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                left = mid + 1;  // Target is smaller, search right
            } else {
                right = mid - 1; // Target is larger, search left
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        SearchDescending sd = new SearchDescending();
        
        int[] arr = {15, 13, 11, 9, 7, 5, 3, 1};
        
        System.out.println(sd.binarySearchDesc(arr, 7));  // 4
        System.out.println(sd.binarySearchDesc(arr, 11)); // 2
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Variation 5: Order-Agnostic Binary Search

```java
public class OrderAgnosticSearch {
    /**
     * Binary search that works for both ascending and descending arrays
     */
    public int search(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0, right = arr.length - 1;
        
        // Determine if array is ascending or descending
        boolean isAscending = arr[0] < arr[arr.length - 1];
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            }
            
            if (isAscending) {
                if (arr[mid] < target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            } else {
                if (arr[mid] > target) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        OrderAgnosticSearch oas = new OrderAgnosticSearch();
        
        int[] ascending = {1, 3, 5, 7, 9};
        int[] descending = {9, 7, 5, 3, 1};
        
        System.out.println(oas.search(ascending, 5));  // 2
        System.out.println(oas.search(descending, 5)); // 2
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

## Common Patterns

### Pattern 1: Search in Rotated Sorted Array (LeetCode 33)

```java
public class SearchRotatedArray {
    /**
     * Search in rotated sorted array (no duplicates)
     * Example: [4,5,6,7,0,1,2] rotated from [0,1,2,4,5,6,7]
     */
    public int search(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            }
            
            // Determine which half is sorted
            if (arr[left] <= arr[mid]) {
                // Left half is sorted
                if (target >= arr[left] && target < arr[mid]) {
                    right = mid - 1; // Target in left sorted half
                } else {
                    left = mid + 1;  // Target in right half
                }
            } else {
                // Right half is sorted
                if (target > arr[mid] && target <= arr[right]) {
                    left = mid + 1;  // Target in right sorted half
                } else {
                    right = mid - 1; // Target in left half
                }
            }
        }
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        SearchRotatedArray sra = new SearchRotatedArray();
        
        int[] arr = {4, 5, 6, 7, 0, 1, 2};
        
        System.out.println(sra.search(arr, 0)); // 4
        System.out.println(sra.search(arr, 3)); // -1
    }
}
```

**Key Insight**: At least one half is always sorted. Use that to determine search direction.

**Complexity**: O(log n) time, O(1) space

---

### Pattern 2: Find Minimum in Rotated Array (LeetCode 153)

```java
public class FindMinRotated {
    /**
     * Find minimum in rotated sorted array
     */
    public int findMin(int[] arr) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        int left = 0, right = arr.length - 1;
        
        // If array is not rotated
        if (arr[left] < arr[right]) {
            return arr[left];
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Check if mid+1 is the minimum
            if (arr[mid] > arr[mid + 1]) {
                return arr[mid + 1];
            }
            
            // Check if mid is the minimum
            if (mid > 0 && arr[mid] < arr[mid - 1]) {
                return arr[mid];
            }
            
            // Decide which half to search
            if (arr[mid] > arr[right]) {
                left = mid + 1; // Min is in right half
            } else {
                right = mid;    // Min is in left half
            }
        }
        
        return arr[left];
    }
    
    // Test
    public static void main(String[] args) {
        FindMinRotated fmr = new FindMinRotated();
        
        System.out.println(fmr.findMin(new int[]{4, 5, 6, 7, 0, 1, 2})); // 0
        System.out.println(fmr.findMin(new int[]{3, 4, 5, 1, 2}));       // 1
        System.out.println(fmr.findMin(new int[]{1, 2, 3, 4, 5}));       // 1
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Pattern 3: Search in 2D Matrix (LeetCode 74)

```java
public class Search2DMatrix {
    /**
     * Search in row-sorted and column-sorted matrix
     * Each row's first element > previous row's last element
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        // Treat 2D matrix as 1D array
        int left = 0, right = rows * cols - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            // Convert 1D index to 2D coordinates
            int midValue = matrix[mid / cols][mid % cols];
            
            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        Search2DMatrix s2d = new Search2DMatrix();
        
        int[][] matrix = {
            {1,  3,  5,  7},
            {10, 11, 16, 20},
            {23, 30, 34, 60}
        };
        
        System.out.println(s2d.searchMatrix(matrix, 3));  // true
        System.out.println(s2d.searchMatrix(matrix, 13)); // false
    }
}
```

**Key Trick**: Convert 2D index to 1D: `row = mid / cols`, `col = mid % cols`

**Complexity**: O(log(m × n)) time, O(1) space

---

### Pattern 4: Search in 2D Matrix II (LeetCode 240)

```java
public class Search2DMatrixII {
    /**
     * Search in matrix where:
     * - Each row is sorted left to right
     * - Each column is sorted top to bottom
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int row = 0;
        int col = matrix[0].length - 1; // Start from top-right
        
        while (row < matrix.length && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] > target) {
                col--; // Move left
            } else {
                row++; // Move down
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        Search2DMatrixII s2d2 = new Search2DMatrixII();
        
        int[][] matrix = {
            {1,  4,  7,  11, 15},
            {2,  5,  8,  12, 19},
            {3,  6,  9,  16, 22},
            {10, 13, 14, 17, 24},
            {18, 21, 23, 26, 30}
        };
        
        System.out.println(s2d2.searchMatrix(matrix, 5));  // true
        System.out.println(s2d2.searchMatrix(matrix, 20)); // false
    }
}
```

**Strategy**: Start from top-right (or bottom-left). Elements to left are smaller, below are larger.

**Complexity**: O(m + n) time, O(1) space

---

### Pattern 5: Find Peak Element (LeetCode 162)

```java
public class FindPeakElement {
    /**
     * Find any peak element (element greater than neighbors)
     * Array may have multiple peaks
     */
    public int findPeakElement(int[] arr) {
        if (arr == null || arr.length == 0) {
            return -1;
        }
        
        if (arr.length == 1) {
            return 0;
        }
        
        int left = 0, right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] > arr[mid + 1]) {
                // Peak is in left half (including mid)
                right = mid;
            } else {
                // Peak is in right half (excluding mid)
                left = mid + 1;
            }
        }
        
        return left; // left == right at this point
    }
    
    // Test
    public static void main(String[] args) {
        FindPeakElement fpe = new FindPeakElement();
        
        System.out.println(fpe.findPeakElement(new int[]{1, 2, 3, 1}));       // 2
        System.out.println(fpe.findPeakElement(new int[]{1, 2, 1, 3, 5, 6, 4})); // 1 or 5
    }
}
```

**Key Insight**: Always move towards the increasing slope - guaranteed to find a peak.

**Complexity**: O(log n) time, O(1) space

---

### Pattern 6: Square Root (LeetCode 69)

```java
public class SquareRoot {
    /**
     * Find integer square root (floor of sqrt)
     */
    public int mySqrt(int x) {
        if (x < 2) {
            return x;
        }
        
        int left = 1, right = x / 2; // sqrt(x) <= x/2 for x >= 2
        int result = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            long square = (long) mid * mid; // Use long to avoid overflow
            
            if (square == x) {
                return mid;
            } else if (square < x) {
                result = mid;     // Store potential answer
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        SquareRoot sr = new SquareRoot();
        
        System.out.println(sr.mySqrt(4));  // 2
        System.out.println(sr.mySqrt(8));  // 2 (floor of 2.82...)
        System.out.println(sr.mySqrt(16)); // 4
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

## Advanced Applications

### Application 1: Find Closest Element

```java
public class FindClosestElement {
    /**
     * Find element closest to target
     */
    public int findClosest(int[] arr, int target) {
        if (arr == null || arr.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        int left = 0, right = arr.length - 1;
        
        // Binary search to find position
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        // Check neighbors
        if (left == 0) return arr[0];
        if (left == arr.length) return arr[arr.length - 1];
        
        // Compare with previous element
        if (Math.abs(arr[left] - target) < Math.abs(arr[left - 1] - target)) {
            return arr[left];
        } else {
            return arr[left - 1];
        }
    }
    
    // Test
    public static void main(String[] args) {
        FindClosestElement fce = new FindClosestElement();
        
        int[] arr = {1, 3, 5, 7, 9};
        
        System.out.println(fce.findClosest(arr, 6)); // 5 or 7 (both distance 1)
        System.out.println(fce.findClosest(arr, 4)); // 3 or 5
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Application 2: Search Insert Position (LeetCode 35)

```java
public class SearchInsertPosition {
    /**
     * Find index where target should be inserted to maintain sorted order
     */
    public int searchInsert(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left; // Insertion position
    }
    
    // Test
    public static void main(String[] args) {
        SearchInsertPosition sip = new SearchInsertPosition();
        
        int[] arr = {1, 3, 5, 6};
        
        System.out.println(sip.searchInsert(arr, 5)); // 2
        System.out.println(sip.searchInsert(arr, 2)); // 1
        System.out.println(sip.searchInsert(arr, 7)); // 4
        System.out.println(sip.searchInsert(arr, 0)); // 0
    }
}
```

**Key Insight**: When loop ends, `left` is the insertion position.

**Complexity**: O(log n) time, O(1) space

---

### Application 3: Find First and Last Position (LeetCode 34)

```java
public class FindFirstAndLast {
    /**
     * Find range [first, last] of target in sorted array
     */
    public int[] searchRange(int[] arr, int target) {
        int[] result = {-1, -1};
        
        if (arr == null || arr.length == 0) {
            return result;
        }
        
        // Find first occurrence
        result[0] = findBound(arr, target, true);
        
        // If not found, return
        if (result[0] == -1) {
            return result;
        }
        
        // Find last occurrence
        result[1] = findBound(arr, target, false);
        
        return result;
    }
    
    private int findBound(int[] arr, int target, boolean isFirst) {
        int left = 0, right = arr.length - 1;
        int result = -1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                if (isFirst) {
                    right = mid - 1; // Continue searching left
                } else {
                    left = mid + 1;  // Continue searching right
                }
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindFirstAndLast ffal = new FindFirstAndLast();
        
        int[] arr = {5, 7, 7, 8, 8, 10};
        
        System.out.println(Arrays.toString(ffal.searchRange(arr, 8))); // [3, 4]
        System.out.println(Arrays.toString(ffal.searchRange(arr, 6))); // [-1, -1]
    }
}
```

**Complexity**: O(log n) time (two binary searches), O(1) space

---

### Application 4: Capacity To Ship Packages (LeetCode 1011)

```java
public class ShipPackages {
    /**
     * Binary search on answer space
     * Find minimum capacity to ship all packages within D days
     */
    public int shipWithinDays(int[] weights, int days) {
        // Search space: [max weight, sum of weights]
        int left = 0, right = 0;
        
        for (int weight : weights) {
            left = Math.max(left, weight); // Min capacity = heaviest package
            right += weight;               // Max capacity = all in one day
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canShip(weights, days, mid)) {
                right = mid; // Try smaller capacity
            } else {
                left = mid + 1; // Need larger capacity
            }
        }
        
        return left;
    }
    
    private boolean canShip(int[] weights, int days, int capacity) {
        int daysNeeded = 1;
        int currentLoad = 0;
        
        for (int weight : weights) {
            if (currentLoad + weight > capacity) {
                daysNeeded++;
                currentLoad = weight;
            } else {
                currentLoad += weight;
            }
        }
        
        return daysNeeded <= days;
    }
    
    // Test
    public static void main(String[] args) {
        ShipPackages sp = new ShipPackages();
        
        int[] weights = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println(sp.shipWithinDays(weights, 5)); // 15
    }
}
```

**Key Pattern**: Binary search on answer when answer has monotonic property.

**Complexity**: O(n × log(sum)) time, O(1) space

---

### Application 5: Koko Eating Bananas (LeetCode 875)

```java
public class KokoEatingBananas {
    /**
     * Find minimum eating speed to finish all piles within h hours
     */
    public int minEatingSpeed(int[] piles, int h) {
        // Search space: [1, max pile]
        int left = 1, right = 0;
        
        for (int pile : piles) {
            right = Math.max(right, pile);
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canEatAll(piles, h, mid)) {
                right = mid; // Try slower speed
            } else {
                left = mid + 1; // Need faster speed
            }
        }
        
        return left;
    }
    
    private boolean canEatAll(int[] piles, int h, int speed) {
        long hoursNeeded = 0;
        
        for (int pile : piles) {
            hoursNeeded += (pile + speed - 1) / speed; // Ceiling division
        }
        
        return hoursNeeded <= h;
    }
    
    // Test
    public static void main(String[] args) {
        KokoEatingBananas keb = new KokoEatingBananas();
        
        int[] piles = {3, 6, 7, 11};
        System.out.println(keb.minEatingSpeed(piles, 8)); // 4
        
        int[] piles2 = {30, 11, 23, 4, 20};
        System.out.println(keb.minEatingSpeed(piles2, 5)); // 30
    }
}
```

**Complexity**: O(n × log(max)) time, O(1) space

---

## Common Pitfalls

### Pitfall 1: Integer Overflow

```java
// ❌ WRONG - Can overflow
int mid = (left + right) / 2;

// ✅ CORRECT
int mid = left + (right - left) / 2;

// Alternative (Java)
int mid = (left + right) >>> 1; // Unsigned right shift
```

---

### Pitfall 2: Infinite Loop

```java
// ❌ WRONG - Can cause infinite loop
while (left < right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] < target) {
        left = mid;  // ❌ Should be mid + 1
    } else {
        right = mid;
    }
}

// ✅ CORRECT
while (left < right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] < target) {
        left = mid + 1;  // ✅ Move past mid
    } else {
        right = mid;
    }
}
```

---

### Pitfall 3: Off-by-One Errors

```java
// Different termination conditions for different scenarios

// Finding exact match
while (left <= right) {  // ✅ Use <=
    // ...
}

// Finding boundary
while (left < right) {   // ✅ Use <
    // ...
}
```

---

### Pitfall 4: Array Not Sorted

```java
// ❌ Binary search won't work correctly on unsorted array
int[] arr = {5, 2, 8, 1, 9};
int result = binarySearch(arr, 8); // May return wrong result

// ✅ Sort first or use linear search
Arrays.sort(arr);
int result = binarySearch(arr, 8); // Now correct
```

---

## Interview Questions

### Q1: What is the time and space complexity of binary search?

**Answer**:

**Iterative**:
- Time: O(log n)
- Space: O(1)

**Recursive**:
- Time: O(log n)
- Space: O(log n) due to call stack

**Why O(log n)?**
- Each step cuts search space in half
- After k steps: n/2^k elements remain
- When n/2^k = 1, k = log₂(n)

**Example**: For n = 1,000,000
- log₂(1,000,000) ≈ 20 comparisons

---

### Q2: Why must the array be sorted for binary search?

**Answer**:

Binary search relies on the **comparison property**:
- If `arr[mid] < target`, we know target must be in right half
- This is ONLY true if array is sorted

**Example**:
```java
Sorted: [1, 3, 5, 7, 9]
mid = 5, target = 7
Since 5 < 7, we know 7 must be in [7, 9] ✓

Unsorted: [5, 1, 9, 3, 7]
mid = 9, target = 7
Since 9 > 7, we search left... but 7 is actually on right! ✗
```

**Workaround**: Sort first O(n log n), then search O(log n). Worth it for multiple searches.

---

### Q3: How do you avoid integer overflow when calculating mid?

**Answer**:

**Problem**:
```java
int mid = (left + right) / 2; // ❌ Overflow if left + right > MAX_INT
```

**Solution 1**: Subtraction method
```java
int mid = left + (right - left) / 2; // ✅ Safe
```

**Solution 2**: Unsigned right shift (Java)
```java
int mid = (left + right) >>> 1; // ✅ Safe, slightly faster
```

**Why it matters**:
- `left = 2,000,000,000`, `right = 2,100,000,000`
- `left + right = 4,100,000,000` > `Integer.MAX_VALUE (2,147,483,647)`
- Causes negative overflow!

---

### Q4: What's the difference between `left <= right` and `left < right`?

**Answer**:

**`while (left <= right)`** - Standard binary search for exact match
```java
// When to use: Finding exact element
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) return mid;
    else if (arr[mid] < target) left = mid + 1;
    else right = mid - 1;
}
return -1; // Not found
```

**`while (left < right)`** - Finding boundaries/insertion points
```java
// When to use: Finding first/last occurrence, insertion point
while (left < right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] < target) left = mid + 1;
    else right = mid;
}
return left; // Boundary/insertion point
```

**Key difference**: `<` leaves `left == right` (the answer), `<=` exhausts search space.

---

### Q5: How do you find the first occurrence of an element?

**Answer**:

**Template**:
```java
int findFirst(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;  // ✅ Keep searching left
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

**Key**: Don't return immediately when found; continue searching left half.

---

### Q6: Can binary search be used on linked lists?

**Answer**: **Not efficiently**, but possible.

**Why not efficient**:
- Binary search requires random access O(1)
- Linked list access is O(n)
- Total: O(n) to find mid × O(log n) iterations = **O(n log n)**
- Worse than linear search O(n)!

**When it might make sense**:
- Skip list (special data structure with O(log n) search)
- If you need to maintain sorted order with frequent insertions/deletions

**Better alternatives for linked lists**:
- Linear search O(n)
- Convert to array temporarily
- Use TreeSet/TreeMap instead

---

### Q7: How does binary search work on rotated sorted arrays?

**Answer**:

**Key insight**: After rotation, at least one half is always sorted.

**Algorithm**:
```java
1. Find which half is sorted (compare arr[left] with arr[mid])
2. Check if target is in sorted half using comparisons
3. If yes, search sorted half; otherwise search other half
```

**Example**:
```java
arr = [4, 5, 6, 7, 0, 1, 2], target = 0
mid = 3 (value 7)
arr[left]=4 <= arr[mid]=7 → left half [4,5,6,7] is sorted
Is 0 in [4,7]? No → search right half
Continue...
```

**Complexity**: Still O(log n)!

---

### Q8: What is "binary search on answer"?

**Answer**:

**Technique**: When answer has **monotonic property** (if x works, all values > x work OR all values < x work), binary search the answer space instead of array.

**Pattern**:
```java
int left = minPossibleAnswer;
int right = maxPossibleAnswer;

while (left < right) {
    int mid = left + (right - left) / 2;
    if (isValid(mid)) {
        right = mid;  // Try smaller
    } else {
        left = mid + 1; // Need larger
    }
}
return left;
```

**Examples**:
- Koko eating bananas (speed 1 to max pile)
- Ship packages (capacity from max weight to sum)
- Minimum days to make m bouquets
- Split array largest sum

**Complexity**: O(n × log(answer_range))

---

### Q9: How do you handle duplicates in binary search?

**Answer**:

**Depends on requirement**:

**1. Find ANY occurrence** (standard binary search):
```java
// Return as soon as found
if (arr[mid] == target) return mid;
```

**2. Find FIRST occurrence**:
```java
if (arr[mid] == target) {
    result = mid;
    right = mid - 1; // Keep searching left
}
```

**3. Find LAST occurrence**:
```java
if (arr[mid] == target) {
    result = mid;
    left = mid + 1; // Keep searching right
}
```

**4. Count occurrences**:
```java
int count = findLast(arr, target) - findFirst(arr, target) + 1;
```

---

### Q10: What are the advantages and disadvantages of binary search?

**Answer**:

**Advantages**:
✅ Very fast: O(log n) vs O(n)
✅ Efficient for large datasets
✅ Simple to implement (iterative version)
✅ Predictable performance
✅ Low space: O(1) iterative

**Disadvantages**:
❌ Requires sorted data
❌ Requires random access (arrays only)
❌ Not efficient for frequently changing data
❌ Recursive version uses O(log n) space
❌ More complex than linear search

**Comparison**:
| | Binary Search | Linear Search |
|-|---------------|---------------|
| Time | O(log n) | O(n) |
| Requires sorted | Yes | No |
| Works on lists | No | Yes |
| Complexity | Moderate | Simple |

---

## Practice Problems

### Problem 1: First Bad Version (LeetCode 278)

**Description**: Find first bad version in versions 1 to n.

**Solution**:
```java
public class FirstBadVersion {
    // Simulated API
    boolean isBadVersion(int version) {
        return version >= 4; // Assume version 4 is first bad
    }
    
    public int firstBadVersion(int n) {
        int left = 1, right = n;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (isBadVersion(mid)) {
                right = mid; // First bad is at mid or before
            } else {
                left = mid + 1; // First bad is after mid
            }
        }
        
        return left;
    }
    
    // Test
    public static void main(String[] args) {
        FirstBadVersion fbv = new FirstBadVersion();
        System.out.println(fbv.firstBadVersion(5)); // 4
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 2: Valid Perfect Square (LeetCode 367)

**Description**: Check if number is perfect square without using sqrt.

**Solution**:
```java
public class ValidPerfectSquare {
    public boolean isPerfectSquare(int num) {
        if (num < 2) return true;
        
        long left = 2, right = num / 2;
        
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long square = mid * mid;
            
            if (square == num) {
                return true;
            } else if (square < num) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        ValidPerfectSquare vps = new ValidPerfectSquare();
        
        System.out.println(vps.isPerfectSquare(16)); // true
        System.out.println(vps.isPerfectSquare(14)); // false
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 3: Find Smallest Letter Greater Than Target (LeetCode 744)

**Description**: Find smallest letter in sorted array greater than target.

**Solution**:
```java
public class NextGreatestLetter {
    public char nextGreatestLetter(char[] letters, char target) {
        int left = 0, right = letters.length - 1;
        
        // If target >= last letter, return first (circular)
        if (target >= letters[right]) {
            return letters[0];
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return letters[left];
    }
    
    // Test
    public static void main(String[] args) {
        NextGreatestLetter ngl = new NextGreatestLetter();
        
        char[] letters = {'c', 'f', 'j'};
        System.out.println(ngl.nextGreatestLetter(letters, 'a')); // c
        System.out.println(ngl.nextGreatestLetter(letters, 'c')); // f
        System.out.println(ngl.nextGreatestLetter(letters, 'd')); // f
        System.out.println(ngl.nextGreatestLetter(letters, 'j')); // c (circular)
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 4: Find Minimum in Rotated Array II (LeetCode 154)

**Description**: Find minimum in rotated sorted array with duplicates.

**Solution**:
```java
public class FindMinRotatedWithDuplicates {
    public int findMin(int[] arr) {
        int left = 0, right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] > arr[right]) {
                left = mid + 1; // Min is in right half
            } else if (arr[mid] < arr[right]) {
                right = mid;    // Min is in left half or at mid
            } else {
                // arr[mid] == arr[right], can't determine
                right--;        // Reduce search space
            }
        }
        
        return arr[left];
    }
    
    // Test
    public static void main(String[] args) {
        FindMinRotatedWithDuplicates fmr = new FindMinRotatedWithDuplicates();
        
        System.out.println(fmr.findMin(new int[]{2, 2, 2, 0, 1})); // 0
        System.out.println(fmr.findMin(new int[]{1, 3, 5}));       // 1
    }
}
```

**Note**: Duplicates make worst case O(n), but average still O(log n).

**Complexity**: O(log n) average, O(n) worst case

---

### Problem 5: Single Element in Sorted Array (LeetCode 540)

**Description**: Find element that appears once in sorted array where all others appear twice.

**Solution**:
```java
public class SingleElementSorted {
    public int singleNonDuplicate(int[] arr) {
        int left = 0, right = arr.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Ensure mid is at even index
            if (mid % 2 == 1) {
                mid--;
            }
            
            // Check if pairs are intact
            if (arr[mid] == arr[mid + 1]) {
                // Pairs intact on left, single is on right
                left = mid + 2;
            } else {
                // Pair broken, single is on left (or at mid)
                right = mid;
            }
        }
        
        return arr[left];
    }
    
    // Test
    public static void main(String[] args) {
        SingleElementSorted ses = new SingleElementSorted();
        
        System.out.println(ses.singleNonDuplicate(new int[]{1,1,2,3,3,4,4,8,8})); // 2
        System.out.println(ses.singleNonDuplicate(new int[]{3,3,7,7,10,11,11})); // 10
    }
}
```

**Key Insight**: Before single element, pairs start at even indices. After, they start at odd indices.

**Complexity**: O(log n) time, O(1) space

---

## Summary

### Key Takeaways

1. **Binary search is O(log n)** - exponentially faster than linear search
2. **Requires sorted data** - critical prerequisite
3. **Master the templates** - exact match, first/last occurrence, insertion point
4. **Avoid overflow** - use `left + (right - left) / 2`
5. **Watch for infinite loops** - be careful with boundary updates
6. **Binary search on answer** - powerful technique for optimization problems

### Template Selection Guide

```
Finding exact element?
→ while (left <= right), return mid when found

Finding boundary (first/last occurrence, insertion point)?
→ while (left < right), return left after loop

Finding in rotated array?
→ Determine sorted half, check if target in range

Searching answer space?
→ Binary search on [min, max] with isValid() check
```

### Complexity Comparison

| Problem Type | Time | Space |
|--------------|------|-------|
| Basic search | O(log n) | O(1) |
| First/last occurrence | O(log n) | O(1) |
| Rotated array | O(log n) | O(1) |
| 2D matrix (type 1) | O(log(m×n)) | O(1) |
| 2D matrix (type 2) | O(m+n) | O(1) |
| Binary search on answer | O(n×log(range)) | O(1) |

### Common Patterns Checklist

- [ ] Standard binary search (exact match)
- [ ] Find first/last occurrence
- [ ] Search insert position
- [ ] Search in rotated array
- [ ] Find peak element
- [ ] Search in 2D matrix
- [ ] Binary search on answer space
- [ ] Find closest element
- [ ] Count occurrences

### Interview Tips

1. **Clarify**: Is array sorted? Duplicates allowed?
2. **Start simple**: Write standard binary search first
3. **Handle edge cases**: Empty array, single element, target not found
4. **Avoid overflow**: Use `left + (right - left) / 2`
5. **Test boundaries**: Check when target is at start/end
6. **Discuss alternatives**: When would linear search be better?

### When to Use Binary Search

```
✓ Sorted array or search space
✓ Large dataset (n > 100)
✓ Need O(log n) performance
✓ Finding boundaries/ranges
✓ Optimization problems with monotonic property

✗ Unsorted data (sort first or use linear search)
✗ Linked lists (no random access)
✗ Very small arrays (n < 10)
✗ Need to find ALL occurrences in one pass
```

---

**Next**: [5.3 Ternary Search](5.3-Ternary-Search.md) - Learn searching in unimodal functions
