# 5.3 Binary Search Variations

## Table of Contents
1. [Introduction](#introduction)
2. [Binary Search Templates](#binary-search-templates)
3. [Lower and Upper Bounds](#lower-and-upper-bounds)
4. [Binary Search on Answer](#binary-search-on-answer)
5. [Binary Search on Real Numbers](#binary-search-on-real-numbers)
6. [Advanced Patterns](#advanced-patterns)
7. [Interview Questions](#interview-questions)
8. [Practice Problems](#practice-problems)
9. [Summary](#summary)

---

## Introduction

### Beyond Basic Binary Search

While basic binary search finds an exact element, **binary search variations** solve a wider range of problems:

- Finding boundaries (first/last occurrence)
- Finding insertion points
- Searching on answer spaces
- Optimizing monotonic functions
- Working with real numbers
- Handling complex conditions

### Key Concept: Monotonicity

Binary search works when there's a **monotonic property**:
```
If condition(x) is true, then condition(x+1) is also true (or vice versa)
```

This allows us to partition the search space into two halves.

---

## Binary Search Templates

### Template 1: Standard Binary Search

**Use**: Finding exact element

```java
public class Template1 {
    /**
     * Standard binary search
     * Loop invariant: target may be in [left, right]
     */
    public int search(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1; // Not found
    }
    
    // Test
    public static void main(String[] args) {
        Template1 t1 = new Template1();
        int[] arr = {1, 3, 5, 7, 9};
        System.out.println(t1.search(arr, 5)); // 2
    }
}
```

**Characteristics**:
- Loop condition: `left <= right`
- Update: `left = mid + 1` or `right = mid - 1`
- Returns: specific index or -1
- Post-condition: `left > right`

---

### Template 2: Find Boundary (Left Boundary)

**Use**: Finding first position where condition becomes true

```java
public class Template2 {
    /**
     * Find left boundary
     * Loop invariant: answer is in [left, right]
     */
    public int searchBoundary(int[] arr, int target) {
        int left = 0, right = arr.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < target) {
                left = mid + 1;  // Answer is in (mid, right]
            } else {
                right = mid;     // Answer is in [left, mid]
            }
        }
        
        return left; // Left boundary
    }
    
    // Test
    public static void main(String[] args) {
        Template2 t2 = new Template2();
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        System.out.println(t2.searchBoundary(arr, 2)); // 1 (first occurrence)
    }
}
```

**Characteristics**:
- Loop condition: `left < right`
- Update: `left = mid + 1` or `right = mid` (no -1)
- Returns: `left` (which equals `right`)
- Post-condition: `left == right`

---

### Template 3: Find Boundary with Neighbor Check

**Use**: When decision depends on comparing with neighbors

```java
public class Template3 {
    /**
     * Find target with neighbor comparison
     * Loop invariant: answer is in [left, right]
     */
    public int search(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left + 1 < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid;  // Keep left = mid (not mid + 1)
            } else {
                right = mid; // Keep right = mid (not mid - 1)
            }
        }
        
        // Post-processing: check left and right
        if (arr[left] == target) return left;
        if (arr[right] == target) return right;
        
        return -1;
    }
    
    // Test
    public static void main(String[] args) {
        Template3 t3 = new Template3();
        int[] arr = {1, 3, 5, 7, 9};
        System.out.println(t3.search(arr, 5)); // 2
    }
}
```

**Characteristics**:
- Loop condition: `left + 1 < right`
- Update: `left = mid` or `right = mid` (keep mid)
- Post-processing: check `left` and `right`
- Use when: Need to examine neighbors

---

## Lower and Upper Bounds

### Lower Bound (First Position >= Target)

```java
public class LowerBound {
    /**
     * Find first position where arr[i] >= target
     * Same as C++ lower_bound()
     */
    public int lowerBound(int[] arr, int target) {
        int left = 0, right = arr.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    // Test
    public static void main(String[] args) {
        LowerBound lb = new LowerBound();
        
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        
        System.out.println(lb.lowerBound(arr, 2)); // 1 (first 2)
        System.out.println(lb.lowerBound(arr, 0)); // 0 (insert position)
        System.out.println(lb.lowerBound(arr, 6)); // 7 (after end)
    }
}
```

**Use Cases**:
- Finding first occurrence of element
- Finding insertion position
- Range queries start position

**Complexity**: O(log n) time, O(1) space

---

### Upper Bound (First Position > Target)

```java
public class UpperBound {
    /**
     * Find first position where arr[i] > target
     * Same as C++ upper_bound()
     */
    public int upperBound(int[] arr, int target) {
        int left = 0, right = arr.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    // Test
    public static void main(String[] args) {
        UpperBound ub = new UpperBound();
        
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        
        System.out.println(ub.upperBound(arr, 2)); // 4 (after last 2)
        System.out.println(ub.upperBound(arr, 5)); // 7 (after end)
        System.out.println(ub.upperBound(arr, 0)); // 0 (before start)
    }
}
```

**Use Cases**:
- Finding position after last occurrence
- Range queries end position
- Finding next greater element position

**Complexity**: O(log n) time, O(1) space

---

### Equal Range (Both Bounds Together)

```java
public class EqualRange {
    /**
     * Find range [first, last] of target
     * Returns [lower_bound, upper_bound)
     */
    public int[] equalRange(int[] arr, int target) {
        return new int[]{lowerBound(arr, target), upperBound(arr, target)};
    }
    
    private int lowerBound(int[] arr, int target) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] < target) left = mid + 1;
            else right = mid;
        }
        return left;
    }
    
    private int upperBound(int[] arr, int target) {
        int left = 0, right = arr.length;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] <= target) left = mid + 1;
            else right = mid;
        }
        return left;
    }
    
    /**
     * Count occurrences using equal range
     */
    public int countOccurrences(int[] arr, int target) {
        int[] range = equalRange(arr, target);
        return range[1] - range[0];
    }
    
    // Test
    public static void main(String[] args) {
        EqualRange er = new EqualRange();
        
        int[] arr = {1, 2, 2, 2, 3, 4, 5};
        
        int[] range = er.equalRange(arr, 2);
        System.out.println(Arrays.toString(range)); // [1, 4]
        System.out.println(er.countOccurrences(arr, 2)); // 3
    }
}
```

**Use Cases**:
- Finding all occurrences range
- Counting elements in sorted array
- Range-based operations

**Complexity**: O(log n) time, O(1) space

---

## Binary Search on Answer

### Pattern: Minimize Maximum

```java
public class MinimizeMaximum {
    /**
     * Split Array Largest Sum (LeetCode 410)
     * Minimize the largest sum among m subarrays
     */
    public int splitArray(int[] nums, int m) {
        // Search space: [max element, sum of all elements]
        int left = 0, right = 0;
        
        for (int num : nums) {
            left = Math.max(left, num);
            right += num;
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Can we split with max sum <= mid?
            if (canSplit(nums, m, mid)) {
                right = mid; // Try smaller max sum
            } else {
                left = mid + 1; // Need larger max sum
            }
        }
        
        return left;
    }
    
    private boolean canSplit(int[] nums, int m, int maxSum) {
        int subarrays = 1;
        int currentSum = 0;
        
        for (int num : nums) {
            if (currentSum + num > maxSum) {
                subarrays++;
                currentSum = num;
                if (subarrays > m) return false;
            } else {
                currentSum += num;
            }
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        MinimizeMaximum mm = new MinimizeMaximum();
        
        int[] nums = {7, 2, 5, 10, 8};
        System.out.println(mm.splitArray(nums, 2)); // 18
    }
}
```

**Pattern Recognition**: "Minimize the maximum" → Binary search on answer

**Complexity**: O(n × log(sum)) time, O(1) space

---

### Pattern: Maximize Minimum

```java
public class MaximizeMinimum {
    /**
     * Magnetic Force Between Two Balls (LeetCode 1552)
     * Maximize minimum distance between m balls in baskets
     */
    public int maxDistance(int[] position, int m) {
        Arrays.sort(position);
        
        // Search space: [1, max position - min position]
        int left = 1;
        int right = position[position.length - 1] - position[0];
        
        while (left < right) {
            int mid = left + (right - left + 1) / 2; // Right bias
            
            if (canPlaceBalls(position, m, mid)) {
                left = mid; // Try larger distance
            } else {
                right = mid - 1; // Need smaller distance
            }
        }
        
        return left;
    }
    
    private boolean canPlaceBalls(int[] position, int m, int minDist) {
        int count = 1;
        int lastPos = position[0];
        
        for (int i = 1; i < position.length; i++) {
            if (position[i] - lastPos >= minDist) {
                count++;
                lastPos = position[i];
                if (count >= m) return true;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        MaximizeMinimum mm = new MaximizeMinimum();
        
        int[] position = {1, 2, 3, 4, 7};
        System.out.println(mm.maxDistance(position, 3)); // 3
    }
}
```

**Pattern Recognition**: "Maximize the minimum" → Binary search on answer

**Note**: Use `mid = left + (right - left + 1) / 2` (right bias) to avoid infinite loop.

**Complexity**: O(n log n + n × log(max_position)) time

---

### Pattern: Binary Search + Greedy

```java
public class BinarySearchGreedy {
    /**
     * Cutting Ribbons (LeetCode 1891)
     * Maximum length to cut k ribbons of equal length
     */
    public int maxLength(int[] ribbons, int k) {
        // Search space: [1, max ribbon length]
        int left = 1, right = 0;
        
        for (int ribbon : ribbons) {
            right = Math.max(right, ribbon);
        }
        
        int result = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (canCut(ribbons, k, mid)) {
                result = mid;
                left = mid + 1; // Try longer length
            } else {
                right = mid - 1; // Try shorter length
            }
        }
        
        return result;
    }
    
    private boolean canCut(int[] ribbons, int k, int length) {
        int count = 0;
        
        for (int ribbon : ribbons) {
            count += ribbon / length;
            if (count >= k) return true;
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        BinarySearchGreedy bsg = new BinarySearchGreedy();
        
        int[] ribbons = {9, 7, 5};
        System.out.println(bsg.maxLength(ribbons, 3)); // 5
        
        int[] ribbons2 = {7, 5, 9};
        System.out.println(bsg.maxLength(ribbons2, 4)); // 4
    }
}
```

**Complexity**: O(n × log(max_length)) time, O(1) space

---

## Binary Search on Real Numbers

### Finding Square Root with Precision

```java
public class SquareRootPrecision {
    /**
     * Find square root with given precision
     */
    public double sqrt(double x, double epsilon) {
        if (x < 0) {
            throw new IllegalArgumentException("Cannot compute sqrt of negative number");
        }
        
        if (x == 0 || x == 1) {
            return x;
        }
        
        double left = 0, right = x;
        
        // For x < 1, sqrt(x) > x, so adjust right
        if (x < 1) {
            right = 1;
        }
        
        while (right - left > epsilon) {
            double mid = left + (right - left) / 2;
            double square = mid * mid;
            
            if (square < x) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        return left;
    }
    
    // Test
    public static void main(String[] args) {
        SquareRootPrecision srp = new SquareRootPrecision();
        
        System.out.println(srp.sqrt(2, 1e-6));   // ~1.414214
        System.out.println(srp.sqrt(9, 1e-6));   // ~3.0
        System.out.println(srp.sqrt(0.25, 1e-6)); // ~0.5
    }
}
```

**Key Difference**: Use `while (right - left > epsilon)` instead of `left < right`

**Complexity**: O(log(x / epsilon)) iterations

---

### Finding Function Root (Newton's Method Alternative)

```java
public class FunctionRoot {
    /**
     * Find x where f(x) = 0 using binary search
     * Requires: f is monotonic in [left, right]
     */
    public double findRoot(double left, double right, double epsilon) {
        while (right - left > epsilon) {
            double mid = left + (right - left) / 2;
            double fMid = function(mid);
            
            if (Math.abs(fMid) < epsilon) {
                return mid;
            }
            
            double fLeft = function(left);
            
            // If signs differ, root is in [left, mid]
            if (fLeft * fMid < 0) {
                right = mid;
            } else {
                left = mid;
            }
        }
        
        return left;
    }
    
    // Example: f(x) = x^2 - 2 (finding sqrt(2))
    private double function(double x) {
        return x * x - 2;
    }
    
    // Test
    public static void main(String[] args) {
        FunctionRoot fr = new FunctionRoot();
        
        double root = fr.findRoot(0, 2, 1e-6);
        System.out.println(root); // ~1.414214 (sqrt(2))
    }
}
```

**Use Case**: Finding roots of equations when derivative is complex or unavailable.

**Complexity**: O(log((right - left) / epsilon)) iterations

---

### Ternary Search (Finding Maximum/Minimum)

```java
public class TernarySearch {
    /**
     * Find maximum of unimodal function
     * Unimodal: single peak, strictly increasing then strictly decreasing
     */
    public double findMaximum(double left, double right, double epsilon) {
        while (right - left > epsilon) {
            double mid1 = left + (right - left) / 3;
            double mid2 = right - (right - left) / 3;
            
            if (function(mid1) < function(mid2)) {
                left = mid1; // Maximum is in [mid1, right]
            } else {
                right = mid2; // Maximum is in [left, mid2]
            }
        }
        
        return left;
    }
    
    // Example: f(x) = -(x-2)^2 + 3 (peak at x=2)
    private double function(double x) {
        return -(x - 2) * (x - 2) + 3;
    }
    
    // Test
    public static void main(String[] args) {
        TernarySearch ts = new TernarySearch();
        
        double maxX = ts.findMaximum(0, 5, 1e-6);
        System.out.println("Maximum at x = " + maxX); // ~2.0
        System.out.println("f(x) = " + ts.function(maxX)); // ~3.0
    }
}
```

**Key Difference from Binary Search**: Uses two midpoints, reduces search space by 1/3 each iteration.

**Complexity**: O(log₃((right - left) / epsilon)) iterations

---

## Advanced Patterns

### Pattern 1: Kth Element in Two Sorted Arrays

```java
public class KthElementTwoArrays {
    /**
     * Find kth smallest element in two sorted arrays
     * More efficient than merging (LeetCode 4 variant)
     */
    public int findKthElement(int[] arr1, int[] arr2, int k) {
        int m = arr1.length, n = arr2.length;
        
        // Ensure arr1 is smaller
        if (m > n) {
            return findKthElement(arr2, arr1, k);
        }
        
        int left = Math.max(0, k - n);
        int right = Math.min(k, m);
        
        while (left <= right) {
            int i = left + (right - left) / 2; // Elements from arr1
            int j = k - i;                      // Elements from arr2
            
            int arr1Left = (i == 0) ? Integer.MIN_VALUE : arr1[i - 1];
            int arr1Right = (i == m) ? Integer.MAX_VALUE : arr1[i];
            int arr2Left = (j == 0) ? Integer.MIN_VALUE : arr2[j - 1];
            int arr2Right = (j == n) ? Integer.MAX_VALUE : arr2[j];
            
            if (arr1Left <= arr2Right && arr2Left <= arr1Right) {
                // Found the partition
                return Math.max(arr1Left, arr2Left);
            } else if (arr1Left > arr2Right) {
                right = i - 1; // Take fewer from arr1
            } else {
                left = i + 1;  // Take more from arr1
            }
        }
        
        throw new IllegalArgumentException("Invalid input");
    }
    
    /**
     * Median of two sorted arrays (LeetCode 4)
     */
    public double findMedianSortedArrays(int[] arr1, int[] arr2) {
        int total = arr1.length + arr2.length;
        
        if (total % 2 == 1) {
            return findKthElement(arr1, arr2, total / 2 + 1);
        } else {
            int mid1 = findKthElement(arr1, arr2, total / 2);
            int mid2 = findKthElement(arr1, arr2, total / 2 + 1);
            return (mid1 + mid2) / 2.0;
        }
    }
    
    // Test
    public static void main(String[] args) {
        KthElementTwoArrays kta = new KthElementTwoArrays();
        
        int[] arr1 = {1, 3, 5};
        int[] arr2 = {2, 4, 6};
        
        System.out.println(kta.findKthElement(arr1, arr2, 3)); // 3
        System.out.println(kta.findMedianSortedArrays(arr1, arr2)); // 3.5
    }
}
```

**Complexity**: O(log(min(m, n))) time, O(1) space

---

### Pattern 2: Smallest Divisor (LeetCode 1283)

```java
public class SmallestDivisor {
    /**
     * Find smallest divisor such that sum of (arr[i] / divisor) <= threshold
     */
    public int smallestDivisor(int[] nums, int threshold) {
        // Search space: [1, max element]
        int left = 1, right = 0;
        
        for (int num : nums) {
            right = Math.max(right, num);
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (sumDivisions(nums, mid) <= threshold) {
                right = mid; // Try smaller divisor
            } else {
                left = mid + 1; // Need larger divisor
            }
        }
        
        return left;
    }
    
    private int sumDivisions(int[] nums, int divisor) {
        int sum = 0;
        for (int num : nums) {
            sum += (num + divisor - 1) / divisor; // Ceiling division
        }
        return sum;
    }
    
    // Test
    public static void main(String[] args) {
        SmallestDivisor sd = new SmallestDivisor();
        
        int[] nums = {1, 2, 5, 9};
        System.out.println(sd.smallestDivisor(nums, 6)); // 5
        
        int[] nums2 = {44, 22, 33, 11, 1};
        System.out.println(sd.smallestDivisor(nums2, 5)); // 44
    }
}
```

**Complexity**: O(n × log(max)) time, O(1) space

---

### Pattern 3: Minimum Number of Days to Make Bouquets (LeetCode 1482)

```java
public class MinimumDaysBouquets {
    /**
     * Find minimum days to make m bouquets of k adjacent flowers
     */
    public int minDays(int[] bloomDay, int m, int k) {
        if (m * k > bloomDay.length) {
            return -1; // Impossible
        }
        
        // Search space: [min bloom day, max bloom day]
        int left = Integer.MAX_VALUE, right = Integer.MIN_VALUE;
        
        for (int day : bloomDay) {
            left = Math.min(left, day);
            right = Math.max(right, day);
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canMakeBouquets(bloomDay, m, k, mid)) {
                right = mid; // Try earlier day
            } else {
                left = mid + 1; // Need more days
            }
        }
        
        return left;
    }
    
    private boolean canMakeBouquets(int[] bloomDay, int m, int k, int day) {
        int bouquets = 0;
        int flowers = 0;
        
        for (int bloom : bloomDay) {
            if (bloom <= day) {
                flowers++;
                if (flowers == k) {
                    bouquets++;
                    flowers = 0;
                    if (bouquets >= m) return true;
                }
            } else {
                flowers = 0; // Reset, need adjacent flowers
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        MinimumDaysBouquets mdb = new MinimumDaysBouquets();
        
        int[] bloomDay = {1, 10, 3, 10, 2};
        System.out.println(mdb.minDays(bloomDay, 3, 1)); // 3
        
        int[] bloomDay2 = {7, 7, 7, 7, 12, 7, 7};
        System.out.println(mdb.minDays(bloomDay2, 2, 3)); // 12
    }
}
```

**Complexity**: O(n × log(max_day)) time, O(1) space

---

### Pattern 4: Minimize the Difference (LeetCode 1802)

```java
public class MaxValueAtIndex {
    /**
     * Maximum value at index with constraints:
     * - Sum <= maxSum
     * - |arr[i] - arr[i+1]| <= 1
     */
    public int maxValue(int n, int index, int maxSum) {
        // Search space: [1, maxSum]
        int left = 1, right = maxSum;
        
        while (left < right) {
            int mid = left + (right - left + 1) / 2; // Right bias
            
            if (getSum(n, index, mid) <= maxSum) {
                left = mid; // Try larger value
            } else {
                right = mid - 1; // Too large
            }
        }
        
        return left;
    }
    
    private long getSum(int n, int index, int value) {
        long sum = 0;
        
        // Sum for left side
        if (value > index) {
            sum += (long)(value + value - index) * (index + 1) / 2;
        } else {
            sum += (long)(value + 1) * value / 2 + (index - value + 1);
        }
        
        // Sum for right side
        if (value >= n - index) {
            sum += (long)(value + value - n + 1 + index) * (n - index) / 2;
        } else {
            sum += (long)(value + 1) * value / 2 + (n - index - value);
        }
        
        return sum - value; // Subtract middle (counted twice)
    }
    
    // Test
    public static void main(String[] args) {
        MaxValueAtIndex mvi = new MaxValueAtIndex();
        
        System.out.println(mvi.maxValue(4, 2, 6)); // 2
        System.out.println(mvi.maxValue(6, 1, 10)); // 3
    }
}
```

**Complexity**: O(log(maxSum)) time, O(1) space

---

### Pattern 5: Aggressive Cows (Classic Problem)

```java
public class AggressiveCows {
    /**
     * Place C cows in N stalls to maximize minimum distance
     */
    public int largestMinDistance(int[] stalls, int cows) {
        Arrays.sort(stalls);
        
        // Search space: [1, stalls[n-1] - stalls[0]]
        int left = 1;
        int right = stalls[stalls.length - 1] - stalls[0];
        int result = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (canPlaceCows(stalls, cows, mid)) {
                result = mid;
                left = mid + 1; // Try larger distance
            } else {
                right = mid - 1; // Try smaller distance
            }
        }
        
        return result;
    }
    
    private boolean canPlaceCows(int[] stalls, int cows, int minDist) {
        int count = 1; // Place first cow
        int lastPosition = stalls[0];
        
        for (int i = 1; i < stalls.length; i++) {
            if (stalls[i] - lastPosition >= minDist) {
                count++;
                lastPosition = stalls[i];
                if (count >= cows) return true;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        AggressiveCows ac = new AggressiveCows();
        
        int[] stalls = {1, 2, 4, 8, 9};
        System.out.println(ac.largestMinDistance(stalls, 3)); // 3
    }
}
```

**Complexity**: O(n log n + n × log(max_distance)) time

---

## Interview Questions

### Q1: What's the difference between lower_bound and upper_bound?

**Answer**:

**lower_bound(target)**:
- Returns first position where `arr[i] >= target`
- If target exists, returns its first occurrence
- If target doesn't exist, returns insertion position

**upper_bound(target)**:
- Returns first position where `arr[i] > target`
- If target exists, returns position after last occurrence
- Always returns position strictly greater

**Example**:
```java
arr = [1, 2, 2, 2, 3, 4, 5]

lower_bound(2) = 1  // First 2
upper_bound(2) = 4  // After last 2

lower_bound(2.5) = 4  // Insertion position (before 3)
upper_bound(2.5) = 4  // Same position

// Count occurrences
count(2) = upper_bound(2) - lower_bound(2) = 4 - 1 = 3
```

---

### Q2: When should you use binary search on answer?

**Answer**:

Use when the problem has these properties:

1. **Monotonicity**: If answer x works, then x+1 (or x-1) also works
2. **Easy verification**: Can check if a value works in O(n) or O(n log n)
3. **Optimization**: Asking for min/max value

**Common phrases**:
- "Minimize the maximum..."
- "Maximize the minimum..."
- "Find the smallest/largest value such that..."

**Pattern**:
```java
int left = minPossible, right = maxPossible;
while (left < right) {
    int mid = left + (right - left) / 2;
    if (canAchieve(mid)) {
        // Binary search decision
    }
}
```

**Examples**:
- Koko eating bananas (min speed)
- Capacity to ship packages (min capacity)
- Split array largest sum (min largest sum)
- Aggressive cows (max min distance)

---

### Q3: How do you avoid infinite loops in binary search?

**Answer**:

**Cause**: When `left = mid` or `right = mid` without +1 or -1.

**Problem case**:
```java
// ❌ WRONG - Infinite loop when left + 1 == right
while (left < right) {
    int mid = left + (right - left) / 2;
    if (condition) {
        left = mid;  // ❌ If mid == left, no progress
    } else {
        right = mid;
    }
}
```

**Solutions**:

**Solution 1**: Always use +1 or -1
```java
while (left < right) {
    int mid = left + (right - left) / 2;
    if (condition) {
        left = mid + 1;  // ✅
    } else {
        right = mid;
    }
}
```

**Solution 2**: Use right bias when `left = mid`
```java
while (left < right) {
    int mid = left + (right - left + 1) / 2; // ✅ +1 for right bias
    if (condition) {
        left = mid;   // Safe with right bias
    } else {
        right = mid - 1;
    }
}
```

**Solution 3**: Use `left + 1 < right` termination
```java
while (left + 1 < right) {
    int mid = left + (right - left) / 2;
    if (condition) {
        left = mid;   // ✅ Safe
    } else {
        right = mid;  // ✅ Safe
    }
}
// Post-process left and right
```

---

### Q4: How to do binary search on real numbers?

**Answer**:

**Key differences** from integer binary search:

1. **Termination**: Use `while (right - left > epsilon)` instead of `left < right`
2. **No +1/-1**: Just use `left = mid` or `right = mid`
3. **Precision**: Choose appropriate epsilon (e.g., 1e-6)

**Template**:
```java
double left = 0, right = x;
double epsilon = 1e-6;

while (right - left > epsilon) {
    double mid = left + (right - left) / 2;
    
    if (f(mid) < target) {
        left = mid;   // No +1
    } else {
        right = mid;  // No -1
    }
}

return left; // Or right, they're close enough
```

**Iterations**: O(log((right - left) / epsilon))

**Use cases**:
- Finding square roots
- Finding function roots
- Ternary search for optimization

---

### Q5: What is ternary search and when to use it?

**Answer**:

**Ternary search** finds the maximum or minimum of a **unimodal function** (single peak or valley).

**Algorithm**:
```java
while (right - left > epsilon) {
    double mid1 = left + (right - left) / 3;
    double mid2 = right - (right - left) / 3;
    
    if (f(mid1) < f(mid2)) {
        left = mid1;  // Peak is in [mid1, right]
    } else {
        right = mid2; // Peak is in [left, mid2]
    }
}
```

**When to use**:
- Function has single maximum/minimum
- Can't compute derivative or derivative is complex
- Need to find optimal value, not just check feasibility

**Binary vs Ternary**:
- Binary: 2 regions, reduces by 1/2
- Ternary: 3 regions, reduces by 1/3
- Both: O(log n) complexity

**Example problems**:
- Find maximum of f(x) = -(x-a)² + b
- Minimize time in LeetCode 1300 (bipartite search)

---

### Q6: How do you choose the right binary search template?

**Answer**:

**Decision tree**:

```
Need exact match?
├─ Yes → Template 1 (while left <= right)
└─ No → Need boundary or insertion point?
    ├─ Yes → Template 2 (while left < right)
    └─ No → Need neighbor comparison?
        └─ Yes → Template 3 (while left + 1 < right)
```

**Template 1**: `while (left <= right)`
- Finding exact element
- Returns specific index or -1
- Clear found/not found distinction

**Template 2**: `while (left < right)`
- Finding boundaries (lower/upper bound)
- Finding insertion position
- Minimizing/maximizing with binary search on answer
- Returns the boundary position

**Template 3**: `while (left + 1 < right)`
- Need to examine neighbors
- Complex decision logic
- Post-processing required

**Most common**: Template 2 for competitive programming (handles more cases).

---

### Q7: Can you do binary search on an unsorted array?

**Answer**: **Generally no**, but there are exceptions:

**When it works**:

1. **Rotated sorted array**: Still has structure
```java
// [4,5,6,7,0,1,2] - one half is always sorted
```

2. **Bitonic array**: Increases then decreases
```java
// [1,3,5,7,6,4,2] - use modified binary search
```

3. **Partially sorted**: Some known ordering
```java
// Each row sorted in 2D matrix
```

**When it doesn't work**:
```java
// [5,2,8,1,9] - completely random, no structure
// Must use linear search O(n) or sort first O(n log n)
```

**Key**: Binary search needs **monotonicity** or **structure**, not necessarily full sorting.

---

### Q8: What's the difference between finding minimum and maximum with binary search?

**Answer**:

**Finding minimum** (use `left < right`):
```java
while (left < right) {
    int mid = left + (right - left) / 2;
    if (isValid(mid)) {
        right = mid;     // Try smaller
    } else {
        left = mid + 1;  // Need larger
    }
}
return left; // Minimum valid value
```

**Finding maximum** (use `left <= right` or right bias):
```java
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (isValid(mid)) {
        result = mid;
        left = mid + 1;  // Try larger
    } else {
        right = mid - 1; // Too large
    }
}
return result; // Maximum valid value
```

**Or with right bias**:
```java
while (left < right) {
    int mid = left + (right - left + 1) / 2; // +1 for right bias
    if (isValid(mid)) {
        left = mid;      // Try larger
    } else {
        right = mid - 1; // Too large
    }
}
return left;
```

**Key difference**: Direction of optimization and update strategy.

---

### Q9: How do you handle edge cases in binary search?

**Answer**:

**Common edge cases**:

1. **Empty array**:
```java
if (arr == null || arr.length == 0) return -1;
```

2. **Single element**:
```java
if (arr.length == 1) return arr[0] == target ? 0 : -1;
```

3. **Target smaller than all elements**:
```java
// lower_bound returns 0 (insertion at start)
```

4. **Target larger than all elements**:
```java
// upper_bound returns arr.length (insertion at end)
```

5. **All elements equal**:
```java
// lower_bound returns 0, upper_bound returns arr.length
```

6. **Integer overflow**:
```java
// Use: mid = left + (right - left) / 2
// Not: mid = (left + right) / 2
```

**Testing strategy**:
- Test with arrays of size 0, 1, 2
- Test target at start, middle, end
- Test target not in array
- Test boundary values

---

### Q10: What are the common mistakes in binary search?

**Answer**:

**Top 10 mistakes**:

1. **Integer overflow**:
```java
❌ int mid = (left + right) / 2;
✅ int mid = left + (right - left) / 2;
```

2. **Wrong loop condition**:
```java
❌ while (left < right) when need <=
✅ Choose based on template
```

3. **Infinite loop**:
```java
❌ left = mid (without right bias)
✅ left = mid + 1 OR use right bias
```

4. **Off-by-one in update**:
```java
❌ left = mid, right = mid (can miss answer)
✅ Consistent with loop condition
```

5. **Not checking sorted**:
```java
❌ Using binary search on unsorted array
✅ Verify or sort first
```

6. **Wrong return value**:
```java
❌ return mid after loop (mid is undefined)
✅ return left or result variable
```

7. **Not handling edge cases**:
```java
❌ Assuming array is non-empty
✅ Check null and empty
```

8. **Wrong bias**:
```java
❌ Using left bias when finding maximum
✅ Use right bias: mid = left + (right - left + 1) / 2
```

9. **Forgetting post-processing**:
```java
❌ Template 3 without checking left and right
✅ Always post-process for Template 3
```

10. **Checking wrong condition**:
```java
❌ if (arr[mid] == target) in boundary search
✅ Use inequality for boundaries
```

---

## Practice Problems

### Problem 1: Kth Missing Positive Number (LeetCode 1539)

**Description**: Find the kth missing positive number in sorted array.

**Solution**:
```java
public class KthMissingPositive {
    public int findKthPositive(int[] arr, int k) {
        int left = 0, right = arr.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Missing numbers before arr[mid]
            int missing = arr[mid] - (mid + 1);
            
            if (missing < k) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        // left is the index where we should insert kth missing
        // kth missing = left + k
        return left + k;
    }
    
    // Test
    public static void main(String[] args) {
        KthMissingPositive kmp = new KthMissingPositive();
        
        System.out.println(kmp.findKthPositive(new int[]{2, 3, 4, 7, 11}, 5)); // 9
        System.out.println(kmp.findKthPositive(new int[]{1, 2, 3, 4}, 2)); // 6
    }
}
```

**Complexity**: O(log n) time, O(1) space

---

### Problem 2: Maximum Side Length of Square (LeetCode 1292)

**Description**: Find maximum side length of square with sum <= threshold.

**Solution**:
```java
public class MaxSquareSideLength {
    public int maxSideLength(int[][] mat, int threshold) {
        int m = mat.length, n = mat[0].length;
        
        // Build prefix sum
        int[][] prefix = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = mat[i-1][j-1] + prefix[i-1][j] 
                             + prefix[i][j-1] - prefix[i-1][j-1];
            }
        }
        
        // Binary search on side length
        int left = 0, right = Math.min(m, n);
        int result = 0;
        
        while (left <= right) {
            int mid = left + (right - left) / 2;
            
            if (hasValidSquare(prefix, mid, threshold)) {
                result = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    private boolean hasValidSquare(int[][] prefix, int len, int threshold) {
        int m = prefix.length - 1, n = prefix[0].length - 1;
        
        for (int i = len; i <= m; i++) {
            for (int j = len; j <= n; j++) {
                int sum = prefix[i][j] - prefix[i-len][j] 
                        - prefix[i][j-len] + prefix[i-len][j-len];
                if (sum <= threshold) return true;
            }
        }
        
        return false;
    }
    
    // Test
    public static void main(String[] args) {
        MaxSquareSideLength mssl = new MaxSquareSideLength();
        
        int[][] mat = {{1,1,3,2,4,3,2},{1,1,3,2,4,3,2},{1,1,3,2,4,3,2}};
        System.out.println(mssl.maxSideLength(mat, 4)); // 2
    }
}
```

**Complexity**: O(m × n × log(min(m,n))) time

---

### Problem 3: Minimized Maximum of Products (LeetCode 2064)

**Description**: Minimize the maximum number of products assigned to any store.

**Solution**:
```java
public class MinimizedMaximum {
    public int minimizedMaximum(int n, int[] quantities) {
        // Search space: [1, max quantity]
        int left = 1, right = 0;
        
        for (int q : quantities) {
            right = Math.max(right, q);
        }
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (canDistribute(quantities, n, mid)) {
                right = mid; // Try smaller maximum
            } else {
                left = mid + 1; // Need larger maximum
            }
        }
        
        return left;
    }
    
    private boolean canDistribute(int[] quantities, int n, int maxPerStore) {
        int storesNeeded = 0;
        
        for (int q : quantities) {
            storesNeeded += (q + maxPerStore - 1) / maxPerStore; // Ceiling
            if (storesNeeded > n) return false;
        }
        
        return true;
    }
    
    // Test
    public static void main(String[] args) {
        MinimizedMaximum mm = new MinimizedMaximum();
        
        System.out.println(mm.minimizedMaximum(6, new int[]{11, 6})); // 3
        System.out.println(mm.minimizedMaximum(7, new int[]{15, 10, 10})); // 5
    }
}
```

**Complexity**: O(m × log(max_quantity)) time

---

### Problem 4: Find K Closest Elements (LeetCode 658)

**Description**: Find k closest elements to x in sorted array.

**Solution**:
```java
import java.util.*;

public class FindKClosestElements {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        // Binary search to find the start of k elements window
        int left = 0, right = arr.length - k;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Compare distances from x
            // If arr[mid] is farther than arr[mid+k], move right
            if (x - arr[mid] > arr[mid + k] - x) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        // Collect k elements starting from left
        List<Integer> result = new ArrayList<>();
        for (int i = left; i < left + k; i++) {
            result.add(arr[i]);
        }
        
        return result;
    }
    
    // Test
    public static void main(String[] args) {
        FindKClosestElements fkce = new FindKClosestElements();
        
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(fkce.findClosestElements(arr, 4, 3)); // [1,2,3,4]
        
        int[] arr2 = {1, 2, 3, 4, 5};
        System.out.println(fkce.findClosestElements(arr2, 4, -1)); // [1,2,3,4]
    }
}
```

**Complexity**: O(log(n - k) + k) time, O(1) space (excluding output)

---

### Problem 5: Count Complete Tree Nodes (LeetCode 222)

**Description**: Count nodes in complete binary tree more efficiently than O(n).

**Solution**:
```java
public class CountCompleteTreeNodes {
    static class TreeNode {
        int val;
        TreeNode left, right;
        TreeNode(int val) { this.val = val; }
    }
    
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        
        int leftDepth = getLeftDepth(root);
        int rightDepth = getRightDepth(root);
        
        if (leftDepth == rightDepth) {
            // Perfect binary tree
            return (1 << leftDepth) - 1; // 2^depth - 1
        }
        
        // Recursively count left and right subtrees
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
    
    private int getLeftDepth(TreeNode node) {
        int depth = 0;
        while (node != null) {
            depth++;
            node = node.left;
        }
        return depth;
    }
    
    private int getRightDepth(TreeNode node) {
        int depth = 0;
        while (node != null) {
            depth++;
            node = node.right;
        }
        return depth;
    }
    
    // Test
    public static void main(String[] args) {
        CountCompleteTreeNodes cctn = new CountCompleteTreeNodes();
        
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        
        System.out.println(cctn.countNodes(root)); // 6
    }
}
```

**Complexity**: O(log²n) time, O(log n) space

---

## Summary

### Key Takeaways

1. **Three main templates** - Choose based on exact match, boundary, or neighbor needs
2. **Lower/upper bounds** - Essential for range queries and duplicates
3. **Binary search on answer** - Powerful for optimization problems
4. **Real number search** - Use epsilon for termination
5. **Ternary search** - For unimodal functions

### Template Selection

| Scenario | Template | Loop Condition |
|----------|----------|----------------|
| Exact match | Template 1 | `while (left <= right)` |
| Boundary/insertion | Template 2 | `while (left < right)` |
| Neighbor comparison | Template 3 | `while (left + 1 < right)` |
| Real numbers | Custom | `while (right - left > eps)` |

### Common Patterns

- **Minimize maximum**: Binary search on answer, minimize
- **Maximize minimum**: Binary search on answer, maximize  
- **Kth element**: Binary search with counting
- **Valid distribution**: Binary search with greedy check
- **Distance optimization**: Binary search on distance

### Complexity Summary

| Pattern | Time | Space |
|---------|------|-------|
| Lower/upper bound | O(log n) | O(1) |
| Binary on answer | O(n × log(range)) | O(1) |
| Real numbers | O(log(range/eps)) | O(1) |
| Ternary search | O(log(range/eps)) | O(1) |
| Median of two arrays | O(log(min(m,n))) | O(1) |

### Interview Strategy

1. **Identify monotonicity**: Can you partition into true/false?
2. **Define search space**: What are min and max possible answers?
3. **Write isValid()**: Can you check if a value works?
4. **Choose template**: Exact, boundary, or neighbor?
5. **Handle edge cases**: Empty, single element, boundaries

---

**Next**: [5.4 Exponential Search](5.4-Exponential-Search.md) - Learn searching in unbounded/infinite arrays
